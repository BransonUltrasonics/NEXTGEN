/*
 *  wmb_webclidemo.c
 *
 *  This is a part of a Wind River Management SDK source code library.
 *
 *  Copyright (C) 2018 WindRiver Systems.
 *  All rights reserved.
 *  Version 4.9
 *
 */

/* WARNING:  This file is generated by a Wind River Management Integration
 * Tool.  Any changes made to this file may be overwritten by
 * subsequent uses of the tool. */

#include "wmw_httpconf.h"
#include "wm.h"
#include "wmb.h"
#include <logLib.h>
#include "wmc.h"
#include "wmbMibwayLib.h"

/* include the header file, including Private sections */
#define __WMB_WEBCLIDEMO_PRIVATE_HEADER__
#include "wmb_webclidemo.h"
#undef __WMB_WEBCLIDEMO_PRIVATE_HEADER__
#include "wmc_webclidemo.h"
/* #include "wmm_webclidemo.h" */
/* #include "wmw_webclidemo.h" */

/* Include files defined in project */
#include "sampleDevice.h"
#include "sampleLiveCtrlApp.h"
#include "httpWmbHandlers.h"
#include "httpLib.h"

/* Include sub-project headers file */

/* %%BeginUserCode webclidemo_IncludeFiles */ 
#include "httpNonce.h"
#include "sampleCheckbox.h"
#include "sampleDynamicTable.h"
/* %%EndUserCode   webclidemo_IncludeFiles */ 

/* Defines */ 
/* %%BeginUserCode webclidemo_Defines */ 
/* %%EndUserCode   webclidemo_Defines */ 

/* Globals */ 
/* %%BeginUserCode webclidemo_Globals */ 
extern int ramDiskCreate(char *pDevName, unsigned int  memSize);
extern void webcli_http_init(void);
extern void webcli_cli_init(void);
extern void webcli_common_init(void);
/* %%EndUserCode   webclidemo_Globals */ 


/* Local Predefines */ 
static char moduleName[] = "webclidemo";
static char moduleDate[] = __DATE__;
int wmbStartedWebCLI = FALSE;

/* Locals */ 
/* %%BeginUserCode webclidemo_Locals */ 
/* %%EndUserCode   webclidemo_Locals */ 


/* Access Options Structure */
static DTEnumInfo mAccessTbl[] =
{
		{"",ENUM_ACCESS_EMPTY,0}
};

static DTTypeInfo mAccessInfo =
{   NULL,
		NULL,
		DATATYPE_ACCESS_K,
		"N=1 D=|",
		0,
		NULL,
		NULL,
		mAccessTbl
};


/* Prototypes */ 

/* %%BeginUserCode webclidemo_Prototypes */ 
/* %%EndUserCode   webclidemo_Prototypes */ 

static STATUS webclidemoScalarHandler(WMB_TID_T tid,WMB_OBJ_T obj,COMMAND_T command);
static STATUS stringTblHandler(WMB_TID_T tid,WMB_OBJ_T obj,COMMAND_T command);
static STATUS numberTblIntHandler(WMB_TID_T tid,WMB_OBJ_T obj,COMMAND_T command);
static STATUS numberTblPtrHandler(WMB_TID_T tid,WMB_OBJ_T obj,COMMAND_T command);
static STATUS numberTblPtrIntHandler(WMB_TID_T tid,WMB_OBJ_T obj,COMMAND_T command);

/* OID Table Structures */
static int oid_atIfIndex[] = { 1,3,6,1,2,1,3,1,1,1 };
static int oid_atNetAddress[] = { 1,3,6,1,2,1,3,1,1,3 };
static int oid_atPhysAddress[] = { 1,3,6,1,2,1,3,1,1,2 };
static int oid_egpAs[] = { 1,3,6,1,2,1,8,6 };
static int oid_egpInErrors[] = { 1,3,6,1,2,1,8,2 };
static int oid_egpInMsgs[] = { 1,3,6,1,2,1,8,1 };
static int oid_egpNeighAddr[] = { 1,3,6,1,2,1,8,5,1,2 };
static int oid_egpNeighAs[] = { 1,3,6,1,2,1,8,5,1,3 };
static int oid_egpNeighEventTrigger[] = { 1,3,6,1,2,1,8,5,1,15 };
static int oid_egpNeighInErrMsgs[] = { 1,3,6,1,2,1,8,5,1,8 };
static int oid_egpNeighInErrs[] = { 1,3,6,1,2,1,8,5,1,5 };
static int oid_egpNeighInMsgs[] = { 1,3,6,1,2,1,8,5,1,4 };
static int oid_egpNeighIntervalHello[] = { 1,3,6,1,2,1,8,5,1,12 };
static int oid_egpNeighIntervalPoll[] = { 1,3,6,1,2,1,8,5,1,13 };
static int oid_egpNeighMode[] = { 1,3,6,1,2,1,8,5,1,14 };
static int oid_egpNeighOutErrMsgs[] = { 1,3,6,1,2,1,8,5,1,9 };
static int oid_egpNeighOutErrs[] = { 1,3,6,1,2,1,8,5,1,7 };
static int oid_egpNeighOutMsgs[] = { 1,3,6,1,2,1,8,5,1,6 };
static int oid_egpNeighState[] = { 1,3,6,1,2,1,8,5,1,1 };
static int oid_egpNeighStateDowns[] = { 1,3,6,1,2,1,8,5,1,11 };
static int oid_egpNeighStateUps[] = { 1,3,6,1,2,1,8,5,1,10 };
static int oid_egpOutErrors[] = { 1,3,6,1,2,1,8,4 };
static int oid_egpOutMsgs[] = { 1,3,6,1,2,1,8,3 };
static int oid_icmpInAddrMaskReps[] = { 1,3,6,1,2,1,5,13 };
static int oid_icmpInAddrMasks[] = { 1,3,6,1,2,1,5,12 };
static int oid_icmpInDestUnreachs[] = { 1,3,6,1,2,1,5,3 };
static int oid_icmpInEchoReps[] = { 1,3,6,1,2,1,5,9 };
static int oid_icmpInEchos[] = { 1,3,6,1,2,1,5,8 };
static int oid_icmpInErrors[] = { 1,3,6,1,2,1,5,2 };
static int oid_icmpInMsgs[] = { 1,3,6,1,2,1,5,1 };
static int oid_icmpInParmProbs[] = { 1,3,6,1,2,1,5,5 };
static int oid_icmpInRedirects[] = { 1,3,6,1,2,1,5,7 };
static int oid_icmpInSrcQuenchs[] = { 1,3,6,1,2,1,5,6 };
static int oid_icmpInTimeExcds[] = { 1,3,6,1,2,1,5,4 };
static int oid_icmpInTimestampReps[] = { 1,3,6,1,2,1,5,11 };
static int oid_icmpInTimestamps[] = { 1,3,6,1,2,1,5,10 };
static int oid_icmpOutAddrMaskReps[] = { 1,3,6,1,2,1,5,26 };
static int oid_icmpOutAddrMasks[] = { 1,3,6,1,2,1,5,25 };
static int oid_icmpOutDestUnreachs[] = { 1,3,6,1,2,1,5,16 };
static int oid_icmpOutEchoReps[] = { 1,3,6,1,2,1,5,22 };
static int oid_icmpOutEchos[] = { 1,3,6,1,2,1,5,21 };
static int oid_icmpOutErrors[] = { 1,3,6,1,2,1,5,15 };
static int oid_icmpOutMsgs[] = { 1,3,6,1,2,1,5,14 };
static int oid_icmpOutParmProbs[] = { 1,3,6,1,2,1,5,18 };
static int oid_icmpOutRedirects[] = { 1,3,6,1,2,1,5,20 };
static int oid_icmpOutSrcQuenchs[] = { 1,3,6,1,2,1,5,19 };
static int oid_icmpOutTimeExcds[] = { 1,3,6,1,2,1,5,17 };
static int oid_icmpOutTimestampReps[] = { 1,3,6,1,2,1,5,24 };
static int oid_icmpOutTimestamps[] = { 1,3,6,1,2,1,5,23 };
static int oid_ifAdminStatus[] = { 1,3,6,1,2,1,2,2,1,7 };
static int oid_ifDescr[] = { 1,3,6,1,2,1,2,2,1,2 };
static int oid_ifInDiscards[] = { 1,3,6,1,2,1,2,2,1,13 };
static int oid_ifInErrors[] = { 1,3,6,1,2,1,2,2,1,14 };
static int oid_ifInNUcastPkts[] = { 1,3,6,1,2,1,2,2,1,12 };
static int oid_ifInOctets[] = { 1,3,6,1,2,1,2,2,1,10 };
static int oid_ifInUcastPkts[] = { 1,3,6,1,2,1,2,2,1,11 };
static int oid_ifInUnknownProtos[] = { 1,3,6,1,2,1,2,2,1,15 };
static int oid_ifIndex[] = { 1,3,6,1,2,1,2,2,1,1 };
static int oid_ifLastChange[] = { 1,3,6,1,2,1,2,2,1,9 };
static int oid_ifMtu[] = { 1,3,6,1,2,1,2,2,1,4 };
static int oid_ifNumber[] = { 1,3,6,1,2,1,2,1 };
static int oid_ifOperStatus[] = { 1,3,6,1,2,1,2,2,1,8 };
static int oid_ifOutDiscards[] = { 1,3,6,1,2,1,2,2,1,19 };
static int oid_ifOutErrors[] = { 1,3,6,1,2,1,2,2,1,20 };
static int oid_ifOutNUcastPkts[] = { 1,3,6,1,2,1,2,2,1,18 };
static int oid_ifOutOctets[] = { 1,3,6,1,2,1,2,2,1,16 };
static int oid_ifOutQLen[] = { 1,3,6,1,2,1,2,2,1,21 };
static int oid_ifOutUcastPkts[] = { 1,3,6,1,2,1,2,2,1,17 };
static int oid_ifPhysAddress[] = { 1,3,6,1,2,1,2,2,1,6 };
static int oid_ifSpecific[] = { 1,3,6,1,2,1,2,2,1,22 };
static int oid_ifSpeed[] = { 1,3,6,1,2,1,2,2,1,5 };
static int oid_ifType[] = { 1,3,6,1,2,1,2,2,1,3 };
static int oid_ipAdEntAddr[] = { 1,3,6,1,2,1,4,20,1,1 };
static int oid_ipAdEntBcastAddr[] = { 1,3,6,1,2,1,4,20,1,4 };
static int oid_ipAdEntIfIndex[] = { 1,3,6,1,2,1,4,20,1,2 };
static int oid_ipAdEntNetMask[] = { 1,3,6,1,2,1,4,20,1,3 };
static int oid_ipAdEntReasmMaxSize[] = { 1,3,6,1,2,1,4,20,1,5 };
static int oid_ipDefaultTTL[] = { 1,3,6,1,2,1,4,2 };
static int oid_ipForwDatagrams[] = { 1,3,6,1,2,1,4,6 };
static int oid_ipForwarding[] = { 1,3,6,1,2,1,4,1 };
static int oid_ipFragCreates[] = { 1,3,6,1,2,1,4,19 };
static int oid_ipFragFails[] = { 1,3,6,1,2,1,4,18 };
static int oid_ipFragOKs[] = { 1,3,6,1,2,1,4,17 };
static int oid_ipInAddrErrors[] = { 1,3,6,1,2,1,4,5 };
static int oid_ipInDelivers[] = { 1,3,6,1,2,1,4,9 };
static int oid_ipInDiscards[] = { 1,3,6,1,2,1,4,8 };
static int oid_ipInHdrErrors[] = { 1,3,6,1,2,1,4,4 };
static int oid_ipInReceives[] = { 1,3,6,1,2,1,4,3 };
static int oid_ipInUnknownProtos[] = { 1,3,6,1,2,1,4,7 };
static int oid_ipNetToMediaIfIndex[] = { 1,3,6,1,2,1,4,22,1,1 };
static int oid_ipNetToMediaNetAddress[] = { 1,3,6,1,2,1,4,22,1,3 };
static int oid_ipNetToMediaPhysAddress[] = { 1,3,6,1,2,1,4,22,1,2 };
static int oid_ipNetToMediaType[] = { 1,3,6,1,2,1,4,22,1,4 };
static int oid_ipOutDiscards[] = { 1,3,6,1,2,1,4,11 };
static int oid_ipOutNoRoutes[] = { 1,3,6,1,2,1,4,12 };
static int oid_ipOutRequests[] = { 1,3,6,1,2,1,4,10 };
static int oid_ipReasmFails[] = { 1,3,6,1,2,1,4,16 };
static int oid_ipReasmOKs[] = { 1,3,6,1,2,1,4,15 };
static int oid_ipReasmReqds[] = { 1,3,6,1,2,1,4,14 };
static int oid_ipReasmTimeout[] = { 1,3,6,1,2,1,4,13 };
static int oid_ipRouteAge[] = { 1,3,6,1,2,1,4,21,1,10 };
static int oid_ipRouteDest[] = { 1,3,6,1,2,1,4,21,1,1 };
static int oid_ipRouteIfIndex[] = { 1,3,6,1,2,1,4,21,1,2 };
static int oid_ipRouteInfo[] = { 1,3,6,1,2,1,4,21,1,13 };
static int oid_ipRouteMask[] = { 1,3,6,1,2,1,4,21,1,11 };
static int oid_ipRouteMetric1[] = { 1,3,6,1,2,1,4,21,1,3 };
static int oid_ipRouteMetric2[] = { 1,3,6,1,2,1,4,21,1,4 };
static int oid_ipRouteMetric3[] = { 1,3,6,1,2,1,4,21,1,5 };
static int oid_ipRouteMetric4[] = { 1,3,6,1,2,1,4,21,1,6 };
static int oid_ipRouteMetric5[] = { 1,3,6,1,2,1,4,21,1,12 };
static int oid_ipRouteNextHop[] = { 1,3,6,1,2,1,4,21,1,7 };
static int oid_ipRouteProto[] = { 1,3,6,1,2,1,4,21,1,9 };
static int oid_ipRouteType[] = { 1,3,6,1,2,1,4,21,1,8 };
static int oid_ipRoutingDiscards[] = { 1,3,6,1,2,1,4,23 };
static int oid_snmpEnableAuthenTraps[] = { 1,3,6,1,2,1,11,30 };
static int oid_snmpInASNParseErrs[] = { 1,3,6,1,2,1,11,6 };
static int oid_snmpInBadCommunityNames[] = { 1,3,6,1,2,1,11,4 };
static int oid_snmpInBadCommunityUses[] = { 1,3,6,1,2,1,11,5 };
static int oid_snmpInBadValues[] = { 1,3,6,1,2,1,11,10 };
static int oid_snmpInBadVersions[] = { 1,3,6,1,2,1,11,3 };
static int oid_snmpInGenErrs[] = { 1,3,6,1,2,1,11,12 };
static int oid_snmpInGetNexts[] = { 1,3,6,1,2,1,11,16 };
static int oid_snmpInGetRequests[] = { 1,3,6,1,2,1,11,15 };
static int oid_snmpInGetResponses[] = { 1,3,6,1,2,1,11,18 };
static int oid_snmpInNoSuchNames[] = { 1,3,6,1,2,1,11,9 };
static int oid_snmpInPkts[] = { 1,3,6,1,2,1,11,1 };
static int oid_snmpInReadOnlys[] = { 1,3,6,1,2,1,11,11 };
static int oid_snmpInSetRequests[] = { 1,3,6,1,2,1,11,17 };
static int oid_snmpInTooBigs[] = { 1,3,6,1,2,1,11,8 };
static int oid_snmpInTotalReqVars[] = { 1,3,6,1,2,1,11,13 };
static int oid_snmpInTotalSetVars[] = { 1,3,6,1,2,1,11,14 };
static int oid_snmpInTraps[] = { 1,3,6,1,2,1,11,19 };
static int oid_snmpOutBadValues[] = { 1,3,6,1,2,1,11,22 };
static int oid_snmpOutGenErrs[] = { 1,3,6,1,2,1,11,24 };
static int oid_snmpOutGetNexts[] = { 1,3,6,1,2,1,11,26 };
static int oid_snmpOutGetRequests[] = { 1,3,6,1,2,1,11,25 };
static int oid_snmpOutGetResponses[] = { 1,3,6,1,2,1,11,28 };
static int oid_snmpOutNoSuchNames[] = { 1,3,6,1,2,1,11,21 };
static int oid_snmpOutPkts[] = { 1,3,6,1,2,1,11,2 };
static int oid_snmpOutSetRequests[] = { 1,3,6,1,2,1,11,27 };
static int oid_snmpOutTooBigs[] = { 1,3,6,1,2,1,11,20 };
static int oid_snmpOutTraps[] = { 1,3,6,1,2,1,11,29 };
static int oid_sysContact[] = { 1,3,6,1,2,1,1,4 };
static int oid_sysDescr[] = { 1,3,6,1,2,1,1,1 };
static int oid_sysLocation[] = { 1,3,6,1,2,1,1,6 };
static int oid_sysName[] = { 1,3,6,1,2,1,1,5 };
static int oid_sysObjectID[] = { 1,3,6,1,2,1,1,2 };
static int oid_sysServices[] = { 1,3,6,1,2,1,1,7 };
static int oid_sysUpTime[] = { 1,3,6,1,2,1,1,3 };
static int oid_tcpActiveOpens[] = { 1,3,6,1,2,1,6,5 };
static int oid_tcpAttemptFails[] = { 1,3,6,1,2,1,6,7 };
static int oid_tcpConnLocalAddress[] = { 1,3,6,1,2,1,6,13,1,2 };
static int oid_tcpConnLocalPort[] = { 1,3,6,1,2,1,6,13,1,3 };
static int oid_tcpConnRemAddress[] = { 1,3,6,1,2,1,6,13,1,4 };
static int oid_tcpConnRemPort[] = { 1,3,6,1,2,1,6,13,1,5 };
static int oid_tcpConnState[] = { 1,3,6,1,2,1,6,13,1,1 };
static int oid_tcpCurrEstab[] = { 1,3,6,1,2,1,6,9 };
static int oid_tcpEstabResets[] = { 1,3,6,1,2,1,6,8 };
static int oid_tcpInErrs[] = { 1,3,6,1,2,1,6,14 };
static int oid_tcpInSegs[] = { 1,3,6,1,2,1,6,10 };
static int oid_tcpMaxConn[] = { 1,3,6,1,2,1,6,4 };
static int oid_tcpOutRsts[] = { 1,3,6,1,2,1,6,15 };
static int oid_tcpOutSegs[] = { 1,3,6,1,2,1,6,11 };
static int oid_tcpPassiveOpens[] = { 1,3,6,1,2,1,6,6 };
static int oid_tcpRetransSegs[] = { 1,3,6,1,2,1,6,12 };
static int oid_tcpRtoAlgorithm[] = { 1,3,6,1,2,1,6,1 };
static int oid_tcpRtoMax[] = { 1,3,6,1,2,1,6,3 };
static int oid_tcpRtoMin[] = { 1,3,6,1,2,1,6,2 };
static int oid_udpInDatagrams[] = { 1,3,6,1,2,1,7,1 };
static int oid_udpInErrors[] = { 1,3,6,1,2,1,7,3 };
static int oid_udpLocalAddress[] = { 1,3,6,1,2,1,7,5,1,1 };
static int oid_udpLocalPort[] = { 1,3,6,1,2,1,7,5,1,2 };
static int oid_udpNoPorts[] = { 1,3,6,1,2,1,7,2 };
static int oid_udpOutDatagrams[] = { 1,3,6,1,2,1,7,4 };

/* Validation Structures */
static char val_egpNeighEventTrigger[] = "L=1 U=2 E=E N=2 D=| T=start=1|stop=2|";
static char val_egpNeighMode[] = "L=1 U=2 E=E N=2 D=| T=active=1|passive=2|";
static char val_egpNeighState[] = "L=1 U=5 E=E N=5 D=| T=idle=1|acquisition=2|down=3|up=4|cease=5|";
static char val_ifAdminStatus[] = "L=1 U=3 E=E N=3 D=| T=up=1|down=2|testing=3|";
static char val_ifDescr[] = "T=AL N=255 E=N";
static char val_ifOperStatus[] = "L=1 U=3 E=E N=3 D=| T=up=1|down=2|testing=3|";
static char val_ifType[] = "L=1 U=32 E=E N=32 D=| T=other=1|regular1822=2|hdh1822=3|ddn-x25=4|rfc877-x25=5|ethernet-csmacd=6|iso88023-csmacd=7|iso88024-toke\
nBus=8|iso88025-tokenRing=9|iso88026-man=10|starLan=11|proteon-10Mbit=12|proteon-80Mbit=13|hyperchannel=14|fddi=15|lapb=16|sdlc=\
17|ds1=18|e1=19|basicISDN=20|primaryISDN=21|propPointToPointSerial=22|ppp=23|softwareLoopback=24|eon=25|ethernet-3Mbit=26|nsip=2\
7|slip=28|ultra=29|ds3=30|sip=31|frame-relay=32|";
static char val_ipForwarding[] = "L=1 U=2 E=E N=2 D=| T=forwarding=1|not-forwarding=2|";
static char val_ipNetToMediaType[] = "L=1 U=4 E=E N=4 D=| T=other=1|invalid=2|dynamic=3|static=4|";
static char val_ipRouteProto[] = "L=1 U=14 E=E N=14 D=| T=other=1|local=2|netmgmt=3|icmp=4|egp=5|ggp=6|hello=7|rip=8|is-is=9|es-is=10|ciscoIgrp=11|bbnSpfIgp=12|os\
pf=13|bgp=14|";
static char val_ipRouteType[] = "L=1 U=4 E=E N=4 D=| T=other=1|invalid=2|direct=3|indirect=4|";
static char val_number[] = "T=AL N=20 E=N";
static char val_snmpEnableAuthenTraps[] = "L=1 U=2 E=E N=2 D=| T=enabled=1|disabled=2|";
static char val_sysContact[] = "T=AL N=255 E=N";
static char val_sysDescr[] = "T=AL N=255 E=N";
static char val_sysLocation[] = "T=AL N=255 E=N";
static char val_sysName[] = "T=AL N=255 E=N";
static char val_szAreaBuffer[] = "T=AO N=200 E=N";
static char val_szString[] = "T=AL N=101 E=N";
static char val_tcpConnState[] = "L=1 U=12 E=E N=12 D=| T=closed=1|listen=2|synSent=3|synReceived=4|established=5|finWait1=6|finWait2=7|closeWait=8|lastAck=9|clos\
ing=10|timeWait=11|deleteTCB=12|";
static char val_tcpRtoAlgorithm[] = "L=1 U=4 E=E N=4 D=| T=other=1|constant=2|rsre=3|vanj=4|";
static char val_nonce[] = "T=AO N=32 E=N";
static char val_first_i[] = "T=AL N=11 E=N";
static char val_first_s[] = "T=AL N=40 E=N";
static char val_first_pi[] = "T=AL N=19 E=N";
static char val_first_p[] = "T=AL N=19 E=N";
static char val_myIpAddress[] = "T=AL N=10 E=N";
static char val_nameCase[] = "T=AL N=256 E=N";
static char val_nameLetter[] = "T=AL N=2 E=N";
static char val_nameToAdd[] = "T=AL N=40 E=N";
static char val_nameToDelete[] = "T=AL N=40 E=N";
static char val_nameToModify[] = "T=AL N=40 E=N";
static char val_changeNameTo[] = "T=AL N=40 E=N";
static char val_first_name[] = "T=AL N=20 E=N";
static char val_key_s[] = "T=AL N=40 E=N";
static char val_last_name[] = "T=AL N=20 E=N";

/* Forward Reference for the Parent Tables */
static WMB_TABLE_T mTableTbl[];

/* Resource Entries Structure */
/* { sName, nLocalId, pDataCookie, nType, pValid, nDataSize, nAccessRead, nAccessWrite, nFlags, pHandler, enumTable, enumNextMember} */
static WMB_ENTRY_T mEntryTbl[] =
{
		{ "BoolTest", WMID_BoolTest, &g_liveCtrl_fBoolTest, DATATYPE_BOOL_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "CHECKED", WMID_CHECKED, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, checkedHandler , NULL , NULL },
		{ "CharTest", WMID_CharTest, &g_liveCtrl_cCharTest, DATATYPE_CHAR_K, NULL, 1, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "DoubleTest", WMID_DoubleTest, &g_liveCtrl_myDoubleTest, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "ERROR", WMID_ERROR, x_ERROR, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LEVEL_TABLE_K, webclidemoScalarHandler , NULL , NULL },
		{ "FloatTest", WMID_FloatTest, &g_liveCtrl_myFloatTest, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "IF", WMID_IF, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, webclidemoScalarHandler , NULL , NULL },
		{ "LiveCounter", WMID_LiveCounter, &g_liveCtrl_myLiveCounter, DATATYPE_LONG_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "LongTest", WMID_LongTest, &g_liveCtrl_lLongTest, DATATYPE_LONG_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "REPEAT", WMID_REPEAT, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, webclidemoScalarHandler , NULL , NULL },
		{ "SELECTED", WMID_SELECTED, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, selHandler , NULL , NULL },
		{ "ShortTest", WMID_ShortTest, &g_liveCtrl_sShortTest, DATATYPE_SHORT_K, NULL, 2, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "atIfIndex", WMID_atIfIndex, oid_atIfIndex, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_atTable] , &mEntryTbl[WMID_atNetAddress] },
		{ "atNetAddress", WMID_atNetAddress, oid_atNetAddress, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_atTable] , &mEntryTbl[WMID_atPhysAddress] },
		{ "atPhysAddress", WMID_atPhysAddress, oid_atPhysAddress, DATATYPE_MACADDR_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_atTable] , NULL },
		{ "createTable", WMID_createTable, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "egpAs", WMID_egpAs, oid_egpAs, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "egpInErrors", WMID_egpInErrors, oid_egpInErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "egpInMsgs", WMID_egpInMsgs, oid_egpInMsgs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "egpNeighAddr", WMID_egpNeighAddr, oid_egpNeighAddr, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighAs] },
		{ "egpNeighAs", WMID_egpNeighAs, oid_egpNeighAs, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighEventTrigger] },
		{ "egpNeighEventTrigger", WMID_egpNeighEventTrigger, oid_egpNeighEventTrigger, DATATYPE_INTEGER_K, val_egpNeighEventTrigger, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighInErrMsgs] },
		{ "egpNeighInErrMsgs", WMID_egpNeighInErrMsgs, oid_egpNeighInErrMsgs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighInErrs] },
		{ "egpNeighInErrs", WMID_egpNeighInErrs, oid_egpNeighInErrs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighInMsgs] },
		{ "egpNeighInMsgs", WMID_egpNeighInMsgs, oid_egpNeighInMsgs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighIntervalHello] },
		{ "egpNeighIntervalHello", WMID_egpNeighIntervalHello, oid_egpNeighIntervalHello, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighIntervalPoll] },
		{ "egpNeighIntervalPoll", WMID_egpNeighIntervalPoll, oid_egpNeighIntervalPoll, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighMode] },
		{ "egpNeighMode", WMID_egpNeighMode, oid_egpNeighMode, DATATYPE_INTEGER_K, val_egpNeighMode, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighOutErrMsgs] },
		{ "egpNeighOutErrMsgs", WMID_egpNeighOutErrMsgs, oid_egpNeighOutErrMsgs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighOutErrs] },
		{ "egpNeighOutErrs", WMID_egpNeighOutErrs, oid_egpNeighOutErrs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighOutMsgs] },
		{ "egpNeighOutMsgs", WMID_egpNeighOutMsgs, oid_egpNeighOutMsgs, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighState] },
		{ "egpNeighState", WMID_egpNeighState, oid_egpNeighState, DATATYPE_INTEGER_K, val_egpNeighState, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighStateDowns] },
		{ "egpNeighStateDowns", WMID_egpNeighStateDowns, oid_egpNeighStateDowns, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , &mEntryTbl[WMID_egpNeighStateUps] },
		{ "egpNeighStateUps", WMID_egpNeighStateUps, oid_egpNeighStateUps, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_egpNeighTable] , NULL },
		{ "egpOutErrors", WMID_egpOutErrors, oid_egpOutErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "egpOutMsgs", WMID_egpOutMsgs, oid_egpOutMsgs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "endRow", WMID_endRow, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "endTable", WMID_endTable, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "err_noReadNoWrite", WMID_err_noReadNoWrite, x_sysContact, DATATYPE_STRING_K, NULL, 256, 15, 15, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "err_readButNotWrite", WMID_err_readButNotWrite, x_sysContact, DATATYPE_STRING_K, NULL, 256, 0, 15, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "fFlag", WMID_fFlag, &g_liveCtrl_fFlag, DATATYPE_BOOL_K, NULL, 4, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "fFloat", WMID_fFloat, &g_liveCtrl_fFloat, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "fileInclude", WMID_fileInclude, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, wmbFileIncludeHandler , NULL , NULL },
		{ "getInstance", WMID_getInstance, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LOCK_SELF_K, wmbGetInstanceHandler , NULL , NULL },
		{ "icmpInAddrMaskReps", WMID_icmpInAddrMaskReps, oid_icmpInAddrMaskReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInAddrMasks", WMID_icmpInAddrMasks, oid_icmpInAddrMasks, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInDestUnreachs", WMID_icmpInDestUnreachs, oid_icmpInDestUnreachs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInEchoReps", WMID_icmpInEchoReps, oid_icmpInEchoReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInEchos", WMID_icmpInEchos, oid_icmpInEchos, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInErrors", WMID_icmpInErrors, oid_icmpInErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInMsgs", WMID_icmpInMsgs, oid_icmpInMsgs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInParmProbs", WMID_icmpInParmProbs, oid_icmpInParmProbs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInRedirects", WMID_icmpInRedirects, oid_icmpInRedirects, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInSrcQuenchs", WMID_icmpInSrcQuenchs, oid_icmpInSrcQuenchs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInTimeExcds", WMID_icmpInTimeExcds, oid_icmpInTimeExcds, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInTimestampReps", WMID_icmpInTimestampReps, oid_icmpInTimestampReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpInTimestamps", WMID_icmpInTimestamps, oid_icmpInTimestamps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutAddrMaskReps", WMID_icmpOutAddrMaskReps, oid_icmpOutAddrMaskReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutAddrMasks", WMID_icmpOutAddrMasks, oid_icmpOutAddrMasks, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutDestUnreachs", WMID_icmpOutDestUnreachs, oid_icmpOutDestUnreachs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutEchoReps", WMID_icmpOutEchoReps, oid_icmpOutEchoReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutEchos", WMID_icmpOutEchos, oid_icmpOutEchos, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutErrors", WMID_icmpOutErrors, oid_icmpOutErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutMsgs", WMID_icmpOutMsgs, oid_icmpOutMsgs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutParmProbs", WMID_icmpOutParmProbs, oid_icmpOutParmProbs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutRedirects", WMID_icmpOutRedirects, oid_icmpOutRedirects, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutSrcQuenchs", WMID_icmpOutSrcQuenchs, oid_icmpOutSrcQuenchs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutTimeExcds", WMID_icmpOutTimeExcds, oid_icmpOutTimeExcds, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutTimestampReps", WMID_icmpOutTimestampReps, oid_icmpOutTimestampReps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "icmpOutTimestamps", WMID_icmpOutTimestamps, oid_icmpOutTimestamps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ifAdminStatus", WMID_ifAdminStatus, oid_ifAdminStatus, DATATYPE_INTEGER_K, val_ifAdminStatus, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifDescr] },
		{ "ifDescr", WMID_ifDescr, oid_ifDescr, DATATYPE_STRING_K, val_ifDescr, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInDiscards] },
		{ "ifInDiscards", WMID_ifInDiscards, oid_ifInDiscards, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInErrors] },
		{ "ifInErrors", WMID_ifInErrors, oid_ifInErrors, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInNUcastPkts] },
		{ "ifInNUcastPkts", WMID_ifInNUcastPkts, oid_ifInNUcastPkts, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInOctets] },
		{ "ifInOctets", WMID_ifInOctets, oid_ifInOctets, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInUcastPkts] },
		{ "ifInUcastPkts", WMID_ifInUcastPkts, oid_ifInUcastPkts, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifInUnknownProtos] },
		{ "ifInUnknownProtos", WMID_ifInUnknownProtos, oid_ifInUnknownProtos, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifIndex] },
		{ "ifIndex", WMID_ifIndex, oid_ifIndex, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifLastChange] },
		{ "ifLastChange", WMID_ifLastChange, oid_ifLastChange, DATATYPE_TICKS_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifMtu] },
		{ "ifMtu", WMID_ifMtu, oid_ifMtu, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOperStatus] },
		{ "ifNumber", WMID_ifNumber, oid_ifNumber, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ifOperStatus", WMID_ifOperStatus, oid_ifOperStatus, DATATYPE_INTEGER_K, val_ifOperStatus, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutDiscards] },
		{ "ifOutDiscards", WMID_ifOutDiscards, oid_ifOutDiscards, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutErrors] },
		{ "ifOutErrors", WMID_ifOutErrors, oid_ifOutErrors, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutNUcastPkts] },
		{ "ifOutNUcastPkts", WMID_ifOutNUcastPkts, oid_ifOutNUcastPkts, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutOctets] },
		{ "ifOutOctets", WMID_ifOutOctets, oid_ifOutOctets, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutQLen] },
		{ "ifOutQLen", WMID_ifOutQLen, oid_ifOutQLen, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifOutUcastPkts] },
		{ "ifOutUcastPkts", WMID_ifOutUcastPkts, oid_ifOutUcastPkts, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifPhysAddress] },
		{ "ifPhysAddress", WMID_ifPhysAddress, oid_ifPhysAddress, DATATYPE_MACADDR_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifSpecific] },
		{ "ifSpecific", WMID_ifSpecific, oid_ifSpecific, DATATYPE_OID_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifSpeed] },
		{ "ifSpeed", WMID_ifSpeed, oid_ifSpeed, DATATYPE_ULONG_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , &mEntryTbl[WMID_ifType] },
		{ "ifType", WMID_ifType, oid_ifType, DATATYPE_INTEGER_K, val_ifType, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ifTable] , NULL },
		{ "ipAdEntAddr", WMID_ipAdEntAddr, oid_ipAdEntAddr, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipAddrTable] , &mEntryTbl[WMID_ipAdEntBcastAddr] },
		{ "ipAdEntBcastAddr", WMID_ipAdEntBcastAddr, oid_ipAdEntBcastAddr, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipAddrTable] , &mEntryTbl[WMID_ipAdEntIfIndex] },
		{ "ipAdEntIfIndex", WMID_ipAdEntIfIndex, oid_ipAdEntIfIndex, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipAddrTable] , &mEntryTbl[WMID_ipAdEntNetMask] },
		{ "ipAdEntNetMask", WMID_ipAdEntNetMask, oid_ipAdEntNetMask, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipAddrTable] , &mEntryTbl[WMID_ipAdEntReasmMaxSize] },
		{ "ipAdEntReasmMaxSize", WMID_ipAdEntReasmMaxSize, oid_ipAdEntReasmMaxSize, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipAddrTable] , NULL },
		{ "ipDefaultTTL", WMID_ipDefaultTTL, oid_ipDefaultTTL, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipForwDatagrams", WMID_ipForwDatagrams, oid_ipForwDatagrams, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipForwarding", WMID_ipForwarding, oid_ipForwarding, DATATYPE_INTEGER_K, val_ipForwarding, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipFragCreates", WMID_ipFragCreates, oid_ipFragCreates, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipFragFails", WMID_ipFragFails, oid_ipFragFails, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipFragOKs", WMID_ipFragOKs, oid_ipFragOKs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInAddrErrors", WMID_ipInAddrErrors, oid_ipInAddrErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInDelivers", WMID_ipInDelivers, oid_ipInDelivers, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInDiscards", WMID_ipInDiscards, oid_ipInDiscards, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInHdrErrors", WMID_ipInHdrErrors, oid_ipInHdrErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInReceives", WMID_ipInReceives, oid_ipInReceives, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipInUnknownProtos", WMID_ipInUnknownProtos, oid_ipInUnknownProtos, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipNetToMediaIfIndex", WMID_ipNetToMediaIfIndex, oid_ipNetToMediaIfIndex, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipNetToMediaTable] , &mEntryTbl[WMID_ipNetToMediaNetAddress] },
		{ "ipNetToMediaNetAddress", WMID_ipNetToMediaNetAddress, oid_ipNetToMediaNetAddress, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipNetToMediaTable] , &mEntryTbl[WMID_ipNetToMediaPhysAddress] },
		{ "ipNetToMediaPhysAddress", WMID_ipNetToMediaPhysAddress, oid_ipNetToMediaPhysAddress, DATATYPE_MACADDR_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipNetToMediaTable] , &mEntryTbl[WMID_ipNetToMediaType] },
		{ "ipNetToMediaType", WMID_ipNetToMediaType, oid_ipNetToMediaType, DATATYPE_INTEGER_K, val_ipNetToMediaType, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipNetToMediaTable] , NULL },
		{ "ipOutDiscards", WMID_ipOutDiscards, oid_ipOutDiscards, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipOutNoRoutes", WMID_ipOutNoRoutes, oid_ipOutNoRoutes, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipOutRequests", WMID_ipOutRequests, oid_ipOutRequests, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipReasmFails", WMID_ipReasmFails, oid_ipReasmFails, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipReasmOKs", WMID_ipReasmOKs, oid_ipReasmOKs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipReasmReqds", WMID_ipReasmReqds, oid_ipReasmReqds, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipReasmTimeout", WMID_ipReasmTimeout, oid_ipReasmTimeout, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "ipRouteAge", WMID_ipRouteAge, oid_ipRouteAge, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteDest] },
		{ "ipRouteDest", WMID_ipRouteDest, oid_ipRouteDest, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteIfIndex] },
		{ "ipRouteIfIndex", WMID_ipRouteIfIndex, oid_ipRouteIfIndex, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteInfo] },
		{ "ipRouteInfo", WMID_ipRouteInfo, oid_ipRouteInfo, DATATYPE_OID_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMask] },
		{ "ipRouteMask", WMID_ipRouteMask, oid_ipRouteMask, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMetric1] },
		{ "ipRouteMetric1", WMID_ipRouteMetric1, oid_ipRouteMetric1, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMetric2] },
		{ "ipRouteMetric2", WMID_ipRouteMetric2, oid_ipRouteMetric2, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMetric3] },
		{ "ipRouteMetric3", WMID_ipRouteMetric3, oid_ipRouteMetric3, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMetric4] },
		{ "ipRouteMetric4", WMID_ipRouteMetric4, oid_ipRouteMetric4, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteMetric5] },
		{ "ipRouteMetric5", WMID_ipRouteMetric5, oid_ipRouteMetric5, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteNextHop] },
		{ "ipRouteNextHop", WMID_ipRouteNextHop, oid_ipRouteNextHop, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteProto] },
		{ "ipRouteProto", WMID_ipRouteProto, oid_ipRouteProto, DATATYPE_INTEGER_K, val_ipRouteProto, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , &mEntryTbl[WMID_ipRouteType] },
		{ "ipRouteType", WMID_ipRouteType, oid_ipRouteType, DATATYPE_INTEGER_K, val_ipRouteType, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_ipRouteTable] , NULL },
		{ "ipRoutingDiscards", WMID_ipRoutingDiscards, oid_ipRoutingDiscards, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "mark", WMID_mark, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, webclidemoScalarHandler , NULL , NULL },
		{ "number", WMID_number, NULL, DATATYPE_STRING_K, val_number, 20, 0, 0, DB_FLAG_LEVEL_TABLE_K, webclidemoScalarHandler , NULL , NULL },
		{ "sListIndex", WMID_sListIndex, &g_liveCtrl_sListIndex, DATATYPE_SHORT_K, NULL, 2, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "sRadioIndex", WMID_sRadioIndex, &g_liveCtrl_sRadioIndex, DATATYPE_SHORT_K, NULL, 2, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_domain", WMID_smtp_domain, x_domain, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_emailBody", WMID_smtp_emailBody, x_emailBody, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_emailTextInfo", WMID_smtp_emailTextInfo, x_emailTextInfo, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_mailFrom", WMID_smtp_mailFrom, x_mailFrom, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_mailServer", WMID_smtp_mailServer, x_mailServer, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_mailTo", WMID_smtp_mailTo, x_mailTo, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_sendNow", WMID_smtp_sendNow, x_sendNow, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "smtp_subjectHeading", WMID_smtp_subjectHeading, x_subjectHeading, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "snmpEnableAuthenTraps", WMID_snmpEnableAuthenTraps, oid_snmpEnableAuthenTraps, DATATYPE_INTEGER_K, val_snmpEnableAuthenTraps, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInASNParseErrs", WMID_snmpInASNParseErrs, oid_snmpInASNParseErrs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInBadCommunityNames", WMID_snmpInBadCommunityNames, oid_snmpInBadCommunityNames, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInBadCommunityUses", WMID_snmpInBadCommunityUses, oid_snmpInBadCommunityUses, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInBadValues", WMID_snmpInBadValues, oid_snmpInBadValues, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInBadVersions", WMID_snmpInBadVersions, oid_snmpInBadVersions, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInGenErrs", WMID_snmpInGenErrs, oid_snmpInGenErrs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInGetNexts", WMID_snmpInGetNexts, oid_snmpInGetNexts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInGetRequests", WMID_snmpInGetRequests, oid_snmpInGetRequests, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInGetResponses", WMID_snmpInGetResponses, oid_snmpInGetResponses, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInNoSuchNames", WMID_snmpInNoSuchNames, oid_snmpInNoSuchNames, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInPkts", WMID_snmpInPkts, oid_snmpInPkts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInReadOnlys", WMID_snmpInReadOnlys, oid_snmpInReadOnlys, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInSetRequests", WMID_snmpInSetRequests, oid_snmpInSetRequests, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInTooBigs", WMID_snmpInTooBigs, oid_snmpInTooBigs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInTotalReqVars", WMID_snmpInTotalReqVars, oid_snmpInTotalReqVars, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInTotalSetVars", WMID_snmpInTotalSetVars, oid_snmpInTotalSetVars, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpInTraps", WMID_snmpInTraps, oid_snmpInTraps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutBadValues", WMID_snmpOutBadValues, oid_snmpOutBadValues, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutGenErrs", WMID_snmpOutGenErrs, oid_snmpOutGenErrs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutGetNexts", WMID_snmpOutGetNexts, oid_snmpOutGetNexts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutGetRequests", WMID_snmpOutGetRequests, oid_snmpOutGetRequests, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutGetResponses", WMID_snmpOutGetResponses, oid_snmpOutGetResponses, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutNoSuchNames", WMID_snmpOutNoSuchNames, oid_snmpOutNoSuchNames, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutPkts", WMID_snmpOutPkts, oid_snmpOutPkts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutSetRequests", WMID_snmpOutSetRequests, oid_snmpOutSetRequests, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutTooBigs", WMID_snmpOutTooBigs, oid_snmpOutTooBigs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "snmpOutTraps", WMID_snmpOutTraps, oid_snmpOutTraps, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysContact", WMID_sysContact, oid_sysContact, DATATYPE_STRING_K, val_sysContact, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysDescr", WMID_sysDescr, oid_sysDescr, DATATYPE_STRING_K, val_sysDescr, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysLocation", WMID_sysLocation, oid_sysLocation, DATATYPE_STRING_K, val_sysLocation, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysName", WMID_sysName, oid_sysName, DATATYPE_STRING_K, val_sysName, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysObjectID", WMID_sysObjectID, oid_sysObjectID, DATATYPE_OID_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysServices", WMID_sysServices, oid_sysServices, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "sysUpTime", WMID_sysUpTime, oid_sysUpTime, DATATYPE_TICKS_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "szAreaBuffer", WMID_szAreaBuffer, g_liveCtrl_szAreaBuffer, DATATYPE_OCTETS_K, val_szAreaBuffer, 200, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "szString", WMID_szString, g_liveCtrl_szString, DATATYPE_STRING_K, val_szString, 101, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "tcpActiveOpens", WMID_tcpActiveOpens, oid_tcpActiveOpens, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpAttemptFails", WMID_tcpAttemptFails, oid_tcpAttemptFails, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpConnLocalAddress", WMID_tcpConnLocalAddress, oid_tcpConnLocalAddress, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_tcpConnTable] , &mEntryTbl[WMID_tcpConnLocalPort] },
		{ "tcpConnLocalPort", WMID_tcpConnLocalPort, oid_tcpConnLocalPort, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_tcpConnTable] , &mEntryTbl[WMID_tcpConnRemAddress] },
		{ "tcpConnRemAddress", WMID_tcpConnRemAddress, oid_tcpConnRemAddress, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_tcpConnTable] , &mEntryTbl[WMID_tcpConnRemPort] },
		{ "tcpConnRemPort", WMID_tcpConnRemPort, oid_tcpConnRemPort, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_tcpConnTable] , &mEntryTbl[WMID_tcpConnState] },
		{ "tcpConnState", WMID_tcpConnState, oid_tcpConnState, DATATYPE_INTEGER_K, val_tcpConnState, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_tcpConnTable] , NULL },
		{ "tcpCurrEstab", WMID_tcpCurrEstab, oid_tcpCurrEstab, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpEstabResets", WMID_tcpEstabResets, oid_tcpEstabResets, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpInErrs", WMID_tcpInErrs, oid_tcpInErrs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpInSegs", WMID_tcpInSegs, oid_tcpInSegs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpMaxConn", WMID_tcpMaxConn, oid_tcpMaxConn, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpOutRsts", WMID_tcpOutRsts, oid_tcpOutRsts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpOutSegs", WMID_tcpOutSegs, oid_tcpOutSegs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpPassiveOpens", WMID_tcpPassiveOpens, oid_tcpPassiveOpens, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpRetransSegs", WMID_tcpRetransSegs, oid_tcpRetransSegs, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpRtoAlgorithm", WMID_tcpRtoAlgorithm, oid_tcpRtoAlgorithm, DATATYPE_INTEGER_K, val_tcpRtoAlgorithm, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpRtoMax", WMID_tcpRtoMax, oid_tcpRtoMax, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "tcpRtoMin", WMID_tcpRtoMin, oid_tcpRtoMin, DATATYPE_INTEGER_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "udpInDatagrams", WMID_udpInDatagrams, oid_udpInDatagrams, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "udpInErrors", WMID_udpInErrors, oid_udpInErrors, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "udpLocalAddress", WMID_udpLocalAddress, oid_udpLocalAddress, DATATYPE_IPV4_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_udpTable] , &mEntryTbl[WMID_udpLocalPort] },
		{ "udpLocalPort", WMID_udpLocalPort, oid_udpLocalPort, DATATYPE_INTEGER_K, NULL, 40, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , &mTableTbl[WGID_udpTable] , NULL },
		{ "udpNoPorts", WMID_udpNoPorts, oid_udpNoPorts, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "udpOutDatagrams", WMID_udpOutDatagrams, oid_udpOutDatagrams, DATATYPE_ULONG_K, NULL, 32, 0, 0, DB_FLAG_OID_COOKIE_K|DB_FLAG_LOCK_SELF_K, wmmHandler , NULL , NULL },
		{ "xsysContact", WMID_xsysContact, x_sysContact, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "xsysDescr", WMID_xsysDescr, x_sysDescr, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "xsysName", WMID_xsysName, x_sysName, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "nonce", WMID_nonce, NULL, DATATYPE_OCTETS_K, val_nonce, 32, 0, 0, 0, wmbGetNonceHandler , NULL , NULL },
		{ "myCheckbox", WMID_myCheckbox, &myCheckbox, DATATYPE_STRING_K, NULL, 256, 0, 0, 0, checkboxHandler , NULL , NULL },
		{ "first_i", WMID_first_i, sFirstInt, DATATYPE_STRING_K, val_first_i, 11, 0, 0, 0, webclidemoScalarHandler , NULL , NULL },
		{ "a", WMID_a, &sample_a, DATATYPE_UCHAR_K, NULL, 1, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "b", WMID_b, &sample_b, DATATYPE_UCHAR_K, NULL, 1, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "c", WMID_c, &sample_c, DATATYPE_UCHAR_K, NULL, 1, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "d", WMID_d, &sample_d, DATATYPE_UCHAR_K, NULL, 1, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "first_s", WMID_first_s, sFirstStr, DATATYPE_STRING_K, val_first_s, 40, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "first_pi", WMID_first_pi, sFirstPtrInt, DATATYPE_STRING_K, val_first_pi, 19, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "first_p", WMID_first_p, sFirstPtr, DATATYPE_STRING_K, val_first_p, 19, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "myIpAddress", WMID_myIpAddress, sFirstPtrInt, DATATYPE_STRING_K, val_myIpAddress, 10, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "nameCase", WMID_nameCase, NULL, DATATYPE_STRING_K, val_nameCase, 256, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "nameLetter", WMID_nameLetter, NULL, DATATYPE_STRING_K, val_nameLetter, 2, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "nameToAdd", WMID_nameToAdd, NULL, DATATYPE_STRING_K, val_nameToAdd, 40, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "nameToDelete", WMID_nameToDelete, NULL, DATATYPE_STRING_K, val_nameToDelete, 40, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "nameToModify", WMID_nameToModify, NULL, DATATYPE_STRING_K, val_nameToModify, 40, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "changeNameTo", WMID_changeNameTo, NULL, DATATYPE_STRING_K, val_changeNameTo, 40, 0, 0, DB_FLAG_LOCK_SELF_K, webclidemoScalarHandler , NULL , NULL },
		{ "first_name", WMID_first_name, NULL, DATATYPE_STRING_K, val_first_name, 20, 0, 0, DB_FLAG_LEVEL_TABLE_K, stringTblHandler , &mTableTbl[WGID_stringTbl] , &mEntryTbl[WMID_key_s] },
		{ "key_s", WMID_key_s, NULL, DATATYPE_STRING_K, val_key_s, 40, 0, 0, DB_FLAG_LEVEL_TABLE_K, stringTblHandler , &mTableTbl[WGID_stringTbl] , &mEntryTbl[WMID_last_name] },
		{ "last_name", WMID_last_name, NULL, DATATYPE_STRING_K, val_last_name, 20, 0, 0, DB_FLAG_LEVEL_TABLE_K, stringTblHandler , &mTableTbl[WGID_stringTbl] , NULL },
		{ "offset_i", WMID_offset_i, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblIntHandler , &mTableTbl[WGID_numberTblInt] , &mEntryTbl[WMID_value_i] },
		{ "value_i", WMID_value_i, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblIntHandler , &mTableTbl[WGID_numberTblInt] , NULL },
		{ "value_p", WMID_value_p, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrHandler , &mTableTbl[WGID_numberTblPtr] , &mEntryTbl[WMID_offset_p] },
		{ "offset_p", WMID_offset_p, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrHandler , &mTableTbl[WGID_numberTblPtr] , &mEntryTbl[WMID_pointer_p] },
		{ "pointer_p", WMID_pointer_p, NULL, DATATYPE_ULONG_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrHandler , &mTableTbl[WGID_numberTblPtr] , NULL },
		{ "offset_pi", WMID_offset_pi, NULL, DATATYPE_INTEGER_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrIntHandler , &mTableTbl[WGID_numberTblPtrInt] , &mEntryTbl[WMID_pointer_pi] },
		{ "pointer_pi", WMID_pointer_pi, NULL, DATATYPE_ULONG_K, NULL, 4, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrIntHandler , &mTableTbl[WGID_numberTblPtrInt] , &mEntryTbl[WMID_value_pi] },
		{ "value_pi", WMID_value_pi, NULL, DATATYPE_STRING_K, NULL, 256, 0, 0, DB_FLAG_LEVEL_TABLE_K, numberTblPtrIntHandler , &mTableTbl[WGID_numberTblPtrInt] , NULL },
		{ "~componentName", WMID__COMPONENTNAME_, moduleName, DATATYPE_STRING_K, NULL, sizeof(moduleName)+1, 0, 0, DB_FLAG_LOCK_SELF_K|DB_FLAG_READONLY_K, webclidemoScalarHandler , 0 , 0  },
		{ "~componentDate", WMID__COMPONENTDATE_, moduleDate, DATATYPE_STRING_K, NULL, sizeof(moduleDate)+1, 0, 0, DB_FLAG_LOCK_SELF_K|DB_FLAG_READONLY_K, webclidemoScalarHandler , 0 , 0  }
};

/* Table Index Arrays */
static char* idx_atTable[] =
{
		"atIfIndex",              /* 1 : internal */
		"atNetAddress"            /* 2 : internal */
};
static char* idx_egpNeighTable[] =
{
		"egpNeighAddr"            /* 1 : internal */
};
static char* idx_ifTable[] =
{
		"ifIndex"                 /* 1 : internal */
};
static char* idx_ipAddrTable[] =
{
		"ipAdEntAddr"             /* 1 : internal */
};
static char* idx_ipNetToMediaTable[] =
{
		"ipNetToMediaIfIndex",    /* 1 : internal */
		"ipNetToMediaNetAddress"  /* 2 : internal */
};
static char* idx_ipRouteTable[] =
{
		"ipRouteDest"             /* 1 : internal */
};
static char* idx_tcpConnTable[] =
{
		"tcpConnLocalAddress",    /* 1 : internal */
		"tcpConnLocalPort",       /* 2 : internal */
		"tcpConnRemAddress",      /* 3 : internal */
		"tcpConnRemPort"          /* 4 : internal */
};
static char* idx_udpTable[] =
{
		"udpLocalAddress",        /* 1 : internal */
		"udpLocalPort"            /* 2 : internal */
};

/* Table Entries Structure */
/* { tblName, indexCount, pIndexNames[], memberCount, WMID_FirstMember } */
static WMB_TABLE_T mTableTbl[] =
{
		{ "atTable", 2, idx_atTable, 3, &mEntryTbl[WMID_atIfIndex] },
		{ "egpNeighTable", 1, idx_egpNeighTable, 15, &mEntryTbl[WMID_egpNeighAddr] },
		{ "ifTable", 1, idx_ifTable, 22, &mEntryTbl[WMID_ifAdminStatus] },
		{ "ipAddrTable", 1, idx_ipAddrTable, 5, &mEntryTbl[WMID_ipAdEntAddr] },
		{ "ipNetToMediaTable", 2, idx_ipNetToMediaTable, 4, &mEntryTbl[WMID_ipNetToMediaIfIndex] },
		{ "ipRouteTable", 1, idx_ipRouteTable, 13, &mEntryTbl[WMID_ipRouteAge] },
		{ "tcpConnTable", 4, idx_tcpConnTable, 5, &mEntryTbl[WMID_tcpConnLocalAddress] },
		{ "udpTable", 2, idx_udpTable, 2, &mEntryTbl[WMID_udpLocalAddress] },
		{ "stringTbl", 0, NULL, 3, &mEntryTbl[WMID_first_name] },
		{ "numberTblInt", 0, NULL, 2, &mEntryTbl[WMID_offset_i] },
		{ "numberTblPtr", 0, NULL, 3, &mEntryTbl[WMID_value_p] },
		{ "numberTblPtrInt", 0, NULL, 3, &mEntryTbl[WMID_offset_pi] }
};

/******************************************************************************
 * User Local Functions.
 */

/* Forward defines for WM handles */
WMB_CID_T webclidemoComponent;


/* %%BeginUserCode webclidemo_UserFunctions */
/* %%EndUserCode   webclidemo_UserFunctions */


#ifdef __WM_EVENT_MANAGER__
/**************************************************************************
 *
 * webclidemo_RegisterEvents - Register for events with Event Manager
 *
 * This function registers to listen for all events that are generated by WMB.
 *
 * RETURNS: OK
 */

/* Instantiate the Component's Event Structures */
EM_LISTENER_CONTEXT  webclidemoEventContext;
uint32_t             webclidemoEvId[2] = {0, 0};

void webclidemo_Listener(WMB_EM_EVENT_T *pEmEvent);

static void webclidemo_RegisterEvents (void)
{
	STATUS  rc;

	rc = emListenerRegister("webclidemo", WMB_EM_NAME_K, &webclidemoEventContext);
	logMsg("Listener Register returned: %d\n", rc, 0, 0, 0, 0, 0);

	rc = emListenerEventRegister(&webclidemoEventContext, WMB_EVENT_TYPE_CONTROL_NAME_K, 0,
			EM_NOTIFY_FUNC, webclidemo_Listener, &webclidemoEvId[0]);
	logMsg("Control Event Register returned: %d\n", rc, 0, 0, 0, 0, 0);

	rc = emListenerEventRegister(&webclidemoEventContext, WMB_EVENT_TYPE_PORTFOLIO_NAME_K, 0,
			EM_NOTIFY_FUNC, webclidemo_Listener, &webclidemoEvId[1]);
	logMsg("Portfolio Event Register returned: %d\n", rc, 0, 0, 0, 0, 0);


	/* Add your events here !!! */
	/* %%BeginUserCode webclidemo_RegEmBody */
	/* %%EndUserCode   webclidemo_RegEmBody */
}
#endif /* __WM_EVENT_MANAGER__ */



#ifdef __WM_EVENT_MANAGER__
/**************************************************************************
 *
 * webclidemo_UnregisterEvents - Unregister events
 *
 * This function registers to listen for all events that are generated by WMB.
 *
 * RETURNS: OK
 */
static void webclidemo_UnregisterEvents (void)
{
	STATUS rc;
	if (webclidemoEvId[0])
	{
		rc = emListenerEventUnregister(&webclidemoEventContext, webclidemoEvId[0]);
		logMsg("Event Register returned: %d\n", rc, 0, 0, 0, 0, 0);
	}
	if (webclidemoEvId[1])
	{
		rc = emListenerEventUnregister(&webclidemoEventContext, webclidemoEvId[1]);
		logMsg("Event Register returned: %d\n", rc, 0, 0, 0, 0, 0);
	}

	/* Add your events here !!! */
	/* %%BeginUserCode webclidemo_UnregEmBody */
	/* %%EndUserCode   webclidemo_UnregEmBody */

}
#endif /* __WM_EVENT_MANAGER__ */



#ifdef __WM_EVENT_MANAGER__
/**************************************************************************
 *
 * webclidemo_Listener - receive events from WM EM
 *
 * Note that this function is designed to receive WMB generated events only. If
 * non-WMB events are expected to be handled by the same function, then the input
 * parameter must be EM_EVENT_DATA_T pointer type.
 *
 * RETURNS: OK
 */
void webclidemo_Listener
(
		WMB_EM_EVENT_T  *pEmEvent       /* [in] Pointer to the WMB specific event structure */
)
{
	/* WMB_PORTFOLIO_T *portfolio; */

	/* %%BeginUserCode webclidemo_ListenerProlog */
	/* %%EndUserCode   webclidemo_ListenerProlog */

	if (pEmEvent->emEvent.payloadSize != sizeof(WMB_EVENT_T))
	{
		logMsg("Received an unknown event\n", 0, 0, 0, 0, 0, 0);
		return;
	}

	switch (pEmEvent->wmbEvent.eventType)
	{
	case WMB_EVENT_TYPE_CONTROL:
		switch (pEmEvent->wmbEvent.eventID)
		{
		case WMB_BACKPLANE_CREATED_EVENT:
			logMsg("Backplane created event is received. Name: %s\n", (char*) pEmEvent->wmbEvent.eventInfo, 0, 0, 0, 0, 0);
			break;

		case WMB_BACKPLANE_DELETED_EVENT:
			logMsg("Backplane deleted event is received. Name:  %s\n", (char*) pEmEvent->wmbEvent.eventInfo, 0, 0, 0, 0, 0);
			break;

		default:
			logMsg("Unknown control event is received\n", 0, 0, 0, 0, 0, 0);
			break;
		}
		break;

		case WMB_EVENT_TYPE_PORTFOLIO:
			switch (pEmEvent->wmbEvent.eventID)
			{
			case WMB_PORTFOLIO_CREATED_EVENT:
				logMsg("Portfolio registered event is received. Component: %x\n", pEmEvent->wmbEvent.eventInfo[0], 0, 0, 0, 0, 0);
				break;

			case WMB_PORTFOLIO_DELETED_EVENT:
				logMsg("Portfolio unregistered event is received. Component: %x\n", pEmEvent->wmbEvent.eventInfo[0], 0, 0, 0, 0, 0);
				break;

			default:
				logMsg("Unknown portfolio event is received\n", 0, 0, 0, 0, 0, 0);
				break;
			}
			break;

			default:
				logMsg("Unknown WMB event is received\n", 0, 0, 0, 0, 0, 0);
				break;
	}

	webclidemo_WmwListener(pEmEvent);  /* Pass along to the Web Listner */


	/* %%BeginUserCode webclidemo_ListenerEpilog */
	/* %%EndUserCode   webclidemo_ListenerEpilog */

}
#endif /* __WM_EVENT_MANAGER__ */


/**************************************************************************
 *
 * WMB_WEBCLI_COMPONENT_Start - main entry point into component
 *
 * RETURNS: OK
 *
 */

WMB_CID_T webclidemoComponent = NULL;


STATUS WMB_WEBCLI_COMPONENT_Start
(
		void
)
{

	STATUS status = OK;

	/* %%BeginUserCode webclidemo_InitProlog */
	/* %%EndUserCode   webclidemo_InitProlog */

	/* %%BeginUserCode webclidemo_InitBody */
	webcli_common_init();
	webcli_http_init();
	webcli_cli_init();  
	/* %%EndUserCode   webclidemo_InitBody */

	if (wmbStartedWebCLI) return status;

	/* Startup a Wind River Management Backplane */ 
	status = wmbStart
			(
					WMB_NAME_K,           /* Name for this backplane */
					12,                   /* max registered components */
					1000,                 /* max resource entries */
					10,                   /* max table entries */
					NULL,                 /* dereg function */
					NULL,                 /* dereg cookie */
					&mAccessInfo          /* access control struct */
			);
	if (OK != status) return status;

	/* Initialize this WMB Component */
	status = wmbComponentRegister
			(
					WMB_NAME_K,           /* Name of the target backplane */
					"webclidemo",         /* Name for this component */
					WMB_WEBCLI_COMPONENT_Stop, /* Deregister Handler */
					NULL,                 /* Deregister Cookie */
					&webclidemoComponent  /* Component Structure */
			);
	if (OK != status) return status;

	/* After WMB is started you must register with backplane */
	status = wmbResourceRegister 
			(
					"webclidemo",         /* Component Name */
					"",                   /* Component Path */
					mEntryTbl,            /* Resource Entry Array */
					ARRAY_SIZE(mEntryTbl), /* Resource Entry Count */
					mTableTbl,            /* Table Entry Array */
					ARRAY_SIZE(mTableTbl), /* Resource Entry Count */
					NULL                  /* Default Resource Handler */
			);
	if (OK != status) return status;

#ifdef __WM_EVENT_MANAGER__
	/* Register with the Event Manager */
	webclidemo_RegisterEvents();
#endif

	/* #ifdef NOT_YET */
	status = webclidemo_Cli_Start(webclidemoComponent); /* cli_start */
	if (OK != status) return status;
	/* #endif */

	status = webclidemo_Web_Start(webclidemoComponent); /* httpd() */
	if (OK != status) return status;


	/* %%BeginUserCode webclidemo_InitEpilog */
	StringTableInit();

	ramDiskCreate("/ram0",64*1024*1024);
	/* %%EndUserCode   webclidemo_InitEpilog */


	wmbStartedWebCLI = TRUE;

	return OK;
}



/**************************************************************************
 *
 * WMB_WEBCLI_COMPONENT_Stop - shutdown entry point for component
 *
 * RETURNS: OK
 *
 */


STATUS WMB_WEBCLI_COMPONENT_Stop
(
		void* deregCookie
)
{
	STATUS status = OK;

	/* %%BeginUserCode webclidemo_ShutdownProlog */
	/* %%EndUserCode   webclidemo_ShutdownProlog */

	if (!wmbStartedWebCLI) return status;

#ifdef NOT_YET
	status = webclidemo_Cli_Stop(); /* cli_start */
	if (OK != status) return status;
#endif

#ifdef NOT_YET
	status = webclidemo_Mib_Stop(); /* mibway() */
	if (OK != status) return status;
#endif

	status = webclidemo_Web_Stop(); /* httpd() */
	if (OK != status) return status;

#ifdef __WM_EVENT_MANAGER__
	/* Un-Register with the Event Manager */
	webclidemo_UnregisterEvents();
#endif

	if (webclidemoComponent)
		(void) wmbComponentDeregister
		(
				webclidemoComponent   /* Component Id */
		);
	webclidemoComponent = NULL;


	/* shutdown the Wind River Management system */
	status = wmbStop
			(
					WMB_NAME_K            /* Backplane Id */
			);

	/* %%BeginUserCode webclidemo_ShutdownEpilog */
	/* %%EndUserCode   webclidemo_ShutdownEpilog */

	wmbStartedWebCLI = FALSE;

	return status;
}


/******************************************************************************
 *  Resource Handler Code
 *
 */


/**************************************************************************
 *
 * webclidemo: webclidemoScalarHandler - Displays Wind River Management system data.
 *
 */

static STATUS webclidemoScalarHandler
(
		WMB_TID_T  tid,     /* wmb transaction pointer */
		WMB_OBJ_T  obj,     /* wmb object      pointer */
		COMMAND_T  command  /* transaction type (e.g. GET,SET) */
)
{
	STATUS status = OK;
	STATUS error  = 0;
	size_t nSize  = 0;

	/* %%BeginUserCode webclidemoScalar_HandlerProlog */
	/* %%EndUserCode   webclidemoScalar_HandlerProlog */

	/* loop through all objects in the group linked list */
	while (wmbObjectGood(obj))
	{
		status = OK;
		error  = 0;

		/* %%BeginUserCode webclidemoScalar_HandlerInstance */
		/* Preset common instance or context information */
		/* %%EndUserCode   webclidemoScalar_HandlerInstance */

		/* switch on the object's enumeration ID */
		if (OK == status) switch (wmbObjectLocalGet(obj))
		{

		/* ================================================================= */
		case WMID_BoolTest :   /* bool (DATATYPE_BOOL_K) : read-write */
		{
			/* %%BeginUserCode BoolTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   BoolTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_CharTest :   /* char (DATATYPE_CHAR_K) : read-write */
		{
			/* %%BeginUserCode CharTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   CharTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_DoubleTest :   /* Custom (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode DoubleTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   DoubleTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_ERROR :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode ERROR_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   ERROR_Body */
		}
		break;

		/* ================================================================= */
		case WMID_FloatTest :   /* Custom (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode FloatTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   FloatTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_IF :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode IF_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   IF_Body */
		}
		break;

		/* ================================================================= */
		case WMID_LiveCounter :   /* long (DATATYPE_LONG_K) : read-write */
		{
			/* %%BeginUserCode LiveCounter_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   LiveCounter_Body */
		}
		break;

		/* ================================================================= */
		case WMID_LongTest :   /* long (DATATYPE_LONG_K) : read-write */
		{
			/* %%BeginUserCode LongTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   LongTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_REPEAT :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode REPEAT_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   REPEAT_Body */
		}
		break;

		/* ================================================================= */
		case WMID_ShortTest :   /* short (DATATYPE_SHORT_K) : read-write */
		{
			/* %%BeginUserCode ShortTest_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   ShortTest_Body */
		}
		break;

		/* ================================================================= */
		case WMID_createTable :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode createTable_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   createTable_Body */
		}
		break;

		/* ================================================================= */
		case WMID_endRow :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode endRow_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   endRow_Body */
		}
		break;

		/* ================================================================= */
		case WMID_endTable :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode endTable_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   endTable_Body */
		}
		break;

		/* ================================================================= */
		case WMID_err_noReadNoWrite :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode err_noReadNoWrite_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   err_noReadNoWrite_Body */
		}
		break;

		/* ================================================================= */
		case WMID_err_readButNotWrite :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode err_readButNotWrite_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   err_readButNotWrite_Body */
		}
		break;

		/* ================================================================= */
		case WMID_fFlag :   /* bool (DATATYPE_BOOL_K) : read-write */
		{
			/* %%BeginUserCode fFlag_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   fFlag_Body */
		}
		break;

		/* ================================================================= */
		case WMID_fFloat :   /* Custom (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode fFloat_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   fFloat_Body */
		}
		break;

		/* ================================================================= */
		case WMID_mark :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode mark_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/* Insert validate test here */
				/* status = wmbObjectSetRangeTest(obj); */
				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   mark_Body */
		}
		break;

		/* ================================================================= */
		case WMID_number :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode number_Body */


			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=20 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   number_Body */
		}
		break;

		/* ================================================================= */
		case WMID_sListIndex :   /* short (DATATYPE_SHORT_K) : read-write */
		{
			/* %%BeginUserCode sListIndex_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   sListIndex_Body */
		}
		break;

		/* ================================================================= */
		case WMID_sRadioIndex :   /* short (DATATYPE_SHORT_K) : read-write */
		{
			/* %%BeginUserCode sRadioIndex_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   sRadioIndex_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_domain :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_domain_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_domain_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_emailBody :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_emailBody_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_emailBody_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_emailTextInfo :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_emailTextInfo_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_emailTextInfo_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_mailFrom :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_mailFrom_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_mailFrom_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_mailServer :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_mailServer_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_mailServer_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_mailTo :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_mailTo_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_mailTo_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_sendNow :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_sendNow_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_sendNow_Body */
		}
		break;

		/* ================================================================= */
		case WMID_smtp_subjectHeading :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode smtp_subjectHeading_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Insert your undo handler code here */

				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Insert your undo handler code here */

				break;
			case CMD_COMPLETE_K:
				/* Insert your undo handler code here */

				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   smtp_subjectHeading_Body */
		}
		break;

		/* ================================================================= */
		case WMID_szAreaBuffer :   /* string (DATATYPE_OCTETS_K) : read-write */
		{
			/* %%BeginUserCode szAreaBuffer_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AO N=200 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   szAreaBuffer_Body */
		}
		break;

		/* ================================================================= */
		case WMID_szString :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode szString_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=101 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   szString_Body */
		}
		break;

		/* ================================================================= */
		case WMID_xsysContact :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode xsysContact_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   xsysContact_Body */
		}
		break;

		/* ================================================================= */
		case WMID_xsysDescr :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode xsysDescr_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   xsysDescr_Body */
		}
		break;

		/* ================================================================= */
		case WMID_xsysName :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode xsysName_Body */


			switch (command)
			{
			case CMD_GET_K:
				status =  wmbObjectLoad(obj); 
				break;
			case CMD_NVMSET_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectLoad(obj);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectRedo(obj);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectStore(obj);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectUndo(obj);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   xsysName_Body */
		}
		break;

		/* ================================================================= */
		case WMID_first_i :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode first_i_Body */


			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,sFirstInt,11,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,sFirstInt,11,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/*status = wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,sFirstInt,11,DATATYPE_STRING_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=11 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/*wmbObjectRedo(obj);*/
				wmbObjectSavedSet(obj,sFirstInt,11,DATATYPE_STRING_K);
				break;
			case CMD_COMMIT_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,sFirstInt,11,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectUndo(obj);*/
				wmbObjectSavedGet(obj,sFirstInt,11,DATATYPE_STRING_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   first_i_Body */
		}
		break;

		/* ================================================================= */
		case WMID_a :   /* unsigned char (DATATYPE_UCHAR_K) : read-write */
		{
			/* %%BeginUserCode a_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj);*/ 
				status = wmbObjectImport(obj,&sample_a,1,DATATYPE_UCHAR_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_a,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/*status = wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_a,1,DATATYPE_UCHAR_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/*wmbObjectRedo(obj);*/
				wmbObjectSavedSet(obj,&sample_a,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMMIT_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_a,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectUndo(obj);*/
				wmbObjectSavedGet(obj,&sample_a,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   a_Body */
		}
		break;

		/* ================================================================= */
		case WMID_b :   /* unsigned char (DATATYPE_UCHAR_K) : read-write */
		{
			/* %%BeginUserCode b_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_b,1,DATATYPE_UCHAR_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_b,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/*status = wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_b,1,DATATYPE_UCHAR_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/*wmbObjectRedo(obj);*/
				wmbObjectSavedSet(obj,&sample_b,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMMIT_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_b,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectUndo(obj);*/
				wmbObjectSavedGet(obj,&sample_b,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   b_Body */
		}
		break;

		/* ================================================================= */
		case WMID_c :   /* unsigned char (DATATYPE_UCHAR_K) : read-write */
		{
			/* %%BeginUserCode c_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_c,1,DATATYPE_UCHAR_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_c,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/*status = wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_c,1,DATATYPE_UCHAR_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/*wmbObjectRedo(obj);*/
				wmbObjectSavedSet(obj,&sample_c,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMMIT_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_c,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectUndo(obj);*/
				wmbObjectSavedGet(obj,&sample_c,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   c_Body */
		}
		break;

		/* ================================================================= */
		case WMID_d :   /* unsigned char (DATATYPE_UCHAR_K) : read-write */
		{
			/* %%BeginUserCode d_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&sample_d,1,DATATYPE_UCHAR_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_d,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,&sample_d,1,DATATYPE_UCHAR_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/*wmbObjectRedo(obj);*/
				wmbObjectSavedSet(obj,&sample_d,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMMIT_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,&sample_d,1,DATATYPE_UCHAR_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectUndo(obj);*/
				wmbObjectSavedGet(obj,&sample_d,1,DATATYPE_UCHAR_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   d_Body */
		}
		break;

		/* ================================================================= */
		case WMID_first_s :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode first_s_Body */
			char *sPtr;
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:

				status = wmbObjectImport(obj,sFirstStr,strlen(sFirstStr)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				status = wmbObjectExport(obj,sFirstStr,stringTableValMax*2,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectImport(obj,sFirstStr,strlen(sFirstStr)+1,DATATYPE_STRING_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */
				if (OK != status)
				{
					error = ERROR_GENERAL_OUT_OF_RANGE;
					break;
				}

				/* Attach undo information to transaction */
				wmbObjectSavedSet(obj,sFirstStr,stringTableValMax*2,DATATYPE_STRING_K);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectExport(obj,sFirstStr,stringTableValMax*2,DATATYPE_STRING_K,&nSize);

				/* force to lower case - like the keys themselves */
				for (sPtr=sFirstStr;*sPtr;sPtr++)
					*sPtr = tolower(*sPtr);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedGet(obj,sFirstStr,stringTableValMax*2,DATATYPE_STRING_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   first_s_Body */
		}
		break;

		/* ================================================================= */
		case WMID_first_pi :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode first_pi_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:

				status = wmbObjectImport(obj,sFirstPtrInt,19,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				status = wmbObjectExport(obj,sFirstPtrInt,19,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectImport(obj,sFirstPtrInt,19,DATATYPE_STRING_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=19 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectSavedSet(obj,sFirstPtrInt,19,DATATYPE_STRING_K);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectExport(obj,sFirstPtrInt,19,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedGet(obj,sFirstPtrInt,19,DATATYPE_STRING_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   first_pi_Body */
		}
		break;

		/* ================================================================= */
		case WMID_first_p :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode first_p_Body */

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/*status =  wmbObjectLoad(obj);*/
				status = wmbObjectImport(obj,sFirstPtr,19,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/*status = wmbObjectStore(obj);*/
				status = wmbObjectExport(obj,sFirstPtr,19,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				status = wmbObjectImport(obj,sFirstPtr,19,DATATYPE_STRING_K);

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=19 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				wmbObjectSavedSet(obj,sFirstPtr,19,DATATYPE_STRING_K);
				break;
			case CMD_COMMIT_K:
				status = wmbObjectExport(obj,sFirstPtr,19,DATATYPE_STRING_K,&nSize);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */

				wmbObjectSavedGet(obj,sFirstPtr,19,DATATYPE_STRING_K);
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   first_p_Body */
		}
		break;

		/* ================================================================= */
		case WMID_myIpAddress :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode myIpAddress_Body */
			char   *pIntChar = (char *) &myIpAddress;
			int    myIpOffset,myIpWithSubstitute;
			char   *sArgument = (char *) wmBufferDataGet(wmbObjectInstanceGet(obj));
			if (NULL == sArgument)
				sArgument = "";

			/* Map the argument to the IP adress byte (or whole) */
			if('0' == sArgument[0])
				myIpOffset = 0;
			else if ('1' == sArgument[0])
				myIpOffset = 1;
			else if ('2' == sArgument[0])
				myIpOffset = 2;
			else if ('3' == sArgument[0])
				myIpOffset = 3;
			else
				myIpOffset = -1;

			/* a 's' as the second char in the argument means to return the substitution WindMark  */
			/*    if specified, else always return the numerical value */
			myIpWithSubstitute = (2 == strlen(sArgument)) && ('s' == sArgument[1]);
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				switch (myIpOffset)
				{
				case 0:
					if ((0 == strlen(myIpMapping[0])) || !myIpWithSubstitute)
						status = wmbObjectImport(obj  ,&pIntChar[0],1,DATATYPE_UCHAR_K);
					else
						status = wmbObjectImport(obj,myIpMapping[0],1,DATATYPE_STRING_K);
					break;
				case 1:
					if ((0 == strlen(myIpMapping[1])) || !myIpWithSubstitute)
						status = wmbObjectImport(obj  ,&pIntChar[1],1,DATATYPE_UCHAR_K);
					else
						status = wmbObjectImport(obj,myIpMapping[1],1,DATATYPE_STRING_K);
					break;
				case 2:
					if ((0 == strlen(myIpMapping[2])) || !myIpWithSubstitute)
						status = wmbObjectImport(obj  ,&pIntChar[2],1,DATATYPE_UCHAR_K);
					else
						status = wmbObjectImport(obj,myIpMapping[2],1,DATATYPE_STRING_K);
					break;
				case 3:
					if ((0 == strlen(myIpMapping[3])) || !myIpWithSubstitute)
						status = wmbObjectImport(obj  ,&pIntChar[3],1,DATATYPE_UCHAR_K);
					else
						status = wmbObjectImport(obj,myIpMapping[3],1,DATATYPE_STRING_K);
					break;
				default :
					status = wmbObjectImport(obj,&myIpAddress,4,DATATYPE_IPV4_K);
					break;
				}                    
				break;
				case CMD_NVMSET_K:
					status = wmbObjectStore(obj);
					break;
				case CMD_GET_NEXT_K:
					/* Insert Instance Increment Code here */

					status = wmbObjectLoad(obj);

					/* Perform NEXT on instance */
					break;
				case CMD_TEST_K:
					/*   (validation string: "T=AL N=10 E=N") */
					status = wmbObjectSetRangeTest(obj); 

					/* Insert additional validate code here */

					if (OK != status)
					{   error = ERROR_GENERAL_OUT_OF_RANGE;
					break;
					}

					/* Attach undo information to transaction */
					wmbObjectRedo(obj);
					break;
				case CMD_COMMIT_K:
				{
					char *sData = (char *) wmBufferDataGet(wmbObjectValueGet(obj));

					if (myIpOffset >= 0)
					{
						/* Cancel any current WindMark substitution mapping */
						strcpy(myIpMapping[myIpOffset],"");

						/* perform any WindMark substitution */
						if((NULL != sData))
						{
							if(0 == strcmp("a",sData))
							{status = wmbObjectImport(obj,&sample_a,1,DATATYPE_UCHAR_K); strcpy(myIpMapping[myIpOffset],"a");}
							else if (0 == strcmp("b",sData))
							{status = wmbObjectImport(obj,&sample_b,1,DATATYPE_UCHAR_K); strcpy(myIpMapping[myIpOffset],"b");}
							else if (0 == strcmp("c",sData))
							{status = wmbObjectImport(obj,&sample_c,1,DATATYPE_UCHAR_K); strcpy(myIpMapping[myIpOffset],"c");}
							else if (0 == strcmp("d",sData))
							{status = wmbObjectImport(obj,&sample_d,1,DATATYPE_UCHAR_K); strcpy(myIpMapping[myIpOffset],"d");}
						}
					}

					/* Perform the IP byte (or whole) SET */
					switch (myIpOffset)
					{
					case 0:
						status = wmbObjectExport(obj,&pIntChar[0],1,DATATYPE_UCHAR_K,&nSize);
						break;
					case 1:
						status = wmbObjectExport(obj,&pIntChar[1],1,DATATYPE_UCHAR_K,&nSize);
						break;
					case 2:
						status = wmbObjectExport(obj,&pIntChar[2],1,DATATYPE_UCHAR_K,&nSize);
						break;
					case 3:
						status = wmbObjectExport(obj,&pIntChar[3],1,DATATYPE_UCHAR_K,&nSize);
						break;
					default:
						status = wmbObjectExport(obj,&myIpAddress,4,DATATYPE_IPV4_K,&nSize);
						break;
					}
				}                    
				break;
				case CMD_UNDO_K:
					/* Retrieve undo information from transaction */
					wmbObjectUndo(obj);
					break;
				case CMD_COMPLETE_K:
					/* Retrieve undo information from transaction */
					wmbObjectSavedFree(obj);
					break;
				default:
					error = ERROR_TM_BAD_CMD;
					break;
			}
			/* %%EndUserCode   myIpAddress_Body */
		}
		break;

		/* ================================================================= */
		case WMID_nameCase :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode nameCase_Body */
			char   sName[stringTableValMax*2];
			char   sKey [stringTableValMax*2];
			char   *sArgument = (char *) wmBufferDataGet(wmbObjectInstanceGet(obj));
			struct stringEntry *pPtrInstance;
			size_t bWritten;
			char   *sPtr;

			wmbTableInstanceGet ( wmbTransactionSessionGet(tid), "stringTbl", sKey, sizeof(sKey), (size_t *)(&bWritten));
			if (OK != StringTableFindbyKey(&pPtrInstance, sKey, FALSE))
				strcpy(sName,"");
			else
				sprintf(sName,"%s %s",pPtrInstance->firstName,pPtrInstance->lastName);    
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				if (NULL != sArgument)
				{
					if(0 == strcmp("upper",sArgument))
					{
						for (sPtr = sName; *sPtr; sPtr++)
							*sPtr = toupper(*sPtr);
					} else if (0 == strcmp("lower",sArgument))
					{
						for (sPtr = sName; *sPtr; sPtr++)
							*sPtr = tolower(*sPtr);
					}
				}

				status = wmbObjectImport(obj,sName,strlen(sName)+1,DATATYPE_STRING_K);                	
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=256 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   nameCase_Body */
		}
		break;

		/* ================================================================= */
		case WMID_nameLetter :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode nameLetter_Body */
			char   sName[stringTableValMax*2];
			char   sKey [stringTableValMax*2];
			char   *sArgument = (char *) wmBufferDataGet(wmbObjectInstanceGet(obj));
			struct stringEntry *pPtrInstance;
			size_t bWritten,nIndex=0;

			wmbTableInstanceGet ( wmbTransactionSessionGet(tid), "stringTbl", sKey, sizeof(sKey), (size_t *)(&bWritten));
			if (OK != StringTableFindbyKey(&pPtrInstance, sKey, FALSE))
				strcpy(sName,"");
			else
				sprintf(sName,"%s %s",pPtrInstance->firstName,pPtrInstance->lastName);

			/* Handler out-of-bounds index */
			nIndex = atoi(sArgument);
			if (nIndex > strlen(sName))
			{
				nIndex = 0;
				strcpy(sName," ");
			}  
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				sName[0] = sName[nIndex];
				sName[1] = '\0';

				status = wmbObjectImport(obj,sName,strlen(sName)+1,DATATYPE_STRING_K);                	
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=2 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   nameLetter_Body */
		}
		break;

		/* ================================================================= */
		case WMID_nameToAdd :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode nameToAdd_Body */
			char	key[stringTableValMax*2];	/* Value for entry */
			char	firstName[stringTableValMax+1];	/* Value for entry */
			char	lastName[ stringTableValMax+1];	/* Value for entry */
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,"",1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				status = wmbObjectExport(obj,(void *) key,sizeof(key),DATATYPE_STRING_K,&nSize);
				status = StringTableParseName(key, firstName, lastName);
				status = StringTableAddName(firstName,lastName);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   nameToAdd_Body */
		}
		break;

		/* ================================================================= */
		case WMID_nameToDelete :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode nameToDelete_Body */
			char	key[      stringTableValMax*2];	/* Value for entry */
			char	firstName[stringTableValMax+1];	/* Value for entry */
			char	lastName[ stringTableValMax+1];	/* Value for entry */   
			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				status = wmbObjectExport(obj,key,sizeof(key),DATATYPE_STRING_K,&nSize);
				status = StringTableParseName(key, firstName, lastName);
				status = StringTableDelName(firstName,lastName);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   nameToDelete_Body */
		}
		break;

		/* ================================================================= */
		case WMID_nameToModify :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode nameToModify_Body */
			char	key[      stringTableValMax*2];	/* Value for entry */
			char	firstName[stringTableValMax+1];	/* Value for entry */
			char	lastName[ stringTableValMax+1];	/* Value for entry */  

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				status = wmbObjectExport(obj,key,sizeof(key),DATATYPE_STRING_K,&nSize);
				status = StringTableParseName(key, firstName, lastName);
				status = StringTableDelName(firstName,lastName);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   nameToModify_Body */
		}
		break;

		/* ================================================================= */
		case WMID_changeNameTo :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode changeNameTo_Body */
			char	key[stringTableValMax*2];	/* Value for entry */
			char	firstName[stringTableValMax+1];	/* Value for entry */
			char	lastName[ stringTableValMax+1];	/* Value for entry */			

			/* Note: Locking is indicated as being handled by the user */

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,"",1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				status = wmbObjectExport(obj,(void *) key,sizeof(key),DATATYPE_STRING_K,&nSize);
				status = StringTableParseName(key, firstName, lastName);
				status = StringTableAddName(firstName,lastName);
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   changeNameTo_Body */
		}
		break;
		/* == Default Resources =================================================== */
		case WMID__COMPONENTNAME_ :   /* string : R/O */
		{   switch (command)
		{
		case CMD_GET_K:
			nSize  = strlen(moduleName) + 1;
			status = wmbObjectImport(obj,moduleName,nSize,DATATYPE_STRING_K);
			break;
		case CMD_COMPLETE_K:
			break;
		default:
			error = ERROR_TM_BAD_CMD;
			break;
		}
		}
		break;
		case WMID__COMPONENTDATE_ :   /* string : R/O */
		{   switch (command)
		{
		case CMD_GET_K:
			nSize  = strlen(moduleDate) + 1;
			status = wmbObjectImport(obj,moduleDate,nSize,DATATYPE_STRING_K);
		case CMD_COMPLETE_K:
			break;
		default:
			error = ERROR_TM_BAD_CMD;
			break;
		}
		}
		break;

		default:
		{
#ifdef _DEBUG
			printf("unknown data: %s\n", wmbObjectNameGet(obj));
#endif
			error = ERROR_GENERAL;
		}
		break;

		} /* end switch on object */

		/* set any object errors, return if not Best Effort */
		if (OK != status)
		{
			if (0 == error)
				error = ERROR_GENERAL;
			wmbObjectStatusSet(obj,error);
			if (!wmbTransactionIsBestEffort(tid))
				break;
		}

		obj = wmbObjectNextGet(obj);
	}

	/* %%BeginUserCode webclidemoScalar_HandlerEpilog */
	/* %%EndUserCode   webclidemoScalar_HandlerEpilog */

	return status;
}


/**************************************************************************
 *
 * webclidemo: stringTblHandler - Displays Wind River Management system data.
 *
 */

static STATUS stringTblHandler
(
		WMB_TID_T  tid,     /* wmb transaction pointer */
		WMB_OBJ_T  obj,     /* wmb object      pointer */
		COMMAND_T  command  /* transaction type (e.g. GET,SET) */
)
{
	STATUS status = OK;
	STATUS error  = 0;

	/* %%BeginUserCode stringTbl_HandlerProlog */
	struct stringEntry *PtrInstance;
	size_t keyOffset =  (size_t) &((struct stringEntry *) 0x0)->key;
	size_t ptrOffset =  (size_t) &((struct stringEntry *) 0x0)->nextPtr;
	/* %%EndUserCode   stringTbl_HandlerProlog */

	/* loop through all objects in the group linked list */
	while (wmbObjectGood(obj))
	{
		status = OK;
		error  = 0;

		/* %%BeginUserCode stringTbl_HandlerInstance */
		/* Preset common instance or context information */
		/* Convert the instance into a record pointer, advance the instance if GET-NEXT */

		if (OK != (status = usrObjectStrInstanceStrKey(tid, obj, command,(void*) &PtrInstance, stringTblHead, (size_t)keyOffset, (size_t)ptrOffset )))
		{
			error = wmErrNo();
		}
		/* %%EndUserCode   stringTbl_HandlerInstance */

		/* switch on the object's enumeration ID */
		if (OK == status) switch (wmbObjectLocalGet(obj))
		{

		/* ================================================================= */
		case WMID_first_name :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode first_name_Body */


			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->firstName,strlen(PtrInstance->firstName)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				status = wmbObjectImport(obj,&PtrInstance->firstName,strlen(PtrInstance->firstName)+1,DATATYPE_STRING_K);
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=20 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   first_name_Body */
		}
		break;

		/* ================================================================= */
		case WMID_key_s :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode key_s_Body */


			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->key,strlen(PtrInstance->key)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				status = wmbObjectImport(obj,&PtrInstance->key,strlen(PtrInstance->key)+1,DATATYPE_STRING_K);
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=40 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   key_s_Body */
		}
		break;

		/* ================================================================= */
		case WMID_last_name :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode last_name_Body */


			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->lastName,strlen(PtrInstance->lastName)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				status = wmbObjectImport(obj,&PtrInstance->lastName,strlen(PtrInstance->lastName)+1,DATATYPE_STRING_K);
				break;
			case CMD_TEST_K:
				/*   (validation string: "T=AL N=20 E=N") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   last_name_Body */
		}
		break;
		default:
		{
#ifdef _DEBUG
			printf("unknown data: %s\n", wmbObjectNameGet(obj));
#endif
			error = ERROR_GENERAL;
		}
		break;

		} /* end switch on object */

		/* set any object errors, return if not Best Effort */
		if (OK != status)
		{
			if (0 == error)
				error = ERROR_GENERAL;
			wmbObjectStatusSet(obj,error);
			if (!wmbTransactionIsBestEffort(tid))
				break;
		}

		obj = wmbObjectNextGet(obj);
	}

	/* %%BeginUserCode stringTbl_HandlerEpilog */
	/* %%EndUserCode   stringTbl_HandlerEpilog */

	return status;
}


/**************************************************************************
 *
 * webclidemo: numberTblIntHandler - Displays Wind River Management system data.
 *
 */

static STATUS numberTblIntHandler
(
		WMB_TID_T  tid,     /* wmb transaction pointer */
		WMB_OBJ_T  obj,     /* wmb object      pointer */
		COMMAND_T  command  /* transaction type (e.g. GET,SET) */
)
{
	STATUS status = OK;
	STATUS error  = 0;

	/* %%BeginUserCode numberTblInt_HandlerProlog */
	unsigned int IntInstance;
	/* %%EndUserCode   numberTblInt_HandlerProlog */

	/* loop through all objects in the group linked list */
	while (wmbObjectGood(obj))
	{
		status = OK;
		error  = 0;

		/* %%BeginUserCode numberTblInt_HandlerInstance */
		/* Preset common instance or context information */
		/* %%EndUserCode   numberTblInt_HandlerInstance */

		/* switch on the object's enumeration ID */
		if (OK == status) switch (wmbObjectLocalGet(obj))
		{

		/* ================================================================= */
		case WMID_offset_i :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode offset_i_Body */
			if (OK != (status = usrObjectStrInstanceInt(tid, obj, command, &IntInstance,0,numberTableRowMax-1)))
			{
				error = wmErrNo();
				break;
			}

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&numberTable[IntInstance].offset,sizeof(int),DATATYPE_INTEGER_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				/*  status = wmbObjectSetRangeTest(obj);*/ 

				/* Insert additional validate code here */
				/*
                    if (OK != status)
                    {   error = ERROR_GENERAL_OUT_OF_RANGE;
                        break;
                    }
				 */
				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectSavedFree(obj);*/
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   offset_i_Body */
		}
		break;

		/* ================================================================= */
		case WMID_value_i :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode value_i_Body */

			if (OK != (status = usrObjectStrInstanceInt(tid, obj, command, &IntInstance,0,numberTableRowMax-1)))
			{
				error = wmErrNo();
				break;
			}
			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,numberTable[IntInstance].value,strlen(numberTable[IntInstance].value)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   value_i_Body */
		}
		break;
		default:
		{
#ifdef _DEBUG
			printf("unknown data: %s\n", wmbObjectNameGet(obj));
#endif
			error = ERROR_GENERAL;
		}
		break;

		} /* end switch on object */

		/* set any object errors, return if not Best Effort */
		if (OK != status)
		{
			if (0 == error)
				error = ERROR_GENERAL;
			wmbObjectStatusSet(obj,error);
			if (!wmbTransactionIsBestEffort(tid))
				break;
		}

		obj = wmbObjectNextGet(obj);
	}

	/* %%BeginUserCode numberTblInt_HandlerEpilog */
	/* %%EndUserCode   numberTblInt_HandlerEpilog */

	return status;
}


/**************************************************************************
 *
 * webclidemo: numberTblPtrHandler - Displays Wind River Management system data.
 *
 */

static STATUS numberTblPtrHandler
(
		WMB_TID_T  tid,     /* wmb transaction pointer */
		WMB_OBJ_T  obj,     /* wmb object      pointer */
		COMMAND_T  command  /* transaction type (e.g. GET,SET) */
)
{
	STATUS status = OK;
	STATUS error  = 0;

	/* %%BeginUserCode numberTblPtr_HandlerProlog */
	struct numberEntry *PtrInstance;
	DATATYPE_T 	nType;
	char   valstr[19];
	/* %%EndUserCode   numberTblPtr_HandlerProlog */

	/* loop through all objects in the group linked list */
	while (wmbObjectGood(obj))
	{
		status = OK;
		error  = 0;

		/* %%BeginUserCode numberTblPtr_HandlerInstance */
		/* Preset common instance or context information */
		/* %%EndUserCode   numberTblPtr_HandlerInstance */

		/* switch on the object's enumeration ID */
		if (OK == status) switch (wmbObjectLocalGet(obj))
		{

		/* ================================================================= */
		case WMID_value_p :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode value_p_Body */
			if (OK != (status = usrObjectStrInstancePtr(tid, obj, command,(void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			} 

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->value,strlen(PtrInstance->value)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   value_p_Body */
		}
		break;

		/* ================================================================= */
		case WMID_offset_p :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode offset_p_Body */
			if (OK != (status = usrObjectStrInstancePtr(tid, obj, command,(void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			}

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->offset,sizeof(int),DATATYPE_INTEGER_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				/* status = wmbObjectSetRangeTest(obj);*/ 

				/* Insert additional validate code here */
				/*
                    if (OK != status)
                    {   error = ERROR_GENERAL_OUT_OF_RANGE;
                        break;
                    }
				 */
				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectSavedFree(obj);*/
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   offset_p_Body */
		}
		break;

		/* ================================================================= */
		case WMID_pointer_p :   /* unsigned long (DATATYPE_ULONG_K) : read-write */
		{
			/* %%BeginUserCode pointer_p_Body */

			if (OK != (status = usrObjectStrInstancePtr(tid, obj, command,(void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			}

			nType = wmbObjectTypeLocalGet(obj);

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				if (DATATYPE_STRING_K == nType)
				{/* Force display to hex format */
					sprintf(valstr,"0x%lx",PtrInstance->nextPtr);
					status = wmbObjectImport(obj,valstr,sizeof(valstr),DATATYPE_STRING_K);
				}
				else
				{
					status = wmbObjectImport(obj,&PtrInstance->nextPtr,sizeof(int),DATATYPE_ULONG_K);
				}                	
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				/* status = wmbObjectSetRangeTest(obj);*/ 

				/* Insert additional validate code here */
				/*
                    if (OK != status)
                    {   error = ERROR_GENERAL_OUT_OF_RANGE;
                        break;
                    }
				 */
				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				/*wmbObjectSavedFree(obj);*/
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   pointer_p_Body */
		}
		break;
		default:
		{
#ifdef _DEBUG
			printf("unknown data: %s\n", wmbObjectNameGet(obj));
#endif
			error = ERROR_GENERAL;
		}
		break;

		} /* end switch on object */

		/* set any object errors, return if not Best Effort */
		if (OK != status)
		{
			if (0 == error)
				error = ERROR_GENERAL;
			wmbObjectStatusSet(obj,error);
			if (!wmbTransactionIsBestEffort(tid))
				break;
		}

		obj = wmbObjectNextGet(obj);
	}

	/* %%BeginUserCode numberTblPtr_HandlerEpilog */
	/* %%EndUserCode   numberTblPtr_HandlerEpilog */

	return status;
}


/**************************************************************************
 *
 * webclidemo: numberTblPtrIntHandler - Displays Wind River Management system data.
 *
 */

static STATUS numberTblPtrIntHandler
(
		WMB_TID_T  tid,     /* wmb transaction pointer */
		WMB_OBJ_T  obj,     /* wmb object      pointer */
		COMMAND_T  command  /* transaction type (e.g. GET,SET) */
)
{
	STATUS status = OK;
	STATUS error  = 0;

	/* %%BeginUserCode numberTblPtrInt_HandlerProlog */
	struct numberEntry *PtrInstance;
	DATATYPE_T 	nType;
	char   valstr[19];    
	/* %%EndUserCode   numberTblPtrInt_HandlerProlog */

	/* loop through all objects in the group linked list */
	while (wmbObjectGood(obj))
	{
		status = OK;
		error  = 0;

		/* %%BeginUserCode numberTblPtrInt_HandlerInstance */
		/* Preset common instance or context information */
		/* %%EndUserCode   numberTblPtrInt_HandlerInstance */

		/* switch on the object's enumeration ID */
		if (OK == status) switch (wmbObjectLocalGet(obj))
		{

		/* ================================================================= */
		case WMID_offset_pi :   /* integer (DATATYPE_INTEGER_K) : read-write */
		{
			/* %%BeginUserCode offset_pi_Body */
			if (OK != (status = usrObjectStrInstancePtrInt(tid, obj, command, (void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			}    

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->offset,sizeof(int),DATATYPE_INTEGER_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   offset_pi_Body */
		}
		break;

		/* ================================================================= */
		case WMID_pointer_pi :   /* unsigned long (DATATYPE_ULONG_K) : read-write */
		{
			/* %%BeginUserCode pointer_pi_Body */

			if (OK != (status = usrObjectStrInstancePtrInt(tid, obj, command, (void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			}

			nType = wmbObjectTypeLocalGet(obj);

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				if (DATATYPE_STRING_K == nType)
				{/* Force display to hex format */
					sprintf(valstr,"0x%lx",PtrInstance->nextPtr);
					status = wmbObjectImport(obj,valstr,sizeof(valstr),DATATYPE_STRING_K);
				}
				else
				{
					status = wmbObjectImport(obj,&PtrInstance->nextPtr,sizeof(int),DATATYPE_ULONG_K);
				}                	
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   pointer_pi_Body */
		}
		break;

		/* ================================================================= */
		case WMID_value_pi :   /* string (DATATYPE_STRING_K) : read-write */
		{
			/* %%BeginUserCode value_pi_Body */
			if (OK != (status = usrObjectStrInstancePtrInt(tid, obj, command, (void*) &PtrInstance,numberTblHead, (size_t) &((struct numberEntry *) 0x0)->nextPtr )))
			{
				error = wmErrNo();
				break;
			}

			switch (command)
			{
			case CMD_GET_K:
				/* status =  wmbObjectLoad(obj); */
				status = wmbObjectImport(obj,&PtrInstance->value,strlen(PtrInstance->value)+1,DATATYPE_STRING_K);
				break;
			case CMD_NVMSET_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_GET_NEXT_K:
				/* Insert Instance Increment Code here */

				/* status = wmbObjectLoad(obj); */

				/* Perform NEXT on instance */
				break;
			case CMD_TEST_K:
				/*   (validation string: "NULL") */
				status = wmbObjectSetRangeTest(obj); 

				/* Insert additional validate code here */

				if (OK != status)
				{   error = ERROR_GENERAL_OUT_OF_RANGE;
				break;
				}

				/* Attach undo information to transaction */
				/* wmbObjectRedo(obj); */
				break;
			case CMD_COMMIT_K:
				/* status = wmbObjectStore(obj); */
				break;
			case CMD_UNDO_K:
				/* Retrieve undo information from transaction */
				/* wmbObjectUndo(obj); */
				break;
			case CMD_COMPLETE_K:
				/* Retrieve undo information from transaction */
				wmbObjectSavedFree(obj);
				break;
			default:
				error = ERROR_TM_BAD_CMD;
				break;
			}
			/* %%EndUserCode   value_pi_Body */
		}
		break;
		default:
		{
#ifdef _DEBUG
			printf("unknown data: %s\n", wmbObjectNameGet(obj));
#endif
			error = ERROR_GENERAL;
		}
		break;

		} /* end switch on object */

		/* set any object errors, return if not Best Effort */
		if (OK != status)
		{
			if (0 == error)
				error = ERROR_GENERAL;
			wmbObjectStatusSet(obj,error);
			if (!wmbTransactionIsBestEffort(tid))
				break;
		}

		obj = wmbObjectNextGet(obj);
	}

	/* %%BeginUserCode numberTblPtrInt_HandlerEpilog */
	/* %%EndUserCode   numberTblPtrInt_HandlerEpilog */

	return status;
}

/* Include sub-project code files */


/* End of Code Generation */

