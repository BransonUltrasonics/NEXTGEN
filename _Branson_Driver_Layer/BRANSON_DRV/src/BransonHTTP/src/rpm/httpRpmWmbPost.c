/* httpRpmWmbPost.c - WindMark POST request processing modules */

/* Copyright (c) 2001-2008, 2010-2014 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */
 
/*
modification history
-------------------- 
26sep14,r_w  fix static CHECKED_RETURN issue.
28may14,r_w  fix compile warnings(V7MAN-78)
05may14,r_w  fix static analysis issues(US35919)
08apr13,r_w  fix static analysis issues for defect WIND00411995
17dec10,m_z  part of APIs changed
             CQID: Fix WIND00247096
02feb10,h_y  support for LP64 
01apr08,q_z  Fix defect WIND00113013
05sep07,ten  Add include to allow building for linux target
22feb07,ps   apigen reformatting
13feb07,msa  Fix comments to remove APIgen errors.
26jul06,ps   update for IPV6
16feb06,ps   changes for webcli on linux
26aug05,msa  In httpRpmWmbPostExec, move session data setting code out of
             ifdef. SPR#110431
25apr05,???  Update JS Auth #define ordering
11oct04,gsr  changed httpMaxTempBufSize to wmVarMagicMarkupBufferSize
             for SPR#102228
13sep04,dkg  Modify httpRpmWmbPostExec() to support JavaScript
             Authentication feature
20jul04,dlr  SPR #99342 Use wmbObjectValueCreate to correctly set up instance/argument
27may04,dlr  Do not destroy the optional GET session if not created in httpRpmWmbPostExec
06may04,vmk  error handling for wmbTransactionProcess ( spr#91378)
27apr04,adb  replaced all buffer size constants with kMagicMarkupBufferSize
10mar04,adb  NULL instance to empty sting conversion
03mar04,gsr  for inline instancing set operation SPR#91008
16jan04,jws  remove per project dependencies
18aug03,jws  documentation updates
24jul03,jws  SPR 89657 work and general clean-up
16jun03,adb  introduced tempBuf in lclBuildSetTrans
06nov01,jc   initial creation.
*/

/*
DESCRIPTION

This library contains request processing modules (RPMs) for setting
Windmarks via an http POST.  These standard RPMs can be associated with URLs
using the WMIT project configuration tool.

In addition, the function httpRpmWmbPostExec() can be called by a user custom
RPM to do Windmark POST processing with various options not available using the
"standard" RPMs.  For example, a custom RPM which would set only posted items
whose value has changed could be as simple as:
\cs
short customRPM
    (
    HTTP_REQ_ID reqId
    )
    {
    return httpRpmWmbPostExec(reqId,RPM_CHANGE_ONLY_SET);
    }
\ce
Before the functions in this library are called to process a request, some
pre-processing of the data must be done.  The functions httpRpmUpload() or
httpRpmPost() copy any name=value duplets in the CGI stream (the http request)
to the server's environment.  Functions here will look for WindMarks in that
environment, and if found, will access the backplane to update their values.
So, for example, the following sequence could be used to register
httpRpmWmbPost() with the server for the URL /url/:
\cs
    httpRpmConfAdd (HTTP_M_POST, "/url/", httpRpmPost)
    httpRpmConfAdd (HTTP_M_POST, "/url/", httpRpmWmbPost)
\ce
Registration is normally done automatically during server initialization
in code generated by the tool WMIT.  RPMs are invoked seriatim until one
does not return RPM_OK.  RPMs in this library return RPM_OK, only if they
do not recognize the Content-Type of the request.

Functions in this library recognize POSTs with Content-Type of
"application/x-www-form-urlencoded" or "multipart/form-data".  These are the
standard types for forms and multi-part forms, respectively.


INCLUDE FILES: httpLib.h,httpRpms.h

*/

#define __WMB_STR_INST_SUPPORT__	/* Allow support for string (non-OID) instances that start with a number */

/* system header files */

#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#include "commonCfg.h"
#include "httpCfg.h"

#ifndef WEBCLI_STANDALONE_WEBSERVER

#ifdef WEBCLI_ON_LINUX
# include <errno.h>
#endif

/* WM header files */

#include "httpLib.h"
#include "httpRpms.h"
#include "httpReq.h"
#include "private/httpInt.h"
#include "httpWmbExpandInstance.h"

#ifdef __JAVASCRIPT_DIGEST_ENABLED__
#include "httpAuth.h"
#endif

/* WM project header files */

#if 0
#include "httpCfg.h"
#endif

#ifdef __SNMP_API_ENABLED__
#include "wmmErrorLog.h"
#endif

/* externals - will move to header file(s) */

IMPORT ubyte4  wmVarMagicMarkupBufferSize;

#ifdef __SNMP_API_ENABLED__
STATUS (*pWmmErrorLogStart)(INT32) = wmmErrorLogStart;
STATUS (*pWmmErrorLogEnd)(INT32) = wmmErrorLogEnd;
#else
STATUS (*pWmmErrorLogStart)(INT32) = NULL;
STATUS (*pWmmErrorLogEnd)(INT32) = NULL;
#endif

/* constants */


/* locals */

LOCAL STATUS lclBuildSetTrans(HTTP_REQ_ID, WMB_SESSION_T *, WMB_TID_T,
                              WMB_SESSION_T *);

LOCAL short   lclReportError(void);
LOCAL sbyte * lclParseInstanceInfo(sbyte * fullWindMarkName);

#if 0  /* unused routines */
LOCAL STATUS lclBuildGetTrans(HTTP_REQ_ID,WMB_SESSION_T *,WMB_TID_T);
LOCAL STATUS lclGetToSetTrans(HTTP_REQ_ID,WMB_SESSION_T *,WMB_TID_T,int);
LOCAL BOOL lclValueMatches
    (
    WMB_OBJ_T obj,     /* object to check */
    sbyte *   pVal     /* value to check against */
    );

LOCAL WMB_OBJ_T lclObjCut
    (
    WMB_TID_T tid,
    WMB_OBJ_T obj
    );

/* debuggering */

LOCAL void lclDumpTrans(WMB_TID_T,char *);
#endif

/* format string for error reporting */

static char errFmt[] = "httpRpmWmbPost errno = %d\r\n";


/* prototypes missing from header files */

WM_BUFFER_T * wmbObjectValueBufferGet
    (
    WMB_OBJ_T       obj
    );

STATUS wmbObjectSetupInstance
		(
		WMB_TID_T       tid,            
		WMB_OBJ_T       obj,            
		void  *         pInstance,      
		sbyte4          instanceLength,  
		DATATYPE_T      instanceType,   
		BOOL            copy            
		);

/**************************************************************************
*
* httpWmbPostConfInit - initialize post handling
*
* The only thing this function does is call httpUploadRpmNotLast() which
* forces the upload RPM to return RPM_OK instead of RPM_DONE, allowing for
* further http request processing after uploading.  This function is called
* by server initialization code and is not part of the public API.
*
* RETURNS: HTTP_OK
*
* NOMANUAL
*/

HTTP_STATUS httpWmbPostConfInit (void)
    {
    /* notify Upload RPM that this RPM will finish its job */

    (void) httpUploadRpmNotLast();

    return HTTP_OK;
    }

/**************************************************************************
*
* httpRpmWmbPostExec - process Windmarks in a POST
*
* This is the routine that actually sets WindMarks.  It underlies
* httpRpmWmbPost() and httpRpmWmbBestEffortPost().  Users who write their
* own custom RPM module would typically call this function to do the
* actual Windmark processing.
*
* If <flags> is 0, all items in the POST will be set.  Otherwise, <flags>
* may be any combination of:
* \is
* \i RPM_BEST_EFFORT_SET
* The set transaction is done on a "best effort" basis and will succeed
* even if some items cannot be set.
* \i RPM_CHANGE_ONLY_SET
* Set only those items whose value will change.  If, for some reason, the
* current value of an item cannot be determined, it will be set.
* \ie
*
* RETURNS: RPM_OK if the POST Content-Type is inappropriate; RPM_DONE if
* the post processing was successful; RPM_ERROR otherwise.
*/

short httpRpmWmbPostExec
    (
    HTTP_REQ_ID reqId,  /* handle of the active request */
	int         flags   /* processing options */
    )
    {
    const sbyte *     contentEnc;
    WMB_SESSION_T *   pSession = NULL;
    WMB_SESSION_T *   pGetSession = NULL;
    WMB_TID_T         tid = NULL;
    WMB_OBJ_T         pObj;
    ubyte4            trans_flags;
    BOOL              doSet;

#ifdef __JAVASCRIPT_DIGEST_ENABLED__
    WM_ACCESS_T       *userAccessLevel = NULL;
    MUD_SOCKET        sock;
#endif

	/* Set up the transaction flag(s) */

	trans_flags = (ubyte4)((flags & RPM_BEST_EFFORT_SET)  ?  WMB_TM_NOUNDO : 0);

	/* Check the header for correct content type */

    contentEnc = httpMimeHdrGet(reqId, HDR_IN, "Content-Type");

    if (strcmp(contentEnc, "application/x-www-form-urlencoded") &&
        strcmp(contentEnc, "multipart/form-data"))
        {
        return RPM_OK; /* some other RPM may deal with it */
        }

    /* create a WMB session */

    if (OK != wmbSessionCreate (httpGetWmbComp(), 0,
                                WMB_SESSION_NO_DEF_TRANSACTION, &pSession))
        {
        return lclReportError ();
        }

    /* store this request in this session */

    wmbSessionStateSet ( pSession, (void *) reqId );

    /* configure session type */

    wmbSessionTypeSet ( pSession, WMB_TYPE_WEB_K );

#ifdef __JAVASCRIPT_DIGEST_ENABLED__

    if ( OK != mudConnSocketGet(reqId->ioHandle,&sock))
         {
          (void) wmbSessionDestroy(pSession);
          return (short)wmError (ERROR_GENERAL, "unable to get sock ID");
         }

    if ( OK != wmnetClientIpAddrGet(sock,&(pSession->wmnet_IpAddr)))
         {
         pSession->wmnet_IpAddr.len = 0; /* this indicates an invalid addr */
         (void) wmbSessionDestroy(pSession);         
         return (short)wmError (ERROR_GENERAL, "unable to get address from socket");
         }

    userAccessLevel = wmAUTHCheckAuthentication ( pSession );
    if ( NULL != userAccessLevel)
         pSession->access = *userAccessLevel;


#endif /*__JAVASCRIPT_DIGEST_ENABLED__*/

    /*
     * A second session may be created if we are doing selective set's.
     * It is not an error if this session cannot be created.
     */

    if (flags & RPM_CHANGE_ONLY_SET)
        {
        (void)wmbSessionCreate(httpGetWmbComp(),0,0,&pGetSession);
        }

    if (pWmmErrorLogStart)  pWmmErrorLogStart(pSession->id);

    /*
     * Create a transaction in which to store the WindMark objects.
     * If this fails, report the error, but continue so that we can
     * clean-up properly.
     */

    doSet = ((wmbTransactionCreate(pSession, 0, trans_flags, &tid) == OK) &&
             (lclBuildSetTrans(reqId, pSession, tid, pGetSession) == OK))
            ?  TRUE : FALSE;

     if (!doSet)  
         (void) lclReportError();  /* do now to report proper errno */



#if 0
    lclDumpTrans(tid,"Before Set");
#endif

    if (doSet)  /* If nothing is wrong, we now do a SET transaction. */
        {
	    if (wmbTransactionProcess(tid, CMD_SET_K) != OK)
            {
            pObj = wmbTransactionErrQGet( tid );
		    if (NULL != pObj )
                {
                (*phttpWindMarkSetFailed)(reqId, wmbObjectNamePtrGet(pObj), (unsigned short)wmbTransactionStatusGet(tid));
                }
            else
                {
                wmLogPrintf ("httpRpmWmbPost: failed to process transaction\n");
                }
            }

        /*
         * httpPostReply() is a user supplied function which sends some
         * kind of POST response message to the client.  It might need
         * to know the session we're in.
         */

        reqId->pSession = pSession;
        (void)(*phttpPostReply) (reqId, HTTP_OK);
        }

    if (pWmmErrorLogEnd)  pWmmErrorLogEnd(pSession->id);

    /*
     * Clean up.  There is really no point in checking for errors
     * here.
     */

    if (NULL != pGetSession)
    	(void) wmbSessionDestroy(pGetSession);

    (void) wmbTransactionEnd(tid);
    (void) wmbSessionDestroy(pSession);

    return (short)((doSet)  ?  RPM_DONE : RPM_ERROR);
    }

/**************************************************************************
*
* httpRpmWmbPost - set all Windmarks in a POST
*
* Equivalent to 'httpRpmWmbPostExec(reqId,0)'.  This is the standard WMB
* POST processing function selected when Windmark POST processing is
* configured in WMIT.
*
* RETURNS: See httpRpmWmbPostExec().
*/

short httpRpmWmbPost
    (
    HTTP_REQ_ID reqId   /* Handle of the active request */
    )
	{

	return httpRpmWmbPostExec(reqId, 0) ;
	}

/**************************************************************************
*
* httpRpmWmbBestEffortPost - set Windmarks in a POST using best effort
*
* Equivalent to 'httpRpmWmbPostExec(reqId,RPM_BEST_EFFORT_SET)'.  This is
* the standard WMB POST processing function selected when Windmark
* POST processing with "best effort" is configured in WMIT.
*
* RETURNS: See httpRpmWmbPostExec().
*/

short httpRpmWmbBestEffortPost
    (
    HTTP_REQ_ID reqId   /* Handle of the active request */
    )
	{
	return httpRpmWmbPostExec(reqId, RPM_BEST_EFFORT_SET ) ;
	}


/**************************************************************************
*
* lclBuildSetTrans - build transaction for setting Windmarks
*
* This routine searches an http request for form element names and
* adds them to a wmb transaction.  If <pGetSession> is not NULL, and buffer
* space can be allocated, it will do a get on each WindMark and only add it
* to the transaction if it's value will change.
*
* Because of session and transaction interactions, we must do our get's in
* a different session than the one for the set transaction we are building.
*
* NOMANUAL
*
* RETURNS: OK or ERROR
*/

STATUS SendResponse
    (
    HTTP_REQ_ID     reqId,         /* http request */
    WMB_SESSION_T * pSession,      /* session for setting */
    WMB_TID_T       tid,           /* transaction in pSession */
    WMB_SESSION_T * pGetSession    /* (optional) session for getting */
    )
{
	return lclBuildSetTrans(reqId,pSession,tid,pGetSession);
}

LOCAL STATUS lclBuildSetTrans
    (
    HTTP_REQ_ID     reqId,         /* http request */
    WMB_SESSION_T * pSession,      /* session for setting */
    WMB_TID_T       tid,           /* transaction in pSession */
    WMB_SESSION_T * pGetSession    /* (optional) session for getting */
    )
    {
    sbyte *        pMagicMarkup = NULL;
    sbyte *        pVal = NULL;
    sbyte *        pInst = NULL;
    sbyte *        pStrTokState = NULL;
    sbyte *        pArgMagicMarkup = NULL;
    sbyte4         instLen = 0;
    void *         pBuffer = NULL;
    sbyte *        tempBuf = NULL;
    ssize_t        written = 0;
    WMB_OBJ_T      obj;
    HTTP_GEN_LIST_ENTRY_ID  lstEntry;
    static char    sUnchecked[] = "OFF";
    sbyte    inlineMark[kMagicMarkupBufferSize + 1]; /* should be max instance length ??*/


    if (NULL == reqId || NULL == reqId->argListId)
        return wmError (ERROR_GENERAL_NULL_POINTER, errFmt);

    lstEntry = httpGenListFind (reqId->argListId, "END_OF_HEADERS");

    if (lstEntry == NULL)
        return wmError(0, errFmt);

    /*
     * We use the memory pool associated with this HTTP request because
     * it should be more efficient than a general malloc().
     */

    tempBuf = memPoolAlloc(reqId->memPool,wmVarMagicMarkupBufferSize);

    if (tempBuf == NULL)
        return wmError(0, errFmt);

    /* Even if this next allocation fails, it is safe to proceed. */

    pBuffer = (pGetSession)  ?  memPoolAlloc(reqId->memPool,
                                             wmVarMagicMarkupBufferSize)
                                : NULL;

    while (httpGenListIterator(reqId->argListId, &lstEntry) != NULL)
        {
        pMagicMarkup = httpGenListIdGet (lstEntry);

        /*
         * tempBuf has sufficient size and pMagicMarkup does point to
         * a null terminated string
         */

        STRCPY (tempBuf, pMagicMarkup);


       /* Check for braces */
       if (NULL != (pInst = strstr(tempBuf,"{[")))
           {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));
             tempBuf[(pInst - tempBuf) - 1] = '\0';

           }
        else if (NULL != (pInst = strstr(tempBuf,"{(")))
            {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));
             tempBuf[(pInst - tempBuf) - 1] = '\0';

            }
        else
            {

            /* look for instance information (dotted OID suffix or parenthesis) */
            pInst = lclParseInstanceInfo (tempBuf);
            if(NULL == pInst)
                STRCPY(inlineMark, "");
            else
                {
                if(STRLEN(pInst) < (kMagicMarkupBufferSize + 1))
                  STRCPY(inlineMark, pInst);
                else
                   {
                   MEMCPY(inlineMark,pInst, kMagicMarkupBufferSize);
                   inlineMark[kMagicMarkupBufferSize] = '\0';
                   }
                }

            }

        instLen = (sbyte4)(strlen(inlineMark) + 1);

        /*
         * Deal with the only special WindMark: the checkbox manager.
         * Arguments of this "Windmark" are a list of all the checkboxes
         * in the form.  We use this list to determine which boxes are
         * not checked.
         */

        if (0 == strcmp(tempBuf, "CheckBoxManager"))
            {
            pArgMagicMarkup = httpGetEnv (reqId, pMagicMarkup);

            /*
             * Parse comma delimited list of checkboxes.  This is a
             * destructive parse which renders the list unusable.
             */

            for (pArgMagicMarkup = STRTOK_REENTRANT(pArgMagicMarkup,
                                                    ",",&pStrTokState);
                 pArgMagicMarkup != NULL;
                 pArgMagicMarkup = STRTOK_REENTRANT(NULL,
                                                    ",", &pStrTokState)
                )
                {

                if (NULL == httpGetEnv (reqId, pArgMagicMarkup))
                    {

                    /*
                     * If pArgMagicMarkup is not found in the environment
                     * (CGI stream), set it to "OFF".  We may not do this
                     * if it is already "OFF".
                     */

                    if (pBuffer)   /* set only if value will change */
                        {

                        if (wmbDataStringGet(pGetSession,pArgMagicMarkup,
                                     inlineMark,instLen,
				                     pBuffer,wmVarMagicMarkupBufferSize,
				                     &written) == OK)
     				        {

				            if (strcmp(pBuffer,sUnchecked) == 0)  continue;
				            }
				        }

#ifndef __WMB_STR_INST_SUPPORT__
                    if ((OK != wmbObjectCreate(tid, pArgMagicMarkup,
                                               inlineMark, instLen, &obj)) ||
                        (OK != wmbObjectValueCreate(obj, sUnchecked,
                                                    sizeof(sUnchecked),
                                                 DATATYPE_STRING_K, TRUE)) )
                        {
                        (*phttpWindMarkSetFailed)(reqId, pArgMagicMarkup, errno);
                        }
#else
                    if ((OK != wmbObjectCreate(tid, pArgMagicMarkup,
                                                           NULL, 0, &obj)) ||
						(OK != wmbObjectSetupInstance(tid,  obj, inlineMark,
								        instLen, DATATYPE_STRING_K, TRUE)) ||
                        (OK != wmbObjectValueCreate(obj, sUnchecked,
                                                    sizeof(sUnchecked),
                                                 DATATYPE_STRING_K, TRUE)) )
                        {
                        (*phttpWindMarkSetFailed)(reqId, pArgMagicMarkup, (unsigned short)errno);
                        }
#endif

                    }

                }
            }
        else if (wmbDataExists(pSession, tempBuf))
            {
            pVal = httpGetEnv(reqId, pMagicMarkup);

            /*
             * Create object (memory representation of a WindMark)
             * that will be added to transaction list.  The object
             * might not be created if its value would not change.
             */

            if (pBuffer)  /* set only if value will change */
                {

                if (wmbDataStringGet(pGetSession,tempBuf,inlineMark,
                                     instLen,
				                     pBuffer,wmVarMagicMarkupBufferSize,
				                     &written) == OK)
				    {
				    /*
				     * Unfortunately, "written" is not necessarily the
				     * size of the string returned, so we do a strcmp().
				     */

				    if (strcmp(pBuffer,pVal) == 0)  continue;
				    }
                }

#ifndef __WMB_STR_INST_SUPPORT__
            if ((OK != wmbObjectCreate(tid, tempBuf,
                                       inlineMark, instLen, &obj)) ||
                (OK != wmbObjectValueCreate(obj,pVal,strlen(pVal) + 1,
                                          DATATYPE_STRING_K,TRUE)) )
                {
                (*phttpWindMarkSetFailed)(reqId, pMagicMarkup, (ubyte4)errno);
                }
#else
            if ((OK != wmbObjectCreate(tid, tempBuf,
                                                   NULL, 0, &obj)) ||
				(OK != wmbObjectValueCreate(obj,pVal,strlen(pVal) + 1,
                                          DATATYPE_STRING_K,TRUE)) )
                {
                (*phttpWindMarkSetFailed)(reqId, pMagicMarkup, (unsigned short)errno);
                }

			if (OK != wmbObjectSetupInstance(tid, obj, inlineMark,
								instLen, DATATYPE_STRING_K, TRUE))
                (*phttpWindMarkSetFailed)(reqId, pMagicMarkup, (unsigned short)errno);

#endif

            }
        else   /* WindMark does not exist in wmb */
            {
                logInfoMsg ("The http post data (%s) is not a WindMark that exist in wmb, but ignore it and reply normally", pMagicMarkup);
            }
        } /* while */

    /*
     * We don't really have to free stuff here because it will be
     * freed when the request is ended, but it is not a good idea
     * to let garbage accumulate.
     */

   (void)memPoolFree(reqId->memPool,tempBuf);
    if (pBuffer)  
        (void) memPoolFree(reqId->memPool,pBuffer);

    return OK;
    }   /* lclBuildSetTrans */


#if 0  /* Here are some routines which are not used. */

/**************************************************************************
*
* lclGetToSetTrans - turn a get transaction into a set
*
* This routine takes a transaction and updates the item values so that
* a set operation can be performed.  If <setIfNeeded> is non-zero, items
* whose value would not change are cut from the transaction.
*
* Implicitly, the item values in <tid> passed to this function are the
* result of a get operation constructed by lclBuildGetTrans() using <reqId>.
*
* NOMANUAL
*
* RETURNS: OK or ERROR
*/


LOCAL STATUS lclGetToSetTrans
    (
    HTTP_REQ_ID     reqId,
    WMB_SESSION_T * pSession,
    WMB_TID_T       tid,
    int             setIfNeeded
    )
    {
    sbyte *                 pMagicMarkup;
    sbyte *                 pVal;
    sbyte4                  lenVal;
    sbyte *                 pInst =             NULL;
    sbyte *                 pStrTokState;
    sbyte *                 pArgMagicMarkup;
    sbyte4                  instLen =           0;
    WMB_OBJ_T               obj;

    HTTP_GEN_LIST_ENTRY_ID  lstEntry =          NULL;

    sbyte tempBuf[HTTP_MAX_REQLINE_SIZE];

    /* We can probably remove these parameter checks */

    if (NULL == reqId || NULL == reqId->argListId)
        return wmError (ERROR_GENERAL, "null pointer!");

    if (NULL == (lstEntry = httpGenListFind (reqId->argListId, "END_OF_HEADERS")))
        return wmError (ERROR_GENERAL, "corrupted environment");

    obj = wmbTransactionHeadGet(tid);  /* find the first object */

    /*
     * This loop needs work.
     */

    while (!wmbObjectBad(obj) &&
           (httpGenListIterator(reqId->argListId, &lstEntry) != NULL))
        {

        pMagicMarkup = httpGenListIdGet (lstEntry);

        /*
         * tempBuf has sufficient size
         * and pMagicMarkup does point to
         * a null terminating string
         */

        STRCPY (tempBuf, pMagicMarkup);

        /* Check for braces */
        if (NULL != (pInst = strstr(tempBuf,"{[")))
           {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));;
             tempBuf[(pInst - tempBuf) - 1] = '\0';

           }
        else if (NULL != (pInst = strstr(tempBuf,"{(")))
            {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));;
             tempBuf[(pInst - tempBuf) - 1] = '\0';

            }
        else
            {

            /* look for instance information (dotted OID suffix or parenthesis) */
            pInst = lclParseInstanceInfo (tempBuf);
            STRCPY(inlineMark, (NULL != pInst) ? pInst : "");

            }

        instLen = strlen(inlineMark) + 1;


        if (0 == strcmp(tempBuf, "CheckBoxManager"))
            {

            /*
             * Deal with the only special WindMark: the
             * checkbox manager.
             */

            /* copy, because parsing clobbers the list */

            pArgMagicMarkup = STRCPY(tempBuf,httpGetEnv(reqId, pMagicMarkup));

            /* parse comma delimited list to find unchecked checkboxes */

            pArgMagicMarkup = STRTOK_REENTRANT(pArgMagicMarkup,
                                               ",",
                                               &pStrTokState);

            while (NULL != pArgMagicMarkup)
                {

                if (NULL == httpGetEnv (reqId, pArgMagicMarkup))
                    {

                    /*
                     * If we get here, the object is a checkbox that we
                     * want to turn OFF.
                     */

                    pVal = "OFF";
                    lenVal = 1 + strlen(pVal);

                    if (setIfNeeded && lclValueMatches(obj,pVal))
                        {
                        obj = lclObjCut(tid,obj);  /* returns next obj */
                        }
                    else
                        {
                        if (OK != wmbObjectImport (obj, pVal,
                                                   lenVal, DATATYPE_STRING_K))
                            {
                            httpWindMarkSetFailed(reqId, pArgMagicMarkup,
                                                  errno);
                            }

                        obj = wmbObjectListNextGet (obj);
                        }
                    }

                pArgMagicMarkup = STRTOK_REENTRANT(NULL, ",", &pStrTokState);
                }
            }
        else if (wmbDataExists(pSession, tempBuf))
            {

            /*
             * This is the processing for non-special WindMarks.  This
             * is everything but the checkbox manager, which is processed
             * above.
             */

            pVal = httpGetEnv(reqId, pMagicMarkup); /* points to string */

            lenVal = 1 + strlen(pVal);              /* compute this now */

            if (setIfNeeded && lclValueMatches(obj,pVal))
                {
                obj = lclObjCut(tid,obj);  /* returns next obj */
                continue;                  /* go to next obj */
                }

            /* store the new value for this object */

            if (OK != wmbObjectImport
                          (
                          obj,               /* object          */
                          pVal,              /* value           */
                          lenVal,            /* length of value */
                          DATATYPE_STRING_K  /* type of value   */
                          ))
                {
                httpWindMarkSetFailed(reqId, pMagicMarkup, errno);
                }

            obj = wmbObjectListNextGet (obj);

            }
        else   /* WindMark does not exist in wmb */
            {
            httpWindMarkSetFailed(reqId, pMagicMarkup, errno);
            }


        } /* while */

    return OK;
    }



/**************************************************************************
*
* lclBuildGetTrans - Add WindMark names to transaction
*
* This routine searches an http request for form element names and
* adds them to a wmb transaction.  It does not create values for the
* WindMarks.
*
* NOMANUAL
*
* RETURNS: OK or ERROR
*/


LOCAL STATUS lclBuildGetTrans
    (
    HTTP_REQ_ID     reqId,
    WMB_SESSION_T * pSession,
    WMB_TID_T       tid
    )
    {
    sbyte *                 pMagicMarkup;
    sbyte *                 pVal;
    sbyte *                 pInst =             NULL;
    sbyte *                 pStrTokState;
    sbyte *                 pArgMagicMarkup;
    sbyte4                  instLen =           0;
    WMB_OBJ_T               obj;

    HTTP_GEN_LIST_ENTRY_ID  lstEntry =          NULL;

    sbyte tempBuf[HTTP_MAX_REQLINE_SIZE];

    if (NULL == reqId || NULL == reqId->argListId)
        return wmError (ERROR_GENERAL, "null pointer!");

    if (NULL == (lstEntry = httpGenListFind (reqId->argListId, "END_OF_HEADERS")))
        return wmError (ERROR_GENERAL, "corrupted environment");

    while (NULL != httpGenListIterator(reqId->argListId, &lstEntry))
        {
        pMagicMarkup = httpGenListIdGet (lstEntry);

        /*
         * tempBuf has sufficient size
         * and pMagicMarkup does point to
         * a null terminating string
         */

        STRCPY (tempBuf, pMagicMarkup);

       /* Check for braces */
       if (NULL != (pInst = strstr(tempBuf,"{[")))
           {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));;
             tempBuf[(pInst - tempBuf) - 1] = '\0';

           }
        else if (NULL != (pInst = strstr(tempBuf,"{(")))
            {
            /* expand the instances */
             httpExpandInstance (pSession, pInst, inlineMark);
             if (inlineMark[0] == '\0')
                return (wmError (ERROR_GENERAL, errFmt));;
             tempBuf[(pInst - tempBuf) - 1] = '\0';

            }
        else
           {
           /* look for instance information (dotted OID suffix or parenthesis) */
           pInst = lclParseInstanceInfo (tempBuf);
		   
		   if ((NULL != pInst)&&(strlen(pInst) > kMagicMarkupBufferSize))
		       pInst[kMagicMarkupBufferSize] = '\0';
			   
           STRCPY(inlineMark, (NULL != pInst) ? pInst : "");
           }


        instLen = strlen(inlineMark) + 1;

        /* deal with the only special WindMark: the checkbox manager */

        if (0 == strcmp(tempBuf, "CheckBoxManager"))
            {

            /* copy, because parsing clobbers the list */

            pArgMagicMarkup = STRCPY(tempBuf,httpGetEnv(reqId, pMagicMarkup));

            printf("Checkbox args = %s\r\n",pArgMagicMarkup);

            /* parse comma delimited list to find unchecked checkboxes */

            pArgMagicMarkup = STRTOK_REENTRANT(pArgMagicMarkup,
                                               ",",
                                               &pStrTokState);

            while (NULL != pArgMagicMarkup)
                {

                if (NULL == httpGetEnv (reqId, pArgMagicMarkup))
                    {

                    /*
                     * If pArgMagicMarkup which was found in the CheckBox
                     * Manager is not found in the environment (CGI stream),
                     * turn it OFF.
                     */

                    /* create a WindMark object */

#ifndef __WMB_STR_INST_SUPPORT__
                    if (OK != wmbObjectCreate(tid, pArgMagicMarkup, inlineMark,
                                              instLen, &obj))
                        {
                        httpWindMarkSetFailed(reqId, pArgMagicMarkup, errno);
                        }
#else
					/* Initialize the object, but defer the instance init to second call */
                    if ((OK != wmbObjectCreate(tid, pArgMagicMarkup, NULL,0, &obj)) ||
						(OK != wmbObjectSetupInstance(tid, obj, inlineMark,
								                 instLen, DATATYPE_STRING_K, TRUE)) )
                        {
                        httpWindMarkSetFailed(reqId, pArgMagicMarkup, errno);
                        }
#endif
                    }
                pArgMagicMarkup = STRTOK_REENTRANT(NULL, ",", &pStrTokState);
                }
            }
        else if (wmbDataExists(pSession, tempBuf))
            {
            pVal = httpGetEnv(reqId, pMagicMarkup);

            /*
             * Create object (memory representation of a WindMark)
             * that will be added to transaction list.
             */

#ifndef __WMB_STR_INST_SUPPORT__
            if (OK != wmbObjectCreate(tid, tempBuf, inlineMark, instLen, &obj))
                {
                httpWindMarkSetFailed(reqId, pMagicMarkup, errno);
                }
#else
			/* Initialize the object, but defer the instance init to second call */
            if ((OK != wmbObjectCreate(tid, tempBuf, NULL, 0, &obj)) ||
				(OK != wmbObjectSetupInstance(tid,  obj, inlineMark, instLen,
				                           DATATYPE_STRING_K, TRUE)) )
				{
				httpWindMarkSetFailed(reqId, pArgMagicMarkup, errno);
				}
#endif
            }
        else   /* WindMark does not exist in wmb */
            {
            httpWindMarkSetFailed(reqId, pMagicMarkup, errno);
            }
        } /* while */

    return OK;
    }

/**************************************************************************
*
* lclValueMatches - Check object and external value for equality
*
* This assumes both values are strings, which is a safe bet for web use.
*
* <obj> and <pVal> are known to be valid when this function is called.
*
* NOMANUAL
*
* RETURNS:
*/

LOCAL BOOL lclValueMatches
    (
    WMB_OBJ_T obj,     /* object to check */
    sbyte *   pVal     /* value to check against */
    )
    {
    WM_BUFFER_T * pBuf;      /* value buffer in object */
    void *        pBufData;  /* ptr to data in buffer */

    /*
     * XXX - We would like to pass a length in to this function and
     * be able to return FALSE if the data length of the object's
     * value does not match.  Unfortunately, this won't work, at
     * least for strings, which is what we are assuming we have
     * here.
     */

    pBuf = wmbObjectValueBufferGet(obj);
    pBufData = wmBufferDataGet(pBuf);

    return ((pBufData != NULL) && (wmBufferUsedGet(pBuf) != 0))  ?
               (strcmp(pBufData,pVal) == 0) : FALSE;

    }

/**************************************************************************
*
* lclObjCut - Cut an object from a transaction
*
* The <obj> is removed from <tid> and the next <obj> in the transaction
* is returned.
*
* This internal function can assume that the input arguments are valid.
*
* NOMANUAL
*
* RETURNS:
*/

LOCAL WMB_OBJ_T lclObjCut
    (
    WMB_TID_T tid,
    WMB_OBJ_T obj
    )
    {
    WMB_OBJ_T objNext;

    objNext = wmbObjectListNextGet(obj);   /* get this first!! */

    /* XXX - Cannot delete first object in a transaction??? */

    if (obj == wmbTransactionHeadGet(tid))  return objNext;

    printf("Cutting object %p\r\n",obj);

    wmbTransactionObjectRemove(tid,obj);
    wmbObjectDelete(obj);

    return objNext;
    }

#endif  /* End of unused routines. */


/**************************************************************************
*
* lclReportError - return RPM_ERROR and display error message
*
* This is an error reporting function used by the local RPMs.  <errno>
* should have already been set when we get here, so we pass a zero
* to wmError() which won't change <errno>.
*
* NOMANUAL
*
* RETURNS: RPM_ERROR
*/

LOCAL short lclReportError()
    {

    logErrorMsg (errFmt,errnoGet());
    wmError (0, errFmt);

    return RPM_ERROR;
    }

/**************************************************************************
*
* lclParseInstanceInfo - look for instance information in a posted WindMark
*
* This function looks for instance information in a posted WindMark. Currently
* there are two types of instance data supported:  a dotted OID following the
* WindMarks' name (such as ifPhysAddr.2.3.1), and a string delimited by
* parenthesis (such as myFormat(1.12x)).  On the first example, the instance
* data is considered to be the string "2.3.1" and in the second, "1.12x".
*
* This function takes a pointer to the full WindMark name as its first parameter,
* parses it for either type of instance information, and if found, a pointer
* to it will be returned.
*
* All processing is done "in place" so no new memory is allocated.
*
* NOMANUAL
*/

LOCAL sbyte *  lclParseInstanceInfo
    (
    sbyte * fullWindMarkName
    )
    {
    sbyte * pInst;
    sbyte * pStrTokState = NULL;

    /* look for a dot or an opening parens */

    STRTOK_REENTRANT (fullWindMarkName, ".(", &pStrTokState);
    pInst = pStrTokState;

    /* look for closing parens - don't care for result, just to overwrite it */

    (void)STRTOK_REENTRANT (NULL, ")", &pStrTokState);

    return pInst;
    }



#if 0

/**************************************************************************
*
* lclDumpTrans - print transaction info for debugging
*
* NOMANUAL
*
* RETURNS:
*/

LOCAL void lclDumpTrans
    (
    WMB_TID_T tid,
    char *    title
    )
    {
    WMB_OBJ_T       obj;
    sbyte4          written;
    sbyte *         pName;
    STATUS          s;
    static sbyte    temp[512];

    if (title)  printf("-------- %s --------\r\n",title);

    obj = wmbTransactionHeadGet (tid);

    while (! wmbObjectBad(obj))
        {
        temp[0] = '\0';
        pName   = wmbObjectNameGet  (obj);

        s = wmbObjectExport(obj,temp,sizeof(temp),DATATYPE_STRING_K,&written);

        if (s == OK)
            {
            printf("%s [%d bytes] = %s\r\n", pName, written, temp);
            }
        else
            {
            printf("%s [ERROR]\r\n", pName);
            }

        obj = wmbObjectListNextGet (obj);
        }

#if 0
    wmOidPrint(table->rowOidSfx, "instance");
#endif

    return ;
    }

#endif
#endif
