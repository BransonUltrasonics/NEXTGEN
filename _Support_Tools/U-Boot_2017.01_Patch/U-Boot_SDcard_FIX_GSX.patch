### Jazz Patch 1.0
#date: "2019-09-13 14:06:46.000000217 -0500"
#itemid: "U-Boot_SDcard/board/davinci/da8xxevm/README.da850" "_ohRi0dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ohRi0dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/dra72-evm.dts" "_nsJRoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nsJRoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/README" "_nkQg8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nkQg8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/include" "_ns4RcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ns4RcNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/mvebu_mmc.c" "_paEMANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paEMANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am43xx" "_pA3o4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA3o4NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/nand-uclass.c" "_Heoh4NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Heoh4NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/rapidio/keystone_rio.c" "_HfxxYdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HfxxYdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/configs/ti_armv7_common.h" "_prcP4dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_prcP4dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/dts/Kconfig" "_pjmigNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pjmigNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h" "_nwXDQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwXDQdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools/patman/patman" "_p6MdkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p6MdkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net/phy" "_pcYgMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pcYgMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c" "_pZ6bANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ6bANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/Makefile" "_nkP54NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nkP54NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mmc_write.c" "_paC94NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paC94NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/baltos.h" "_pn2JUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pn2JUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/lib/bootm-fdt.c" "_n3DhIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n3DhIdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/memory/Makefile" "_pZgLUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZgLUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/common" "_pBFEQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBFEQdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h" "_n6LGkdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6LGkdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/dfu/Kconfig" "_pX6P4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX6P4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/memory/Kconfig" "_pZe9MNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZe9MNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t3517" "_ogLWoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogLWoNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/tools/patman" "_p6Fv4dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p6Fv4dWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/technexion/twister/twister.c" "_pAB7YNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAB7YNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm" "_nwGkkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwGkkNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx" "_nm4-MNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nm4-MNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/fs/jffs2" "_pkO0oNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkO0oNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/configs/dra7xx_evm_defconfig" "_pNFf8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pNFf8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/microblaze/dts/include/dt-bindings" "_HAGy0NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HAGy0NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/doc/driver-model" "_pUwOMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pUwOMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h" "_nwSx0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwSx0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/MAINTAINERS" "_nkLBYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nkLBYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c" "_ogOZ8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogOZ8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig" "_pNGHANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pNGHANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap4" "_n7n4ENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7n4ENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h" "_n6GOENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6GOENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am335x" "_pAt34NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAt34NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig" "_n7R50NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7R50NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand" "_paXuAdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paXuAdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/am57xx" "_pA76UdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA76UdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/usb/gadget/rndis.h" "_phlwUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phlwUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board.c" "_pBU74dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBU74dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/amazon/kc1" "_oX1S8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oX1S8NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/lib/efi_loader/helloworld.efi" "_HlsMINZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HlsMINZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/uniphier-sd.c" "_paMu4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paMu4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h" "_nwT_8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwT_8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2e-evm.dts" "_G5z9ldZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9ldZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/configs/socfpga_de1_soc.h" "_prD1YNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_prD1YNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/mon.c" "_n6PYANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6PYANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools/binman/binman" "_p4ZGwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p4ZGwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/davinci/da8xxevm" "_ohN4cNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ohN4cNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c" "_peYrUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_peYrUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs" "_pmVtcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pmVtcNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/configs/k2l_evm_defconfig" "_pN0fwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pN0fwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2g-netcp.dtsi" "_G5z9ktZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9ktZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c" "_pBWxENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBWxENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/microblaze/dts/include" "_oGiuodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oGiuodWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/tools/dtoc/dtoc.py" "_p5PbUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p5PbUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig" "_n7vM0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7vM0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am57xx/mux_data.h" "_pBALwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBALwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/environment/ti/qspi_am5728.h" "_Hk7XIdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hk7XIdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/omap_common.h" "_n2m1MdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2m1MdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/k2hk_evm_defconfig" "_pN0fwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pN0fwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am572x-idk.dts" "_nrZDsNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrZDsNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/s3c_sdi.c" "_paIdcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paIdcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2e-netcp.dtsi" "_G5z9k9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9k9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/scripts/checkpatch.pl" "_p2lI4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p2lI4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools/dtoc/dtoc" "_p5O0QNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p5O0QNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/sdp4430/sdp.c" "_pBmosdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBmosdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/common/Kconfig" "_pBGSYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBGSYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile" "_n7TH8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7TH8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/htkw/mcx/mcx.c" "_owZj8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_owZj8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c" "_o0k5UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0k5UNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/cache.h" "_n2F30NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2F30NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net" "_pbUJMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pbUJMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/siemens-am33x-common.h" "_pq9HsdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pq9HsdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/omap5_uevm/evm.c" "_pBeF0dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBeF0dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools/buildman/buildman" "_p5ItodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p5ItodWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/environment/ti/mmc.h" "_Hk7XItZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hk7XItZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/logicpd/zoom1" "_o0pKwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0pKwNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/spl/Kconfig" "_pHeAINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHeAINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/fat" "_pkKjMdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkKjMdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/configs/omapl138_lcdk_defconfig" "_pPIuYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pPIuYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/technexion/tao3530" "_o_5YgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o_5YgNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/omapl138_lcdk.h" "_pqZHANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pqZHANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/ext4/dev.c" "_pkHf4dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkHf4dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2l.dtsi" "_G5z9lNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9lNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c" "_n7y3MNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7y3MNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-tegra/board.c" "_n-ov0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n-ov0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c" "_n7zeQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7zeQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am335x/board.h" "_pAywYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAywYdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c" "_pid6ENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pid6ENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c" "_pBXYINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBXYINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/memory" "_pZeWIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZeWIdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/timll/devkit8000" "_pB1SMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pB1SMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/.gitignore" "_HbglYNWdEem1BusWY07OVQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbglYNWdEem1BusWY07OVQ" "file"
#itemid: "U-Boot_SDcard/common/splash_source.c" "_pHnKENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHnKENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/spl.h" "_pwtKYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pwtKYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/k2g_evm_defconfig" "_pNz4sNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pNz4sNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am437x-gp-evm-u-boot.dtsi" "_G5z9kdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9kdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/ti-common" "_n2zpgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2zpgNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/am43xx/MAINTAINERS" "_pA6FINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA6FINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h" "_n2oDUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2oDUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am335x/board.c" "_pAywYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAywYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/memory/ti-gpmc.c" "_HeKAwNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HeKAwNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h" "_nwWcMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwWcMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/pepper.h" "_pqiQ8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pqiQ8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/environment/ti/qspi.h" "_Hk7XINZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hk7XINZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/sh_sdhi.c" "_paK5sNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paK5sNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/sunxi_mmc.c" "_paLgwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paLgwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c" "_pdpEcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pdpEcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/ti_omap4_common.h" "_presINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_presINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/pengwyn.h" "_pqhp4dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pqhp4dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h" "_n6E_8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6E_8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/fsl_esdhc.c" "_pZ9eUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ9eUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/dw_mmc.c" "_pZ83QNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ83QNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mmc_spi.c" "_paCW0dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paCW0dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/dfu" "_pX5BwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX5BwdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/common.h" "_pmQ08NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pmQ08NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2g-ice.dts" "_G5t29dZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t29dZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/configs/am335x_evm.h" "_pnj1cdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnj1cdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2e.dtsi" "_G56EMdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G56EMdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t35" "_ogHsQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogHsQNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c" "_n7cR4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7cR4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am571x-idk.dts" "_nrYcoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrYcoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am57xx/board.c" "_pA_ksdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA_ksdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/sandbox/dts/include" "_oN0bUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oN0bUNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/xyzModem.c" "_pHqNYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHqNYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/omap5_uevm" "_pBbCgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBbCgNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/ti_omap5_common.h" "_presIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_presIdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h" "_nzSbcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzSbcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2g-evm.dts" "_G5t29tZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t29tZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mmc_private.h" "_paCW0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paCW0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl_ram.c" "_HY0NwdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HY0NwdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/tools/buildman" "_p5D1INWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p5D1INWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/main.c" "_pHZusNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHZusNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2l-netcp.dtsi" "_G56EMtZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G56EMtZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/dts" "_pjkGQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pjkGQdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c" "_n7XZYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7XZYdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/Makefile" "_nrM2cNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrM2cNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/doc/driver-model/README.txt" "_pUxcUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pUxcUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/power" "_pwGtcdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pwGtcdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/scripts" "_p2V4UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p2V4UNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c" "_pa880NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pa880NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/technexion/tao3530/tao3530.c" "_o_9C4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o_9C4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/usb/gadget/Kconfig" "_phUDgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phUDgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/power/pmic" "_peL3ANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_peL3ANWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/x86/dts/include" "_oRuq8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oRuq8NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/spl/spl_fat.c" "_pHhDcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHhDcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/beagle" "_pBALwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBALwdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/quipos/cairo/cairo.c" "_o5EXwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o5EXwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/logicpd/am3517evm" "_o0gn4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0gn4NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2hk.dtsi" "_G56EM9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G56EM9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/ti/dra7xx" "_pBIuoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBIuoNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h" "_nwUnANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwUnANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/linux/mtd/nand.h" "_pvKSQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pvKSQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/pinctrl" "_pdR4ENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pdR4ENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/logicpd/omap3som" "_o0lgYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0lgYNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/sdp4430" "_pBjlYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBjlYNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2g-generic.dts" "_G5t29NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t29NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/fs/yaffs2" "_pkxAIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkxAIdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/am3517crane/am3517crane.c" "_pA3B0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA3B0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd/jffs2.c" "_pGRtUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pGRtUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/dm/util.h" "_psVAsNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_psVAsNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/dm" "_psGXMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_psGXMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/tools/dtoc" "_p5MYAdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p5MYAdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/core" "_pWabENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pWabENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/environment/ti" "_ptzAUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ptzAUNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/fs/fat/fat.c" "_pkM_cdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkM_cdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am3517crane" "_pAz-gdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAz-gdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-davinci/include/mach" "_n4rRwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n4rRwNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/cmd/rio.c" "_HYbzQNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HYbzQNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/rapidio/keystone_rio.h" "_Hf34AtZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hf34AtZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/Kconfig" "_pabYYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pabYYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/malloc_simple.c" "_pHZusdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHZusdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/am335x_igep0033.h" "_pnkcgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnkcgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c" "_pZ-FYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ-FYdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/boot_fit.h" "_HiixgNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HiixgNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/amazon/kc1/kc1.c" "_oX5kYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oX5kYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/rapidio/Makefile" "_HfxxYNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HfxxYNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/isee/igep00x0/igep00x0.c" "_oyVdoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oyVdoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile" "_n7wa8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7wa8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/quipos/cairo" "_o5AGUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o5AGUNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/rapidio/Kconfig" "_Hf34AdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hf34AdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx" "_nwN5UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwN5UNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/imx6_spl.h" "_ppFfcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ppFfcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx" "_n7QEodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7QEodWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/dfu.c" "_pHAtINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHAtINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/env_ext4.c" "_pHHa0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHHa0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/k2e_evm_defconfig" "_pNzRodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pNzRodWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/dra7.dtsi" "_nsFnQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nsFnQdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/evm/evm.c" "_pBQDYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBQDYdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/rio.h" "_HiixgdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HiixgdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/asm-generic" "_plyT0dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_plyT0dWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c" "_n7U9INWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7U9INWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common" "_pGwOcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pGwOcNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/dfu/dfu_mmc.c" "_pX8sINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX8sINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/am335x_sl50.h" "_pnlDkdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnlDkdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/panda" "_pBfT8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBfT8NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h" "_n6JRYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6JRYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl_ext.c" "_pHgcYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHgcYdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/lib" "_pxoXcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pxoXcNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/rapidio/rio-uclass.c" "_Hf34ANZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hf34ANZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/common/board_f.c" "_pG5YYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pG5YYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/dra7xx_evm.h" "_pom-UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pom-UNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-tegra" "_n-j3UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n-j3UNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/env_fat.c" "_pHHa0dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHHa0dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/lib/tiny-printf.c" "_py1RUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_py1RUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c" "_n76L8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n76L8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5" "_n7t-sNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7t-sNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/configs/am43xx_evm_defconfig" "_pLwDMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLwDMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/dfu/dfu_nand.c" "_pX8sIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX8sIdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/overo" "_o33d4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o33d4NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/am335x_shc.h" "_pnlDkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnlDkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl.c" "_pHf1UNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHf1UNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/bur_am335x_common.h" "_poH2INWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_poH2INWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/scripts/Makefile.spl" "_p2fpUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p2fpUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts" "_nraR0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nraR0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/lib/efi_loader" "_pyCnINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pyCnINWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c" "_paGoQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paGoQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2e-clocks.dtsi" "_G5nwUtZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5nwUtZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/config.mk" "_n572ANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n572ANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c" "_n7dgANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7dgANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h" "_n2oqYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2oqYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c" "_pZ_TgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ_TgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include" "_plPhQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_plPhQNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/sdhci.c" "_paJrkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paJrkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mxcmmc.c" "_paEzENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paEzENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd/Kconfig" "_pFtsoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pFtsoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h" "_nzaXQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzaXQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/bfin_sdh.c" "_pZ7pIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ7pIdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/linux/mtd" "_pvDkkdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pvDkkdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/dfu.h" "_psEiANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_psEiANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/lib/cache-cp15.c" "_n3EvQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n3EvQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h" "_nzVewNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzVewNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2g.dtsi" "_G5nwUdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5nwUdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/overo/overo.c" "_o37IQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o37IQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ti814x" "_pBnPwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBnPwdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/davinci_mmc.c" "_pZ8QMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ8QMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/spi/ti_qspi.c" "_pgbSsdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pgbSsdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am57xx_evm_defconfig" "_pLx4YNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLx4YNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/sh_mmcif.c" "_paJrkdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paJrkdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/Kconfig" "_n52WcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n52WcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools" "_p4NgkdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p4NgkdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/power" "_pd14wNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pd14wNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/serial" "_pfgssNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pfgssNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/lg/sniper" "_o0UaoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0UaoNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h" "_n6DKwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6DKwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/tools/binman" "_p4WDcdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p4WDcdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/spi" "_pgDfQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pgDfQNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/Kconfig" "_pG2VENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pG2VENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c" "_ogKvkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogKvkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl_net.c" "_pHi4oNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHi4oNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-davinci" "_n4hgwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n4hgwNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/serial/ns16550.c" "_pfpPkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pfpPkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net/cpsw.c" "_pbkn4dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pbkn4dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/jffs2/jffs2_1pass.c" "_pkTtINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkTtINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/Makefile" "_pacmgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pacmgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/lg/sniper/sniper.c" "_o0YsENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0YsENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c" "_pkUUMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkUUMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/asm-generic/global_data.h" "_pl5BgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pl5BgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/tegra_mmc.c" "_paMH0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paMH0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mmc-uclass.c" "_paAhoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paAhoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c" "_n572AdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n572AdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/isee/igep00x0" "_oySaUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oySaUNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/boot_fit.c" "_HYuHINZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HYuHINZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts" "_nsIDgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nsIDgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/technexion/twister" "_o_9p8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o_9p8NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/usb/gadget" "_phRAMdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phRAMdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/tools/omapimage.c" "_p6D6sNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p6D6sNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mmc.c" "_paBIsNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paBIsNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc/mxsmmc.c" "_paEzEdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paEzEdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net/cpsw-common.c" "_pbkn4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pbkn4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c" "_pacmgdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pacmgdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/Kconfig" "_pBSfoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBSfoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/serial/serial_rockchip.c" "_pfyZgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pfyZgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c" "_pARL8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pARL8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/power/palmas.c" "_peLP8dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_peLP8dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/usb/gadget/rndis.c" "_phlJQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phlJQdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/clock.c" "_n54ysNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n54ysNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi" "_nrZqwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrZqwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2hk-evm.dts" "_G56EMNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G56EMNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/usb/musb-new" "_piRs0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_piRs0NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h" "_phitAdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phitAdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/doc/README.ti-secure" "_pSouUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pSouUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/lib/fdtdec.c" "_pyM_MdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pyM_MdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/gumstix/duovero" "_ov_UQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ov_UQNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/nand.h" "_pv3c4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pv3c4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/dt-bindings/pinctrl" "_ptJgENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ptJgENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c" "_pBWKANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBWKANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/dm/uclass-id.h" "_psTLgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_psTLgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig" "_pLyfcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLyfcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/am43xx_evm.h" "_pnm4wNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnm4wNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-davinci/spl.c" "_n5GIgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n5GIgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board.h" "_pBVi8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBVi8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c" "_patFMdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_patFMdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts" "_nrZqwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrZqwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h" "_pBabcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBabcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/teejet/mt_ventoux" "_pAM6gNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pAM6gNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c" "_nm9PoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nm9PoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c" "_plGXUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_plGXUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c" "_n7TvANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7TvANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl" "_pHcyANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHcyANWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/cm_t335.h" "_poTcUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_poTcUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c" "_n7sJgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7sJgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi" "_nrbf8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nrbf8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/am43xx/board.c" "_pA6sMdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pA6sMdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/sandbox/dts/include/dt-bindings" "_HCNEkNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HCNEkNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/common/env_sf.c" "_pHLsQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHLsQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/mips/dts/include" "_oHGvUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oHGvUNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/usb/gadget/ether.c" "_phfCoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_phfCoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/bav335x.h" "_pn2wYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pn2wYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts" "_nqsgINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nqsgINWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/corscience/tricorder/tricorder.c" "_og8LoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_og8LoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c" "_n7UWEdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7UWEdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/Makefile" "_n7PdkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7PdkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/core/regmap.c" "_pWfTkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pWfTkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/Makefile" "_pHfOQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHfOQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd/bootm.c" "_pF1BYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pF1BYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am335x_hs_evm_defconfig" "_HbMzYdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbMzYdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/fdt.c" "_G9PsENZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G9PsENZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/power/tps65218.h" "_pwV-AdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pwV-AdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c" "_pBWKAdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBWKAdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am57xx_hs_evm_defconfig" "_pLyfcdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLyfcdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c" "_n56n4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n56n4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone" "_n5z6MNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n5z6MNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/Kconfig" "_nj2RQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nj2RQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/dra71-evm.dts" "_nsG1YNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nsG1YNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/fs/fat/fat_write.c" "_pkNmgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkNmgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/core/util.c" "_pWhIwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pWhIwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/ti_armv7_keystone2.h" "_prc28NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_prc28NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/Kconfig" "_n7NoYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7NoYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am43xx_hs_evm_qspi_defconfig" "_HbMzYtZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbMzYtZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/cmd/nand.c" "_pGcFYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pGcFYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/scripts/Makefile.lib" "_p2fCQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p2fCQdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/dra7-evm.dts" "_nsFAMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nsFAMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h" "_n4_a0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n4_a0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net/keystone_net.c" "_pcIokdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pcIokdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/corscience/tricorder" "_og2sENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_og2sENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c" "_n7YngNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7YngNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am43xx_hs_evm_defconfig" "_pLxRUdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLxRUdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/dra7xx/mux_data.h" "_pBMZANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBMZANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/common/board_detect.c" "_pBHggNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBHggNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/include/dt-bindings" "_G56ENNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G56ENNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/fdt-common.c" "_G9JlcNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G9JlcNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/build_sdcard_sc.sh" "_G2YPEdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G2YPEdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/xtensa/dts/include" "_oUHQkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oUHQkNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5" "_nzP_MdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzP_MdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/panda/panda.c" "_pBiXQdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBiXQdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/dra7xx/evm.c" "_pBLx8dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBLx8dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/lib/Makefile" "_n3BE4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n3BE4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/x86/dts/include/dt-bindings" "_HDKG0NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HDKG0NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/configs/k2g_hs_evm_defconfig" "_HbMzYNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbMzYNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/doc/README.rapidio" "_Hb3hwNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_Hb3hwNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/common/Makefile" "_pG4KQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pG4KQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ti814x/evm.c" "_pBq6INWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBq6INWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/net/phy/ti.c" "_pcjfUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pcjfUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl_mmc.c" "_pHhqgdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHhqgdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/rapidio" "_HdAxQNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HdAxQNZNEemoQdC2-rADaQ" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/config.mk" "_n7acsdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7acsdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd.txt" "_G2YPENZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G2YPENZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/omap5-u-boot.dtsi" "_G5z9kNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5z9kNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/logicpd/zoom1/zoom1.c" "_o0tcMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0tcMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/nios2/dts/include" "_oI9JcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oI9JcNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/configs/pcm051.h" "_pqfNoNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pqfNoNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/image.h" "_pueVwdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pueVwdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd/mmc.c" "_pGXM4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pGXM4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/mmc.h" "_pvtE0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pvtE0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/spi" "_pa2PINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pa2PINWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/ti-common/ti-gpmc.h" "_G70IsNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G70IsNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/cmd/Makefile" "_pFu6wNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pFu6wNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/spl/spl_fit.c" "_pHhqgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHhqgNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/TISDK-README" "_G2YPE9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G2YPE9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/lib" "_n2-BkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n2-BkNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/net/phy/cortina.c" "_pccxodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pccxodWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t54" "_ogT5gdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogT5gdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/tools/microcode-tool" "_p58l8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_p58l8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/BuR/common" "_oVaRENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oVaRENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/common/board_detect.h" "_pBIHkNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBIHkNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/evm" "_pBNAENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBNAENWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/fs/ext4/ext4fs.c" "_pkKjMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkKjMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds" "_n76zAdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n76zAdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mmc" "_pZ1igNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pZ1igNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/env_mmc.c" "_pHIo8dWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHIo8dWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h" "_nzWs4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzWs4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm" "_pBRRgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBRRgNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/fw_update.h" "_HYuHI9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HYuHI9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/nios2/dts/include/dt-bindings" "_HA9ucNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HA9ucNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-evm-reva3.dts" "_G5t28tZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t28tZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/core/root.c" "_pWf6oNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pWf6oNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach" "_n59rMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n59rMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c" "_pibd0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pibd0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/power/tps65910.h" "_pwWlENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pwWlENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am335x_hs_evm_uart_defconfig" "_HbS6AtZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbS6AtZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/lib/efi_loader/helloworld.so" "_HlySwNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HlySwNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/configs/omap5_uevm.h" "_pqWDsdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pqWDsdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c" "_n7VkMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7VkMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/clk/at91" "_pV9vIdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pV9vIdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/env_nand.c" "_pHJQANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHJQANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/fw_validation.h" "_HYuHItZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HYuHItZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/am57xx-evm-common.dtsi" "_G5t28dZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t28dZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/drivers/dfu/dfu.c" "_pX8FENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX8FENWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h" "_nwe_EdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nwe_EdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2" "_n7LzMdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7LzMdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/board/ti/beagle/beagle.c" "_pBD2IdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBD2IdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/k2hk_evm.h" "_ppNbQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ppNbQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/dfu/Makefile" "_pX7eANWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pX7eANWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/k2l_evm.h" "_ppOCUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ppOCUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/k2e_hs_evm_defconfig" "_HbS6AdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbS6AdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c" "_ogXj4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ogXj4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk" "_n7bDwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7bDwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/mtd/nand/nand.c" "_panlodWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_panlodWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/cli.c" "_pG9CwNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pG9CwNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig" "_pLxRUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLxRUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/am57xx_evm.h" "_pnnf0NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pnnf0NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2hk-clocks.dtsi" "_G5nwUNZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5nwUNZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/timll/devkit8000/devkit8000.c" "_pB48kNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pB48kNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h" "_ptNKcdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ptNKcdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/environment/ti/dfu.h" "_pt01gNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pt01gNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/Kconfig" "_pVKd4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pVKd4NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2hk-netcp.dtsi" "_G5t28NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t28NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c" "_n7yQINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7yQINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/configs/k2e_evm.h" "_ppM0MNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ppM0MNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/common_fit.c" "_HYuHIdZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HYuHIdZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/htkw/mcx" "_owV5kNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_owV5kNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/common/fb_nand.c" "_pHNhcNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHNhcNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/common/image.c" "_pHSZ8NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHSZ8NWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c" "_o0ojsNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_o0ojsNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/k2hk_hs_evm_defconfig" "_HbS6ANZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbS6ANZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/fs/ext4" "_pkEckNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pkEckNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers/mmc/omap_hsmmc.c" "_paFaINWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_paFaINWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/BuR/common/common.c" "_oVcGQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_oVcGQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/xtensa/dts/include/dt-bindings" "_HD670NZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HD670NZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2l-evm.dts" "_G5nwU9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5nwU9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/arch/mips/dts/include/dt-bindings" "_HATAENZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HATAENZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c" "_pBZNUNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pBZNUNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/cmd" "_pFmX4NWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pFmX4NWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/include/ns16550.h" "_pv6gMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pv6gMNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h" "_nzblYNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nzblYNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/arch/arm/dts/keystone-k2l-clocks.dtsi" "_G5t289ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_G5t289ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/include/configs/k2g_evm.h" "_ppM0MdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_ppM0MdWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am335x_evm_defconfig" "_pLm5QNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pLm5QNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard" "_nfadMNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_nfadMNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/doc" "_pRRcYdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pRRcYdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c" "_n7Z1oNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n7Z1oNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/board/gumstix/duovero/duovero.c" "_owC-oNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_owC-oNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/include/net.h" "_pv55INWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pv55INWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/configs/am43xx_evm_rtconly_defconfig" "_HbS6A9ZNEemoQdC2-rADaQ" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_HbS6A9ZNEemoQdC2-rADaQ" "file"
#itemid: "U-Boot_SDcard/configs" "_pHq0cdWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pHq0cdWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/drivers" "_pVGzgNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pVGzgNWREemosbt8qfSL1Q" "folder"
#itemid: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h" "_n6IDQNWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_n6IDQNWREemosbt8qfSL1Q" "file"
#itemid: "U-Boot_SDcard/drivers/clk/at91/pmc.c" "_pWG5ENWREemosbt8qfSL1Q" "_XfK8ktP4EemuhoWuhn5Uqg"
#item_type: "_pWG5ENWREemosbt8qfSL1Q" "file"
#before_state: "U-Boot_SDcard/board/davinci/da8xxevm/README.da850" "_ohRi0dWREemosbt8qfSL1Q" "_ssjIotWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/dra72-evm.dts" "_nsJRoNWREemosbt8qfSL1Q" "_sxUTjtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/config.mk" "_n572ANWREemosbt8qfSL1Q" "_tDV3-9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/README" "_nkQg8NWREemosbt8qfSL1Q" "_snVRadWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c" "_n7dgANWREemosbt8qfSL1Q" "_slF1fNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h" "_n2oqYNWREemosbt8qfSL1Q" "_shOCDNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mvebu_mmc.c" "_paEMANWREemosbt8qfSL1Q" "_s6Z-jtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c" "_pZ_TgNWREemosbt8qfSL1Q" "_s-ks7NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/sdhci.c" "_paJrkNWREemosbt8qfSL1Q" "_slsSZdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mxcmmc.c" "_paEzENWREemosbt8qfSL1Q" "_srDTk9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/Kconfig" "_pFtsoNWREemosbt8qfSL1Q" "_stI-wdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/ti_armv7_common.h" "_prcP4dWREemosbt8qfSL1Q" "_s3t3H9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h" "_nzaXQNWREemosbt8qfSL1Q" "_stSvl9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/dts/Kconfig" "_pjmigNWREemosbt8qfSL1Q" "_sgLgItWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/bfin_sdh.c" "_pZ7pIdWREemosbt8qfSL1Q" "_sdMd3dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/dfu.h" "_psEiANWREemosbt8qfSL1Q" "_sgeb5NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/lib/cache-cp15.c" "_n3EvQNWREemosbt8qfSL1Q" "_sflDjdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h" "_nzVewNWREemosbt8qfSL1Q" "_soquCNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h" "_nwXDQdWREemosbt8qfSL1Q" "_sv0fEtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/patman/patman" "_p6MdkNWREemosbt8qfSL1Q" "_sjJ70dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/overo/overo.c" "_o37IQNWREemosbt8qfSL1Q" "_s7vbm9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c" "_pZ6bANWREemosbt8qfSL1Q" "_sbtQJNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/Makefile" "_nkP54NWREemosbt8qfSL1Q" "_s_w_mdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mmc_write.c" "_paC94NWREemosbt8qfSL1Q" "_s3RxyNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/davinci_mmc.c" "_pZ8QMNWREemosbt8qfSL1Q" "_tCTWCNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/baltos.h" "_pn2JUNWREemosbt8qfSL1Q" "_s7va5dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/lib/bootm-fdt.c" "_n3DhIdWREemosbt8qfSL1Q" "_scAK19WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/spi/ti_qspi.c" "_pgbSsdWREemosbt8qfSL1Q" "_s21FktWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/memory/Makefile" "_pZgLUNWREemosbt8qfSL1Q" "_s59R_dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am57xx_evm_defconfig" "_pLx4YNWREemosbt8qfSL1Q" "_su7upNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/sh_mmcif.c" "_paJrkdWREemosbt8qfSL1Q" "_sbje_NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/Kconfig" "_n52WcNWREemosbt8qfSL1Q" "_stI-WNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h" "_n6LGkdWREemosbt8qfSL1Q" "_tB2qZdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/dfu/Kconfig" "_pX6P4NWREemosbt8qfSL1Q" "_tBjvbtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/memory/Kconfig" "_pZe9MNWREemosbt8qfSL1Q" "_s3a8E9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h" "_n6DKwNWREemosbt8qfSL1Q" "_s1MGtNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/Kconfig" "_pG2VENWREemosbt8qfSL1Q" "_seYwvdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c" "_ogKvkNWREemosbt8qfSL1Q" "_srDUGNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl_net.c" "_pHi4oNWREemosbt8qfSL1Q" "_svE4BNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/technexion/twister/twister.c" "_pAB7YNWREemosbt8qfSL1Q" "_s3a7sdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/dra7xx_evm_defconfig" "_pNFf8NWREemosbt8qfSL1Q" "_sjwZAtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/serial/ns16550.c" "_pfpPkNWREemosbt8qfSL1Q" "_tBZ-WdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/net/cpsw.c" "_pbkn4dWREemosbt8qfSL1Q" "_sePmv9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/jffs2/jffs2_1pass.c" "_pkTtINWREemosbt8qfSL1Q" "_suMG8tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h" "_nwSx0NWREemosbt8qfSL1Q" "_scJ77NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/MAINTAINERS" "_nkLBYNWREemosbt8qfSL1Q" "_s7mQ2dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c" "_ogOZ8NWREemosbt8qfSL1Q" "_seihmtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/nand/Makefile" "_pacmgNWREemosbt8qfSL1Q" "_snoMMdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/lg/sniper/sniper.c" "_o0YsENWREemosbt8qfSL1Q" "_sqddbdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig" "_pNGHANWREemosbt8qfSL1Q" "_s-IATdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c" "_pkUUMNWREemosbt8qfSL1Q" "_s_BYbNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/asm-generic/global_data.h" "_pl5BgNWREemosbt8qfSL1Q" "_s2YaPNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h" "_n6GOENWREemosbt8qfSL1Q" "_sygm6tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/tegra_mmc.c" "_paMH0NWREemosbt8qfSL1Q" "_s8MHXNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mmc-uclass.c" "_paAhoNWREemosbt8qfSL1Q" "_sh0fgdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c" "_n572AdWREemosbt8qfSL1Q" "_s5D609WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig" "_n7R50NWREemosbt8qfSL1Q" "_tAD6SNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts" "_nsIDgNWREemosbt8qfSL1Q" "_s6jIQdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/omapimage.c" "_p6D6sNWREemosbt8qfSL1Q" "_sxKih9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mmc.c" "_paBIsNWREemosbt8qfSL1Q" "_s8ykINWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mxsmmc.c" "_paEzEdWREemosbt8qfSL1Q" "_sgxWqtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/gadget/rndis.h" "_phlwUNWREemosbt8qfSL1Q" "_srW1vdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/net/cpsw-common.c" "_pbkn4NWREemosbt8qfSL1Q" "_soXzltWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board.c" "_pBU74dWREemosbt8qfSL1Q" "_tBHDvdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c" "_pacmgdWREemosbt8qfSL1Q" "_sdWPNdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/Kconfig" "_pBSfoNWREemosbt8qfSL1Q" "_sk8rcNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/serial/serial_rockchip.c" "_pfyZgNWREemosbt8qfSL1Q" "_scmn1dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c" "_pARL8NWREemosbt8qfSL1Q" "_s6_0IdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/uniphier-sd.c" "_paMu4NWREemosbt8qfSL1Q" "_ss2De9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h" "_nwT_8NWREemosbt8qfSL1Q" "_srNEodWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/power/palmas.c" "_peLP8dWREemosbt8qfSL1Q" "_s3IA-dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/gadget/rndis.c" "_phlJQdWREemosbt8qfSL1Q" "_swa739WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/clock.c" "_n54ysNWREemosbt8qfSL1Q" "_scTs7NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/socfpga_de1_soc.h" "_prD1YNWREemosbt8qfSL1Q" "_syNEc9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi" "_nrZqwNWREemosbt8qfSL1Q" "_sgoMidWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/mon.c" "_n6PYANWREemosbt8qfSL1Q" "_sux9cdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/binman/binman" "_p4ZGwdWREemosbt8qfSL1Q" "_syW1QtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c" "_peYrUNWREemosbt8qfSL1Q" "_slsSNNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h" "_phitAdWREemosbt8qfSL1Q" "_skWOttWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/doc/README.ti-secure" "_pSouUNWREemosbt8qfSL1Q" "_sufCetWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/k2l_evm_defconfig" "_pN0fwdWREemosbt8qfSL1Q" "_suCWftWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/lib/fdtdec.c" "_pyM_MdWREemosbt8qfSL1Q" "_smb5dtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/nand.h" "_pv3c4NWREemosbt8qfSL1Q" "_skf_jtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c" "_pBWKANWREemosbt8qfSL1Q" "_s59SutWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/dm/uclass-id.h" "_psTLgNWREemosbt8qfSL1Q" "_s6jISNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig" "_pLyfcNWREemosbt8qfSL1Q" "_sjwYfdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c" "_pBWxENWREemosbt8qfSL1Q" "_sqnOrNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am43xx_evm.h" "_pnm4wNWREemosbt8qfSL1Q" "_swRLJdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-davinci/spl.c" "_n5GIgNWREemosbt8qfSL1Q" "_s4xABNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board.h" "_pBVi8NWREemosbt8qfSL1Q" "_sg7H29WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c" "_patFMdWREemosbt8qfSL1Q" "_szQNl9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts" "_nrZqwdWREemosbt8qfSL1Q" "_sqwZPdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/dtoc/dtoc.py" "_p5PbUNWREemosbt8qfSL1Q" "_sdMeRtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig" "_n7vM0NWREemosbt8qfSL1Q" "_s2hj8tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am57xx/mux_data.h" "_pBALwNWREemosbt8qfSL1Q" "_s7JlitWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/omap_common.h" "_n2m1MdWREemosbt8qfSL1Q" "_s4eEUtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h" "_pBabcNWREemosbt8qfSL1Q" "_sc5jX9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/k2hk_evm_defconfig" "_pN0fwNWREemosbt8qfSL1Q" "_sj5jS9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c" "_nm9PoNWREemosbt8qfSL1Q" "_syNEXtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c" "_plGXUNWREemosbt8qfSL1Q" "_sePmsdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am572x-idk.dts" "_nrZDsNWREemosbt8qfSL1Q" "_s6QN29WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c" "_n7TvANWREemosbt8qfSL1Q" "_sfSIXtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/s3c_sdi.c" "_paIdcNWREemosbt8qfSL1Q" "_skWO_NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/scripts/checkpatch.pl" "_p2lI4NWREemosbt8qfSL1Q" "_s-bimtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/dtoc/dtoc" "_p5O0QNWREemosbt8qfSL1Q" "_sypw79WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/sdp4430/sdp.c" "_pBmosdWREemosbt8qfSL1Q" "_sbQj8NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/common/Kconfig" "_pBGSYNWREemosbt8qfSL1Q" "_s_n1R9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile" "_n7TH8NWREemosbt8qfSL1Q" "_s4UTYNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/cm_t335.h" "_poTcUNWREemosbt8qfSL1Q" "_sky7GNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/htkw/mcx/mcx.c" "_owZj8NWREemosbt8qfSL1Q" "_siRLWNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c" "_o0k5UNWREemosbt8qfSL1Q" "_szGcfdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c" "_n7sJgNWREemosbt8qfSL1Q" "_s0vazdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/cache.h" "_n2F30NWREemosbt8qfSL1Q" "_s_BY49WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/siemens-am33x-common.h" "_pq9HsdWREemosbt8qfSL1Q" "_syW1etWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi" "_nrbf8NWREemosbt8qfSL1Q" "_sn7HYNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am43xx/board.c" "_pA6sMdWREemosbt8qfSL1Q" "_siRLZtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/omap5_uevm/evm.c" "_pBeF0dWREemosbt8qfSL1Q" "_sxnOftWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/buildman/buildman" "_p5ItodWREemosbt8qfSL1Q" "_sjJ72NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/env_sf.c" "_pHLsQNWREemosbt8qfSL1Q" "_stb5jtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/Kconfig" "_pHeAINWREemosbt8qfSL1Q" "_s4eERNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/omapl138_lcdk_defconfig" "_pPIuYNWREemosbt8qfSL1Q" "_su7tvdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/gadget/ether.c" "_phfCoNWREemosbt8qfSL1Q" "_s21GM9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/bav335x.h" "_pn2wYNWREemosbt8qfSL1Q" "_sr8sFNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/omapl138_lcdk.h" "_pqZHANWREemosbt8qfSL1Q" "_s87uSNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/ext4/dev.c" "_pkHf4dWREemosbt8qfSL1Q" "_ss_0-dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c" "_n7y3MNWREemosbt8qfSL1Q" "_s-udYNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-tegra/board.c" "_n-ov0NWREemosbt8qfSL1Q" "_sfu0MtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/corscience/tricorder/tricorder.c" "_og8LoNWREemosbt8qfSL1Q" "_s8fCT9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c" "_n7zeQNWREemosbt8qfSL1Q" "_soquhtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am335x/board.h" "_pAywYdWREemosbt8qfSL1Q" "_sgLg5tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c" "_n7UWEdWREemosbt8qfSL1Q" "_sjJ8CdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/Makefile" "_n7PdkNWREemosbt8qfSL1Q" "_sohj59WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/core/regmap.c" "_pWfTkNWREemosbt8qfSL1Q" "_s-udfNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c" "_pid6ENWREemosbt8qfSL1Q" "_sv0e4dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/Makefile" "_pHfOQNWREemosbt8qfSL1Q" "_tBZ-ktWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c" "_pBXYINWREemosbt8qfSL1Q" "_sfSIq9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/bootm.c" "_pF1BYNWREemosbt8qfSL1Q" "_s1MG0NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/.gitignore" "_HbglYNWdEem1BusWY07OVQ" "_s3a71NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/splash_source.c" "_pHnKENWREemosbt8qfSL1Q" "_s59SpdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/spl.h" "_pwtKYNWREemosbt8qfSL1Q" "_s7Jk8NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/power/tps65218.h" "_pwV-AdWREemosbt8qfSL1Q" "_s91F8NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/k2g_evm_defconfig" "_pNz4sNWREemosbt8qfSL1Q" "_svYZ3tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c" "_pBWKAdWREemosbt8qfSL1Q" "_svrU1dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am57xx_hs_evm_defconfig" "_pLyfcdWREemosbt8qfSL1Q" "_st4k69WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c" "_n56n4NWREemosbt8qfSL1Q" "_skpwx9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am43xx/MAINTAINERS" "_pA6FINWREemosbt8qfSL1Q" "_s8C8ydWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/Kconfig" "_nj2RQNWREemosbt8qfSL1Q" "_swa8ZNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h" "_n2oDUNWREemosbt8qfSL1Q" "_s7Jk29WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am335x/board.c" "_pAywYNWREemosbt8qfSL1Q" "_sqdd69WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h" "_nwWcMNWREemosbt8qfSL1Q" "_spkF79WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/dra71-evm.dts" "_nsG1YNWREemosbt8qfSL1Q" "_tCTV0NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/fat/fat_write.c" "_pkNmgNWREemosbt8qfSL1Q" "_soXyvdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/core/util.c" "_pWhIwdWREemosbt8qfSL1Q" "_syNEJtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/ti_armv7_keystone2.h" "_prc28NWREemosbt8qfSL1Q" "_sx6JwtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/pepper.h" "_pqiQ8NWREemosbt8qfSL1Q" "_tBZ-vNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/Kconfig" "_n7NoYNWREemosbt8qfSL1Q" "_sgUqNdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/sh_sdhi.c" "_paK5sNWREemosbt8qfSL1Q" "_svOpCNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/sunxi_mmc.c" "_paLgwdWREemosbt8qfSL1Q" "_srf_fNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/nand.c" "_pGcFYNWREemosbt8qfSL1Q" "_s8yke9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c" "_pdpEcNWREemosbt8qfSL1Q" "_s1fCFNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/ti_omap4_common.h" "_presINWREemosbt8qfSL1Q" "_su7t59WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/pengwyn.h" "_pqhp4dWREemosbt8qfSL1Q" "_scc2ltWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/scripts/Makefile.lib" "_p2fCQdWREemosbt8qfSL1Q" "_s_n1XNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/dra7-evm.dts" "_nsFAMNWREemosbt8qfSL1Q" "_s8C9TtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h" "_n4_a0NWREemosbt8qfSL1Q" "_srpwg9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h" "_n6E_8NWREemosbt8qfSL1Q" "_srDTYtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/net/keystone_net.c" "_pcIokdWREemosbt8qfSL1Q" "_scc2x9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/fsl_esdhc.c" "_pZ9eUNWREemosbt8qfSL1Q" "_si3AztWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/dw_mmc.c" "_pZ83QNWREemosbt8qfSL1Q" "_swt269WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c" "_n7YngNWREemosbt8qfSL1Q" "_sky7CtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mmc_spi.c" "_paCW0dWREemosbt8qfSL1Q" "_spkGNdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am43xx_hs_evm_defconfig" "_pLxRUdWREemosbt8qfSL1Q" "_s1oy89WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/common.h" "_pmQ08NWREemosbt8qfSL1Q" "_szQN1tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am335x_evm.h" "_pnj1cdWREemosbt8qfSL1Q" "_s87tp9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/dra7xx/mux_data.h" "_pBMZANWREemosbt8qfSL1Q" "_saz319WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c" "_n7cR4NWREemosbt8qfSL1Q" "_svOpeNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am571x-idk.dts" "_nrYcoNWREemosbt8qfSL1Q" "_spa8fdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am57xx/board.c" "_pA_ksdWREemosbt8qfSL1Q" "_sdy6idWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/common/board_detect.c" "_pBHggNWREemosbt8qfSL1Q" "_sgBvyNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/xyzModem.c" "_pHqNYNWREemosbt8qfSL1Q" "_tB2qLdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/ti_omap5_common.h" "_presIdWREemosbt8qfSL1Q" "_sky6y9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h" "_nzSbcNWREemosbt8qfSL1Q" "_sqTtMdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/mmc_private.h" "_paCW0NWREemosbt8qfSL1Q" "_sfb5XtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/panda/panda.c" "_pBiXQdWREemosbt8qfSL1Q" "_so-PwtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/dra7xx/evm.c" "_pBLx8dWREemosbt8qfSL1Q" "_sgUqntWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/lib/Makefile" "_n3BE4NWREemosbt8qfSL1Q" "_s7vbHdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/main.c" "_pHZusNWREemosbt8qfSL1Q" "_sufCJtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c" "_n7XZYdWREemosbt8qfSL1Q" "_sgUqC9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/Makefile" "_nrM2cNWREemosbt8qfSL1Q" "_tBHDqNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/doc/driver-model/README.txt" "_pUxcUNWREemosbt8qfSL1Q" "_sjJ8M9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/Makefile" "_pG4KQNWREemosbt8qfSL1Q" "_s5zhINWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ti814x/evm.c" "_pBq6INWREemosbt8qfSL1Q" "_sxAyDNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/net/phy/ti.c" "_pcjfUNWREemosbt8qfSL1Q" "_sjAxztWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl_mmc.c" "_pHhqgdWREemosbt8qfSL1Q" "_sc5jGdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/config.mk" "_n7acsdWREemosbt8qfSL1Q" "_sdpJutWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/logicpd/zoom1/zoom1.c" "_o0tcMNWREemosbt8qfSL1Q" "_sgLgBtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c" "_pa880NWREemosbt8qfSL1Q" "_s5D6XNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/technexion/tao3530/tao3530.c" "_o_9C4NWREemosbt8qfSL1Q" "_s5D6zNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/gadget/Kconfig" "_phUDgNWREemosbt8qfSL1Q" "_s0SvYtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl_fat.c" "_pHhDcNWREemosbt8qfSL1Q" "_s2hj69WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/pcm051.h" "_pqfNoNWREemosbt8qfSL1Q" "_tDMt79WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/image.h" "_pueVwdWREemosbt8qfSL1Q" "_spt2_dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/quipos/cairo/cairo.c" "_o5EXwNWREemosbt8qfSL1Q" "_scTtD9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/mmc.c" "_pGXM4NWREemosbt8qfSL1Q" "_s7SuvdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/mmc.h" "_pvtE0NWREemosbt8qfSL1Q" "_s0Su69WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/Makefile" "_pFu6wNWREemosbt8qfSL1Q" "_swRLCdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h" "_nwUnANWREemosbt8qfSL1Q" "_siRLdNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl_fit.c" "_pHhqgNWREemosbt8qfSL1Q" "_snLgANWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/linux/mtd/nand.h" "_pvKSQNWREemosbt8qfSL1Q" "_s_6wvNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/net/phy/cortina.c" "_pccxodWREemosbt8qfSL1Q" "_siHZ9dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/tools/microcode-tool" "_p58l8NWREemosbt8qfSL1Q" "_sohj9dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/common/board_detect.h" "_pBIHkNWREemosbt8qfSL1Q" "_s91FctWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/am3517crane/am3517crane.c" "_pA3B0NWREemosbt8qfSL1Q" "_s0I-k9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/ext4/ext4fs.c" "_pkKjMNWREemosbt8qfSL1Q" "_sgLghNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds" "_n76zAdWREemosbt8qfSL1Q" "_snCWM9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/env_mmc.c" "_pHIo8dWREemosbt8qfSL1Q" "_scAKwtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/cmd/jffs2.c" "_pGRtUNWREemosbt8qfSL1Q" "_ss2DWNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/dm/util.h" "_psVAsNWREemosbt8qfSL1Q" "_s3RxpdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h" "_nzWs4NWREemosbt8qfSL1Q" "_sfIXO9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/core/root.c" "_pWf6oNWREemosbt8qfSL1Q" "_sv0ezNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c" "_pibd0NWREemosbt8qfSL1Q" "_skWOhdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/fs/fat/fat.c" "_pkM_cdWREemosbt8qfSL1Q" "_smSI5tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/power/tps65910.h" "_pwWlENWREemosbt8qfSL1Q" "_so0erdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/nand/Kconfig" "_pabYYNWREemosbt8qfSL1Q" "_sd8EctWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/omap5_uevm.h" "_pqWDsdWREemosbt8qfSL1Q" "_s_eEQNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c" "_n7VkMNWREemosbt8qfSL1Q" "_siaU3tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/malloc_simple.c" "_pHZusdWREemosbt8qfSL1Q" "_skWPO9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am335x_igep0033.h" "_pnkcgNWREemosbt8qfSL1Q" "_skpwUNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c" "_pZ-FYdWREemosbt8qfSL1Q" "_sy8rBNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/env_nand.c" "_pHJQANWREemosbt8qfSL1Q" "_tC5L2tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/amazon/kc1/kc1.c" "_oX5kYNWREemosbt8qfSL1Q" "_smSI-9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/dfu/dfu.c" "_pX8FENWREemosbt8qfSL1Q" "_s91FzdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h" "_nwe_EdWREemosbt8qfSL1Q" "_shE37dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/isee/igep00x0/igep00x0.c" "_oyVdoNWREemosbt8qfSL1Q" "_shg9ZdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile" "_n7wa8NWREemosbt8qfSL1Q" "_srW159WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/beagle/beagle.c" "_pBD2IdWREemosbt8qfSL1Q" "_s-IAy9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/k2hk_evm.h" "_ppNbQNWREemosbt8qfSL1Q" "_sbQkbtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/dfu/Makefile" "_pX7eANWREemosbt8qfSL1Q" "_si3BG9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/k2l_evm.h" "_ppOCUNWREemosbt8qfSL1Q" "_s2FfRdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/imx6_spl.h" "_ppFfcNWREemosbt8qfSL1Q" "_siRLidWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c" "_ogXj4NWREemosbt8qfSL1Q" "_sjAyhNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk" "_n7bDwNWREemosbt8qfSL1Q" "_s6_0rdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mtd/nand/nand.c" "_panlodWREemosbt8qfSL1Q" "_sfSIj9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/cli.c" "_pG9CwNWREemosbt8qfSL1Q" "_sz_0ldWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig" "_pLxRUNWREemosbt8qfSL1Q" "_s_w_i9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/dfu.c" "_pHAtINWREemosbt8qfSL1Q" "_ss2DUdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am57xx_evm.h" "_pnnf0NWREemosbt8qfSL1Q" "_si3A6tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/env_ext4.c" "_pHHa0NWREemosbt8qfSL1Q" "_sdMdidWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/timll/devkit8000/devkit8000.c" "_pB48kNWREemosbt8qfSL1Q" "_s4BYr9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/k2e_evm_defconfig" "_pNzRodWREemosbt8qfSL1Q" "_s1VRK9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/dra7.dtsi" "_nsFnQdWREemosbt8qfSL1Q" "_ssZX0dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h" "_ptNKcdWREemosbt8qfSL1Q" "_swt3B9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/environment/ti/dfu.h" "_pt01gNWREemosbt8qfSL1Q" "_sypwR9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/Kconfig" "_pVKd4NWREemosbt8qfSL1Q" "_sk8rd9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/evm/evm.c" "_pBQDYdWREemosbt8qfSL1Q" "_tANrWNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c" "_n7yQINWREemosbt8qfSL1Q" "_szZXwdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/k2e_evm.h" "_ppM0MNWREemosbt8qfSL1Q" "_szQN-dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c" "_n7U9INWREemosbt8qfSL1Q" "_s9YZcNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/fb_nand.c" "_pHNhcNWREemosbt8qfSL1Q" "_sgBvBNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/dfu/dfu_mmc.c" "_pX8sINWREemosbt8qfSL1Q" "_suCWP9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am335x_sl50.h" "_pnlDkdWREemosbt8qfSL1Q" "_s_LJ9tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/image.c" "_pHSZ8NWREemosbt8qfSL1Q" "_scAKu9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c" "_o0ojsNWREemosbt8qfSL1Q" "_skWO2dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h" "_n6JRYNWREemosbt8qfSL1Q" "_svE39tWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl_ext.c" "_pHgcYdWREemosbt8qfSL1Q" "_stI-69WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/omap_hsmmc.c" "_paFaINWREemosbt8qfSL1Q" "_sbQkGtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/BuR/common/common.c" "_oVcGQNWREemosbt8qfSL1Q" "_s7mRQtWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/board_f.c" "_pG5YYNWREemosbt8qfSL1Q" "_se1cPdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/dra7xx_evm.h" "_pom-UNWREemosbt8qfSL1Q" "_sz2Dv9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/env_fat.c" "_pHHa0dWREemosbt8qfSL1Q" "_snVRW9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c" "_pBZNUNWREemosbt8qfSL1Q" "_tBQNRNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/lib/tiny-printf.c" "_py1RUNWREemosbt8qfSL1Q" "_tAqXo9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c" "_n76L8NWREemosbt8qfSL1Q" "_s1x88dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/ns16550.h" "_pv6gMNWREemosbt8qfSL1Q" "_shquLdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h" "_nzblYNWREemosbt8qfSL1Q" "_sj5jKNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am43xx_evm_defconfig" "_pLwDMNWREemosbt8qfSL1Q" "_s21FtdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/k2g_evm.h" "_ppM0MdWREemosbt8qfSL1Q" "_s91FnNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/configs/am335x_evm_defconfig" "_pLm5QNWREemosbt8qfSL1Q" "_sxUUPdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/dfu/dfu_nand.c" "_pX8sIdWREemosbt8qfSL1Q" "_sj5i6dWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/am335x_shc.h" "_pnlDkNWREemosbt8qfSL1Q" "_s05MEdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/common/spl/spl.c" "_pHf1UNWREemosbt8qfSL1Q" "_sz2DJdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c" "_n7Z1oNWREemosbt8qfSL1Q" "_tCwB_9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/board/gumstix/duovero/duovero.c" "_owC-oNWREemosbt8qfSL1Q" "_sxddodWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/configs/bur_am335x_common.h" "_poH2INWREemosbt8qfSL1Q" "_syD6rdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/include/net.h" "_pv55INWREemosbt8qfSL1Q" "_svrVTNWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/scripts/Makefile.spl" "_p2fpUNWREemosbt8qfSL1Q" "_sl_NVdWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts" "_nraR0NWREemosbt8qfSL1Q" "_sxKi99WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c" "_paGoQNWREemosbt8qfSL1Q" "_smu05NWfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h" "_n6IDQNWREemosbt8qfSL1Q" "_s7SvA9WfEemuhoWuhn5Uqg"
#before_state: "U-Boot_SDcard/drivers/clk/at91/pmc.c" "_pWG5ENWREemosbt8qfSL1Q" "_svhj6tWfEemuhoWuhn5Uqg"
#create_folder: "U-Boot_SDcard/drivers/rapidio"
#
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h
--- U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h	2019-09-12 15:54:13.000000862 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/mux-k2g.h	1969-12-31 19:29:27.000000214 -0600
@@ -11,7 +11,23 @@
 #include <asm/io.h>
 #include <asm/arch/mux-k2g.h>
 #include <asm/arch/hardware.h>
+#include "board.h"
+
+struct pin_cfg k2g_generic_pin_cfg[] = {
+	/* UART0 */
+	{ 115,  MODE(0) },      /* SOC_UART0_RXD */
+	{ 116,  MODE(0) },      /* SOC_UART0_TXD */
 
+	/* I2C 0 */
+	{ 223,  MODE(0) },      /* SOC_I2C0_SCL */
+	{ 224,  MODE(0) },      /* SOC_I2C0_SDA */
+
+	/* I2C 1 */
+	{ 225,  MODE(0) },      /* SOC_I2C1_SCL */
+	{ 226,  MODE(0) },      /* SOC_I2C1_SDA */
+	{ MAX_PIN_N, }
+};
+
 struct pin_cfg k2g_evm_pin_cfg[] = {
 	/* GPMC */
 	{ 0,	MODE(0) },	/* GPMCAD0 */
@@ -170,8 +186,6 @@
 	{ 114,	MODE(0) },	/* SOC_SPI2_MOSI */
 
 	/* UART0 */
-	{ 115,	MODE(0) },	/* SOC_UART0_RXD */
-	{ 116,	MODE(0) },	/* SOC_UART0_TXD */
 	{ 117,	MODE(0) },	/* SOC_UART0_CTSn */
 	{ 118,	MODE(0) },	/* SOC_UART0_RTSn */
 
@@ -281,8 +295,6 @@
 	{ 215,	MODE(2) },	/* SOC_MCBSPCLKR */
 
 	/* I2C */
-	{ 223,	MODE(0) },	/* SOC_I2C0_SCL */
-	{ 224,	MODE(0) },	/* SOC_I2C0_SDA */
 	{ 225,	MODE(0) },	/* SOC_I2C1_SCL */
 	{ 226,	MODE(0) },	/* SOC_I2C1_SDA */
 	{ 227,	MODE(0) },	/* SOC_I2C2_SCL */
@@ -307,7 +319,60 @@
 	{ MAX_PIN_N, }
 };
 
+struct pin_cfg k2g_ice_evm_pin_cfg[] = {
+	/* MMC 1 */
+	{ 63, MODE(0) | PIN_PTD },	/* MMC1_DAT3.MMC1_DAT3 */
+	{ 64, MODE(0) | PIN_PTU },	/* MMC1_DAT2.MMC1_DAT2 */
+	{ 65, MODE(0) | PIN_PTU },	/* MMC1_DAT1.MMC1_DAT1 */
+	{ 66, MODE(0) | PIN_PTD },	/* MMC1_DAT0.MMC1_DAT0 */
+	{ 67, MODE(0) | PIN_PTD },	/* MMC1_CLK.MMC1_CLK   */
+	{ 68, MODE(0) | PIN_PTD },	/* MMC1_CMD.MMC1_CMD   */
+	{ 69, MODE(3) | PIN_PTU },	/* MMC1_SDCD.GPIO0_69  */
+	{ 70, MODE(0) | PIN_PTU },	/* MMC1_SDWP.MMC1_SDWP */
+	{ 71, MODE(0) | PIN_PTD },	/* MMC1_POW.MMC1_POW   */
+
+	/* QSPI */
+	{ 129,	MODE(0) },	/* SOC_QSPI_CLK */
+	{ 130,	MODE(0) },	/* SOC_QSPI_RTCLK */
+	{ 131,	MODE(0) },	/* SOC_QSPI_D0 */
+	{ 132,	MODE(0) },	/* SOC_QSPI_D1 */
+	{ 133,	MODE(0) },	/* SOC_QSPI_D2 */
+	{ 134,	MODE(0) },	/* SOC_QSPI_D3 */
+	{ 135,	MODE(0) },	/* SOC_QSPI_CSN0 */
+
+	/* RGMII */
+	{ 85, MODE(1) },		/* MII_TXCLK.RGMII_TXC  */
+	{ 72, MODE(1) },		/* MII_RXCLK.RGMII_RXC  */
+	{ 77, MODE(1) | PIN_PDIS},	/* MII_RXD3.RGMII_RXD3  */
+	{ 78, MODE(1) | PIN_PDIS},	/* MII_RXD2.RGMII_RXD2  */
+	{ 79, MODE(1) | PIN_PDIS},	/* MII_RXD1.RGMII_RXD1  */
+	{ 80, MODE(1) | PIN_PDIS},	/* MII_RXD0.RGMII_RXD0  */
+	{ 81, MODE(1) | PIN_PDIS},	/* MII_RXDV.RGMII_RXCTL */
+	{ 91, MODE(1) },		/* MII_TXD3.RGMII_TXD3  */
+	{ 92, MODE(1) },		/* MII_TXD2.RGMII_TXD2  */
+	{ 93, MODE(1) },		/* MII_TXD1.RGMII_TXD1  */
+	{ 94, MODE(1) },		/* MII_TXD0.RGMII_TXD0  */
+	{ 95, MODE(1) },		/* MII_TXEN.RGMII_TXCTL */
+	{ 98, MODE(0) },		/* MDIO_DATA.MDIO_DATA  */
+	{ 99, MODE(0) },		/* MDIO_CLK.MDIO_CLK    */
+	{ 10, MODE(3) },		/* GPMC_AD10.GPIO0_10   */
+
+	/* ICSS1 Padconf Workaround */
+	{ 202, MODE(1) | PIN_PDIS },    /* PR1_PRU1_GPO1.PR1_PRU1_GPI1 (PR1_MII1_RXD1) */
+
+	{ MAX_PIN_N, }
+};
+
 void k2g_mux_config(void)
 {
-	configure_pin_mux(k2g_evm_pin_cfg);
+	if (!board_ti_was_eeprom_read()) {
+		configure_pin_mux(k2g_generic_pin_cfg);
+	} else if (board_is_k2g_gp()) {
+		configure_pin_mux(k2g_evm_pin_cfg);
+	} else if (board_is_k2g_ice()) {
+		configure_pin_mux(k2g_ice_evm_pin_cfg);
+	} else {
+		puts("Unknown board, cannot configure pinmux.");
+		hang();
+	}
 }
diff -u -N U-Boot_SDcard/include/configs/pcm051.h U-Boot_SDcard/include/configs/pcm051.h
--- U-Boot_SDcard/include/configs/pcm051.h	2019-09-12 15:55:02.000000903 -0500
+++ U-Boot_SDcard/include/configs/pcm051.h	1969-12-31 19:29:22.000000386 -0600
@@ -120,7 +120,7 @@
 /* CPU */
 #define CONFIG_ENV_IS_NOWHERE
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #ifdef CONFIG_SPI_BOOT
 #define CONFIG_SPL_SPI_LOAD
diff -u -N U-Boot_SDcard/drivers/net/phy/ti.c U-Boot_SDcard/drivers/net/phy/ti.c
--- U-Boot_SDcard/drivers/net/phy/ti.c	2019-09-12 15:54:21.000000881 -0500
+++ U-Boot_SDcard/drivers/net/phy/ti.c	1969-12-31 19:29:27.000000836 -0600
@@ -25,8 +25,10 @@
 #define DP83867_CTRL		0x1f
 
 /* Extended Registers */
+#define DP83867_CFG4		0x0031
 #define DP83867_RGMIICTL	0x0032
 #define DP83867_RGMIIDCTL	0x0086
+#define DP83867_IO_MUX_CFG	0x0170
 
 #define DP83867_SW_RESET	BIT(15)
 #define DP83867_SW_RESTART	BIT(14)
@@ -84,10 +86,18 @@
 #define DEFAULT_TX_ID_DELAY	DP83867_RGMIIDCTL_2_75_NS
 #define DEFAULT_FIFO_DEPTH	DP83867_PHYCR_FIFO_DEPTH_4_B_NIB
 
+/* IO_MUX_CFG bits */
+#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_CTRL	0x1f
+
+#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_MAX	0x0
+#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_MIN	0x1f
+
 struct dp83867_private {
 	int rx_id_delay;
 	int tx_id_delay;
 	int fifo_depth;
+	int io_impedance;
+	bool rxctrl_strap_quirk;
 };
 
 /**
@@ -166,7 +176,19 @@
 {
 	struct dp83867_private *dp83867 = phydev->priv;
 	struct udevice *dev = phydev->dev;
+	int node = dev->of_offset;
+	const void *fdt = gd->fdt_blob;
 
+	if (fdtdec_get_bool(fdt, node, "ti,max-output-impedance"))
+		dp83867->io_impedance = DP83867_IO_MUX_CFG_IO_IMPEDANCE_MAX;
+	else if (fdtdec_get_bool(fdt, node, "ti,min-output-impedance"))
+		dp83867->io_impedance = DP83867_IO_MUX_CFG_IO_IMPEDANCE_MIN;
+	else
+		dp83867->io_impedance = -EINVAL;
+
+	if (fdtdec_get_bool(fdt, node, "ti,dp83867-rxctrl-strap-quirk"))
+		dp83867->rxctrl_strap_quirk = true;
+
 	dp83867->rx_id_delay = fdtdec_get_uint(gd->fdt_blob, dev->of_offset,
 				 "ti,rx-internal-delay", -1);
 
@@ -186,6 +208,7 @@
 	dp83867->rx_id_delay = DEFAULT_RX_ID_DELAY;
 	dp83867->tx_id_delay = DEFAULT_TX_ID_DELAY;
 	dp83867->fifo_depth = DEFAULT_FIFO_DEPTH;
+	dp83867->io_impedance = -EINVAL;
 
 	return 0;
 }
@@ -215,6 +238,15 @@
 	phy_write(phydev, MDIO_DEVAD_NONE, DP83867_CTRL,
 		  val | DP83867_SW_RESTART);
 
+	/* Mode 1 or 2 workaround */
+	if (dp83867->rxctrl_strap_quirk) {
+		val = phy_read_mmd_indirect(phydev, DP83867_CFG4,
+					    DP83867_DEVADDR, phydev->addr);
+		val &= ~BIT(7);
+		phy_write_mmd_indirect(phydev, DP83867_CFG4,
+				       DP83867_DEVADDR, phydev->addr, val);
+	}
+
 	if (phy_interface_is_rgmii(phydev)) {
 		ret = phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_PHYCTRL,
 			(DP83867_MDI_CROSSOVER_AUTO << DP83867_MDI_CROSSOVER) |
@@ -269,6 +301,19 @@
 
 		phy_write_mmd_indirect(phydev, DP83867_RGMIIDCTL,
 				       DP83867_DEVADDR, phydev->addr, delay);
+
+		if (dp83867->io_impedance >= 0) {
+			val = phy_read_mmd_indirect(phydev,
+						    DP83867_IO_MUX_CFG,
+						    DP83867_DEVADDR,
+						    phydev->addr);
+			val &= ~DP83867_IO_MUX_CFG_IO_IMPEDANCE_CTRL;
+			val |= dp83867->io_impedance &
+			       DP83867_IO_MUX_CFG_IO_IMPEDANCE_CTRL;
+			phy_write_mmd_indirect(phydev, DP83867_IO_MUX_CFG,
+					       DP83867_DEVADDR, phydev->addr,
+					       val);
+		}
 	}
 
 	genphy_config_aneg(phydev);
diff -u -N U-Boot_SDcard/cmd/Makefile U-Boot_SDcard/cmd/Makefile
--- U-Boot_SDcard/cmd/Makefile	2019-09-12 15:54:39.000000145 -0500
+++ U-Boot_SDcard/cmd/Makefile	1969-12-31 19:29:17.000000315 -0600
@@ -1,167 +1,168 @@
-#
-# (C) Copyright 2004-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-ifndef CONFIG_SPL_BUILD
-# core command
-obj-y += boot.o
-obj-$(CONFIG_CMD_BOOTM) += bootm.o
-obj-y += help.o
-obj-y += version.o
-
-# command
-obj-$(CONFIG_CMD_AES) += aes.o
-obj-$(CONFIG_CMD_AMBAPP) += ambapp.o
-obj-$(CONFIG_CMD_ARMFLASH) += armflash.o
-obj-$(CONFIG_SOURCE) += source.o
-obj-$(CONFIG_CMD_SOURCE) += source.o
-obj-$(CONFIG_CMD_BDI) += bdinfo.o
-obj-$(CONFIG_CMD_BEDBUG) += bedbug.o
-obj-$(CONFIG_CMD_BLOCK_CACHE) += blkcache.o
-obj-$(CONFIG_CMD_BMP) += bmp.o
-obj-$(CONFIG_CMD_BOOTEFI) += bootefi.o
-obj-$(CONFIG_CMD_BOOTMENU) += bootmenu.o
-obj-$(CONFIG_CMD_BOOTLDR) += bootldr.o
-obj-$(CONFIG_CMD_BOOTSTAGE) += bootstage.o
-obj-$(CONFIG_CMD_BOOTZ) += bootz.o
-obj-$(CONFIG_CMD_BOOTI) += booti.o
-obj-$(CONFIG_CMD_CACHE) += cache.o
-obj-$(CONFIG_CMD_CBFS) += cbfs.o
-obj-$(CONFIG_CMD_CLK) += clk.o
-obj-$(CONFIG_CMD_CONSOLE) += console.o
-obj-$(CONFIG_CMD_CPLBINFO) += cplbinfo.o
-obj-$(CONFIG_CMD_CPU) += cpu.o
-obj-$(CONFIG_DATAFLASH_MMC_SELECT) += dataflash_mmc_mux.o
-obj-$(CONFIG_CMD_DATE) += date.o
-obj-$(CONFIG_CMD_DEMO) += demo.o
-obj-$(CONFIG_CMD_SOUND) += sound.o
-ifdef CONFIG_4xx
-obj-$(CONFIG_CMD_SETGETDCR) += dcr.o
-endif
-ifdef CONFIG_POST
-obj-$(CONFIG_CMD_DIAG) += diag.o
-endif
-obj-$(CONFIG_CMD_DISPLAY) += display.o
-obj-$(CONFIG_CMD_DTT) += dtt.o
-obj-$(CONFIG_CMD_ECHO) += echo.o
-obj-$(CONFIG_ENV_IS_IN_EEPROM) += eeprom.o
-obj-$(CONFIG_CMD_EEPROM) += eeprom.o
-obj-$(CONFIG_EFI_STUB) += efi.o
-obj-$(CONFIG_CMD_ELF) += elf.o
-obj-$(CONFIG_HUSH_PARSER) += exit.o
-obj-$(CONFIG_CMD_EXT4) += ext4.o
-obj-$(CONFIG_CMD_EXT2) += ext2.o
-obj-$(CONFIG_CMD_FAT) += fat.o
-obj-$(CONFIG_CMD_FDC) += fdc.o
-obj-$(CONFIG_CMD_FDT) += fdt.o
-obj-$(CONFIG_CMD_FITUPD) += fitupd.o
-obj-$(CONFIG_CMD_FLASH) += flash.o
-ifdef CONFIG_FPGA
-obj-$(CONFIG_CMD_FPGA) += fpga.o
-endif
-obj-$(CONFIG_CMD_FPGAD) += fpgad.o
-obj-$(CONFIG_CMD_FS_GENERIC) += fs.o
-obj-$(CONFIG_CMD_FUSE) += fuse.o
-obj-$(CONFIG_CMD_GETTIME) += gettime.o
-obj-$(CONFIG_CMD_GPIO) += gpio.o
-obj-$(CONFIG_CMD_I2C) += i2c.o
-obj-$(CONFIG_CMD_IOTRACE) += iotrace.o
-obj-$(CONFIG_CMD_HASH) += hash.o
-obj-$(CONFIG_CMD_IDE) += ide.o disk.o
-obj-$(CONFIG_CMD_IMMAP) += immap.o
-obj-$(CONFIG_CMD_INI) += ini.o
-obj-$(CONFIG_CMD_IRQ) += irq.o
-obj-$(CONFIG_CMD_ITEST) += itest.o
-obj-$(CONFIG_CMD_JFFS2) += jffs2.o
-obj-$(CONFIG_CMD_CRAMFS) += cramfs.o
-obj-$(CONFIG_CMD_LDRINFO) += ldrinfo.o
-obj-$(CONFIG_CMD_LED) += led.o
-obj-$(CONFIG_CMD_LICENSE) += license.o
-obj-y += load.o
-obj-$(CONFIG_LOGBUFFER) += log.o
-obj-$(CONFIG_ID_EEPROM) += mac.o
-obj-$(CONFIG_CMD_MD5SUM) += md5sum.o
-obj-$(CONFIG_CMD_MEMORY) += mem.o
-obj-$(CONFIG_CMD_IO) += io.o
-obj-$(CONFIG_CMD_MFSL) += mfsl.o
-obj-$(CONFIG_CMD_MII) += mii.o
-ifdef CONFIG_PHYLIB
-obj-$(CONFIG_CMD_MII) += mdio.o
-endif
-obj-$(CONFIG_CMD_MISC) += misc.o
-obj-$(CONFIG_CMD_MMC) += mmc.o
-obj-$(CONFIG_CMD_MMC_SPI) += mmc_spi.o
-obj-$(CONFIG_MP) += mp.o
-obj-$(CONFIG_CMD_MTDPARTS) += mtdparts.o
-obj-$(CONFIG_CMD_NAND) += nand.o
-obj-$(CONFIG_CMD_NET) += net.o
-obj-$(CONFIG_CMD_ONENAND) += onenand.o
-obj-$(CONFIG_CMD_OTP) += otp.o
-obj-$(CONFIG_CMD_PART) += part.o
-ifdef CONFIG_PCI
-obj-$(CONFIG_CMD_PCI) += pci.o
-endif
-obj-y += pcmcia.o
-obj-$(CONFIG_CMD_PORTIO) += portio.o
-obj-$(CONFIG_CMD_PXE) += pxe.o
-obj-$(CONFIG_CMD_QFW) += qfw.o
-obj-$(CONFIG_CMD_READ) += read.o
-obj-$(CONFIG_CMD_REGINFO) += reginfo.o
-obj-$(CONFIG_CMD_REISER) += reiser.o
-obj-$(CONFIG_CMD_REMOTEPROC) += remoteproc.o
-obj-$(CONFIG_SANDBOX) += host.o
-obj-$(CONFIG_CMD_SATA) += sata.o
-obj-$(CONFIG_CMD_SF) += sf.o
-obj-$(CONFIG_SCSI) += scsi.o disk.o
-obj-$(CONFIG_CMD_SHA1SUM) += sha1sum.o
-obj-$(CONFIG_CMD_SETEXPR) += setexpr.o
-obj-$(CONFIG_CMD_SOFTSWITCH) += softswitch.o
-obj-$(CONFIG_CMD_SPI) += spi.o
-obj-$(CONFIG_CMD_SPIBOOTLDR) += spibootldr.o
-obj-$(CONFIG_CMD_STRINGS) += strings.o
-obj-$(CONFIG_CMD_TERMINAL) += terminal.o
-obj-$(CONFIG_CMD_TIME) += time.o
-obj-$(CONFIG_CMD_TRACE) += trace.o
-obj-$(CONFIG_HUSH_PARSER) += test.o
-obj-$(CONFIG_CMD_TPM) += tpm.o
-obj-$(CONFIG_CMD_TPM_TEST) += tpm_test.o
-obj-$(CONFIG_CMD_CROS_EC) += cros_ec.o
-obj-$(CONFIG_CMD_TSI148) += tsi148.o
-obj-$(CONFIG_CMD_UBI) += ubi.o
-obj-$(CONFIG_CMD_UBIFS) += ubifs.o
-obj-$(CONFIG_CMD_UNIVERSE) += universe.o
-obj-$(CONFIG_CMD_UNZIP) += unzip.o
-ifdef CONFIG_LZMA
-obj-$(CONFIG_CMD_LZMADEC) += lzmadec.o
-endif
-
-obj-$(CONFIG_CMD_USB) += usb.o disk.o
-obj-$(CONFIG_CMD_FASTBOOT) += fastboot.o
-obj-$(CONFIG_CMD_FS_UUID) += fs_uuid.o
-
-obj-$(CONFIG_CMD_USB_MASS_STORAGE) += usb_mass_storage.o
-obj-$(CONFIG_CMD_THOR_DOWNLOAD) += thordown.o
-obj-$(CONFIG_CMD_XIMG) += ximg.o
-obj-$(CONFIG_YAFFS2) += yaffs2.o
-obj-$(CONFIG_CMD_SPL) += spl.o
-obj-$(CONFIG_CMD_ZIP) += zip.o
-obj-$(CONFIG_CMD_ZFS) += zfs.o
-
-obj-$(CONFIG_CMD_DFU) += dfu.o
-obj-$(CONFIG_CMD_GPT) += gpt.o
-obj-$(CONFIG_CMD_ETHSW) += ethsw.o
-
-# Power
-obj-$(CONFIG_CMD_PMIC) += pmic.o
-obj-$(CONFIG_CMD_REGULATOR) += regulator.o
-endif # !CONFIG_SPL_BUILD
-
-obj-$(CONFIG_CMD_BLOB) += blob.o
-
-# core command
-obj-y += nvedit.o
-
-obj-$(CONFIG_ARCH_MVEBU) += mvebu/
+#
+# (C) Copyright 2004-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifndef CONFIG_SPL_BUILD
+# core command
+obj-y += boot.o
+obj-$(CONFIG_CMD_BOOTM) += bootm.o
+obj-y += help.o
+obj-y += version.o
+
+# command
+obj-$(CONFIG_CMD_AES) += aes.o
+obj-$(CONFIG_CMD_AMBAPP) += ambapp.o
+obj-$(CONFIG_CMD_ARMFLASH) += armflash.o
+obj-$(CONFIG_SOURCE) += source.o
+obj-$(CONFIG_CMD_SOURCE) += source.o
+obj-$(CONFIG_CMD_BDI) += bdinfo.o
+obj-$(CONFIG_CMD_BEDBUG) += bedbug.o
+obj-$(CONFIG_CMD_BLOCK_CACHE) += blkcache.o
+obj-$(CONFIG_CMD_BMP) += bmp.o
+obj-$(CONFIG_CMD_BOOTEFI) += bootefi.o
+obj-$(CONFIG_CMD_BOOTMENU) += bootmenu.o
+obj-$(CONFIG_CMD_BOOTLDR) += bootldr.o
+obj-$(CONFIG_CMD_BOOTSTAGE) += bootstage.o
+obj-$(CONFIG_CMD_BOOTZ) += bootz.o
+obj-$(CONFIG_CMD_BOOTI) += booti.o
+obj-$(CONFIG_CMD_CACHE) += cache.o
+obj-$(CONFIG_CMD_CBFS) += cbfs.o
+obj-$(CONFIG_CMD_CLK) += clk.o
+obj-$(CONFIG_CMD_CONSOLE) += console.o
+obj-$(CONFIG_CMD_CPLBINFO) += cplbinfo.o
+obj-$(CONFIG_CMD_CPU) += cpu.o
+obj-$(CONFIG_DATAFLASH_MMC_SELECT) += dataflash_mmc_mux.o
+obj-$(CONFIG_CMD_DATE) += date.o
+obj-$(CONFIG_CMD_DEMO) += demo.o
+obj-$(CONFIG_CMD_SOUND) += sound.o
+ifdef CONFIG_4xx
+obj-$(CONFIG_CMD_SETGETDCR) += dcr.o
+endif
+ifdef CONFIG_POST
+obj-$(CONFIG_CMD_DIAG) += diag.o
+endif
+obj-$(CONFIG_CMD_DISPLAY) += display.o
+obj-$(CONFIG_CMD_DTT) += dtt.o
+obj-$(CONFIG_CMD_ECHO) += echo.o
+obj-$(CONFIG_ENV_IS_IN_EEPROM) += eeprom.o
+obj-$(CONFIG_CMD_EEPROM) += eeprom.o
+obj-$(CONFIG_EFI_STUB) += efi.o
+obj-$(CONFIG_CMD_ELF) += elf.o
+obj-$(CONFIG_HUSH_PARSER) += exit.o
+obj-$(CONFIG_CMD_EXT4) += ext4.o
+obj-$(CONFIG_CMD_EXT2) += ext2.o
+obj-$(CONFIG_CMD_FAT) += fat.o
+obj-$(CONFIG_CMD_FDC) += fdc.o
+obj-$(CONFIG_CMD_FDT) += fdt.o
+obj-$(CONFIG_CMD_FITUPD) += fitupd.o
+obj-$(CONFIG_CMD_FLASH) += flash.o
+ifdef CONFIG_FPGA
+obj-$(CONFIG_CMD_FPGA) += fpga.o
+endif
+obj-$(CONFIG_CMD_FPGAD) += fpgad.o
+obj-$(CONFIG_CMD_FS_GENERIC) += fs.o
+obj-$(CONFIG_CMD_FUSE) += fuse.o
+obj-$(CONFIG_CMD_GETTIME) += gettime.o
+obj-$(CONFIG_CMD_GPIO) += gpio.o
+obj-$(CONFIG_CMD_I2C) += i2c.o
+obj-$(CONFIG_CMD_IOTRACE) += iotrace.o
+obj-$(CONFIG_CMD_HASH) += hash.o
+obj-$(CONFIG_CMD_IDE) += ide.o disk.o
+obj-$(CONFIG_CMD_IMMAP) += immap.o
+obj-$(CONFIG_CMD_INI) += ini.o
+obj-$(CONFIG_CMD_IRQ) += irq.o
+obj-$(CONFIG_CMD_ITEST) += itest.o
+obj-$(CONFIG_CMD_JFFS2) += jffs2.o
+obj-$(CONFIG_CMD_CRAMFS) += cramfs.o
+obj-$(CONFIG_CMD_LDRINFO) += ldrinfo.o
+obj-$(CONFIG_CMD_LED) += led.o
+obj-$(CONFIG_CMD_LICENSE) += license.o
+obj-y += load.o
+obj-$(CONFIG_LOGBUFFER) += log.o
+obj-$(CONFIG_ID_EEPROM) += mac.o
+obj-$(CONFIG_CMD_MD5SUM) += md5sum.o
+obj-$(CONFIG_CMD_MEMORY) += mem.o
+obj-$(CONFIG_CMD_IO) += io.o
+obj-$(CONFIG_CMD_MFSL) += mfsl.o
+obj-$(CONFIG_CMD_MII) += mii.o
+ifdef CONFIG_PHYLIB
+obj-$(CONFIG_CMD_MII) += mdio.o
+endif
+obj-$(CONFIG_CMD_MISC) += misc.o
+obj-$(CONFIG_CMD_MMC) += mmc.o
+obj-$(CONFIG_CMD_MMC_SPI) += mmc_spi.o
+obj-$(CONFIG_MP) += mp.o
+obj-$(CONFIG_CMD_MTDPARTS) += mtdparts.o
+obj-$(CONFIG_CMD_NAND) += nand.o
+obj-$(CONFIG_CMD_NET) += net.o
+obj-$(CONFIG_CMD_ONENAND) += onenand.o
+obj-$(CONFIG_CMD_OTP) += otp.o
+obj-$(CONFIG_CMD_PART) += part.o
+ifdef CONFIG_PCI
+obj-$(CONFIG_CMD_PCI) += pci.o
+endif
+obj-y += pcmcia.o
+obj-$(CONFIG_CMD_PORTIO) += portio.o
+obj-$(CONFIG_CMD_PXE) += pxe.o
+obj-$(CONFIG_CMD_QFW) += qfw.o
+obj-$(CONFIG_CMD_READ) += read.o
+obj-$(CONFIG_CMD_REGINFO) += reginfo.o
+obj-$(CONFIG_CMD_REISER) += reiser.o
+obj-$(CONFIG_CMD_REMOTEPROC) += remoteproc.o
+obj-$(CONFIG_SANDBOX) += host.o
+obj-$(CONFIG_CMD_SATA) += sata.o
+obj-$(CONFIG_CMD_SF) += sf.o
+obj-$(CONFIG_SCSI) += scsi.o disk.o
+obj-$(CONFIG_CMD_SHA1SUM) += sha1sum.o
+obj-$(CONFIG_CMD_SETEXPR) += setexpr.o
+obj-$(CONFIG_CMD_SOFTSWITCH) += softswitch.o
+obj-$(CONFIG_CMD_SPI) += spi.o
+obj-$(CONFIG_CMD_SPIBOOTLDR) += spibootldr.o
+obj-$(CONFIG_CMD_STRINGS) += strings.o
+obj-$(CONFIG_CMD_TERMINAL) += terminal.o
+obj-$(CONFIG_CMD_TIME) += time.o
+obj-$(CONFIG_CMD_TRACE) += trace.o
+obj-$(CONFIG_HUSH_PARSER) += test.o
+obj-$(CONFIG_CMD_TPM) += tpm.o
+obj-$(CONFIG_CMD_TPM_TEST) += tpm_test.o
+obj-$(CONFIG_CMD_CROS_EC) += cros_ec.o
+obj-$(CONFIG_CMD_TSI148) += tsi148.o
+obj-$(CONFIG_CMD_UBI) += ubi.o
+obj-$(CONFIG_CMD_UBIFS) += ubifs.o
+obj-$(CONFIG_CMD_UNIVERSE) += universe.o
+obj-$(CONFIG_CMD_UNZIP) += unzip.o
+ifdef CONFIG_LZMA
+obj-$(CONFIG_CMD_LZMADEC) += lzmadec.o
+endif
+
+obj-$(CONFIG_CMD_USB) += usb.o disk.o
+obj-$(CONFIG_CMD_FASTBOOT) += fastboot.o
+obj-$(CONFIG_CMD_FS_UUID) += fs_uuid.o
+
+obj-$(CONFIG_CMD_USB_MASS_STORAGE) += usb_mass_storage.o
+obj-$(CONFIG_CMD_THOR_DOWNLOAD) += thordown.o
+obj-$(CONFIG_CMD_XIMG) += ximg.o
+obj-$(CONFIG_YAFFS2) += yaffs2.o
+obj-$(CONFIG_CMD_SPL) += spl.o
+obj-$(CONFIG_CMD_ZIP) += zip.o
+obj-$(CONFIG_CMD_ZFS) += zfs.o
+
+obj-$(CONFIG_CMD_DFU) += dfu.o
+obj-$(CONFIG_CMD_GPT) += gpt.o
+obj-$(CONFIG_CMD_ETHSW) += ethsw.o
+obj-$(CONFIG_CMD_RIO) += rio.o
+
+# Power
+obj-$(CONFIG_CMD_PMIC) += pmic.o
+obj-$(CONFIG_CMD_REGULATOR) += regulator.o
+endif # !CONFIG_SPL_BUILD
+
+obj-$(CONFIG_CMD_BLOB) += blob.o
+
+# core command
+obj-y += nvedit.o
+
+obj-$(CONFIG_ARCH_MVEBU) += mvebu/
diff -u -N U-Boot_SDcard/common/malloc_simple.c U-Boot_SDcard/common/malloc_simple.c
--- U-Boot_SDcard/common/malloc_simple.c	2019-09-12 15:54:23.000000680 -0500
+++ U-Boot_SDcard/common/malloc_simple.c	1969-12-31 19:29:17.000000519 -0600
@@ -39,10 +39,14 @@
 
 	addr = ALIGN(gd->malloc_base + gd->malloc_ptr, align);
 	new_ptr = addr + bytes - gd->malloc_base;
-	if (new_ptr > gd->malloc_limit)
+	if (new_ptr > gd->malloc_limit) {
+		debug("space exhausted\n");
 		return NULL;
+	}
+
 	ptr = map_sysmem(addr, bytes);
 	gd->malloc_ptr = ALIGN(new_ptr, sizeof(new_ptr));
+	debug("%lx\n", (ulong)ptr);
 
 	return ptr;
 }
diff -u -N U-Boot_SDcard/board/timll/devkit8000/devkit8000.c U-Boot_SDcard/board/timll/devkit8000/devkit8000.c
--- U-Boot_SDcard/board/timll/devkit8000/devkit8000.c	2019-09-12 15:54:48.000000366 -0500
+++ U-Boot_SDcard/board/timll/devkit8000/devkit8000.c	1969-12-31 19:29:27.000000251 -0600
@@ -48,7 +48,8 @@
 static const struct ns16550_platdata devkit8000_serial = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(devkit8000_uart) = {
@@ -130,7 +131,7 @@
 	MUX_DEVKIT8000();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/common/env_mmc.c U-Boot_SDcard/common/env_mmc.c
--- U-Boot_SDcard/common/env_mmc.c	2019-09-12 15:54:12.000000548 -0500
+++ U-Boot_SDcard/common/env_mmc.c	1969-12-31 19:29:17.000000484 -0600
@@ -64,6 +64,11 @@
 	/* use default */
 	gd->env_addr	= (ulong)&default_environment[0];
 	gd->env_valid	= 1;
+	/*
+	 * intialize the MMC sub-system. This will probe the
+	 * MMC controllers if not already done
+	 */
+	mmc_initialize(NULL);
 
 	return 0;
 }
@@ -82,10 +87,6 @@
 	int dev = mmc_get_env_dev();
 	int ret = 0;
 
-#ifdef CONFIG_SPL_BUILD
-	dev = 0;
-#endif
-
 	env_mmc_orig_hwpart = mmc_get_blk_desc(mmc)->hwpart;
 	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, dev, part);
 	if (ret)
@@ -116,9 +117,6 @@
 #ifdef CONFIG_SYS_MMC_ENV_PART
 	int dev = mmc_get_env_dev();
 
-#ifdef CONFIG_SPL_BUILD
-	dev = 0;
-#endif
 	blk_select_hwpart_devnum(IF_TYPE_MMC, dev, env_mmc_orig_hwpart);
 #endif
 }
@@ -223,10 +221,6 @@
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, tmp_env1, 1);
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, tmp_env2, 1);
 
-#ifdef CONFIG_SPL_BUILD
-	dev = 0;
-#endif
-
 	mmc = find_mmc_device(dev);
 
 	errmsg = init_mmc_for_env(mmc);
@@ -306,10 +300,6 @@
 	int dev = mmc_get_env_dev();
 	const char *errmsg;
 
-#ifdef CONFIG_SPL_BUILD
-	dev = 0;
-#endif
-
 	mmc = find_mmc_device(dev);
 
 	errmsg = init_mmc_for_env(mmc);
diff -u -N /dev/null U-Boot_SDcard/include/rio.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/include/rio.h	1969-12-31 19:31:37.000000915 -0600
@@ -0,0 +1,394 @@
+/*
+ * (C) Copyright 2017
+ * Texas Instruments Incorporated, <www.ti.com>
+ * Authors: Aurelien Jacquiot <a-jacquiot@ti.com>
+ *
+ * Part of this file is borrowed from Linux rio_regs.h.
+ * (C) Copyright 2005 MontaVista Software, Inc.
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _RIO_H_
+#define _RIO_H_
+
+#include <dm.h>
+
+/*
+ * In RapidIO, each device has a 16MB configuration space that is
+ * accessed via maintenance transactions. Portions of configuration
+ * space are standardized and/or reserved.
+ */
+#define RIO_DEV_ID_CAR			0x00
+#define RIO_DEV_INFO_CAR		0x04
+#define RIO_ASM_ID_CAR			0x08
+#define RIO_ASM_ID_MASK			0xffff0000
+#define RIO_ASM_VEN_ID_MASK		0x0000ffff
+
+#define RIO_ASM_INFO_CAR		0x0c
+#define RIO_ASM_REV_MASK		0xffff0000
+#define RIO_EXT_FTR_PTR_MASK		0x0000ffff
+
+#define RIO_PEF_CAR			0x10
+#define RIO_PEF_BRIDGE			0x80000000
+#define RIO_PEF_MEMORY			0x40000000
+#define RIO_PEF_PROCESSOR		0x20000000
+#define RIO_PEF_SWITCH			0x10000000
+#define RIO_PEF_INB_MBOX		0x00f00000
+#define RIO_PEF_INB_MBOX0		0x00800000
+#define RIO_PEF_INB_MBOX1		0x00400000
+#define RIO_PEF_INB_MBOX2		0x00200000
+#define RIO_PEF_INB_MBOX3		0x00100000
+#define RIO_PEF_INB_DOORBELL		0x00080000
+#define RIO_PEF_EXT_RT			0x00000200
+#define RIO_PEF_STD_RT			0x00000100
+#define RIO_PEF_CTLS			0x00000010
+#define RIO_PEF_FLOW_CONTROL		0x00000080
+#define RIO_PEF_EXT_FEATURES		0x00000008
+#define RIO_PEF_ADDR_66			0x00000004
+#define RIO_PEF_ADDR_50			0x00000002
+#define RIO_PEF_ADDR_34			0x00000001
+
+#define RIO_SWP_INFO_CAR		0x14
+#define RIO_SWP_INFO_PORT_TOTAL_MASK	0x0000ff00
+#define RIO_SWP_INFO_PORT_NUM_MASK	0x000000ff
+
+#define RIO_SRC_OPS_CAR			0x18
+#define RIO_SRC_OPS_READ		0x00008000
+#define RIO_SRC_OPS_WRITE		0x00004000
+#define RIO_SRC_OPS_STREAM_WRITE	0x00002000
+#define RIO_SRC_OPS_WRITE_RESPONSE	0x00001000
+#define RIO_SRC_OPS_DATA_MSG		0x00000800
+#define RIO_SRC_OPS_DOORBELL		0x00000400
+#define RIO_SRC_OPS_ATOMIC_TST_SWP	0x00000100
+#define RIO_SRC_OPS_ATOMIC_INC		0x00000080
+#define RIO_SRC_OPS_ATOMIC_DEC		0x00000040
+#define RIO_SRC_OPS_ATOMIC_SET		0x00000020
+#define RIO_SRC_OPS_ATOMIC_CLR		0x00000010
+#define RIO_SRC_OPS_PORT_WRITE		0x00000004
+
+#define RIO_DST_OPS_CAR			0x1c
+#define RIO_DST_OPS_READ		0x00008000
+#define RIO_DST_OPS_WRITE		0x00004000
+#define RIO_DST_OPS_STREAM_WRITE	0x00002000
+#define RIO_DST_OPS_WRITE_RESPONSE	0x00001000
+#define RIO_DST_OPS_DATA_MSG		0x00000800
+#define RIO_DST_OPS_DOORBELL		0x00000400
+#define RIO_DST_OPS_ATOMIC_TST_SWP	0x00000100
+#define RIO_DST_OPS_ATOMIC_INC		0x00000080
+#define RIO_DST_OPS_ATOMIC_DEC		0x00000040
+#define RIO_DST_OPS_ATOMIC_SET		0x00000020
+#define RIO_DST_OPS_ATOMIC_CLR		0x00000010
+#define RIO_DST_OPS_PORT_WRITE		0x00000004
+
+#define RIO_OPS_READ			0x00008000
+#define RIO_OPS_WRITE			0x00004000
+#define RIO_OPS_STREAM_WRITE		0x00002000
+#define RIO_OPS_WRITE_RESPONSE		0x00001000
+#define RIO_OPS_DATA_MSG		0x00000800
+#define RIO_OPS_DOORBELL		0x00000400
+#define RIO_OPS_ATOMIC_TST_SWP		0x00000100
+#define RIO_OPS_ATOMIC_INC		0x00000080
+#define RIO_OPS_ATOMIC_DEC		0x00000040
+#define RIO_OPS_ATOMIC_SET		0x00000020
+#define RIO_OPS_ATOMIC_CLR		0x00000010
+#define RIO_OPS_PORT_WRITE		0x00000004
+
+/* 0x20-0x30 *//* Reserved */
+
+#define RIO_SWITCH_RT_LIMIT		0x34
+#define RIO_RT_MAX_DESTID		0x0000ffff
+
+#define RIO_MBOX_CSR			0x40
+#define RIO_MBOX0_AVAIL			0x80000000
+#define RIO_MBOX0_FULL			0x40000000
+#define RIO_MBOX0_EMPTY			0x20000000
+#define RIO_MBOX0_BUSY			0x10000000
+#define RIO_MBOX0_FAIL			0x08000000
+#define RIO_MBOX0_ERROR			0x04000000
+#define RIO_MBOX1_AVAIL			0x00800000
+#define RIO_MBOX1_FULL			0x00200000
+#define RIO_MBOX1_EMPTY			0x00200000
+#define RIO_MBOX1_BUSY			0x00100000
+#define RIO_MBOX1_FAIL			0x00080000
+#define RIO_MBOX1_ERROR			0x00040000
+#define RIO_MBOX2_AVAIL			0x00008000
+#define RIO_MBOX2_FULL			0x00004000
+#define RIO_MBOX2_EMPTY			0x00002000
+#define RIO_MBOX2_BUSY			0x00001000
+#define RIO_MBOX2_FAIL			0x00000800
+#define RIO_MBOX2_ERROR			0x00000400
+#define RIO_MBOX3_AVAIL			0x00000080
+#define RIO_MBOX3_FULL			0x00000040
+#define RIO_MBOX3_EMPTY			0x00000020
+#define RIO_MBOX3_BUSY			0x00000010
+#define RIO_MBOX3_FAIL			0x00000008
+#define RIO_MBOX3_ERROR			0x00000004
+
+#define RIO_WRITE_PORT_CSR		0x44
+#define RIO_DOORBELL_CSR		0x44
+#define RIO_DOORBELL_AVAIL		0x80000000
+#define RIO_DOORBELL_FULL		0x40000000
+#define RIO_DOORBELL_EMPTY		0x20000000
+#define RIO_DOORBELL_BUSY		0x10000000
+#define RIO_DOORBELL_FAILED		0x08000000
+#define RIO_DOORBELL_ERROR		0x04000000
+#define RIO_WRITE_PORT_AVAILABLE	0x00000080
+#define RIO_WRITE_PORT_FULL		0x00000040
+#define RIO_WRITE_PORT_EMPTY		0x00000020
+#define RIO_WRITE_PORT_BUSY		0x00000010
+#define RIO_WRITE_PORT_FAILED		0x00000008
+#define RIO_WRITE_PORT_ERROR		0x00000004
+
+/* 0x48 *//* Reserved */
+
+#define RIO_PELL_CTRL_CSR		0x4c
+#define RIO_PELL_ADDR_66		0x00000004
+#define RIO_PELL_ADDR_50		0x00000002
+#define RIO_PELL_ADDR_34		0x00000001
+
+/* 0x50-0x54 *//* Reserved */
+
+#define RIO_LCSH_BA			0x58
+#define RIO_LCSL_BA			0x5c
+
+#define RIO_DID_CSR			0x60
+
+/* 0x64 *//* Reserved */
+
+#define RIO_HOST_DID_LOCK_CSR		0x68
+#define RIO_COMPONENT_TAG_CSR		0x6c
+
+#define RIO_STD_RTE_CONF_DESTID_SEL_CSR	0x70
+#define RIO_STD_RTE_CONF_PORT_SEL_CSR	0x74
+#define RIO_STD_RTE_DEFAULT_PORT	0x78
+
+/* 0x7c-0xf8 *//* Reserved */
+/* 0x100-0xfff8 *//* [I] Extended Features Space */
+
+#define RIO_PORT_LINK_MAINT_REQ_CSR	0x140
+#define RIO_PORT_LINK_MAINT_RESP_CSR	0x144
+#define RIO_PORT_LOCAL_ACKID_CSR	0x148
+#define RIO_PORT_ERR_STAT_CSR		0x158
+#define RIO_PORT_CTRL_CSR		0x15c
+
+#define RIO_PORT_OFFSET			0x20
+
+#define RIO_PORT_CTRL_TYPE_SERIAL	0x00000001
+#define RIO_PORT_CTRL_ENUM_BOUNDARY	0x00020000
+#define RIO_PORT_CTRL_MCAST_EVT_PART	0x00080000
+#define RIO_PORT_CTRL_ERR_CHECK_DIS	0x00100000
+#define RIO_PORT_CTRL_INPUT_PORT_EN	0x00200000
+#define RIO_PORT_CTRL_OUTPUT_PORT_EN	0x00400000
+#define RIO_PORT_CTRL_PORT_DIS		0x00800000
+
+/* 0x10000-0xfffff8 *//* [I] Implementation-defined Space */
+
+/*
+ * Extended Features Space is a configuration space area where
+ * functionality is mapped into extended feature blocks via a
+ * singly linked list of extended feature pointers (EFT_PTR).
+ *
+ * Each extended feature block can be identified/located in
+ * Extended Features Space by walking the extended feature
+ * list starting with the Extended Feature Pointer located
+ * in the Assembly Information CAR.
+ *
+ * Extended Feature Blocks (EFBs) are identified with an assigned
+ * EFB ID. Extended feature block offsets in the definitions are
+ * relative to the offset of the EFB within the  Extended Features
+ * Space.
+ */
+
+/* Helper macros to parse the Extended Feature Block header */
+#define RIO_EFB_PTR_MASK		0xffff0000
+#define RIO_EFB_ID_MASK			0x0000ffff
+#define RIO_GET_BLOCK_PTR(x)		((x & RIO_EFB_PTR_MASK) >> 16)
+#define RIO_GET_BLOCK_ID(x)		(x & RIO_EFB_ID_MASK)
+
+/* Extended Feature Block IDs */
+#define RIO_EFB_PAR_EP_ID		0x0001
+#define RIO_EFB_PAR_EP_REC_ID		0x0002
+#define RIO_EFB_PAR_EP_FREE_ID		0x0003
+#define RIO_EFB_SER_EP_ID_V13P		0x0001
+#define RIO_EFB_SER_EP_REC_ID_V13P	0x0002
+#define RIO_EFB_SER_EP_FREE_ID_V13P	0x0003
+#define RIO_EFB_SER_EP_ID		0x0004
+#define RIO_EFB_SER_EP_REC_ID		0x0005
+#define RIO_EFB_SER_EP_FREE_ID		0x0006
+#define RIO_EFB_SER_EP_FREC_ID		0x0009
+#define RIO_EFB_ERR_MGMNT		0x0007
+
+/*
+ * Physical 8/16 LP-LVDS
+ * ID=0x0001, Generic End Point Devices
+ * ID=0x0002, Generic End Point Devices, software assisted recovery option
+ * ID=0x0003, Generic End Point Free Devices
+ *
+ * Physical LP-Serial
+ * ID=0x0004, Generic End Point Devices
+ * ID=0x0005, Generic End Point Devices, software assisted recovery option
+ * ID=0x0006, Generic End Point Free Devices
+ */
+#define RIO_PORT_MNT_HEADER		0x0000
+#define RIO_PORT_REQ_CTL_CSR		0x0020
+#define RIO_PORT_RSP_CTL_CSR		0x0024 /* 0x0001/0x0002 */
+#define RIO_PORT_LINKTO_CTL_CSR		0x0020 /* Serial */
+#define RIO_PORT_RSPTO_CTL_CSR		0x0024 /* Serial */
+#define RIO_PORT_GEN_CTL_CSR		0x003c
+#define RIO_PORT_GEN_HOST		0x80000000
+#define RIO_PORT_GEN_MASTER		0x40000000
+#define RIO_PORT_GEN_DISCOVERED		0x20000000
+#define RIO_PORT_N_MNT_REQ_CSR(x)	(0x0040 + x * 0x20)
+#define RIO_PORT_N_MNT_RSP_CSR(x)	(0x0044 + x * 0x20)
+#define RIO_PORT_N_MNT_RSP_RVAL		0x80000000
+#define RIO_PORT_N_MNT_RSP_ASTAT	0x000003e0
+#define RIO_PORT_N_MNT_RSP_LSTAT	0x0000001f
+#define RIO_PORT_N_ACK_STS_CSR(x)	(0x0048 + x * 0x20)
+#define RIO_PORT_N_ACK_CLEAR		0x80000000
+#define RIO_PORT_N_ACK_INBOUND		0x1f000000
+#define RIO_PORT_N_ACK_OUTSTAND		0x00001f00
+#define RIO_PORT_N_ACK_OUTBOUND		0x0000001f
+#define RIO_PORT_N_ERR_STS_CSR(x)	(0x0058 + x * 0x20)
+#define RIO_PORT_N_ERR_STS_PW_OUT_ES	0x00010000 /* Output Error-stopped */
+#define RIO_PORT_N_ERR_STS_PW_INP_ES	0x00000100 /* Input Error-stopped */
+#define RIO_PORT_N_ERR_STS_PW_PEND	0x00000010 /* Port-Write Pending */
+#define RIO_PORT_N_ERR_STS_PORT_ERR	0x00000004
+#define RIO_PORT_N_ERR_STS_PORT_OK	0x00000002
+#define RIO_PORT_N_ERR_STS_PORT_UNINIT	0x00000001
+#define RIO_PORT_N_ERR_STS_CLR_MASK	0x07120204
+#define RIO_PORT_N_CTL_CSR(x)		(0x005c + x * 0x20)
+#define RIO_PORT_N_CTL_PWIDTH		0xc0000000
+#define RIO_PORT_N_CTL_PWIDTH_1		0x00000000
+#define RIO_PORT_N_CTL_PWIDTH_4		0x40000000
+#define RIO_PORT_N_CTL_P_TYP_SER	0x00000001
+#define RIO_PORT_N_CTL_LOCKOUT		0x00000002
+#define RIO_PORT_N_CTL_EN_RX_SER	0x00200000
+#define RIO_PORT_N_CTL_EN_TX_SER	0x00400000
+#define RIO_PORT_N_CTL_EN_RX_PAR	0x08000000
+#define RIO_PORT_N_CTL_EN_TX_PAR	0x40000000
+
+/*
+ * Error Management Extensions (RapidIO 1.3+, Part 8)
+ *
+ * Extended Features Block ID=0x0007
+ */
+
+/* General EM Registers (Common for all Ports) */
+
+#define RIO_EM_EFB_HEADER		0x000
+#define RIO_EM_LTL_ERR_DETECT		0x008
+#define RIO_EM_LTL_ERR_EN		0x00c
+#define RIO_EM_LTL_HIADDR_CAP		0x010
+#define RIO_EM_LTL_ADDR_CAP		0x014
+#define RIO_EM_LTL_DEVID_CAP		0x018
+#define RIO_EM_LTL_CTRL_CAP		0x01c
+#define RIO_EM_PW_TGT_DEVID		0x028
+#define RIO_EM_PKT_TTL			0x02c
+
+/* Per-Port EM Registers */
+
+#define RIO_EM_PN_ERR_DETECT(x)		(0x040 + x * 0x40)
+#define REM_PED_IMPL_SPEC		0x80000000
+#define REM_PED_LINK_TO			0x00000001
+#define RIO_EM_PN_ERRRATE_EN(x)		(0x044 + x * 0x40)
+#define RIO_EM_PN_ATTRIB_CAP(x)		(0x048 + x * 0x40)
+#define RIO_EM_PN_PKT_CAP_0(x)		(0x04c + x * 0x40)
+#define RIO_EM_PN_PKT_CAP_1(x)		(0x050 + x * 0x40)
+#define RIO_EM_PN_PKT_CAP_2(x)		(0x054 + x * 0x40)
+#define RIO_EM_PN_PKT_CAP_3(x)		(0x058 + x * 0x40)
+#define RIO_EM_PN_ERRRATE(x)		(0x068 + x * 0x40)
+#define RIO_EM_PN_ERRRATE_TR(x)		(0x06c + x * 0x40)
+
+/**
+ * rio_config_read - Generate a RIO read maintenance transaction
+ * @portid: Output port ID of transaction
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Location to be read into
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_config_read(struct udevice *dev,
+		    int  portid,
+		    u16  destid,
+		    u8   hopcount,
+		    u32  offset,
+		    int  len,
+		    u32 *val);
+
+/**
+ * rio_config_write - Generate a RIO write maintenance transaction
+ * @portid: Output port ID of transaction
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Value to be written
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_config_write(struct udevice *dev,
+		     int portid,
+		     u16 destid,
+		     u8  hopcount,
+		     u32 offset,
+		     int len,
+		     u32 val);
+
+/**
+ * rio_local_config_read - RIO local config space read
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be read into
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_local_config_read(struct udevice *dev, u32 offset, int len, u32 *data);
+
+/**
+ * rio_local_config_write - RIO local config space write
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be written
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_local_config_write(struct udevice *dev, u32 offset, int len, u32 data);
+
+/**
+ * rio_doorbell_rx - Blocking wait for receiving doorbell info
+ * @info: 16-bit value to wait for (implementation specific)
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_doorbell_rx(struct udevice *dev, u16 info);
+
+/**
+ * rio_remove - Remove a RapidIO device
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int rio_remove(struct udevice *dev);
+
+struct rio_ops {
+	int (*config_read)(struct udevice *dev,
+			   int portid, u16 destid, u8 hopcount,
+			   u32 offset, int len, u32 *val);
+
+	int (*config_write)(struct udevice *dev,
+			    int portid, u16 destid, u8 hopcount,
+			    u32 offset, int len, u32 val);
+
+	int (*local_config_read)(struct udevice *dev,
+				 u32 offset, int len, u32 *data);
+
+	int (*local_config_write)(struct udevice *dev,
+				  u32 offset, int len, u32 data);
+
+	int (*doorbell_rx)(struct udevice *dev, u16 info);
+};
+#endif /* _RIO_H_ */
diff -u -N U-Boot_SDcard/include/configs/k2e_evm.h U-Boot_SDcard/include/configs/k2e_evm.h
--- U-Boot_SDcard/include/configs/k2e_evm.h	2019-09-12 15:54:42.000000972 -0500
+++ U-Boot_SDcard/include/configs/k2e_evm.h	1969-12-31 19:29:22.000000246 -0600
@@ -13,9 +13,18 @@
 /* Platform type */
 #define CONFIG_SOC_K2E
 
+#ifdef CONFIG_TI_SECURE_DEVICE
+#define DEFAULT_SEC_BOOT_ENV						\
+	DEFAULT_FIT_TI_ARGS						\
+	"findfdt=setenv fdtfile ${name_fdt}\0"
+#else
+#define DEFAULT_SEC_BOOT_ENV
+#endif
+
 /* U-Boot general configuration */
 #define CONFIG_EXTRA_ENV_KS2_BOARD_SETTINGS				\
 	DEFAULT_FW_INITRAMFS_BOOT_ENV					\
+	DEFAULT_SEC_BOOT_ENV						\
 	"boot=ubi\0"							\
 	"args_ubi=setenv bootargs ${bootargs} rootfstype=ubifs "	\
 	"root=ubi0:rootfs rootflags=sync rw ubi.mtd=ubifs,2048\0"	\
@@ -25,14 +34,22 @@
 	"name_uboot=u-boot-spi-k2e-evm.gph\0"				\
 	"name_fs=arago-console-image-k2e-evm.cpio.gz\0"
 
+/* NAND Configuration */
+#define CONFIG_SYS_NAND_PAGE_2K
+#define CONFIG_NAND_DAVINCI
+#define CONFIG_KEYSTONE_RBL_NAND
+#define CONFIG_KEYSTONE_NAND_MAX_RBL_SIZE	CONFIG_ENV_OFFSET
+#define CONFIG_SYS_NAND_MASK_CLE		0x4000
+#define CONFIG_SYS_NAND_MASK_ALE		0x2000
+#define CONFIG_SYS_NAND_CS			2
+#define CONFIG_SYS_NAND_4BIT_HW_ECC_OOBFIRST
+#define CONFIG_SYS_NAND_LARGEPAGE
+
 #include <configs/ti_armv7_keystone2.h>
 
 /* SPL SPI Loader Configuration */
 #define CONFIG_SPL_TEXT_BASE           0x0c100000
 
-/* NAND Configuration */
-#define CONFIG_SYS_NAND_PAGE_2K
-
 /* Network */
 #define CONFIG_KSNET_NETCP_V1_5
 #define CONFIG_KSNET_CPSW_NUM_PORTS	9
diff -u -N U-Boot_SDcard/arch/arm/lib/cache-cp15.c U-Boot_SDcard/arch/arm/lib/cache-cp15.c
--- U-Boot_SDcard/arch/arm/lib/cache-cp15.c	2019-09-12 15:54:17.000000417 -0500
+++ U-Boot_SDcard/arch/arm/lib/cache-cp15.c	1969-12-31 19:29:23.000000728 -0600
@@ -94,6 +94,17 @@
 	mmu_page_table_flush(startpt, stoppt);
 }
 
+static void set_section_caches(int i)
+{
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+		set_section_dcache(i, DCACHE_WRITETHROUGH);
+#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
+		set_section_dcache(i, DCACHE_WRITEALLOC);
+#else
+		set_section_dcache(i, DCACHE_WRITEBACK);
+#endif
+}
+
 __weak void dram_bank_mmu_setup(int bank)
 {
 	bd_t *bd = gd->bd;
@@ -102,17 +113,22 @@
 	debug("%s: bank: %d\n", __func__, bank);
 	for (i = bd->bi_dram[bank].start >> MMU_SECTION_SHIFT;
 	     i < (bd->bi_dram[bank].start >> MMU_SECTION_SHIFT) +
-		 (bd->bi_dram[bank].size >> MMU_SECTION_SHIFT);
-	     i++) {
-#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
-		set_section_dcache(i, DCACHE_WRITETHROUGH);
-#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
-		set_section_dcache(i, DCACHE_WRITEALLOC);
-#else
-		set_section_dcache(i, DCACHE_WRITEBACK);
+		 (bd->bi_dram[bank].size >> MMU_SECTION_SHIFT); i++)
+		set_section_caches(i);
+}
+
+#if defined(CONFIG_SPL_BUILD) && (defined(CONFIG_SPL_MAX_SIZE) || \
+				  defined(CONFIG_SPL_MAX_FOOTPRINT))
+__weak void sram_bank_mmu_setup(phys_addr_t start, phys_addr_t size)
+{
+	int i;
+
+	for (i = start >> MMU_SECTION_SHIFT;
+	     i < (start >> MMU_SECTION_SHIFT) + (size >> MMU_SECTION_SHIFT);
+	     i++)
+		set_section_caches(i);
+}
 #endif
-	}
-}
 
 /* to activate the MMU we need to set up virtual memory: use 1M areas */
 static inline void mmu_setup(void)
@@ -129,6 +145,16 @@
 		dram_bank_mmu_setup(i);
 	}
 
+#if defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_SPL_MAX_SIZE)
+	sram_bank_mmu_setup(CONFIG_SPL_TEXT_BASE,
+			    ALIGN(CONFIG_SPL_MAX_SIZE, MMU_SECTION_SIZE));
+#elif defined(CONFIG_SPL_MAX_FOOTPRINT)
+	sram_bank_mmu_setup(CONFIG_SPL_TEXT_BASE,
+			    ALIGN(CONFIG_SPL_MAX_FOOTPRINT, MMU_SECTION_SIZE));
+#endif
+#endif
+
 #ifdef CONFIG_ARMV7_LPAE
 	/* Set up 4 PTE entries pointing to our 4 1GB page tables */
 	for (i = 0; i < 4; i++) {
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/Makefile U-Boot_SDcard/arch/arm/mach-omap2/Makefile
--- U-Boot_SDcard/arch/arm/mach-omap2/Makefile	2019-09-12 15:54:28.000000891 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/Makefile	1969-12-31 19:29:23.000000889 -0600
@@ -1,45 +1,47 @@
-#
-# (C) Copyright 2000-2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-$(if $(filter am33xx,$(SOC)),y) += am33xx/
-obj-$(CONFIG_OMAP34XX) += omap3/
-obj-$(CONFIG_OMAP44XX) += omap4/
-obj-$(CONFIG_OMAP54XX) += omap5/
-
-obj-y	+= reset.o
-ifeq ($(CONFIG_TIMER),)
-obj-y	+= timer.o
-else
-ifdef CONFIG_SPL_BUILD
-obj-y	+= timer.o
-endif
-endif
-obj-y	+= utils.o
-
-ifneq ($(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX),)
-obj-y	+= hwinit-common.o
-obj-y	+= clocks-common.o
-obj-y	+= emif-common.o
-obj-y	+= vc.o
-obj-y	+= abb.o
-endif
-
-ifneq ($(CONFIG_OMAP54XX),)
-obj-y	+= pipe3-phy.o
-obj-$(CONFIG_SCSI_AHCI_PLAT) += sata.o
-endif
-
-ifeq ($(CONFIG_SYS_DCACHE_OFF),)
-obj-y	+= omap-cache.o
-endif
-
-obj-y	+= boot-common.o
-obj-y	+= lowlevel_init.o
-
-obj-y	+= mem-common.o
-
-obj-$(CONFIG_TI_SECURE_DEVICE) += sec-common.o
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(if $(filter am33xx,$(SOC)),y) += am33xx/
+obj-$(CONFIG_OMAP34XX) += omap3/
+obj-$(CONFIG_OMAP44XX) += omap4/
+obj-$(CONFIG_OMAP54XX) += omap5/
+
+obj-y	+= reset.o
+ifeq ($(CONFIG_TIMER),)
+obj-y	+= timer.o
+else
+ifdef CONFIG_SPL_BUILD
+obj-y	+= timer.o
+endif
+endif
+obj-y	+= utils.o
+
+ifneq ($(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX),)
+obj-y	+= hwinit-common.o
+obj-y	+= clocks-common.o
+obj-y	+= emif-common.o
+obj-y	+= vc.o
+obj-y	+= abb.o
+endif
+
+ifneq ($(CONFIG_OMAP54XX),)
+obj-y	+= pipe3-phy.o
+obj-$(CONFIG_SCSI_AHCI_PLAT) += sata.o
+endif
+
+ifeq ($(CONFIG_SYS_DCACHE_OFF),)
+obj-y	+= omap-cache.o
+endif
+
+obj-y	+= boot-common.o
+obj-y	+= lowlevel_init.o
+
+obj-y	+= mem-common.o
+
+obj-y	+= fdt-common.o
+
+obj-$(CONFIG_TI_SECURE_DEVICE) += sec-common.o
diff -u -N U-Boot_SDcard/drivers/mmc/dw_mmc.c U-Boot_SDcard/drivers/mmc/dw_mmc.c
--- U-Boot_SDcard/drivers/mmc/dw_mmc.c	2019-09-12 15:54:39.000000696 -0500
+++ U-Boot_SDcard/drivers/mmc/dw_mmc.c	1969-12-31 19:29:21.000000182 -0600
@@ -388,7 +388,7 @@
 {
 	struct mmc *mmc = mmc_get_mmc_dev(dev);
 #else
-static void dwmci_set_ios(struct mmc *mmc)
+static int dwmci_set_ios(struct mmc *mmc)
 {
 #endif
 	struct dwmci_host *host = (struct dwmci_host *)mmc->priv;
@@ -421,9 +421,8 @@
 
 	if (host->clksel)
 		host->clksel(host);
-#ifdef CONFIG_DM_MMC_OPS
+
 	return 0;
-#endif
 }
 
 static int dwmci_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/board/ti/am3517crane/am3517crane.c U-Boot_SDcard/board/ti/am3517crane/am3517crane.c
--- U-Boot_SDcard/board/ti/am3517crane/am3517crane.c	2019-09-12 15:54:44.000000087 -0500
+++ U-Boot_SDcard/board/ti/am3517crane/am3517crane.c	1969-12-31 19:29:27.000000164 -0600
@@ -63,7 +63,7 @@
 	MUX_AM3517CRANE();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile
--- U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile	2019-09-12 15:54:32.000000681 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap5/Makefile	1969-12-31 19:29:28.000000759 -0600
@@ -1,18 +1,17 @@
-#
-# (C) Copyright 2000-2010
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	+= boot.o
-obj-y	+= hwinit.o
-obj-y	+= emif.o
-obj-y	+= sdram.o
-obj-y	+= prcm-regs.o
-obj-y	+= hw_data.o
-obj-y	+= abb.o
-obj-y	+= fdt.o
-obj-$(CONFIG_IODELAY_RECALIBRATION) += dra7xx_iodelay.o
-obj-$(CONFIG_TI_SECURE_DEVICE) += sec-fxns.o
-obj-$(CONFIG_DRA7XX) += sec_entry_cpu1.o
+#
+# (C) Copyright 2000-2010
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= boot.o
+obj-y	+= hwinit.o
+obj-y	+= emif.o
+obj-y	+= sdram.o
+obj-y	+= prcm-regs.o
+obj-y	+= hw_data.o
+obj-y	+= abb.o
+obj-y	+= fdt.o
+obj-$(CONFIG_IODELAY_RECALIBRATION) += dra7xx_iodelay.o
+obj-$(CONFIG_DRA7XX) += sec_entry_cpu1.o
diff -u -N U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c
--- U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c	2019-09-12 15:54:52.000000241 -0500
+++ U-Boot_SDcard/board/teejet/mt_ventoux/mt_ventoux.c	1969-12-31 19:29:27.000000139 -0600
@@ -291,8 +291,7 @@
 	return 0;
 }
 
-#if defined(CONFIG_OMAP_HSMMC) && \
-	!defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_OMAP_HSMMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c
--- U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c	2019-09-12 15:54:24.000000512 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap-cache.c	1969-12-31 19:29:23.000000899 -0600
@@ -62,6 +62,21 @@
 		set_section_dcache(i, ARMV7_DCACHE_POLICY);
 }
 
+#ifdef CONFIG_SPL_BUILD
+void sram_bank_mmu_setup(phys_addr_t start, phys_addr_t size)
+{
+	int i;
+	phys_addr_t end;
+
+	start = start >> MMU_SECTION_SHIFT;
+	size = size >> MMU_SECTION_SHIFT;
+	end = start + size;
+
+	for (i = start; i <= end; i++)
+		set_section_dcache(i, ARMV7_DCACHE_POLICY);
+}
+#endif
+
 void arm_init_domains(void)
 {
 	u32 reg;
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c
--- U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c	2019-09-12 15:54:17.000000015 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board_k2l.c	1969-12-31 19:29:27.000000207 -0600
@@ -14,13 +14,33 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-unsigned int external_clk[ext_clk_count] = {
-	[sys_clk]	= 122880000,
-	[alt_core_clk]	= 100000000,
-	[pa_clk]	= 122880000,
-	[tetris_clk]	= 122880000,
-	[ddr3a_clk]	= 100000000,
-};
+unsigned int get_external_clk(u32 clk)
+{
+	unsigned int clk_freq;
+
+	switch (clk) {
+	case sys_clk:
+		clk_freq = 122880000;
+		break;
+	case alt_core_clk:
+		clk_freq = 100000000;
+		break;
+	case pa_clk:
+		clk_freq = 122880000;
+		break;
+	case tetris_clk:
+		clk_freq = 122880000;
+		break;
+	case ddr3a_clk:
+		clk_freq = 100000000;
+		break;
+	default:
+		clk_freq = 0;
+		break;
+	}
+
+	return clk_freq;
+}
 
 static struct pll_init_data core_pll_config[NUM_SPDS] = {
 	[SPD800]	= CORE_PLL_799,
@@ -118,6 +138,16 @@
 }
 #endif
 
+#if defined(CONFIG_FIT_EMBED)
+int board_fit_config_name_match(const char *name)
+{
+	if (!strcmp(name, "keystone-k2l-evm"))
+		return 0;
+
+	return -1;
+}
+#endif
+
 #ifdef CONFIG_SPL_BUILD
 void spl_init_keystone_plls(void)
 {
diff -u -N U-Boot_SDcard/drivers/net/cpsw.c U-Boot_SDcard/drivers/net/cpsw.c
--- U-Boot_SDcard/drivers/net/cpsw.c	2019-09-12 15:54:15.000000513 -0500
+++ U-Boot_SDcard/drivers/net/cpsw.c	1969-12-31 19:29:21.000000269 -0600
@@ -612,21 +612,25 @@
 #endif
 }
 
-static void cpsw_slave_update_link(struct cpsw_slave *slave,
+static int cpsw_slave_update_link(struct cpsw_slave *slave,
 				   struct cpsw_priv *priv, int *link)
 {
 	struct phy_device *phy;
 	u32 mac_control = 0;
+	int ret = -ENODEV;
 
 	phy = priv->phydev;
+	if (!phy)
+		goto out;
 
-	if (!phy)
-		return;
+	ret = phy_startup(phy);
+	if (ret)
+		goto out;
 
-	phy_startup(phy);
-	*link = phy->link;
+	if (link)
+		*link = phy->link;
 
-	if (*link) { /* link up */
+	if (phy->link) { /* link up */
 		mac_control = priv->data.mac_control;
 		if (phy->speed == 1000)
 			mac_control |= GIGABITEN;
@@ -637,7 +641,7 @@
 	}
 
 	if (mac_control == slave->mac_control)
-		return;
+		goto out;
 
 	if (mac_control) {
 		printf("link up on port %d, speed %d, %s duplex\n",
@@ -649,17 +653,20 @@
 
 	__raw_writel(mac_control, &slave->sliver->mac_control);
 	slave->mac_control = mac_control;
+
+out:
+	return ret;
 }
 
 static int cpsw_update_link(struct cpsw_priv *priv)
 {
-	int link = 0;
+	int ret = -ENODEV;
 	struct cpsw_slave *slave;
 
 	for_active_slave(slave, priv)
-		cpsw_slave_update_link(slave, priv, &link);
+		ret = cpsw_slave_update_link(slave, priv, NULL);
 
-	return link;
+	return ret;
 }
 
 static inline u32  cpsw_get_slave_port(struct cpsw_priv *priv, u32 slave_num)
@@ -822,7 +829,9 @@
 	for_active_slave(slave, priv)
 		cpsw_slave_init(slave, priv);
 
-	cpsw_update_link(priv);
+	ret = cpsw_update_link(priv);
+	if (ret)
+		goto out;
 
 	/* init descriptor pool */
 	for (i = 0; i < NUM_DESCS; i++) {
@@ -897,7 +906,8 @@
 		}
 	}
 
-	return 0;
+out:
+	return ret;
 }
 
 static void _cpsw_halt(struct cpsw_priv *priv)
diff -u -N U-Boot_SDcard/arch/arm/lib/bootm-fdt.c U-Boot_SDcard/arch/arm/lib/bootm-fdt.c
--- U-Boot_SDcard/arch/arm/lib/bootm-fdt.c	2019-09-12 15:54:12.000000570 -0500
+++ U-Boot_SDcard/arch/arm/lib/bootm-fdt.c	1969-12-31 19:29:23.000000726 -0600
@@ -27,8 +27,10 @@
 
 int arch_fixup_fdt(void *blob)
 {
+	int ret = 0;
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_OF_LIBFDT)
 	bd_t *bd = gd->bd;
-	int bank, ret;
+	int bank;
 	u64 start[CONFIG_NR_DRAM_BANKS];
 	u64 size[CONFIG_NR_DRAM_BANKS];
 
@@ -42,9 +44,11 @@
 #endif
 	}
 
+#ifdef CONFIG_OF_LIBFDT
 	ret = fdt_fixup_memory_banks(blob, start, size, CONFIG_NR_DRAM_BANKS);
 	if (ret)
 		return ret;
+#endif
 
 #ifdef CONFIG_ARMV8_SPIN_TABLE
 	ret = spin_table_update_dt(blob);
@@ -58,6 +62,7 @@
 	if (ret)
 		return ret;
 #endif
+#endif
 
 	return 0;
 }
diff -u -N /dev/null U-Boot_SDcard/arch/arm/include/asm/ti-common/ti-gpmc.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/include/asm/ti-common/ti-gpmc.h	1969-12-31 19:31:37.000000961 -0600
@@ -0,0 +1,51 @@
+/*
+ * TI GMPC driver
+ *
+ * (C) Copyright 2015
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _TI_GPMC_H_
+#define _TI_GPMC_H_
+
+#define GPMC_SIZE_256M          0x0
+#define GPMC_SIZE_128M          0x8
+#define GPMC_SIZE_64M           0xC
+#define GPMC_SIZE_32M           0xE
+#define GPMC_SIZE_16M           0xF
+
+#define M_NAND_GPMC_CONFIG1     0x00000800
+#define M_NAND_GPMC_CONFIG2     0x001e1e00
+#define M_NAND_GPMC_CONFIG3     0x001e1e00
+#define M_NAND_GPMC_CONFIG4     0x16051807
+#define M_NAND_GPMC_CONFIG5     0x00151e1e
+#define M_NAND_GPMC_CONFIG6     0x16000f80
+#define M_NAND_GPMC_CONFIG7     0x00000008
+
+#define STNOR_GPMC_CONFIG1      0x00001000
+#define STNOR_GPMC_CONFIG2      0x001f1f00
+#define STNOR_GPMC_CONFIG3      0x001f1f01
+#define STNOR_GPMC_CONFIG4      0x1f011f01
+#define STNOR_GPMC_CONFIG5      0x001d1f1f
+#define STNOR_GPMC_CONFIG6      0x08070280
+#define STNOR_GPMC_CONFIG7      0x00000048
+
+/* max number of GPMC Chip Selects */
+#define GPMC_MAX_CS             8
+/* max number of GPMC regs */
+#define GPMC_MAX_REG            7
+
+struct ti_gpmc_config {
+	u32 config1;
+	u32 config2;
+	u32 config3;
+	u32 config4;
+	u32 config5;
+	u32 config6;
+};
+
+void ti_gpmc_init(struct ti_gpmc_config *cfg);
+
+#endif
diff -u -N U-Boot_SDcard/include/configs/pengwyn.h U-Boot_SDcard/include/configs/pengwyn.h
--- U-Boot_SDcard/include/configs/pengwyn.h	2019-09-12 15:54:13.000000086 -0500
+++ U-Boot_SDcard/include/configs/pengwyn.h	1969-12-31 19:29:22.000000392 -0600
@@ -207,6 +207,6 @@
 
 /* CPSW support */
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #endif	/* ! __CONFIG_PENGWYN_H */
diff -u -N /dev/null U-Boot_SDcard/cmd.txt
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/cmd.txt	1969-12-31 19:31:37.000000897 -0600
@@ -0,0 +1,806 @@
+    1  vi /etc/fstab
+    2  clear
+    3  echo 'Acquire::http::Proxy "http://ubuntuz01.sasken.com:3142";' > /etc/apt/apt.conf.d/01proxy
+    4  clear
+    5  apt-get update
+    6  apt-get install ssh
+    7  vi /etc/ssh/sshd_config 
+    8  clear
+    9  apt-get install aptitude
+   10  apt-get install build-essential 
+   11  apt-get install pidgin
+   12  apt-get install pidgin-sipe
+   13  apt-get install thunderbird
+   14  apt-get install chromium-browser
+   15  apt-get install dconf-tools 
+   16  clear
+   17  vi /etc/resolv.conf 
+   18  clear
+   19  vi /etc/resolv.conf 
+   20  clear
+   21  vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf 
+   22  clear
+   23  apt-get install gparted 
+   24  clear
+   25  hwclock
+   26  date
+   27  hwclock -show
+   28  hwclock --show
+   29  hwclock --set --date "12/6/2017 01:30:00"
+   30  hwclock --show
+   31  date --set="2017-12-6 01:34 PM"
+   32  hwclock --show
+   33  hwclock --set --date "12/6/2017 01:30:00 PM "
+   34  hwclock --show
+   35  hwclock --set --date "12/6/2017 01:34:00 PM "
+   36  hwclock --show
+   37  vi /etc/hostname 
+   38  apt-get update
+   39  exit
+   40  date --set="12 Jan 2018 12:49:00 PM"
+   41  date
+   42  reboot
+   43  vi /etc/hostname 
+   44  reboot
+   45  passwd root
+   46  exit
+   47  apt-get install meld
+   48  ls
+   49  exit
+   50  make distclean
+   51  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- distclean
+   52  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- clean
+   53  ls
+   54  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- -o=am43xx-evm 
+   55  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- -O=am43xx-evm am43xx_evm_qspiboot_defconfig
+   56  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- O=am43xx-evm am43xx_evm_qspiboot_defconfig
+   57  make CROSS_COMPILE=../../../Toolchain/bin/arm-linux-gnueabihf- O=am43xx-evm
+   58  make CROSS_COMPILE=./../../../Toolchain/bin/arm-linux-gnueabihf- O=am43xx-evm
+   59  cd ../../../
+   60  cd Toolchain/
+   61  ls
+   62  cd bin/
+   63  ls
+   64  pwd
+   65  export PATH=/home/ee209357/Documents/Toolchain/bin:$PATH
+   66  $PATH
+   67  env
+   68  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+   69  make CROSS_COMPILE=arm-linux-gnueabihf- clean
+   70  cd ../../
+   71  cd am5728/2017-sdk/u-boot-am4377/
+   72  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+   73  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+   74  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+   75  chmod 0755 ../scripts/check-config.sh
+   76  chmod 0755 scripts/check-config.sh
+   77  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+   78  vi scripts/check-config.sh 
+   79  echo $SHELL
+   80  vi /etc/shells 
+   81  sudo apt-get install csh
+   82  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+   83  csh
+   84  chsh -s /bin/csh
+   85  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+   86  chsh
+   87  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+   88  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+   89  vi scripts/kconfig/lxdialog/check-lxdialog.sh
+   90  aptitude search mkimage
+   91  aptitude search mkimage-uboot
+   92  aptitude search uboot
+   93  aptitude search uboot-tools
+   94  aptitude search mkimage
+   95  aptitude search mkimage-uboot
+   96  aptitude search uboot-mkimage
+   97  apt-get install uboot-mkimage
+   98  apt-get install u-boot-tools:i386
+   99  dos2unix
+  100  apt-get install dos2unix
+  101  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+  102  dos2unix scripts/kconfig/lxdialog/check-lxdialog.sh
+  103  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+  104  dos2unix scripts/kconfig/check.sh
+  105  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+  106  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  107  dos2unix scripts/gcc-stack-usage.sh
+  108  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  109  dos2unix scripts/config_whitelist.txt
+  110  dos2unix scripts/check-config.sh
+  111  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  112  ls
+  113  ls arch/arm
+  114  ls
+  115  ls am43xx_evm/
+  116  ls am43xx-evm/
+  117  ls
+  118  rm -rf am43xx-evm
+  119  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+  120  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_qspiboot_defconfig
+  121  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  122  ls
+  123  ls am43xx_evm/
+  124  ls -al am43xx_evm/
+  125  ls
+  126  cp -rf am43xx_evm /home/ee209357/Desktop/
+  127  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+  128  export PATH=/home/ee209357/Documents/Toolchain/bin:$PATH
+  129  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+  130  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm am43xx_evm_defconfig
+  131  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  132  dos2unix scripts/binutils-version.sh
+  133  dos2unix scripts/gcc-version.sh
+  134  dos2unix scripts/dtc-version.sh
+  135  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  136  make CROSS_COMPILE=arm-linux-gnueabihf- O=am43xx_evm
+  137  ls
+  138  cd am43xx_evm/
+  139  ls
+  140  file u-boot
+  141  file u-boot.bin
+  142  objdemp u-boot.bin
+  143  objdump u-boot.bin
+  144  objdump -d u-boot.bin
+  145  arm-linux-gnueabihf-objdump -d u-boot.bin
+  146  ls
+  147  arm-linux-gnueabihf-objdump -d u-boot
+  148  arm-linux-gnueabihf-objdump -d u-boot | less
+  149  ls
+  150  cd ../
+  151  cd configs
+  152  ls
+  153  vi am335x_hs_evm_uart_defconfig
+  154  vi am43xx_evm_defconfig
+  155  grep -irn "CONFIG_DM_SERIAL" ../board/
+  156  vi ../board/ti/am335x/board.c +81
+  157  grep -irn "CONFIG_DM_SERIAL" ../arch/
+  158  cd ../
+  159  ls
+  160  cd am43xx_evm/
+  161  sl
+  162  ls
+  163  cp u-boot.bin /media/ee209357/AC9A-0AF4/
+  164  syncc
+  165  sync
+  166  ls
+  167  vim u-boot.lds 
+  168  apt-get install vim
+  169  ls
+  170  cat u-boot.lds 
+  171  ls
+  172  cp MLO /media/ee209357/AC9A-0AF4/
+  173  sync
+  174  ls spl/
+  175  ls board/
+  176  ls board/ti/
+  177  ls board/ti/am43xx/
+  178  ls board/ti/common/
+  179  ls
+  180  ls scripts/
+  181  ls scripts/basic/
+  182  ls scripts/basic/fixdep 
+  183  ls scripts/basic/
+  184  ls scripts/kconfig/
+  185  ls
+  186  ls test/
+  187  ls test/dm/
+  188  ls tools/
+  189  ls
+  190  cd spl/
+  191  ls
+  192  cd ..
+  193  ls
+  194  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+  195  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm
+  196  ls
+  197  ls include/
+  198  ls include/configs/
+  199  ls
+  200  cd ../../
+  201  ls
+  202  cd -
+  203  ls
+  204  make CROSS_COMPILE=arm-linux-gnueabihf- distclean
+  205  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm am57xx_evm_defconfig
+  206  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm
+  207  ls
+  208  tar -zcvf am57xx_evm.tar.gz am57xx_evm/
+  209  cp am57xx_evm.tar.gz /media/ee209357/AC9A-0AF4/
+  210  sync
+  211  ls
+  212  cd am43xx_evm/
+  213  ls
+  214  cd arch/arm/mach-omap2/am33xx/
+  215  ls
+  216  cd ../../../
+  217  cd ../
+  218  ls
+  219  cd drivers/
+  220  ls
+  221  cd i2c/
+  222  ls
+  223  cd i2c
+  224  ls
+  225  cd
+  226  cd -
+  227  cd ../input/
+  228  ls
+  229  cd ../../../
+  230  ls
+  231  vim drivers/i2c/davinci_i2c.c
+  232  ls
+  233  cd ../
+  234  ls
+  235  cd u-boot-am4377/
+  236  ls
+  237  lss
+  238  ls
+  239  cd am43xx_evm/spl/
+  240  ls
+  241  cd cmd/
+  242  ls
+  243  cd ..
+  244  ls
+  245  cd arch/arm/cpu/
+  246  ls
+  247  cd armv7/
+  248  ls
+  249  cd ../../..
+  250  cd ..
+  251  ls
+  252  cd drivers/serial/
+  253  lsexitt
+  254  ls
+  255  cd ../core/
+  256  ls
+  257  cd ../..
+  258  ls
+  259  cd lib/
+  260  ls
+  261  cd libfdt/
+  262  ls
+  263  cd ../../
+  264  ls
+  265  cat u-boot-spl.map 
+  266  cd ..
+  267  ls
+  268  cd ..
+  269  ls
+  270  cd am57xx_evm
+  271  ls
+  272  cd examples/
+  273  ls
+  274  cd standalone/
+  275  ls
+  276  cd ../..
+  277  ls
+  278  vim Makefile 
+  279  cd source
+  280  ls
+  281  cd board/
+  282  ls
+  283  cd ..
+  284  ls
+  285  cd drivers/
+  286  ls
+  287  cd serial/
+  288  ls
+  289  cd ..
+  290  ls
+  291  cd ..
+  292  ls
+  293  cd doc/
+  294  ls
+  295  vim README.SPL 
+  296  ls
+  297  vim README.SPL 
+  298  ./install_drivers.sh
+  299  ls
+  300  cd install_scripts/
+  301  ls
+  302  ./install_drivers.sh
+  303  init 0
+  304  ./install_drivers.sh 
+  305  sh install_drivers.sh 
+  306  clear
+  307  ls
+  308  ./ti_permissions_install.sh 
+  309  make clean
+  310  ls
+  311  vim cdev.c 
+  312  vim Makefile 
+  313  make
+  314  ls
+  315  insmod cdev.ko 
+  316  dmesg
+  317  gcc cdevtest.c 
+  318  ./a.out 
+  319  vim cdev.c 
+  320  cd ..
+  321  ls
+  322  cd cdev-dyn/
+  323  ls
+  324  vim cdev_load 
+  325  ./cdev_load
+  326  vim cdev_load 
+  327  sh cdev_load 
+  328  cp cdev_load ../prac/
+  329  cd ../prac/
+  330  ls
+  331  insmod cdev
+  332  rmmod cdev.ko
+  333  sh cdev
+  334  sh cdev_load 
+  335  dmesg
+  336  ./a.out 
+  337  dmesg
+  338  cp ../cdev-dyn/cdev_unload .
+  339  sh cdev_unload 
+  340  ls
+  341  dmesg
+  342  clear
+  343  apt-get install usbboot
+  344  apt-get install usb-boot
+  345  cd 
+  346  exit
+  347  apt-get install dfu-utils
+  348  apt-get install dfu-util
+  349  dfu-util -l
+  350  cd
+  351  exit
+  352  ./ti-processor-sdk-rtos-am57xx-evm-04.02.00.09-Linux-x86-Install.bin
+  353  chmod 777 ti-processor-sdk-rtos-am57xx-evm-04.02.00.09-Linux-x86-Install.bin
+  354  ./ti-processor-sdk-rtos-am57xx-evm-04.02.00.09-Linux-x86-Install.bin
+  355  ssh root@10.3.6.23
+  356  ssh mahesh@10.3.6.23
+  357  exit
+  358  make tools BOARD=idkAM572x SOC=AM572x
+  359  ls
+  360  cd tools/
+  361  ls
+  362  cd flashWriter/
+  363  ls
+  364  cd qspi/
+  365  ls
+  366  cd bin/
+  367  ls
+  368  cd idkAM572x/
+  369  ls
+  370  file qspi_flash_writer.out
+  371  ls
+  372  rm qspi_flash_writer.out 
+  373  cd ../../../../
+  374  ls
+  375  cd ../
+  376  ls
+  377  make tools BOARD=idkAM572x SOC=AM572x
+  378  cd -
+  379  cd flashWriter/qspi/bin/idkAM572x/
+  380  ls
+  381  ls obj/
+  382  cd ../
+  383  cd ../../../../
+  384  make tools BOARD=idkAM572x SOC=AM572x
+  385  export BIN_PATH=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary
+  386  pwd
+  387  export TI_PDK_INSTALL_DIR=/opt/ti/pdk_am57xx_1_0_9/packages
+  388  export BIN_PATH=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary
+  389  export TI_PDK_INSTALL_DIR=/opt/ti/pdk_am57xx_1_0_9/packages:$TI_PDK_INSTALL_DIR
+  390  export BIN_PATH=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary
+  391  cd ../../
+  392  ls
+  393  cd ../
+  394  ls
+  395  pdksetupenv.sh
+  396  ./pdksetupenv.sh
+  397  ls
+  398  source pdksetupenv.sh
+  399  make clean
+  400  ls
+  401  ls ti/boot/
+  402  ls ti/boot/sbl/
+  403  make sbl
+  404  make boot
+  405  make tools
+  406  cd ti/boot/sbl/
+  407  ls
+  408  make
+  409  ls
+  410  cd tools/
+  411  ls
+  412  cd flashWriter/
+  413  ls
+  414  cd qspi/
+  415  ls
+  416  cd ../../
+  417  ls
+  418  cd ../
+  419  make cleam
+  420  make clean
+  421  cd ../
+  422  ls
+  423  cd ../
+  424  ls
+  425  cd board/
+  426  ls
+  427  cd build/
+  428  ls
+  429  make clean
+  430  cd ../../
+  431  cd ../
+  432  ls
+  433  vi Rules.make 
+  434  ls
+  435  vi makefile 
+  436  make sbl
+  437  clean
+  438  clear
+  439  make sbl
+  440  vi makefile 
+  441  make all
+  442  ls
+  443  source pdksetupenv.sh
+  444  ls /root/
+  445  ls
+  446  ls /opt/ti/
+  447  source pdksetupenv.sh
+  448  vi pdksetupenv.sh
+  449  source pdksetupenv.sh
+  450  vi pdksetupenv.sh
+  451  source pdksetupenv.sh
+  452  \env
+  453  exit
+  454  chmod 777 -R * 
+  455  exit
+  456  minicom -D /dev/ttyUSB1
+  457  cd ../
+  458  ls
+  459  cd ../../
+  460  ls
+  461  cd bin/
+  462  ls
+  463  cd idkAM572x
+  464  la
+  465  ls
+  466  cd armv7/
+  467  ls
+  468  file qspi_diagExample_idkAM572x_armv7.out
+  469  ifconfig
+  470  ls
+  471  cd /home/ee209357/Documents/
+  472  ls
+  473  cd am5728/
+  474  ls
+  475  cd 2017-sdk/
+  476  ls
+  477  cd u-boot-am4377/
+  478  ls
+  479  find -name am437x-idk-evm.dtb
+  480  vi ./am43xx_evm_latest/arch/arm/dts/am437x-idk-evm.dtb
+  481  cd /home/ee209357/Documents/
+  482  ls
+  483  cd am5728/2017-sdk/u-boot-am4377/
+  484  ls
+  485  vi include/configs/am57xx_evm.h 
+  486  vi configs/am57xx_evm_
+  487  vi configs/am57xx_evm_defconfig 
+  488  vi Makefile 
+  489  ls
+  490  cd /home/ee209357/Documents/
+  491  ls
+  492  cd am5728/
+  493  cd ../
+  494  cd u-boot
+  495  ls
+  496  vi TISDK-README 
+  497  vi config.mk 
+  498  vi Kbuild 
+  499  vi Kconfig 
+  500  vi u-boot.sym 
+  501  find -name version.c
+  502  vi ./cmd/version.c
+  503  grep -irn "U_BOOT_VERSION_STRING" *
+  504  grep -irn "U_BOOT_DATE" *
+  505  grep -irn "version" *
+  506  grep -irn "2016" *
+  507  grep -irn "u-boot2016" *
+  508  grep -irn "u-boo" *
+  509  vi arch/blackfin/include/asm/u-boot.h
+  510  grep -irn "u-boot" *
+  511  vi include/configs/am57xx_evm.h 
+  512  ls
+  513  vi README 
+  514  ls
+  515  vi MAINTAINERS 
+  516  vi snapshot.commit 
+  517  cd ../
+  518  ls
+  519  cd am5728/
+  520  ls
+  521  cd u-boot
+  522  ls
+  523  vi u-boot.srec
+  524  vi include/configs/am57xx_evm.h 
+  525  cd ../
+  526  ls
+  527  cd 2017-sdk/u-boot-am4377/include/configs/
+  528  vi am57xx_evm.h 
+  529  cp u-boot.img /media/ee209357/
+  530  sync
+  531  cd ../
+  532  ls
+  533  cd ../
+  534  ls
+  535  cd ../
+  536  ls
+  537  l
+  538  ls
+  539  cd 2017-sdk/u-boot-am4377/
+  540  ls
+  541  cd am57xx_evm
+  542  ls
+  543  ls /media/ee209357/
+  544  mv /media/ee209357/6EE2-D395/MLO /media/ee209357/6EE2-D395/MLO_backup
+  545  cp MLO /media/ee209357/6EE2-D395/
+  546  cp /media/ee209357/u-boot.img /media/ee209357/6EE2-D395/
+  547  sync
+  548  ls
+  549  bin2header u-boot.bin
+  550  ls
+  551  vi u-boot.h
+  552  pwd
+  553  vi u-boot.h
+  554  cp u-boot.h /opt/ti/pdk_am57xx_1_0_9/packages/ti/board/diag/qspi/src/
+  555  vi u-boot.h
+  556  ll
+  557  vi u-boot.h
+  558  ls
+  559  cd spl/
+  560  ls
+  561  pwd
+  562  ls
+  563  pwd
+  564  cd ../../
+  565  vi include/configs/am57xx_evm.h 
+  566  grep -irn "bootmode" *
+  567  ifconfig
+  568  apt-get install meld
+  569  ls
+  570  grep -nir "sf_write" .
+  571  vim drivers/mtd/spi/sandbox.c +39
+  572  ls
+  573  cd cmd/
+  574  ls
+  575  cd fastboot
+  576  ls
+  577  cd ..
+  578  ls
+  579  cd ..
+  580  ls
+  581  cd examples/
+  582  ls
+  583  cd ..
+  584  ls
+  585  grep -nir "sf write" .
+  586  vim cmd/sf.c 
+  587  ctags -R
+  588  vim cmd/sf.c 
+  589  cd am57xx_evm
+  590  ls
+  591  ls -l
+  592  vim u-boot.h 
+  593  rm u-boot.h 
+  594  ls
+  595  ls -l
+  596  vim u-boot.h 
+  597  file u-boot
+  598  file u-boot.bin 
+  599  file u-boot.img 
+  600  ls
+  601  cp u-boot.h /opt/ti/pdk_am57xx_1_0_9/packages/ti/board/diag/qspi/src/
+  602  ls
+  603  cd ..
+  604  vim cmd/sf.c 
+  605  find spi_flash.c
+  606  find spi_flash.h
+  607  vim cmd/sf.c 
+  608  ls
+  609  find -name spi_flash.h
+  610  find -name spi_flash.c
+  611  vim drivers/mtd/spi/spi_flash.c
+  612  vim cmd/sf.c
+  613  grep -nir "struct dm_spi_flash_ops" .
+  614  vim drivers/mtd/spi/sf_probe.c
+  615  ls
+  616  cd am57xx_evm/
+  617  ls
+  618  cp MLO.h /home/ee209357/
+  619  ls
+  620  cp u-boot.bin /media/ee209357/6EE2-D395/
+  621  sync
+  622  cd ..
+  623  vim cmd/sf.c 
+  624  ls
+  625  vim include/configs/am57xx_evm.h 
+  626  ls
+  627  cd board/ti/am57xx/
+  628  ls
+  629  vi board.c 
+  630  grep -irn "CONFIG_SYS_SDRAM_BASE" *
+  631  cd ../
+  632  grep -irn "CONFIG_SYS_SDRAM_BASE" *
+  633  ../
+  634  cd ../
+  635  grep -irn "CONFIG_SYS_SDRAM_BASE" *
+  636  ls
+  637  cd ../
+  638  cd include/
+  639  grep -irn "CONFIG_SYS_SDRAM_BASE" *
+  640  vi configs/am57xx_evm.h 
+  641  q
+  642  ls
+  643  cd ../
+  644  grep -irn "CONFIG_SYS_SDRAM_BASE" configs/
+  645  ls
+  646  vi configs/am43xx_evm_qspiboot_defconfig 
+  647  vi include/configs/am43xx_evm.h 
+  648  ls
+  649  cd am57xx_evm
+  650  ls
+  651  cp MLO u-boot.img /media/ee209357/6EE2-D395/
+  652  sync
+  653  sl
+  654  ls
+  655  vim System.map 
+  656  cd 
+  657  cd -
+  658  cd ..
+  659  ls
+  660  grep -nir "Unsupported Boot device !" .
+  661  cd ../
+  662  ls
+  663  cd ..
+  664  ls
+  665  cd ..
+  666  ls
+  667  cd am5728/
+  668  ls
+  669  cd ..
+  670  ls
+  671  cd u-boot-2017-sdk/
+  672  ls
+  673  cd s
+  674  cd spl/
+  675  ls
+  676  cd ..
+  677  ls
+  678  cd examples/
+  679  vim 
+  680  cd ..
+  681  ls
+  682  vim include/configs/am57xx_evm.h 
+  683  cd ..
+  684  ls
+  685  cd am5728/
+  686  ls
+  687  cd 2017-sdk/
+  688  ls
+  689  cd ..
+  690  ls
+  691  cd u-boot
+  692  ls
+  693  vim README 
+  694  cd ..
+  695  ls
+  696  cd u-boot
+  697  ls
+  698  export PATH=/home/ee209357/Documents/Toolchain/bin
+  699  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm am57xx_evm_defconfig
+  700  export PATH=/home/ee209357/Documents/Toolchain/bin/:$PATH
+  701  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm am57xx_evm_defconfig
+  702  export PATH=$PATH:/home/ee209357/Documents/Toolchain/bin
+  703  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm am57xx_evm_defconfig
+  704  export PATH=$PATH:/home/ee209357/Documents/Toolchain/bin/
+  705  make CROSS_COMPILE=arm-linux-gnueabihf
+  706  ls
+  707  minicom -D /dev/ttyUSB1
+  708  cd /home/ee209357/Documents/
+  709  ls
+  710  grep -irn "2016.05" am5728/
+  711  cd am5728/2017-sdk/u-boot-m1/
+  712  ls
+  713  vi include/configs/am57xx_evm.h 
+  714  meld include/configs/am57xx_evm.h ../u-boot-am4377/include/configs/am57xx_evm.h 
+  715  vimdiff include/configs/am57xx_evm.h ../u-boot-am4377/include/configs/am57xx_evm.h 
+  716  diff -Naur include/configs/am57xx_evm.h ../u-boot-am4377/include/configs/am57xx_evm.h 
+  717  diff include/configs/am57xx_evm.h ../u-boot-am4377/include/configs/am57xx_evm.h 
+  718  diff configs/am57xx_evm_defconfig ../u-boot-am4377/configs/am57xx_evm_defconfig 
+  719  diff -Naur configs/am57xx_evm_defconfig ../u-boot-am4377/configs/am57xx_evm_defconfig 
+  720  vimdiff configs/am57xx_evm_defconfig ../u-boot-am4377/configs/am57xx_evm_defconfig 
+  721  vimdiff .config ../u-boot-am4377/am57xx_evm/.config 
+  722  ls
+  723  diff board/ti/am57xx/board.c ../u-boot-am4377/board/ti/am57xx/board.c 
+  724  vi board/ti/am57xx/board.c
+  725  ls
+  726  vi u-boot.bin
+  727  vi u-boot.srec
+  728  vi include/configs/am57xx_evm.h 
+  729  vi ../u-boot-am4377/include/configs/am57xx_evm.h 
+  730  vi ../u-boot-am4377/am57xx_evm/.config 
+  731  cd ../
+  732  grep -irn "Nov 09 2016" am5728/
+  733  grep -irn "Nov 09 2016" ../../am5728/
+  734  cd u-boot-am4377/
+  735  ls
+  736  vi board/ti/am57xx/board.c 
+  737  vi include/configs/am57xx_evm.h 
+  738  vimdiff configs/am57xx_evm_defconfig configs/am57xx_evm_nodt_defconfig 
+  739  vi configs/am43xx_evm_qspiboot_defconfig 
+  740  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm distclean
+  741  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 distclean
+  742  vi include/configs/am57xx_evm.h 
+  743  ls
+  744  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  745  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  746  ls
+  747  cd am57xx_evm1/
+  748  ls
+  749* 
+  750  ls
+  751  lks
+  752  ls
+  753* 
+  754  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  755* make CROSS_COMPILE=arm-linux-gnueabihf- O=
+  756  export PATH=$PATH:/home/ee209357/Documents/Toolchain/bin/
+  757  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 distclean
+  758  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  759  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  760  ls
+  761  cd am57xx_evm1/
+  762  ls
+  763  ls -l
+  764  chmod 777 MLO u-boot.img 
+  765  ls
+  766  cd ..
+  767  vim include/configs/am43xx_evm.h 
+  768  vim include/configs/am57xx_evm.h 
+  769  grep -irn "uboot.env" include/configs/
+  770  vi include/configs/am43xx_evm.h +82
+  771  vi include/configs/ib62x0.h +69
+  772  grep -irn "FAT_ENV_FILE" include/configs/
+  773  grep -irn "uEnv" include/configs/
+  774  vi include/configs/omap3_beagle.h +115
+  775  vi include/configs/am43xx_evm.h
+  776  vi include/configs/am57xx_evm.h 
+  777  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 distclean
+  778  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  779  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  780  vi ../include/configs/ti_omap5_common.h
+  781  vi include/configs/ti_omap5_common.h
+  782  ls
+  783* 
+  784  pwd
+  785  cp am43xx_evm/u-boot.bin /home/ee209357/Downloads/Bin2Header-0.1.0/bin/
+  786  ls
+  787  vim /include/configs/ti_omap5_common.h +117
+  788  vim include/configs/ti_omap5_common.h +117
+  789  vim include/configs/am57xx_evm.h 
+  790  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 distclean
+  791  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  792  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  793  ls
+  794  cd am57xx_evm1/
+  795  ls
+  796  cp u-boot.img /home/ee209357/Downloads/Bin2Header-0.1.0/bin/
+  797  ls
+  798  vim 
+  799  ls
+  800* make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  801  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1 am57xx_evm_nodt_defconfig
+  802  make CROSS_COMPILE=arm-linux-gnueabihf- O=am57xx_evm1
+  803  cd ..
+  804  vim include/configs/am57xx_evm.h 
+  805  grep -nir "CONFIG_BOOTCOMMAND" .
+  806  history > cmd.txt
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2l-evm.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2l-evm.dts	1969-12-31 19:31:37.000000944 -0600
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Lamarr EVM device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone.dtsi"
+#include "keystone-k2l.dtsi"
+
+/ {
+	compatible =  "ti,k2l-evm","ti,keystone";
+	model = "Texas Instruments Keystone 2 Lamarr EVM";
+
+	soc {
+		clocks {
+			refclksys: refclksys {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <122880000>;
+				clock-output-names = "refclk-sys";
+			};
+		};
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&i2c0 {
+	dtt@50 {
+		compatible = "at,24c1024";
+		reg = <0x50>;
+	};
+};
+
+&aemif {
+	cs0 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		clock-ranges;
+		ranges;
+
+		ti,cs-chipselect = <0>;
+		/* all timings in nanoseconds */
+		ti,cs-min-turnaround-ns = <12>;
+		ti,cs-read-hold-ns = <6>;
+		ti,cs-read-strobe-ns = <23>;
+		ti,cs-read-setup-ns = <9>;
+		ti,cs-write-hold-ns = <8>;
+		ti,cs-write-strobe-ns = <23>;
+		ti,cs-write-setup-ns = <8>;
+
+		nand@0,0 {
+			compatible = "ti,keystone-nand","ti,davinci-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0 0x4000000
+			       1 0 0x0000100>;
+
+			ti,davinci-chipselect = <0>;
+			ti,davinci-mask-ale = <0x2000>;
+			ti,davinci-mask-cle = <0x4000>;
+			ti,davinci-mask-chipsel = <0>;
+			nand-ecc-mode = "hw";
+			ti,davinci-ecc-bits = <4>;
+			nand-on-flash-bbt;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x0 0x100000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "params";
+				reg = <0x100000 0x80000>;
+				read-only;
+			};
+
+			partition@180000 {
+				label = "ubifs";
+				reg = <0x180000 0x7FE80000>;
+			};
+		};
+	};
+};
+
+&spi0 {
+	status ="okay";
+	nor_flash: n25q128a11@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "Micron,n25q128a11", "spi-flash";
+		spi-max-frequency = <54000000>;
+		m25p,fast-read;
+		reg = <0>;
+
+		partition@0 {
+			label = "u-boot-spl";
+			reg = <0x0 0x80000>;
+			read-only;
+		};
+
+		partition@1 {
+			label = "misc";
+			reg = <0x80000 0xf80000>;
+		};
+	};
+};
+
+&mdio {
+	status = "ok";
+	ethphy0: ethernet-phy@0 {
+		compatible = "marvell,88E1514", "marvell,88E1510", "ethernet-phy-ieee802.3-c22";
+		reg = <0>;
+	};
+
+	ethphy1: ethernet-phy@1 {
+		compatible = "marvell,88E1514", "marvell,88E1510", "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
diff -u -N U-Boot_SDcard/drivers/mmc/sh_mmcif.c U-Boot_SDcard/drivers/mmc/sh_mmcif.c
--- U-Boot_SDcard/drivers/mmc/sh_mmcif.c	2019-09-12 15:54:11.000000959 -0500
+++ U-Boot_SDcard/drivers/mmc/sh_mmcif.c	1969-12-31 19:29:21.000000214 -0600
@@ -539,7 +539,7 @@
 	return ret;
 }
 
-static void sh_mmcif_set_ios(struct mmc *mmc)
+static int sh_mmcif_set_ios(struct mmc *mmc)
 {
 	struct sh_mmcif_host *host = mmc->priv;
 
@@ -554,6 +554,7 @@
 		host->bus_width = MMC_BUS_WIDTH_1;
 
 	debug("clock = %d, buswidth = %d\n", mmc->clock, mmc->bus_width);
+	return 0;
 }
 
 static int sh_mmcif_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/common/env_ext4.c U-Boot_SDcard/common/env_ext4.c
--- U-Boot_SDcard/common/env_ext4.c	2019-09-12 15:54:14.000000088 -0500
+++ U-Boot_SDcard/common/env_ext4.c	1969-12-31 19:29:17.000000480 -0600
@@ -43,6 +43,10 @@
 	gd->env_addr = (ulong)&default_environment[0];
 	gd->env_valid = 1;
 
+	/* intialize the MMC sub-system if env is stored on a MMC*/
+	if (!strcmp(EXT4_ENV_INTERFACE, "mmc"))
+		mmc_initialize(NULL);
+
 	return 0;
 }
 
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c	2019-09-12 15:54:18.000000372 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/emif4.c	1969-12-31 19:29:28.000000733 -0600
@@ -125,8 +125,13 @@
 	writel(DDR_CKE_CTRL_NORMAL, &ddrctrl->ddrckectrl);
 
 	if (emif_sdram_type(regs->sdram_config) == EMIF_SDRAM_TYPE_DDR3)
+#ifndef CONFIG_SPL_RTC_ONLY_SUPPORT
 		/* Allow EMIF to control DDR_RESET */
 		writel(0x00000000, &ddrctrl->ddrioctrl);
+#else
+		/* Override EMIF DDR_RESET control */
+		writel(0x80000000, &ddrctrl->ddrioctrl);
+#endif /* CONFIG_SPL_RTC_ONLY_SUPPORT */
 #endif
 
 	/* Program EMIF instance */
diff -u -N U-Boot_SDcard/drivers/mmc/sunxi_mmc.c U-Boot_SDcard/drivers/mmc/sunxi_mmc.c
--- U-Boot_SDcard/drivers/mmc/sunxi_mmc.c	2019-09-12 15:54:32.000000841 -0500
+++ U-Boot_SDcard/drivers/mmc/sunxi_mmc.c	1969-12-31 19:29:21.000000218 -0600
@@ -227,7 +227,7 @@
 	return 0;
 }
 
-static void sunxi_mmc_set_ios(struct mmc *mmc)
+static int sunxi_mmc_set_ios(struct mmc *mmc)
 {
 	struct sunxi_mmc_host *mmchost = mmc->priv;
 
@@ -247,6 +247,8 @@
 		writel(0x1, &mmchost->reg->width);
 	else
 		writel(0x0, &mmchost->reg->width);
+
+	return 0;
 }
 
 static int sunxi_mmc_core_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/fs/jffs2/jffs2_1pass.c U-Boot_SDcard/fs/jffs2/jffs2_1pass.c
--- U-Boot_SDcard/fs/jffs2/jffs2_1pass.c	2019-09-12 15:54:36.000000463 -0500
+++ U-Boot_SDcard/fs/jffs2/jffs2_1pass.c	1969-12-31 19:29:21.000000823 -0600
@@ -175,10 +175,15 @@
 static int read_nand_cached(u32 off, u32 size, u_char *buf)
 {
 	struct mtdids *id = current_part->dev->id;
+	struct mtd_info *mtd;
 	u32 bytes_read = 0;
 	size_t retlen;
 	int cpy_bytes;
 
+	mtd = get_nand_dev_by_index(id->num);
+	if (!mtd)
+		return -1;
+
 	while (bytes_read < size) {
 		if ((off + bytes_read < nand_cache_off) ||
 		    (off + bytes_read >= nand_cache_off+NAND_CACHE_SIZE)) {
@@ -195,8 +200,8 @@
 			}
 
 			retlen = NAND_CACHE_SIZE;
-			if (nand_read(nand_info[id->num], nand_cache_off,
-						&retlen, nand_cache) != 0 ||
+			if (nand_read(mtd, nand_cache_off,
+				      &retlen, nand_cache) != 0 ||
 					retlen != NAND_CACHE_SIZE) {
 				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
 						nand_cache_off, NAND_CACHE_SIZE);
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c
--- U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c	2019-09-12 15:54:45.000000598 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/sec-common.c	1969-12-31 19:29:23.000000907 -0600
@@ -2,11 +2,13 @@
  *
  * Common security related functions for OMAP devices
  *
- * (C) Copyright 2016
+ * (C) Copyright 2016-2017
  * Texas Instruments, <www.ti.com>
  *
  * Daniel Allred <d-allred@ti.com>
  * Andreas Dannenberg <dannenberg@ti.com>
+ * Harinarayan Bhatta <harinarayan@ti.com>
+ * Andrew F. Davis <afd@ti.com>
  *
  * SPDX-License-Identifier: GPL-2.0+
  */
@@ -15,14 +17,45 @@
 #include <stdarg.h>
 
 #include <asm/arch/sys_proto.h>
+#include <asm/cache.h>
 #include <asm/omap_common.h>
 #include <asm/omap_sec_common.h>
 #include <asm/spl.h>
+#include <asm/ti-common/sys_proto.h>
+#include <mapmem.h>
 #include <spl.h>
+#include <tee/optee.h>
 
 /* Index for signature verify ROM API */
+#ifdef CONFIG_AM33XX
+#define API_HAL_KM_VERIFYCERTIFICATESIGNATURE_INDEX	(0x0000000C)
+#else
 #define API_HAL_KM_VERIFYCERTIFICATESIGNATURE_INDEX	(0x0000000E)
+#endif
 
+/* Index for signature PPA-based TI HAL APIs */
+#define PPA_HAL_SERVICES_START_INDEX        (0x200)
+#define PPA_SERV_HAL_TEE_LOAD_MASTER        (PPA_HAL_SERVICES_START_INDEX + 23)
+#define PPA_SERV_HAL_TEE_LOAD_SLAVE         (PPA_HAL_SERVICES_START_INDEX + 24)
+#define PPA_SERV_HAL_SETUP_SEC_RESVD_REGION (PPA_HAL_SERVICES_START_INDEX + 25)
+#define PPA_SERV_HAL_SETUP_EMIF_FW_REGION   (PPA_HAL_SERVICES_START_INDEX + 26)
+#define PPA_SERV_HAL_LOCK_EMIF_FW           (PPA_HAL_SERVICES_START_INDEX + 27)
+
+/* Offset of header size if image is signed as ISW */
+#define HEADER_SIZE_OFFSET	(0x6D)
+
+int tee_loaded = 0;
+
+/* Argument for PPA_SERV_HAL_TEE_LOAD_MASTER */
+struct ppa_tee_load_info {
+	u32 tee_sec_mem_start; /* Physical start address reserved for TEE */
+	u32 tee_sec_mem_size;  /* Size of the memory reserved for TEE */
+	u32 tee_cert_start;    /* Address where signed TEE binary is loaded */
+	u32 tee_cert_size;     /* Size of TEE certificate (signed binary) */
+	u32 tee_jump_addr;     /* Address to jump to start TEE execution */
+	u32 tee_arg0;          /* argument to TEE jump function, in r0 */
+};
+
 static uint32_t secure_rom_call_args[5] __aligned(ARCH_DMA_MINALIGN);
 
 u32 secure_rom_call(u32 service, u32 proc_id, u32 flag, ...)
@@ -80,8 +113,8 @@
 
 	/* Perform cache writeback on input buffer */
 	flush_dcache_range(
-		(u32)*image,
-		(u32)*image + roundup(*size, ARCH_DMA_MINALIGN));
+		rounddown((u32)*image, ARCH_DMA_MINALIGN),
+		roundup((u32)*image + *size, ARCH_DMA_MINALIGN));
 
 	cert_addr = (uint32_t)*image;
 	sig_addr = find_sig_start((char *)*image, *size);
@@ -93,6 +126,9 @@
 	}
 
 	*size = sig_addr - cert_addr;	/* Subtract out the signature size */
+	/* Subtract header if present */
+	if (strncmp((char *)sig_addr, "CERT_ISW_", 9) == 0)
+		*size -= ((u32 *)*image)[HEADER_SIZE_OFFSET];
 	cert_size = *size;
 
 	/* Check if image load address is 32-bit aligned */
@@ -116,6 +152,12 @@
 	result = secure_rom_call(
 		API_HAL_KM_VERIFYCERTIFICATESIGNATURE_INDEX, 0, 0,
 		4, cert_addr, cert_size, sig_addr, 0xFFFFFFFF);
+
+	/* Perform cache writeback on output buffer */
+	flush_dcache_range(
+		rounddown((u32)*image, ARCH_DMA_MINALIGN),
+		roundup((u32)*image + *size, ARCH_DMA_MINALIGN));
+
 auth_exit:
 	if (result != 0) {
 		printf("Authentication failed!\n");
@@ -137,3 +179,197 @@
 
 	return result;
 }
+
+u32 get_sec_mem_start(void)
+{
+	u32 sec_mem_start = CONFIG_TI_SECURE_EMIF_REGION_START;
+	u32 sec_mem_size = CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE;
+	/*
+	 * Total reserved region is all contiguous with protected
+	 * region coming first, followed by the non-secure region.
+	 * If 0x0 start address is given, we simply put the reserved
+	 * region at the end of the external DRAM.
+	 */
+	if (sec_mem_start == 0)
+		sec_mem_start =
+			(CONFIG_SYS_SDRAM_BASE + (
+#if defined(CONFIG_OMAP54XX)
+			omap_sdram_size()
+#else
+			get_ram_size((void *)CONFIG_SYS_SDRAM_BASE,
+				CONFIG_MAX_RAM_BANK_SIZE)
+#endif
+					- sec_mem_size));
+	return sec_mem_start;
+}
+
+int secure_emif_firewall_setup(uint8_t region_num, uint32_t start_addr,
+			       uint32_t size, uint32_t access_perm,
+			       uint32_t initiator_perm)
+{
+	int result = 1;
+
+	/*
+	 * Call PPA HAL API to do any other general firewall
+	 * configuration for regions 1-6 of the EMIF firewall.
+	 */
+	debug("%s: regionNum = %x, startAddr = %x, size = %x", __func__,
+	      region_num, start_addr, size);
+
+	result = secure_rom_call(
+			PPA_SERV_HAL_SETUP_EMIF_FW_REGION, 0, 0, 4,
+			(start_addr & 0xFFFFFFF0) | (region_num & 0x0F),
+			size, access_perm, initiator_perm);
+
+	if (result != 0) {
+		puts("Secure EMIF Firewall Setup failed!\n");
+		debug("Return Value = %x\n", result);
+	}
+
+	return result;
+}
+
+#if	(CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE <  \
+	CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE)
+#error	"TI Secure EMIF: Protected size cannot be larger than total size."
+#endif
+int secure_emif_reserve(void)
+{
+	int result = 1;
+	u32 sec_mem_start = get_sec_mem_start();
+	u32 sec_prot_size = CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE;
+
+	/* If there is no protected region, there is no reservation to make */
+	if (sec_prot_size == 0)
+		return 0;
+
+	/*
+	 * Call PPA HAL API to reserve a chunk of EMIF SDRAM
+	 * for secure world use. This region should be carved out
+	 * from use by any public code. EMIF firewall region 7
+	 * will be used to protect this block of memory.
+	 */
+	result = secure_rom_call(
+			PPA_SERV_HAL_SETUP_SEC_RESVD_REGION,
+			0, 0, 2, sec_mem_start, sec_prot_size);
+
+	if (result != 0) {
+		puts("SDRAM Firewall: Secure memory reservation failed!\n");
+		debug("Return Value = %x\n", result);
+	}
+
+	return result;
+}
+
+int secure_emif_firewall_lock(void)
+{
+	int result = 1;
+
+	/*
+	 * Call PPA HAL API to lock the EMIF firewall configurations.
+	 * After this API is called, none of the PPA HAL APIs for
+	 * configuring the EMIF firewalls will be usable again (that
+	 * is, calls to those APIs will return failure and have no
+	 * effect).
+	 */
+
+	result = secure_rom_call(
+			PPA_SERV_HAL_LOCK_EMIF_FW,
+			0, 0, 0);
+
+	if (result != 0) {
+		puts("Secure EMIF Firewall Lock failed!\n");
+		debug("Return Value = %x\n", result);
+	}
+
+	return result;
+}
+
+static struct ppa_tee_load_info tee_info __aligned(ARCH_DMA_MINALIGN);
+
+int secure_tee_install(u32 addr)
+{
+	struct optee_header *hdr;
+	void *loadptr;
+	u32 tee_file_size;
+	u32 sec_mem_start = get_sec_mem_start();
+	const u32 size = CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE;
+	u32 ret;
+
+	/* If there is no protected region, there is no place to put the TEE */
+	if (size == 0) {
+		printf("Error loading TEE, no protected memory region available\n");
+		return -ENOBUFS;
+	}
+
+	hdr = (struct optee_header *)map_sysmem(addr, sizeof(struct optee_header));
+	/* 280 bytes = size of signature */
+	tee_file_size = hdr->init_size + hdr->paged_size +
+			sizeof(struct optee_header) + 280;
+
+	if ((hdr->magic != OPTEE_MAGIC) ||
+	    (hdr->version != OPTEE_VERSION) ||
+	    (tee_file_size > size)) {
+		printf("Error in TEE header. Check firewall and TEE sizes\n");
+		unmap_sysmem(hdr);
+		return CMD_RET_FAILURE;
+	}
+
+	tee_info.tee_sec_mem_start = sec_mem_start;
+	tee_info.tee_sec_mem_size = size;
+	tee_info.tee_jump_addr = hdr->init_load_addr_lo;
+	tee_info.tee_cert_start = addr;
+	tee_info.tee_cert_size = tee_file_size;
+	tee_info.tee_arg0 = hdr->init_size + tee_info.tee_jump_addr;
+	unmap_sysmem(hdr);
+	loadptr = map_sysmem(addr, tee_file_size);
+
+	debug("tee_info.tee_sec_mem_start= %08X\n", tee_info.tee_sec_mem_start);
+	debug("tee_info.tee_sec_mem_size = %08X\n", tee_info.tee_sec_mem_size);
+	debug("tee_info.tee_jump_addr = %08X\n", tee_info.tee_jump_addr);
+	debug("tee_info.tee_cert_start = %08X\n", tee_info.tee_cert_start);
+	debug("tee_info.tee_cert_size = %08X\n", tee_info.tee_cert_size);
+	debug("tee_info.tee_arg0 = %08X\n", tee_info.tee_arg0);
+	debug("tee_file_size = %d\n", tee_file_size);
+
+#if !defined(CONFIG_SYS_DCACHE_OFF)
+	flush_dcache_range(
+		rounddown((u32)loadptr, ARCH_DMA_MINALIGN),
+		roundup((u32)loadptr + tee_file_size, ARCH_DMA_MINALIGN));
+
+	flush_dcache_range((u32)&tee_info, (u32)&tee_info +
+			roundup(sizeof(tee_info), ARCH_DMA_MINALIGN));
+#endif
+	unmap_sysmem(loadptr);
+
+	ret = secure_rom_call(PPA_SERV_HAL_TEE_LOAD_MASTER, 0, 0, 1, &tee_info);
+	if (ret) {
+		printf("TEE_LOAD_MASTER Failed\n");
+		return ret;
+	}
+	printf("TEE_LOAD_MASTER Done\n");
+
+#if defined(CONFIG_OMAP54XX)
+	if (!is_dra72x()) {
+		u32 *smc_cpu1_params;
+		/* Reuse the tee_info buffer for SMC params */
+		smc_cpu1_params = (u32 *)&tee_info;
+		smc_cpu1_params[0] = 0;
+#if !defined(CONFIG_SYS_DCACHE_OFF)
+		flush_dcache_range((u32)smc_cpu1_params, (u32)smc_cpu1_params +
+				roundup(sizeof(u32), ARCH_DMA_MINALIGN));
+#endif
+		ret = omap_smc_sec_cpu1(PPA_SERV_HAL_TEE_LOAD_SLAVE, 0, 0,
+				smc_cpu1_params);
+		if (ret) {
+			printf("TEE_LOAD_SLAVE Failed\n");
+			return ret;
+		}
+		printf("TEE_LOAD_SLAVE Done\n");
+	}
+#endif
+
+	tee_loaded = 1;
+
+	return 0;
+}
diff -u -N U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h
--- U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h	2019-09-12 15:54:19.000000525 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/omap_sec_common.h	1969-12-31 19:29:28.000000652 -0600
@@ -28,6 +28,12 @@
 int secure_boot_verify_image(void **p_image, size_t *p_size);
 
 /*
+ * Return the start of secure reserved RAM, if a default start address has
+ * not been configured then return a region at the end of the external DRAM.
+ */
+u32 get_sec_mem_start(void);
+
+/*
  * Invoke a secure HAL API that allows configuration of the external memory
  * firewall regions.
  */
diff -u -N /dev/null U-Boot_SDcard/include/environment/ti/qspi.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/include/environment/ti/qspi.h	1969-12-31 19:31:37.000000951 -0600
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Environment variable definitions for MMC/SD on TI boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define DEFAULT_QSPI_TI_ARGS \
+	"bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+		"source ${loadaddr}\0" \
+	"bootenvfile=uEnv.txt\0" \
+	"importbootenv_qspi=echo Importing environment from qspi flash ...; " \
+                "env import -t 0x84100000 0x132\0" \
+	"loadbootenv_qspi=sf read 0x84100000 0x1d0000 0x132;\0" \
+	"loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
+	"loadfdt=load ${devtype} ${bootpart} ${fdtaddr} ${bootdir}/${fdtfile}\0" \
+	"envboot=sf probe 0; " \
+			"echo qspi flash found on device;" \
+				"if run loadbootenv_qspi; then " \
+                                        "echo Loaded env from ${bootenvfile};" \
+                                        "run importbootenv_qspi;" \
+                                "fi;" \
+				"if test -n $uenvcmd; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+
diff -u -N U-Boot_SDcard/board/ti/beagle/beagle.c U-Boot_SDcard/board/ti/beagle/beagle.c
--- U-Boot_SDcard/board/ti/beagle/beagle.c	2019-09-12 15:54:56.000000297 -0500
+++ U-Boot_SDcard/board/ti/beagle/beagle.c	1969-12-31 19:29:27.000000180 -0600
@@ -75,7 +75,8 @@
 static const struct ns16550_platdata beagle_serial = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(beagle_uart) = {
@@ -523,7 +524,7 @@
 	MUX_BEAGLE();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/common/dfu.c U-Boot_SDcard/common/dfu.c
--- U-Boot_SDcard/common/dfu.c	2019-09-12 15:54:34.000000841 -0500
+++ U-Boot_SDcard/common/dfu.c	1969-12-31 19:29:17.000000469 -0600
@@ -88,7 +88,7 @@
 	board_usb_cleanup(usbctrl_index, USB_INIT_DEVICE);
 
 	if (dfu_reset)
-		run_command("reset", 0);
+		do_reset(NULL, 0, 0, NULL);
 
 	g_dnl_clear_detach();
 
diff -u -N U-Boot_SDcard/drivers/mmc/bfin_sdh.c U-Boot_SDcard/drivers/mmc/bfin_sdh.c
--- U-Boot_SDcard/drivers/mmc/bfin_sdh.c	2019-09-12 15:54:14.000000145 -0500
+++ U-Boot_SDcard/drivers/mmc/bfin_sdh.c	1969-12-31 19:29:21.000000180 -0600
@@ -234,7 +234,7 @@
 		bfin_write_SDH_CLK_CTL(clk_ctl & ~CLK_E);
 }
 
-static void bfin_sdh_set_ios(struct mmc *mmc)
+static int bfin_sdh_set_ios(struct mmc *mmc)
 {
 	u16 cfg = 0;
 	u16 clk_ctl = 0;
@@ -250,6 +250,8 @@
 	}
 	bfin_write_SDH_CLK_CTL(clk_ctl);
 	sdh_set_clk(mmc->clock);
+
+	return 0;
 }
 
 static int bfin_sdh_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/fs/fat/fat_write.c U-Boot_SDcard/fs/fat/fat_write.c
--- U-Boot_SDcard/fs/fat/fat_write.c	2019-09-12 15:54:28.000000658 -0500
+++ U-Boot_SDcard/fs/fat/fat_write.c	1969-12-31 19:29:21.000000814 -0600
@@ -512,7 +512,7 @@
 	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
 		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
 
-		printf("FAT: Misaligned buffer address (%p)\n", buffer);
+		debug("FAT: Misaligned buffer address (%p)\n", buffer);
 
 		while (size >= mydata->sect_size) {
 			memcpy(tmpbuf, buffer, mydata->sect_size);
diff -u -N U-Boot_SDcard/arch/arm/lib/Makefile U-Boot_SDcard/arch/arm/lib/Makefile
--- U-Boot_SDcard/arch/arm/lib/Makefile	2019-09-12 15:54:53.000000279 -0500
+++ U-Boot_SDcard/arch/arm/lib/Makefile	1969-12-31 19:29:23.000000723 -0600
@@ -1,104 +1,105 @@
-#
-# (C) Copyright 2002-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-lib-$(CONFIG_USE_PRIVATE_LIBGCC) += ashldi3.o ashrdi3.o lshrdi3.o \
-				    lib1funcs.o uldivmod.o div0.o \
-				    div64.o muldi3.o
-
-ifdef CONFIG_CPU_V7M
-obj-y	+= vectors_m.o crt0.o
-else ifdef CONFIG_ARM64
-obj-y	+= crt0_64.o
-else
-obj-y	+= vectors.o crt0.o
-endif
-
-ifndef CONFIG_SPL_BUILD
-ifdef CONFIG_ARM64
-obj-y	+= relocate_64.o
-else
-obj-y	+= relocate.o
-endif
-
-obj-$(CONFIG_CPU_V7M) += cmd_boot.o
-obj-$(CONFIG_OF_LIBFDT) += bootm-fdt.o
-obj-$(CONFIG_CMD_BOOTI) += bootm.o
-obj-$(CONFIG_CMD_BOOTM) += bootm.o
-obj-$(CONFIG_CMD_BOOTZ) += bootm.o zimage.o
-obj-$(CONFIG_SYS_L2_PL310) += cache-pl310.o
-obj-$(CONFIG_USE_ARCH_MEMSET) += memset.o
-obj-$(CONFIG_USE_ARCH_MEMCPY) += memcpy.o
-else
-obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
-obj-$(CONFIG_SPL_FRAMEWORK) += zimage.o
-endif
-obj-$(CONFIG_SEMIHOSTING) += semihosting.o
-
-obj-y	+= sections.o
-obj-y	+= stack.o
-ifdef CONFIG_CPU_V7M
-obj-y	+= interrupts_m.o
-else ifdef CONFIG_ARM64
-obj-y	+= ccn504.o
-obj-y	+= gic_64.o
-obj-y	+= interrupts_64.o
-else
-obj-y	+= interrupts.o
-endif
-ifndef CONFIG_SYSRESET
-obj-y	+= reset.o
-endif
-
-obj-y	+= cache.o
-ifndef CONFIG_ARM64
-obj-y	+= cache-cp15.o
-endif
-
-obj-y	+= psci-dt.o
-
-obj-$(CONFIG_DEBUG_LL)	+= debug.o
-
-# For EABI conformant tool chains, provide eabi_compat()
-ifneq (,$(findstring -mabi=aapcs-linux,$(PLATFORM_CPPFLAGS)))
-extra-y	+= eabi_compat.o
-endif
-
-asflags-y += -DCONFIG_ARM_ASM_UNIFIED
-
-# some files can only build in ARM or THUMB2, not THUMB1
-
-ifdef CONFIG_SYS_THUMB_BUILD
-asflags-$(CONFIG_HAS_THUMB2) += -DCONFIG_THUMB2_KERNEL
-ifndef CONFIG_HAS_THUMB2
-
-# for C files, just apend -marm, which will override previous -mthumb*
-
-CFLAGS_cache.o := -marm
-CFLAGS_cache-cp15.o := -marm
-
-# For .S, drop -mthumb* and other thumb-related options.
-# CFLAGS_REMOVE_* would not have an effet, so AFLAGS_REMOVE_*
-# was implemented and is used here.
-# Also, define ${target}_NO_THUMB_BUILD for these two targets
-# so that the code knows it should not use Thumb.
-
-AFLAGS_REMOVE_memset.o := -mthumb -mthumb-interwork
-AFLAGS_REMOVE_memcpy.o := -mthumb -mthumb-interwork
-AFLAGS_memset.o := -DMEMSET_NO_THUMB_BUILD
-AFLAGS_memcpy.o := -DMEMCPY_NO_THUMB_BUILD
-endif
-endif
-
-# For building EFI apps
-CFLAGS_$(EFI_CRT0) := $(CFLAGS_EFI)
-CFLAGS_REMOVE_$(EFI_CRT0) := $(CFLAGS_NON_EFI)
-
-CFLAGS_$(EFI_RELOC) := $(CFLAGS_EFI)
-CFLAGS_REMOVE_$(EFI_RELOC) := $(CFLAGS_NON_EFI)
-
-extra-$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE) += $(EFI_CRT0) $(EFI_RELOC)
-extra-$(CONFIG_EFI) += $(EFI_CRT0) $(EFI_RELOC)
+#
+# (C) Copyright 2002-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+lib-$(CONFIG_USE_PRIVATE_LIBGCC) += ashldi3.o ashrdi3.o lshrdi3.o \
+				    lib1funcs.o uldivmod.o div0.o \
+				    div64.o muldi3.o
+
+ifdef CONFIG_CPU_V7M
+obj-y	+= vectors_m.o crt0.o
+else ifdef CONFIG_ARM64
+obj-y	+= crt0_64.o
+else
+obj-y	+= vectors.o crt0.o
+endif
+
+ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_ARM64
+obj-y	+= relocate_64.o
+else
+obj-y	+= relocate.o
+endif
+
+obj-$(CONFIG_CPU_V7M) += cmd_boot.o
+obj-$(CONFIG_OF_LIBFDT) += bootm-fdt.o
+obj-$(CONFIG_CMD_BOOTI) += bootm.o
+obj-$(CONFIG_CMD_BOOTM) += bootm.o
+obj-$(CONFIG_CMD_BOOTZ) += bootm.o zimage.o
+obj-$(CONFIG_SYS_L2_PL310) += cache-pl310.o
+obj-$(CONFIG_USE_ARCH_MEMSET) += memset.o
+obj-$(CONFIG_USE_ARCH_MEMCPY) += memcpy.o
+else
+obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
+obj-$(CONFIG_SPL_FRAMEWORK) += zimage.o
+obj-$(CONFIG_OF_LIBFDT) += bootm-fdt.o
+endif
+obj-$(CONFIG_SEMIHOSTING) += semihosting.o
+
+obj-y	+= sections.o
+obj-y	+= stack.o
+ifdef CONFIG_CPU_V7M
+obj-y	+= interrupts_m.o
+else ifdef CONFIG_ARM64
+obj-y	+= ccn504.o
+obj-y	+= gic_64.o
+obj-y	+= interrupts_64.o
+else
+obj-y	+= interrupts.o
+endif
+ifndef CONFIG_SYSRESET
+obj-y	+= reset.o
+endif
+
+obj-y	+= cache.o
+ifndef CONFIG_ARM64
+obj-y	+= cache-cp15.o
+endif
+
+obj-y	+= psci-dt.o
+
+obj-$(CONFIG_DEBUG_LL)	+= debug.o
+
+# For EABI conformant tool chains, provide eabi_compat()
+ifneq (,$(findstring -mabi=aapcs-linux,$(PLATFORM_CPPFLAGS)))
+extra-y	+= eabi_compat.o
+endif
+
+asflags-y += -DCONFIG_ARM_ASM_UNIFIED
+
+# some files can only build in ARM or THUMB2, not THUMB1
+
+ifdef CONFIG_SYS_THUMB_BUILD
+asflags-$(CONFIG_HAS_THUMB2) += -DCONFIG_THUMB2_KERNEL
+ifndef CONFIG_HAS_THUMB2
+
+# for C files, just apend -marm, which will override previous -mthumb*
+
+CFLAGS_cache.o := -marm
+CFLAGS_cache-cp15.o := -marm
+
+# For .S, drop -mthumb* and other thumb-related options.
+# CFLAGS_REMOVE_* would not have an effet, so AFLAGS_REMOVE_*
+# was implemented and is used here.
+# Also, define ${target}_NO_THUMB_BUILD for these two targets
+# so that the code knows it should not use Thumb.
+
+AFLAGS_REMOVE_memset.o := -mthumb -mthumb-interwork
+AFLAGS_REMOVE_memcpy.o := -mthumb -mthumb-interwork
+AFLAGS_memset.o := -DMEMSET_NO_THUMB_BUILD
+AFLAGS_memcpy.o := -DMEMCPY_NO_THUMB_BUILD
+endif
+endif
+
+# For building EFI apps
+CFLAGS_$(EFI_CRT0) := $(CFLAGS_EFI)
+CFLAGS_REMOVE_$(EFI_CRT0) := $(CFLAGS_NON_EFI)
+
+CFLAGS_$(EFI_RELOC) := $(CFLAGS_EFI)
+CFLAGS_REMOVE_$(EFI_RELOC) := $(CFLAGS_NON_EFI)
+
+extra-$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE) += $(EFI_CRT0) $(EFI_RELOC)
+extra-$(CONFIG_EFI) += $(EFI_CRT0) $(EFI_RELOC)
diff -u -N U-Boot_SDcard/include/configs/ti_armv7_keystone2.h U-Boot_SDcard/include/configs/ti_armv7_keystone2.h
--- U-Boot_SDcard/include/configs/ti_armv7_keystone2.h	2019-09-12 15:54:41.000000231 -0500
+++ U-Boot_SDcard/include/configs/ti_armv7_keystone2.h	1969-12-31 19:29:22.000000528 -0600
@@ -56,6 +56,13 @@
 #define CONFIG_SPL_SPI_LOAD
 #define CONFIG_SYS_SPI_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
 
+/* SRAM scratch space entries  */
+#define SRAM_SCRATCH_SPACE_ADDR	CONFIG_SPL_STACK + 0x8
+
+#define TI_SRAM_SCRATCH_BOARD_EEPROM_START	(SRAM_SCRATCH_SPACE_ADDR)
+#define TI_SRAM_SCRATCH_BOARD_EEPROM_END	(SRAM_SCRATCH_SPACE_ADDR + 0x200)
+#define KEYSTONE_SRAM_SCRATCH_SPACE_END		(TI_SRAM_SCRATCH_BOARD_EEPROM_END)
+
 /* UART Configuration */
 #define CONFIG_SYS_NS16550_MEM32
 #if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_DM_SERIAL)
@@ -166,16 +173,7 @@
 #define CONFIG_ENV_EEPROM_IS_ON_I2C
 
 /* NAND Configuration */
-#define CONFIG_NAND_DAVINCI
-#define CONFIG_KEYSTONE_RBL_NAND
-#define CONFIG_KEYSTONE_NAND_MAX_RBL_SIZE	CONFIG_ENV_OFFSET
-#define CONFIG_SYS_NAND_MASK_CLE		0x4000
-#define CONFIG_SYS_NAND_MASK_ALE		0x2000
-#define CONFIG_SYS_NAND_CS			2
 #define CONFIG_SYS_NAND_USE_FLASH_BBT
-#define CONFIG_SYS_NAND_4BIT_HW_ECC_OOBFIRST
-
-#define CONFIG_SYS_NAND_LARGEPAGE
 #define CONFIG_SYS_NAND_BASE_LIST		{ 0x30000000, }
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_MAX_CHIPS		1
@@ -250,7 +248,11 @@
 	"addr_secdb_key=0xc000000\0"					\
 	"name_kern=zImage\0"						\
 	"addr_mon=0x87000000\0"						\
+	"addr_non_sec_mon=0x0c087fc0\0"					\
+	"addr_load_sec_bm=0x0c08c000\0"					\
 	"run_mon=mon_install ${addr_mon}\0"				\
+	"run_mon_hs=mon_install ${addr_non_sec_mon} "			\
+			"${addr_load_sec_bm}\0"				\
 	"run_kern=bootz ${loadaddr} ${rd_spec} ${fdtaddr}\0"		\
 	"init_net=run args_all args_net\0"				\
 	"init_nfs=setenv autoload no; dhcp; run args_all args_net\0"	\
@@ -264,10 +266,16 @@
 	"get_kern_ubi=ubifsload ${loadaddr} ${bootdir}/${name_kern}\0"		\
 	"get_mon_net=dhcp ${addr_mon} ${tftp_root}/${name_mon}\0"	\
 	"get_mon_nfs=nfs ${addr_mon} ${nfs_root}/boot/${name_mon}\0"	\
-	"get_mon_ubi=ubifsload ${addr_mon} ${bootdir}/${name_mon}\0"		\
+	"get_mon_ubi=ubifsload ${addr_mon} ${bootdir}/${name_mon}\0"	\
+	"get_fit_net=dhcp ${fit_loadaddr} ${tftp_root}"			\
+						"/${fit_bootfile}\0"	\
+	"get_fit_nfs=nfs ${fit_loadaddr} ${nfs_root}/boot/${fit_bootfile}\0"\
+	"get_fit_ubi=ubifsload ${fit_loadaddr} ${bootdir}/${fit_bootfile}\0"\
+	"get_fit_mmc=load mmc ${bootpart} ${fit_loadaddr} "		\
+					"${bootdir}/${fit_bootfile}\0"	\
 	"get_uboot_net=dhcp ${loadaddr} ${tftp_root}/${name_uboot}\0"	\
 	"get_uboot_nfs=nfs ${loadaddr} ${nfs_root}/boot/${name_uboot}\0" \
-	"burn_uboot_spi=sf probe; sf erase 0 0x80000; "		\
+	"burn_uboot_spi=sf probe; sf erase 0 0x90000; "		\
 		"sf write ${loadaddr} 0 ${filesize}\0"		\
 	"burn_uboot_nand=nand erase 0 0x100000; "			\
 		"nand write ${loadaddr} 0 ${filesize}\0"		\
@@ -279,6 +287,8 @@
 	"get_fdt_ramfs=dhcp ${fdtaddr} ${tftp_root}/${name_fdt}\0"	\
 	"get_kern_ramfs=dhcp ${loadaddr} ${tftp_root}/${name_kern}\0"	\
 	"get_mon_ramfs=dhcp ${addr_mon} ${tftp_root}/${name_mon}\0"	\
+	"get_fit_ramfs=dhcp ${fit_loadaddr} ${tftp_root}"		\
+						"/${fit_bootfile}\0"	\
 	"get_fs_ramfs=dhcp ${rdaddr} ${tftp_root}/${name_fs}\0"	\
 	"get_ubi_net=dhcp ${addr_ubi} ${tftp_root}/${name_ubi}\0"	\
 	"get_ubi_nfs=nfs ${addr_ubi} ${nfs_root}/boot/${name_ubi}\0"	\
@@ -293,9 +303,21 @@
 		"1024k(bootloader)ro,512k(params)ro,-(ubifs)\0"
 
 #ifndef CONFIG_BOOTCOMMAND
+#ifndef CONFIG_TI_SECURE_DEVICE
 #define CONFIG_BOOTCOMMAND						\
-	"run init_${boot} get_mon_${boot} run_mon init_fw_rd_${boot} "	\
-	"get_fdt_${boot} get_kern_${boot} run_kern"
+	"run init_${boot}; "						\
+	"run get_mon_${boot} run_mon; "					\
+	"run get_kern_${boot}; "					\
+	"run init_fw_rd_${boot}; "					\
+	"run get_fdt_${boot}; "						\
+	"run run_kern"
+#else
+#define CONFIG_BOOTCOMMAND						\
+	"run run_mon_hs; "						\
+	"run init_${boot}; "						\
+	"run get_fit_${boot}; "						\
+	"bootm ${fit_loadaddr}#${name_fdt}"
+#endif
 #endif
 
 #define CONFIG_BOOTARGS							\
@@ -316,7 +338,7 @@
 #ifndef CONFIG_SOC_K2G
 #define CONFIG_SYS_HZ_CLOCK		ks_clk_get_rate(KS2_CLK1_6)
 #else
-#define CONFIG_SYS_HZ_CLOCK		external_clk[sys_clk]
+#define CONFIG_SYS_HZ_CLOCK		get_external_clk(sys_clk)
 #endif
 
 #endif /* __CONFIG_KS2_EVM_H */
diff -u -N U-Boot_SDcard/board/technexion/tao3530/tao3530.c U-Boot_SDcard/board/technexion/tao3530/tao3530.c
--- U-Boot_SDcard/board/technexion/tao3530/tao3530.c	2019-09-12 15:54:49.000000694 -0500
+++ U-Boot_SDcard/board/technexion/tao3530/tao3530.c	1969-12-31 19:29:27.000000119 -0600
@@ -179,7 +179,7 @@
 #endif
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/include/configs/am335x_sl50.h U-Boot_SDcard/include/configs/am335x_sl50.h
--- U-Boot_SDcard/include/configs/am335x_sl50.h	2019-09-12 15:54:57.000000832 -0500
+++ U-Boot_SDcard/include/configs/am335x_sl50.h	1969-12-31 19:29:22.000000036 -0600
@@ -86,7 +86,7 @@
 #define CONFIG_BOOTCOUNT_AM33XX
 #define CONFIG_SYS_BOOTCOUNT_BE
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #ifndef CONFIG_SPL_USBETH_SUPPORT
 #define CONFIG_FASTBOOT_FLASH_MMC_DEV   1
diff -u -N U-Boot_SDcard/common/env_fat.c U-Boot_SDcard/common/env_fat.c
--- U-Boot_SDcard/common/env_fat.c	2019-09-12 15:54:27.000000344 -0500
+++ U-Boot_SDcard/common/env_fat.c	1969-12-31 19:29:17.000000481 -0600
@@ -31,6 +31,10 @@
 	gd->env_addr = (ulong)&default_environment[0];
 	gd->env_valid = 1;
 
+	/* intialize the MMC sub-system if env is stored on a MMC*/
+	if (!strcmp(FAT_ENV_INTERFACE, "mmc"))
+		mmc_initialize(NULL);
+
 	return 0;
 }
 
diff -u -N U-Boot_SDcard/arch/arm/dts/Makefile U-Boot_SDcard/arch/arm/dts/Makefile
--- U-Boot_SDcard/arch/arm/dts/Makefile	2019-09-12 15:55:00.000000350 -0500
+++ U-Boot_SDcard/arch/arm/dts/Makefile	1969-12-31 19:29:23.000000203 -0600
@@ -1,334 +1,337 @@
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-dtb-$(CONFIG_AT91FAMILY) += at91sam9260-smartweb.dtb \
-	at91sam9g20-taurus.dtb \
-	at91sam9g45-corvus.dtb \
-	at91sam9g45-gurnard.dtb
-
-dtb-$(CONFIG_S5PC100) += s5pc1xx-smdkc100.dtb
-dtb-$(CONFIG_S5PC110) += s5pc1xx-goni.dtb
-dtb-$(CONFIG_EXYNOS4) += exynos4210-origen.dtb \
-	exynos4210-smdkv310.dtb \
-	exynos4210-universal_c210.dtb \
-	exynos4210-trats.dtb \
-	exynos4412-trats2.dtb \
-	exynos4412-odroid.dtb
-
-dtb-$(CONFIG_TARGET_HIKEY) += hi6220-hikey.dtb
-
-dtb-$(CONFIG_EXYNOS5) += exynos5250-arndale.dtb \
-	exynos5250-snow.dtb \
-	exynos5250-spring.dtb \
-	exynos5250-smdk5250.dtb \
-	exynos5420-smdk5420.dtb \
-	exynos5420-peach-pit.dtb \
-	exynos5800-peach-pi.dtb \
-	exynos5422-odroidxu3.dtb
-dtb-$(CONFIG_EXYNOS7420) += exynos7420-espresso7420.dtb
-dtb-$(CONFIG_ARCH_ROCKCHIP) += \
-	rk3036-sdk.dtb \
-	rk3288-firefly.dtb \
-	rk3288-veyron-jerry.dtb \
-	rk3288-veyron-mickey.dtb \
-	rk3288-veyron-minnie.dtb \
-	rk3288-rock2-square.dtb \
-	rk3288-evb.dtb \
-	rk3288-fennec.dtb \
-	rk3288-miniarm.dtb \
-	rk3288-popmetal.dtb \
-	rk3399-evb.dtb
-dtb-$(CONFIG_ARCH_MESON) += \
-	meson-gxbb-odroidc2.dtb
-dtb-$(CONFIG_TEGRA) += tegra20-harmony.dtb \
-	tegra20-medcom-wide.dtb \
-	tegra20-paz00.dtb \
-	tegra20-plutux.dtb \
-	tegra20-seaboard.dtb \
-	tegra20-tec.dtb \
-	tegra20-trimslice.dtb \
-	tegra20-ventana.dtb \
-	tegra20-whistler.dtb \
-	tegra20-colibri.dtb \
-	tegra30-apalis.dtb \
-	tegra30-beaver.dtb \
-	tegra30-cardhu.dtb \
-	tegra30-colibri.dtb \
-	tegra30-tec-ng.dtb \
-	tegra114-dalmore.dtb \
-	tegra124-jetson-tk1.dtb \
-	tegra124-nyan-big.dtb \
-	tegra124-cei-tk1-som.dtb \
-	tegra124-venice2.dtb \
-	tegra186-p2771-0000-000.dtb \
-	tegra186-p2771-0000-500.dtb \
-	tegra210-e2220-1170.dtb \
-	tegra210-p2371-0000.dtb \
-	tegra210-p2371-2180.dtb \
-	tegra210-p2571.dtb
-
-dtb-$(CONFIG_ARCH_MVEBU) +=			\
-	armada-3720-db.dtb			\
-	armada-375-db.dtb			\
-	armada-388-clearfog.dtb			\
-	armada-388-gp.dtb			\
-	armada-385-amc.dtb			\
-	armada-7040-db.dtb			\
-	armada-8040-db.dtb			\
-	armada-xp-gp.dtb			\
-	armada-xp-maxbcm.dtb			\
-	armada-xp-synology-ds414.dtb		\
-	armada-xp-theadorable.dtb
-
-dtb-$(CONFIG_ARCH_UNIPHIER) += \
-	uniphier-ld11-ref.dtb \
-	uniphier-ld20-ref.dtb \
-	uniphier-ld4-ref.dtb \
-	uniphier-ld6b-ref.dtb \
-	uniphier-pro4-ace.dtb \
-	uniphier-pro4-ref.dtb \
-	uniphier-pro4-sanji.dtb \
-	uniphier-pro5-4kbox.dtb \
-	uniphier-pxs2-gentil.dtb \
-	uniphier-pxs2-vodka.dtb \
-	uniphier-sld3-ref.dtb \
-	uniphier-sld8-ref.dtb
-dtb-$(CONFIG_ARCH_ZYNQ) += zynq-zc702.dtb \
-	zynq-zc706.dtb \
-	zynq-zed.dtb \
-	zynq-zybo.dtb \
-	zynq-microzed.dtb \
-	zynq-picozed.dtb \
-	zynq-topic-miami.dtb \
-	zynq-topic-miamiplus.dtb \
-	zynq-zc770-xm010.dtb \
-	zynq-zc770-xm011.dtb \
-	zynq-zc770-xm012.dtb \
-	zynq-zc770-xm013.dtb
-dtb-$(CONFIG_ARCH_ZYNQMP) += \
-	zynqmp-ep108.dtb			\
-	zynqmp-zcu102.dtb			\
-	zynqmp-zcu102-revB.dtb			\
-	zynqmp-zc1751-xm015-dc1.dtb		\
-	zynqmp-zc1751-xm016-dc2.dtb		\
-	zynqmp-zc1751-xm018-dc4.dtb		\
-	zynqmp-zc1751-xm019-dc5.dtb
-dtb-$(CONFIG_AM33XX) += am335x-boneblack.dtb am335x-bone.dtb \
-	am335x-draco.dtb \
-	am335x-evm.dtb \
-	am335x-evmsk.dtb \
-	am335x-bonegreen.dtb \
-	am335x-icev2.dtb \
-	am335x-pxm50.dtb \
-	am335x-rut.dtb
-dtb-$(CONFIG_AM43XX) += am437x-gp-evm.dtb am437x-sk-evm.dtb	\
-	am43x-epos-evm.dtb \
-	am437x-idk-evm.dtb
-dtb-$(CONFIG_THUNDERX) += thunderx-88xx.dtb
-
-dtb-$(CONFIG_ARCH_SOCFPGA) +=				\
-	socfpga_arria5_socdk.dtb			\
-	socfpga_cyclone5_is1.dtb			\
-	socfpga_cyclone5_mcvevk.dtb			\
-	socfpga_cyclone5_socdk.dtb			\
-	socfpga_cyclone5_de0_nano_soc.dtb			\
-	socfpga_cyclone5_de1_soc.dtb			\
-	socfpga_cyclone5_sockit.dtb			\
-	socfpga_cyclone5_socrates.dtb			\
-	socfpga_cyclone5_sr1500.dtb			\
-	socfpga_cyclone5_vining_fpga.dtb
-
-dtb-$(CONFIG_TARGET_DRA7XX_EVM) += dra72-evm.dtb dra7-evm.dtb	\
-	dra72-evm-revc.dtb dra71-evm.dtb
-dtb-$(CONFIG_TARGET_AM57XX_EVM) += am57xx-beagle-x15.dtb \
-	am57xx-beagle-x15-revb1.dtb \
-	am572x-idk.dtb	\
-	am571x-idk.dtb
-dtb-$(CONFIG_TARGET_STV0991) += stv0991.dtb
-
-dtb-$(CONFIG_LS102XA) += ls1021a-qds-duart.dtb \
-	ls1021a-qds-lpuart.dtb \
-	ls1021a-twr-duart.dtb ls1021a-twr-lpuart.dtb \
-	ls1021a-iot-duart.dtb
-dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2080a-qds.dtb \
-	fsl-ls2080a-rdb.dtb
-dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-duart.dtb \
-	fsl-ls1043a-qds-lpuart.dtb \
-	fsl-ls1043a-rdb.dtb \
-	fsl-ls1046a-qds-duart.dtb \
-	fsl-ls1046a-qds-lpuart.dtb \
-	fsl-ls1046a-rdb.dtb \
-	fsl-ls1012a-qds.dtb \
-	fsl-ls1012a-rdb.dtb \
-	fsl-ls1012a-frdm.dtb
-
-dtb-$(CONFIG_ARCH_SNAPDRAGON) += dragonboard410c.dtb
-
-dtb-$(CONFIG_MACH_SUN4I) += \
-	sun4i-a10-a1000.dtb \
-	sun4i-a10-ba10-tvbox.dtb \
-	sun4i-a10-chuwi-v7-cw0825.dtb \
-	sun4i-a10-cubieboard.dtb \
-	sun4i-a10-dserve-dsrv9703c.dtb \
-	sun4i-a10-gemei-g9.dtb \
-	sun4i-a10-hackberry.dtb \
-	sun4i-a10-hyundai-a7hd.dtb \
-	sun4i-a10-inet1.dtb \
-	sun4i-a10-inet-3f.dtb \
-	sun4i-a10-inet-3w.dtb \
-	sun4i-a10-inet97fv2.dtb \
-	sun4i-a10-inet9f-rev03.dtb \
-	sun4i-a10-itead-iteaduino-plus.dtb \
-	sun4i-a10-jesurun-q5.dtb \
-	sun4i-a10-marsboard.dtb \
-	sun4i-a10-mini-xplus.dtb \
-	sun4i-a10-mk802.dtb \
-	sun4i-a10-mk802ii.dtb \
-	sun4i-a10-olinuxino-lime.dtb \
-	sun4i-a10-pcduino.dtb \
-	sun4i-a10-pcduino2.dtb \
-	sun4i-a10-pov-protab2-ips9.dtb
-dtb-$(CONFIG_MACH_SUN5I) += \
-	sun5i-a10s-auxtek-t003.dtb \
-	sun5i-a10s-auxtek-t004.dtb \
-	sun5i-a10s-mk802.dtb \
-	sun5i-a10s-olinuxino-micro.dtb \
-	sun5i-a10s-r7-tv-dongle.dtb \
-	sun5i-a10s-wobo-i5.dtb \
-	sun5i-a13-ampe-a76.dtb \
-	sun5i-a13-difrnce-dit4350.dtb \
-	sun5i-a13-empire-electronix-d709.dtb \
-	sun5i-a13-empire-electronix-m712.dtb \
-	sun5i-a13-hsg-h702.dtb \
-	sun5i-a13-inet-86vs.dtb \
-	sun5i-a13-inet-98v-rev2.dtb \
-	sun5i-a13-olinuxino.dtb \
-	sun5i-a13-olinuxino-micro.dtb \
-	sun5i-a13-q8-tablet.dtb \
-	sun5i-a13-utoo-p66.dtb \
-	sun5i-r8-chip.dtb
-dtb-$(CONFIG_MACH_SUN6I) += \
-	sun6i-a31-app4-evb1.dtb \
-	sun6i-a31-colombus.dtb \
-	sun6i-a31-hummingbird.dtb \
-	sun6i-a31-i7.dtb \
-	sun6i-a31-m9.dtb \
-	sun6i-a31-mele-a1000g-quad.dtb \
-	sun6i-a31-mixtile-loftq.dtb \
-	sun6i-a31s-colorfly-e708-q1.dtb \
-	sun6i-a31s-cs908.dtb \
-	sun6i-a31s-inet-q972.dtb \
-	sun6i-a31s-primo81.dtb \
-	sun6i-a31s-sina31s.dtb \
-	sun6i-a31s-sinovoip-bpi-m2.dtb \
-	sun6i-a31s-yones-toptech-bs1078-v2.dtb
-dtb-$(CONFIG_MACH_SUN7I) += \
-	sun7i-a20-ainol-aw1.dtb \
-	sun7i-a20-bananapi.dtb \
-	sun7i-a20-bananapi-m1-plus.dtb \
-	sun7i-a20-bananapro.dtb \
-	sun7i-a20-cubieboard2.dtb \
-	sun7i-a20-cubietruck.dtb \
-	sun7i-a20-hummingbird.dtb \
-	sun7i-a20-i12-tvbox.dtb \
-	sun7i-a20-icnova-swac.dtb \
-	sun7i-a20-itead-ibox.dtb \
-	sun7i-a20-lamobo-r1.dtb \
-	sun7i-a20-m3.dtb \
-	sun7i-a20-m5.dtb \
-	sun7i-a20-mk808c.dtb \
-	sun7i-a20-olimex-som-evb.dtb \
-	sun7i-a20-olinuxino-lime.dtb \
-	sun7i-a20-olinuxino-lime2.dtb \
-	sun7i-a20-olinuxino-lime2-emmc.dtb \
-	sun7i-a20-olinuxino-micro.dtb \
-	sun7i-a20-orangepi.dtb \
-	sun7i-a20-orangepi-mini.dtb \
-	sun7i-a20-pcduino3.dtb \
-	sun7i-a20-pcduino3-nano.dtb \
-	sun7i-a20-primo73.dtb \
-	sun7i-a20-wexler-tab7200.dtb \
-	sun7i-a20-wits-pro-a20-dkt.dtb \
-	sun7i-a20-yones-toptech-bd1078.dtb
-dtb-$(CONFIG_MACH_SUN8I_A23) += \
-	sun8i-a23-evb.dtb \
-	sun8i-a23-gt90h-v4.dtb \
-	sun8i-a23-inet86dz.dtb \
-	sun8i-a23-polaroid-mid2407pxe03.dtb \
-	sun8i-a23-polaroid-mid2809pxe04.dtb \
-	sun8i-a23-q8-tablet.dtb
-dtb-$(CONFIG_MACH_SUN8I_A33) += \
-	sun8i-a33-ga10h-v1.1.dtb \
-	sun8i-a33-inet-d978-rev2.dtb \
-	sun8i-a33-olinuxino.dtb \
-	sun8i-a33-q8-tablet.dtb \
-	sun8i-a33-sinlinx-sina33.dtb \
-	sun8i-r16-nintendo-nes-classic-edition.dtb \
-	sun8i-r16-parrot.dtb
-dtb-$(CONFIG_MACH_SUN8I_A83T) += \
-	sun8i-a83t-allwinner-h8homlet-v2.dtb \
-	sun8i-a83t-cubietruck-plus.dtb \
-	sun8i-a83t-sinovoip-bpi-m3.dtb
-dtb-$(CONFIG_MACH_SUN8I_H3) += \
-	sun8i-h3-bananapi-m2-plus.dtb \
-	sun8i-h3-orangepi-2.dtb \
-	sun8i-h3-orangepi-lite.dtb \
-	sun8i-h3-orangepi-one.dtb \
-	sun8i-h3-orangepi-pc.dtb \
-	sun8i-h3-orangepi-pc-plus.dtb \
-	sun8i-h3-orangepi-plus.dtb \
-	sun8i-h3-orangepi-plus2e.dtb \
-	sun8i-h3-nanopi-neo.dtb
-dtb-$(CONFIG_MACH_SUN50I) += \
-	sun50i-a64-pine64-plus.dtb \
-	sun50i-a64-pine64.dtb
-dtb-$(CONFIG_MACH_SUN9I) += \
-	sun9i-a80-optimus.dtb \
-	sun9i-a80-cubieboard4.dtb
-
-dtb-$(CONFIG_VF610) += vf500-colibri.dtb \
-	vf610-colibri.dtb \
-	vf610-twr.dtb \
-	pcm052.dtb \
-	bk4r1.dtb
-
-dtb-$(CONFIG_MX53) += imx53-cx9020.dtb
-
-dtb-$(CONFIG_MX6) += imx6ull-14x14-evk.dtb \
-	imx6sll-evk.dtb \
-	imx6dl-icore.dtb \
-	imx6dl-icore-rqs.dtb \
-	imx6q-icore.dtb \
-	imx6q-icore-rqs.dtb \
-	imx6ul-geam-kit.dtb
-
-dtb-$(CONFIG_MX7) += imx7-colibri.dtb
-
-dtb-$(CONFIG_SOC_KEYSTONE) += k2hk-evm.dtb \
-	k2l-evm.dtb \
-	k2e-evm.dtb \
-	k2g-evm.dtb
-
-dtb-$(CONFIG_TARGET_SAMA5D2_XPLAINED) += \
-	at91-sama5d2_xplained.dtb
-
-dtb-$(CONFIG_ARCH_BCM283X) += \
-	bcm2835-rpi-a-plus.dtb \
-	bcm2835-rpi-a.dtb \
-	bcm2835-rpi-b-plus.dtb \
-	bcm2835-rpi-b-rev2.dtb \
-	bcm2835-rpi-b.dtb \
-	bcm2836-rpi-2-b.dtb \
-	bcm2837-rpi-3-b.dtb
-
-targets += $(dtb-y)
-
-# Add any required device tree compiler flags here
-DTC_FLAGS +=
-
-PHONY += dtbs
-dtbs: $(addprefix $(obj)/, $(dtb-y))
-	@:
-
-clean-files := *.dtb
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+dtb-$(CONFIG_AT91FAMILY) += at91sam9260-smartweb.dtb \
+	at91sam9g20-taurus.dtb \
+	at91sam9g45-corvus.dtb \
+	at91sam9g45-gurnard.dtb
+
+dtb-$(CONFIG_S5PC100) += s5pc1xx-smdkc100.dtb
+dtb-$(CONFIG_S5PC110) += s5pc1xx-goni.dtb
+dtb-$(CONFIG_EXYNOS4) += exynos4210-origen.dtb \
+	exynos4210-smdkv310.dtb \
+	exynos4210-universal_c210.dtb \
+	exynos4210-trats.dtb \
+	exynos4412-trats2.dtb \
+	exynos4412-odroid.dtb
+
+dtb-$(CONFIG_TARGET_HIKEY) += hi6220-hikey.dtb
+
+dtb-$(CONFIG_EXYNOS5) += exynos5250-arndale.dtb \
+	exynos5250-snow.dtb \
+	exynos5250-spring.dtb \
+	exynos5250-smdk5250.dtb \
+	exynos5420-smdk5420.dtb \
+	exynos5420-peach-pit.dtb \
+	exynos5800-peach-pi.dtb \
+	exynos5422-odroidxu3.dtb
+dtb-$(CONFIG_EXYNOS7420) += exynos7420-espresso7420.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += \
+	rk3036-sdk.dtb \
+	rk3288-firefly.dtb \
+	rk3288-veyron-jerry.dtb \
+	rk3288-veyron-mickey.dtb \
+	rk3288-veyron-minnie.dtb \
+	rk3288-rock2-square.dtb \
+	rk3288-evb.dtb \
+	rk3288-fennec.dtb \
+	rk3288-miniarm.dtb \
+	rk3288-popmetal.dtb \
+	rk3399-evb.dtb
+dtb-$(CONFIG_ARCH_MESON) += \
+	meson-gxbb-odroidc2.dtb
+dtb-$(CONFIG_TEGRA) += tegra20-harmony.dtb \
+	tegra20-medcom-wide.dtb \
+	tegra20-paz00.dtb \
+	tegra20-plutux.dtb \
+	tegra20-seaboard.dtb \
+	tegra20-tec.dtb \
+	tegra20-trimslice.dtb \
+	tegra20-ventana.dtb \
+	tegra20-whistler.dtb \
+	tegra20-colibri.dtb \
+	tegra30-apalis.dtb \
+	tegra30-beaver.dtb \
+	tegra30-cardhu.dtb \
+	tegra30-colibri.dtb \
+	tegra30-tec-ng.dtb \
+	tegra114-dalmore.dtb \
+	tegra124-jetson-tk1.dtb \
+	tegra124-nyan-big.dtb \
+	tegra124-cei-tk1-som.dtb \
+	tegra124-venice2.dtb \
+	tegra186-p2771-0000-000.dtb \
+	tegra186-p2771-0000-500.dtb \
+	tegra210-e2220-1170.dtb \
+	tegra210-p2371-0000.dtb \
+	tegra210-p2371-2180.dtb \
+	tegra210-p2571.dtb
+
+dtb-$(CONFIG_ARCH_MVEBU) +=			\
+	armada-3720-db.dtb			\
+	armada-375-db.dtb			\
+	armada-388-clearfog.dtb			\
+	armada-388-gp.dtb			\
+	armada-385-amc.dtb			\
+	armada-7040-db.dtb			\
+	armada-8040-db.dtb			\
+	armada-xp-gp.dtb			\
+	armada-xp-maxbcm.dtb			\
+	armada-xp-synology-ds414.dtb		\
+	armada-xp-theadorable.dtb
+
+dtb-$(CONFIG_ARCH_UNIPHIER) += \
+	uniphier-ld11-ref.dtb \
+	uniphier-ld20-ref.dtb \
+	uniphier-ld4-ref.dtb \
+	uniphier-ld6b-ref.dtb \
+	uniphier-pro4-ace.dtb \
+	uniphier-pro4-ref.dtb \
+	uniphier-pro4-sanji.dtb \
+	uniphier-pro5-4kbox.dtb \
+	uniphier-pxs2-gentil.dtb \
+	uniphier-pxs2-vodka.dtb \
+	uniphier-sld3-ref.dtb \
+	uniphier-sld8-ref.dtb
+dtb-$(CONFIG_ARCH_ZYNQ) += zynq-zc702.dtb \
+	zynq-zc706.dtb \
+	zynq-zed.dtb \
+	zynq-zybo.dtb \
+	zynq-microzed.dtb \
+	zynq-picozed.dtb \
+	zynq-topic-miami.dtb \
+	zynq-topic-miamiplus.dtb \
+	zynq-zc770-xm010.dtb \
+	zynq-zc770-xm011.dtb \
+	zynq-zc770-xm012.dtb \
+	zynq-zc770-xm013.dtb
+dtb-$(CONFIG_ARCH_ZYNQMP) += \
+	zynqmp-ep108.dtb			\
+	zynqmp-zcu102.dtb			\
+	zynqmp-zcu102-revB.dtb			\
+	zynqmp-zc1751-xm015-dc1.dtb		\
+	zynqmp-zc1751-xm016-dc2.dtb		\
+	zynqmp-zc1751-xm018-dc4.dtb		\
+	zynqmp-zc1751-xm019-dc5.dtb
+dtb-$(CONFIG_AM33XX) += am335x-boneblack.dtb am335x-bone.dtb \
+	am335x-draco.dtb \
+	am335x-evm.dtb \
+	am335x-evmsk.dtb \
+	am335x-bonegreen.dtb \
+	am335x-icev2.dtb \
+	am335x-pxm50.dtb \
+	am335x-rut.dtb
+dtb-$(CONFIG_AM43XX) += am437x-gp-evm.dtb am437x-sk-evm.dtb	\
+	am43x-epos-evm.dtb \
+	am437x-idk-evm.dtb
+dtb-$(CONFIG_THUNDERX) += thunderx-88xx.dtb
+
+dtb-$(CONFIG_ARCH_SOCFPGA) +=				\
+	socfpga_arria5_socdk.dtb			\
+	socfpga_cyclone5_is1.dtb			\
+	socfpga_cyclone5_mcvevk.dtb			\
+	socfpga_cyclone5_socdk.dtb			\
+	socfpga_cyclone5_de0_nano_soc.dtb			\
+	socfpga_cyclone5_de1_soc.dtb			\
+	socfpga_cyclone5_sockit.dtb			\
+	socfpga_cyclone5_socrates.dtb			\
+	socfpga_cyclone5_sr1500.dtb			\
+	socfpga_cyclone5_vining_fpga.dtb
+
+dtb-$(CONFIG_TARGET_DRA7XX_EVM) += dra72-evm.dtb dra7-evm.dtb	\
+	dra72-evm-revc.dtb dra71-evm.dtb
+dtb-$(CONFIG_TARGET_AM57XX_EVM) += am57xx-beagle-x15.dtb \
+	am57xx-beagle-x15-revb1.dtb \
+	am57xx-evm-reva3.dtb \
+	am572x-idk.dtb	\
+	am571x-idk.dtb
+dtb-$(CONFIG_TARGET_STV0991) += stv0991.dtb
+
+dtb-$(CONFIG_LS102XA) += ls1021a-qds-duart.dtb \
+	ls1021a-qds-lpuart.dtb \
+	ls1021a-twr-duart.dtb ls1021a-twr-lpuart.dtb \
+	ls1021a-iot-duart.dtb
+dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2080a-qds.dtb \
+	fsl-ls2080a-rdb.dtb
+dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-duart.dtb \
+	fsl-ls1043a-qds-lpuart.dtb \
+	fsl-ls1043a-rdb.dtb \
+	fsl-ls1046a-qds-duart.dtb \
+	fsl-ls1046a-qds-lpuart.dtb \
+	fsl-ls1046a-rdb.dtb \
+	fsl-ls1012a-qds.dtb \
+	fsl-ls1012a-rdb.dtb \
+	fsl-ls1012a-frdm.dtb
+
+dtb-$(CONFIG_ARCH_SNAPDRAGON) += dragonboard410c.dtb
+
+dtb-$(CONFIG_MACH_SUN4I) += \
+	sun4i-a10-a1000.dtb \
+	sun4i-a10-ba10-tvbox.dtb \
+	sun4i-a10-chuwi-v7-cw0825.dtb \
+	sun4i-a10-cubieboard.dtb \
+	sun4i-a10-dserve-dsrv9703c.dtb \
+	sun4i-a10-gemei-g9.dtb \
+	sun4i-a10-hackberry.dtb \
+	sun4i-a10-hyundai-a7hd.dtb \
+	sun4i-a10-inet1.dtb \
+	sun4i-a10-inet-3f.dtb \
+	sun4i-a10-inet-3w.dtb \
+	sun4i-a10-inet97fv2.dtb \
+	sun4i-a10-inet9f-rev03.dtb \
+	sun4i-a10-itead-iteaduino-plus.dtb \
+	sun4i-a10-jesurun-q5.dtb \
+	sun4i-a10-marsboard.dtb \
+	sun4i-a10-mini-xplus.dtb \
+	sun4i-a10-mk802.dtb \
+	sun4i-a10-mk802ii.dtb \
+	sun4i-a10-olinuxino-lime.dtb \
+	sun4i-a10-pcduino.dtb \
+	sun4i-a10-pcduino2.dtb \
+	sun4i-a10-pov-protab2-ips9.dtb
+dtb-$(CONFIG_MACH_SUN5I) += \
+	sun5i-a10s-auxtek-t003.dtb \
+	sun5i-a10s-auxtek-t004.dtb \
+	sun5i-a10s-mk802.dtb \
+	sun5i-a10s-olinuxino-micro.dtb \
+	sun5i-a10s-r7-tv-dongle.dtb \
+	sun5i-a10s-wobo-i5.dtb \
+	sun5i-a13-ampe-a76.dtb \
+	sun5i-a13-difrnce-dit4350.dtb \
+	sun5i-a13-empire-electronix-d709.dtb \
+	sun5i-a13-empire-electronix-m712.dtb \
+	sun5i-a13-hsg-h702.dtb \
+	sun5i-a13-inet-86vs.dtb \
+	sun5i-a13-inet-98v-rev2.dtb \
+	sun5i-a13-olinuxino.dtb \
+	sun5i-a13-olinuxino-micro.dtb \
+	sun5i-a13-q8-tablet.dtb \
+	sun5i-a13-utoo-p66.dtb \
+	sun5i-r8-chip.dtb
+dtb-$(CONFIG_MACH_SUN6I) += \
+	sun6i-a31-app4-evb1.dtb \
+	sun6i-a31-colombus.dtb \
+	sun6i-a31-hummingbird.dtb \
+	sun6i-a31-i7.dtb \
+	sun6i-a31-m9.dtb \
+	sun6i-a31-mele-a1000g-quad.dtb \
+	sun6i-a31-mixtile-loftq.dtb \
+	sun6i-a31s-colorfly-e708-q1.dtb \
+	sun6i-a31s-cs908.dtb \
+	sun6i-a31s-inet-q972.dtb \
+	sun6i-a31s-primo81.dtb \
+	sun6i-a31s-sina31s.dtb \
+	sun6i-a31s-sinovoip-bpi-m2.dtb \
+	sun6i-a31s-yones-toptech-bs1078-v2.dtb
+dtb-$(CONFIG_MACH_SUN7I) += \
+	sun7i-a20-ainol-aw1.dtb \
+	sun7i-a20-bananapi.dtb \
+	sun7i-a20-bananapi-m1-plus.dtb \
+	sun7i-a20-bananapro.dtb \
+	sun7i-a20-cubieboard2.dtb \
+	sun7i-a20-cubietruck.dtb \
+	sun7i-a20-hummingbird.dtb \
+	sun7i-a20-i12-tvbox.dtb \
+	sun7i-a20-icnova-swac.dtb \
+	sun7i-a20-itead-ibox.dtb \
+	sun7i-a20-lamobo-r1.dtb \
+	sun7i-a20-m3.dtb \
+	sun7i-a20-m5.dtb \
+	sun7i-a20-mk808c.dtb \
+	sun7i-a20-olimex-som-evb.dtb \
+	sun7i-a20-olinuxino-lime.dtb \
+	sun7i-a20-olinuxino-lime2.dtb \
+	sun7i-a20-olinuxino-lime2-emmc.dtb \
+	sun7i-a20-olinuxino-micro.dtb \
+	sun7i-a20-orangepi.dtb \
+	sun7i-a20-orangepi-mini.dtb \
+	sun7i-a20-pcduino3.dtb \
+	sun7i-a20-pcduino3-nano.dtb \
+	sun7i-a20-primo73.dtb \
+	sun7i-a20-wexler-tab7200.dtb \
+	sun7i-a20-wits-pro-a20-dkt.dtb \
+	sun7i-a20-yones-toptech-bd1078.dtb
+dtb-$(CONFIG_MACH_SUN8I_A23) += \
+	sun8i-a23-evb.dtb \
+	sun8i-a23-gt90h-v4.dtb \
+	sun8i-a23-inet86dz.dtb \
+	sun8i-a23-polaroid-mid2407pxe03.dtb \
+	sun8i-a23-polaroid-mid2809pxe04.dtb \
+	sun8i-a23-q8-tablet.dtb
+dtb-$(CONFIG_MACH_SUN8I_A33) += \
+	sun8i-a33-ga10h-v1.1.dtb \
+	sun8i-a33-inet-d978-rev2.dtb \
+	sun8i-a33-olinuxino.dtb \
+	sun8i-a33-q8-tablet.dtb \
+	sun8i-a33-sinlinx-sina33.dtb \
+	sun8i-r16-nintendo-nes-classic-edition.dtb \
+	sun8i-r16-parrot.dtb
+dtb-$(CONFIG_MACH_SUN8I_A83T) += \
+	sun8i-a83t-allwinner-h8homlet-v2.dtb \
+	sun8i-a83t-cubietruck-plus.dtb \
+	sun8i-a83t-sinovoip-bpi-m3.dtb
+dtb-$(CONFIG_MACH_SUN8I_H3) += \
+	sun8i-h3-bananapi-m2-plus.dtb \
+	sun8i-h3-orangepi-2.dtb \
+	sun8i-h3-orangepi-lite.dtb \
+	sun8i-h3-orangepi-one.dtb \
+	sun8i-h3-orangepi-pc.dtb \
+	sun8i-h3-orangepi-pc-plus.dtb \
+	sun8i-h3-orangepi-plus.dtb \
+	sun8i-h3-orangepi-plus2e.dtb \
+	sun8i-h3-nanopi-neo.dtb
+dtb-$(CONFIG_MACH_SUN50I) += \
+	sun50i-a64-pine64-plus.dtb \
+	sun50i-a64-pine64.dtb
+dtb-$(CONFIG_MACH_SUN9I) += \
+	sun9i-a80-optimus.dtb \
+	sun9i-a80-cubieboard4.dtb
+
+dtb-$(CONFIG_VF610) += vf500-colibri.dtb \
+	vf610-colibri.dtb \
+	vf610-twr.dtb \
+	pcm052.dtb \
+	bk4r1.dtb
+
+dtb-$(CONFIG_MX53) += imx53-cx9020.dtb
+
+dtb-$(CONFIG_MX6) += imx6ull-14x14-evk.dtb \
+	imx6sll-evk.dtb \
+	imx6dl-icore.dtb \
+	imx6dl-icore-rqs.dtb \
+	imx6q-icore.dtb \
+	imx6q-icore-rqs.dtb \
+	imx6ul-geam-kit.dtb
+
+dtb-$(CONFIG_MX7) += imx7-colibri.dtb
+
+dtb-$(CONFIG_SOC_KEYSTONE) += keystone-k2hk-evm.dtb \
+	keystone-k2l-evm.dtb \
+	keystone-k2e-evm.dtb \
+	keystone-k2g-evm.dtb \
+	keystone-k2g-generic.dtb \
+	keystone-k2g-ice.dtb
+
+dtb-$(CONFIG_TARGET_SAMA5D2_XPLAINED) += \
+	at91-sama5d2_xplained.dtb
+
+dtb-$(CONFIG_ARCH_BCM283X) += \
+	bcm2835-rpi-a-plus.dtb \
+	bcm2835-rpi-a.dtb \
+	bcm2835-rpi-b-plus.dtb \
+	bcm2835-rpi-b-rev2.dtb \
+	bcm2835-rpi-b.dtb \
+	bcm2836-rpi-2-b.dtb \
+	bcm2837-rpi-3-b.dtb
+
+targets += $(dtb-y)
+
+# Add any required device tree compiler flags here
+DTC_FLAGS +=
+
+PHONY += dtbs
+dtbs: $(addprefix $(obj)/, $(dtb-y))
+	@:
+
+clean-files := *.dtb
diff -u -N /dev/null U-Boot_SDcard/include/environment/ti/qspi_am5728.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/include/environment/ti/qspi_am5728.h	1969-12-31 19:31:37.000000952 -0600
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Environment variable definitions for MMC/SD on TI boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define DEFAULT_QSPI_AM5728_ARGS \
+	"envboot=sf probe 0;"\
+	"echo ERASING THE FLASH. TAKES A WHILE..;"\
+	"sf erase 0 0x4000000;"	\
+	"echo ERASE COMPLETED. COPYING BOOTLOADER(MLO)..;"\
+	"fatload mmc 0 0x84100000 QSPIFLASH/MLO;"\
+	"sf write 0x84100000 0 0x20000;"\
+	"echo COPYING BOOTLOADER(uboot.img)..;"\
+	"fatload mmc 0 0x84100000 QSPIFLASH/u-boot.img;"\
+	"sf write 0x84100000 0x40000 0x70000;"\
+	"echo COPYING VXWORKS IMAGE..;"\
+	"fatload mmc 0 0x84100000 QSPIFLASH/vxWorks.bin;"\
+	"sf write 0x84100000 0x1E0000 0x14EF000;"\
+	"echo FLASHING COMPLETE..;"\
+	"echo REMOVE SD CARD..;"\
+
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c
--- U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c	2019-09-12 15:54:56.000000931 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap5/fdt.c	1969-12-31 19:29:28.000000763 -0600
@@ -90,29 +90,6 @@
 	return 0;
 }
 
-static int ft_hs_disable_rng(void *fdt, bd_t *bd)
-{
-	const char *path;
-	int offs;
-	int ret;
-
-	/* Make HW RNG reserved for secure world use */
-	path = "/ocp/rng";
-	offs = fdt_path_offset(fdt, path);
-	if (offs < 0) {
-		debug("Node %s not found.\n", path);
-		return 0;
-	}
-	ret = fdt_setprop_string(fdt, offs,
-				 "status", "disabled");
-	if (ret < 0) {
-		printf("Could not add status property to node %s: %s\n",
-		       path, fdt_strerror(ret));
-		return ret;
-	}
-	return 0;
-}
-
 #if ((TI_OMAP5_SECURE_BOOT_RESV_SRAM_SZ != 0) || \
     (CONFIG_SECURE_RUNTIME_RESV_SRAM_SZ != 0))
 static int ft_hs_fixup_sram(void *fdt, bd_t *bd)
@@ -153,97 +130,6 @@
 static int ft_hs_fixup_sram(void *fdt, bd_t *bd) { return 0; }
 #endif
 
-#if (CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE != 0)
-static int ft_hs_fixup_dram(void *fdt, bd_t *bd)
-{
-	const char *path, *subpath;
-	int offs;
-	u32 sec_mem_start = CONFIG_TI_SECURE_EMIF_REGION_START;
-	u32 sec_mem_size = CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE;
-	fdt64_t temp[2];
-
-	/* If start address is zero, place at end of DRAM */
-	if (0 == sec_mem_start)
-		sec_mem_start =
-			(CONFIG_SYS_SDRAM_BASE +
-			(omap_sdram_size() - sec_mem_size));
-
-	/* Delete any original secure_reserved node */
-	path = "/reserved-memory/secure_reserved";
-	offs = fdt_path_offset(fdt, path);
-	if (offs >= 0)
-		fdt_del_node(fdt, offs);
-
-	/* Add new secure_reserved node */
-	path = "/reserved-memory";
-	offs = fdt_path_offset(fdt, path);
-	if (offs < 0) {
-		debug("Node %s not found\n", path);
-		path = "/";
-		subpath = "reserved-memory";
-		fdt_path_offset(fdt, path);
-		offs = fdt_add_subnode(fdt, offs, subpath);
-		if (offs < 0) {
-			printf("Could not create %s%s node.\n", path, subpath);
-			return 1;
-		}
-		path = "/reserved-memory";
-		offs = fdt_path_offset(fdt, path);
-	}
-
-	subpath = "secure_reserved";
-	offs = fdt_add_subnode(fdt, offs, subpath);
-	if (offs < 0) {
-		printf("Could not create %s%s node.\n", path, subpath);
-		return 1;
-	}
-
-	temp[0] = cpu_to_fdt64(((u64)sec_mem_start));
-	temp[1] = cpu_to_fdt64(((u64)sec_mem_size));
-	fdt_setprop_string(fdt, offs, "compatible",
-			   "ti,dra7-secure-memory");
-	fdt_setprop_string(fdt, offs, "status", "okay");
-	fdt_setprop(fdt, offs, "no-map", NULL, 0);
-	fdt_setprop(fdt, offs, "reg", temp, sizeof(temp));
-
-	return 0;
-}
-#else
-static int ft_hs_fixup_dram(void *fdt, bd_t *bd) { return 0; }
-#endif
-
-static int ft_hs_add_tee(void *fdt, bd_t *bd)
-{
-	const char *path, *subpath;
-	int offs;
-
-	extern int tee_loaded;
-	if (!tee_loaded)
-		return 0;
-
-	path = "/";
-	offs = fdt_path_offset(fdt, path);
-
-	subpath = "firmware";
-	offs = fdt_add_subnode(fdt, offs, subpath);
-	if (offs < 0) {
-		printf("Could not create %s node.\n", subpath);
-		return 1;
-	}
-
-	subpath = "optee";
-	offs = fdt_add_subnode(fdt, offs, subpath);
-	if (offs < 0) {
-		printf("Could not create %s node.\n", subpath);
-		return 1;
-	}
-
-	fdt_setprop_string(fdt, offs, "compatible", "linaro,optee-tz");
-	fdt_setprop_string(fdt, offs, "method", "smc");
-
-	return 0;
-}
-
 static void ft_hs_fixups(void *fdt, bd_t *bd)
 {
 	/* Check we are running on an HS/EMU device type */
diff -u -N U-Boot_SDcard/drivers/power/palmas.c U-Boot_SDcard/drivers/power/palmas.c
--- U-Boot_SDcard/drivers/power/palmas.c	2019-09-12 15:54:47.000000310 -0500
+++ U-Boot_SDcard/drivers/power/palmas.c	1969-12-31 19:29:21.000000435 -0600
@@ -49,10 +49,9 @@
 #if defined(CONFIG_DRA7XX)
 	/*
 	 * Currently valid for the dra7xx_evm board:
-	 * Set TPS659038 LDO1 to 3.0 V
+	 * Set TPS659038 LDO1 to 3.0 V or 1.8V
 	 */
-	val = LDO_VOLT_3V0;
-	if (palmas_i2c_write_u8(TPS65903X_CHIP_P1, LDO1_VOLTAGE, val)) {
+	if (palmas_i2c_write_u8(TPS65903X_CHIP_P1, LDO1_VOLTAGE, voltage)) {
 		printf("tps65903x: could not set LDO1 voltage.\n");
 		return 1;
 	}
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c
--- U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c	2019-09-12 15:54:37.000000905 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/hwinit-common.c	1969-12-31 19:29:23.000000896 -0600
@@ -157,6 +157,15 @@
 	do_io_settings();
 #endif
 	setup_early_clocks();
+#ifdef CONFIG_SPL_BUILD
+	/*
+	 * Save the boot parameters passed from romcode.
+	 * We cannot delay the saving further than this,
+	 * to prevent overwrites.
+	 */
+	save_omap_boot_params();
+	spl_early_init();
+#endif
 	do_board_detect();
 	vcores_init();
 	prcm_init();
@@ -171,6 +180,7 @@
 #endif
 	/* For regular u-boot sdram_init() is called from dram_init() */
 	sdram_init();
+	gd->ram_size = omap_sdram_size();
 }
 #endif
 
diff -u -N /dev/null U-Boot_SDcard/common/boot_fit.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/common/boot_fit.c	1969-12-31 19:31:37.000000900 -0600
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2017
+ * Texas Instruments, <www.ti.com>
+ *
+ * Franklin S Cooper Jr. <fcooper@ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <boot_fit.h>
+#include <common.h>
+#include <errno.h>
+#include <image.h>
+#include <libfdt.h>
+
+int fdt_offset(void *fit)
+{
+	int fdt_offset, fdt_len;
+	int images;
+
+	images = fdt_path_offset(fit, FIT_IMAGES_PATH);
+	if (images < 0) {
+		debug("%s: Cannot find /images node: %d\n", __func__, images);
+		return -1;
+	}
+
+	/* Figure out which device tree the board wants to use */
+	fdt_len = fit_select_fdt(fit, images, &fdt_offset);
+
+	if (fdt_len < 0)
+		return fdt_len;
+
+	return fdt_offset;
+}
+
+void *locate_dtb_in_fit(void *fit)
+{
+	struct image_header *header;
+	int size;
+	int ret;
+
+	size = fdt_totalsize(fit);
+	size = (size + 3) & ~3;
+
+	header = (struct image_header *)fit;
+
+	if (image_get_magic(header) != FDT_MAGIC) {
+		debug("No FIT image appended to U-boot\n");
+		return NULL;
+	}
+
+	ret = fdt_offset(fit);
+
+	if (ret <= 0)
+		return NULL;
+	else
+		return (void *)fit+size+ret;
+}
diff -u -N U-Boot_SDcard/drivers/mmc/mxsmmc.c U-Boot_SDcard/drivers/mmc/mxsmmc.c
--- U-Boot_SDcard/drivers/mmc/mxsmmc.c	2019-09-12 15:54:19.000000055 -0500
+++ U-Boot_SDcard/drivers/mmc/mxsmmc.c	1969-12-31 19:29:21.000000202 -0600
@@ -304,7 +304,7 @@
 	return 0;
 }
 
-static void mxsmmc_set_ios(struct mmc *mmc)
+static int mxsmmc_set_ios(struct mmc *mmc)
 {
 	struct mxsmmc_priv *priv = mmc->priv;
 	struct mxs_ssp_regs *ssp_regs = priv->regs;
@@ -331,6 +331,7 @@
 
 	debug("MMC%d: Set %d bits bus width\n",
 		mmc->block_dev.devnum, mmc->bus_width);
+	return 0;
 }
 
 static int mxsmmc_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/include/asm-generic/global_data.h U-Boot_SDcard/include/asm-generic/global_data.h
--- U-Boot_SDcard/include/asm-generic/global_data.h	2019-09-12 15:54:46.000000434 -0500
+++ U-Boot_SDcard/include/asm-generic/global_data.h	1969-12-31 19:29:21.000000926 -0600
@@ -127,5 +127,6 @@
 #define GD_FLG_SKIP_RELOC	0x00800	/* Don't relocate		   */
 #define GD_FLG_RECORD		0x01000	/* Record console		   */
 #define GD_FLG_ENV_DEFAULT	0x02000 /* Default variable flag	   */
+#define GD_FLG_SPL_EARLY_INIT	0x04000 /* Early SPL init is done	   */
 
 #endif /* __ASM_GENERIC_GBL_DATA_H */
diff -u -N U-Boot_SDcard/drivers/mmc/s3c_sdi.c U-Boot_SDcard/drivers/mmc/s3c_sdi.c
--- U-Boot_SDcard/drivers/mmc/s3c_sdi.c	2019-09-12 15:54:23.000000623 -0500
+++ U-Boot_SDcard/drivers/mmc/s3c_sdi.c	1969-12-31 19:29:21.000000210 -0600
@@ -207,7 +207,7 @@
 	return ret;
 }
 
-static void s3cmmc_set_ios(struct mmc *mmc)
+static int s3cmmc_set_ios(struct mmc *mmc)
 {
 	struct s3c24x0_sdi *sdi_regs = s3c24x0_get_base_sdi();
 	uint32_t divider = 0;
@@ -223,6 +223,8 @@
 
 	writel(divider, &sdi_regs->sdipre);
 	mdelay(125);
+
+	return 0;
 }
 
 static int s3cmmc_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/drivers/dfu/Makefile U-Boot_SDcard/drivers/dfu/Makefile
--- U-Boot_SDcard/drivers/dfu/Makefile	2019-09-12 15:54:21.000000764 -0500
+++ U-Boot_SDcard/drivers/dfu/Makefile	1969-12-31 19:29:20.000000961 -0600
@@ -1,13 +1,16 @@
-#
-# Copyright (C) 2012 Samsung Electronics
-# Lukasz Majewski <l.majewski@samsung.com>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-$(CONFIG_USB_FUNCTION_DFU) += dfu.o
-obj-$(CONFIG_DFU_MMC) += dfu_mmc.o
-obj-$(CONFIG_DFU_NAND) += dfu_nand.o
-obj-$(CONFIG_DFU_RAM) += dfu_ram.o
-obj-$(CONFIG_DFU_SF) += dfu_sf.o
-obj-$(CONFIG_DFU_TFTP) += dfu_tftp.o
+#
+# Copyright (C) 2012 Samsung Electronics
+# Lukasz Majewski <l.majewski@samsung.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_USB_FUNCTION_DFU) += dfu.o
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_DFU_MMC) += dfu_mmc.o
+endif
+obj-$(CONFIG_SPL_DFU_MMC) += dfu_mmc.o
+obj-$(CONFIG_DFU_NAND) += dfu_nand.o
+obj-$(CONFIG_DFU_RAM) += dfu_ram.o
+obj-$(CONFIG_DFU_SF) += dfu_sf.o
+obj-$(CONFIG_DFU_TFTP) += dfu_tftp.o
diff -u -N U-Boot_SDcard/drivers/core/util.c U-Boot_SDcard/drivers/core/util.c
--- U-Boot_SDcard/drivers/core/util.c	2019-09-12 15:54:41.000000544 -0500
+++ U-Boot_SDcard/drivers/core/util.c	1969-12-31 19:29:20.000000939 -0600
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <libfdt.h>
 #include <vsprintf.h>
 
 void dm_warn(const char *fmt, ...)
@@ -35,3 +36,27 @@
 
 	return count;
 }
+
+int dm_fdt_pre_reloc(const void *blob, int offset)
+{
+	if (fdt_getprop(blob, offset, "u-boot,dm-pre-reloc", NULL))
+		return 1;
+
+#ifdef CONFIG_TPL_BUILD
+	if (fdt_getprop(blob, offset, "u-boot,dm-tpl", NULL))
+		return 1;
+#elif defined(CONFIG_SPL_BUILD)
+	if (fdt_getprop(blob, offset, "u-boot,dm-spl", NULL))
+		return 1;
+#else
+	/*
+	 * In regular builds individual spl and tpl handling both
+	 * count as handled pre-relocation for later second init.
+	 */
+	if (fdt_getprop(blob, offset, "u-boot,dm-spl", NULL) ||
+	    fdt_getprop(blob, offset, "u-boot,dm-tpl", NULL))
+		return 1;
+#endif
+
+	return 0;
+}
diff -u -N U-Boot_SDcard/drivers/mmc/davinci_mmc.c U-Boot_SDcard/drivers/mmc/davinci_mmc.c
--- U-Boot_SDcard/drivers/mmc/davinci_mmc.c	2019-09-12 15:55:01.000000786 -0500
+++ U-Boot_SDcard/drivers/mmc/davinci_mmc.c	1969-12-31 19:29:21.000000181 -0600
@@ -348,7 +348,7 @@
 }
 
 /* Set buswidth or clock as indicated by the GENERIC_MMC framework */
-static void dmmc_set_ios(struct mmc *mmc)
+static int dmmc_set_ios(struct mmc *mmc)
 {
 	struct davinci_mmc *host = mmc->priv;
 	struct davinci_mmc_regs *regs = host->reg_base;
@@ -362,6 +362,8 @@
 	/* Set clock speed */
 	if (mmc->clock)
 		dmmc_set_clock(mmc, mmc->clock);
+
+	return 0;
 }
 
 static const struct mmc_ops dmmc_ops = {
diff -u -N U-Boot_SDcard/arch/arm/include/asm/omap_common.h U-Boot_SDcard/arch/arm/include/asm/omap_common.h
--- U-Boot_SDcard/arch/arm/include/asm/omap_common.h	2019-09-12 15:54:48.000000863 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/omap_common.h	1969-12-31 19:29:28.000000648 -0600
@@ -592,6 +592,7 @@
 extern struct prcm_regs const dra7xx_prcm;
 extern struct dplls const **dplls_data;
 extern struct dplls dra7xx_dplls;
+extern struct dplls dra72x_dplls;
 extern struct vcores_data const **omap_vcores;
 extern const u32 sys_clk_array[8];
 extern struct omap_sys_ctrl_regs const **ctrl;
@@ -662,6 +663,11 @@
 /* Initialize general purpose I2C(0) on the SoC */
 void gpi2c_init(void);
 
+/* Common FDT Fixups */
+int ft_hs_disable_rng(void *fdt, bd_t *bd);
+int ft_hs_fixup_dram(void *fdt, bd_t *bd);
+int ft_hs_add_tee(void *fdt, bd_t *bd);
+
 /* ABB */
 #define OMAP_ABB_NOMINAL_OPP		0
 #define OMAP_ABB_FAST_OPP		1
@@ -767,9 +773,11 @@
 #define OMAP_SRAM_SCRATCH_VCORES_PTR    (SRAM_SCRATCH_SPACE_ADDR + 0x1C)
 #define OMAP_SRAM_SCRATCH_SYS_CTRL	(SRAM_SCRATCH_SPACE_ADDR + 0x20)
 #define OMAP_SRAM_SCRATCH_BOOT_PARAMS	(SRAM_SCRATCH_SPACE_ADDR + 0x24)
-#define OMAP_SRAM_SCRATCH_BOARD_EEPROM_START (SRAM_SCRATCH_SPACE_ADDR + 0x28)
-#define OMAP_SRAM_SCRATCH_BOARD_EEPROM_END (SRAM_SCRATCH_SPACE_ADDR + 0x200)
-#define OMAP_SRAM_SCRATCH_SPACE_END	(OMAP_SRAM_SCRATCH_BOARD_EEPROM_END)
+#ifndef TI_SRAM_SCRATCH_BOARD_EEPROM_START
+#define TI_SRAM_SCRATCH_BOARD_EEPROM_START (SRAM_SCRATCH_SPACE_ADDR + 0x28)
+#define TI_SRAM_SCRATCH_BOARD_EEPROM_END (SRAM_SCRATCH_SPACE_ADDR + 0x200)
+#endif
+#define OMAP_SRAM_SCRATCH_SPACE_END	(TI_SRAM_SCRATCH_BOARD_EEPROM_END)
 
 /* Boot parameters */
 #define DEVICE_DATA_OFFSET	0x18
diff -u -N U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c
--- U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c	2019-09-12 15:54:22.000000004 -0500
+++ U-Boot_SDcard/board/compulab/cm_t54/cm_t54.c	1969-12-31 19:29:25.000000118 -0600
@@ -96,7 +96,7 @@
 }
 #endif
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 #define SB_T54_CD_GPIO 228
 #define SB_T54_WP_GPIO 229
 
diff -u -N U-Boot_SDcard/include/configs/omap5_uevm.h U-Boot_SDcard/include/configs/omap5_uevm.h
--- U-Boot_SDcard/include/configs/omap5_uevm.h	2019-09-12 15:54:58.000000074 -0500
+++ U-Boot_SDcard/include/configs/omap5_uevm.h	1969-12-31 19:29:22.000000371 -0600
@@ -38,7 +38,7 @@
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SLOT2: eMMC(1) */
 #define CONFIG_ENV_SIZE			(128 << 10)
-#define CONFIG_ENV_OFFSET		0xE0000
+#define CONFIG_ENV_OFFSET		0x260000
 #define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
 #define CONFIG_SYS_REDUNDAND_ENVIRONMENT
 
diff -u -N U-Boot_SDcard/drivers/mmc/mmc_write.c U-Boot_SDcard/drivers/mmc/mmc_write.c
--- U-Boot_SDcard/drivers/mmc/mmc_write.c	2019-09-12 15:54:47.000000445 -0500
+++ U-Boot_SDcard/drivers/mmc/mmc_write.c	1969-12-31 19:29:21.000000197 -0600
@@ -198,6 +198,7 @@
 	int dev_num = block_dev->devnum;
 	lbaint_t cur, blocks_todo = blkcnt;
 	int err;
+	uint start_time;
 
 	struct mmc *mmc = find_mmc_device(dev_num);
 	if (!mmc)
@@ -210,15 +211,35 @@
 	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
 		return 0;
 
+	start_time =  get_timer(0);
 	do {
+		mmc->wr_stats.transfers++;
 		cur = (blocks_todo > mmc->cfg->b_max) ?
 			mmc->cfg->b_max : blocks_todo;
-		if (mmc_write_blocks(mmc, start, cur, src) != cur)
+		if (mmc_write_blocks(mmc, start, cur, src) != cur) {
+			mmc->wr_stats.errors++;
+			/*
+			 * An error occured. Maybe we should try a slower but
+			 * safer mode.
+			 */
+			if (mmc_check_error_rate(mmc, &mmc->wr_stats))
+				if (mmc_disable_current_mode(mmc))
+					return (blkcnt - blocks_todo) +
+#ifdef CONFIG_BLK
+						mmc_bwrite(dev, start,
+#else
+						mmc_bwrite(block_dev, start,
+#endif
+							   blocks_todo, src);
+			debug("%s: Failed to write blocks\n", __func__);
 			return 0;
+		}
 		blocks_todo -= cur;
 		start += cur;
 		src += cur * mmc->write_bl_len;
 	} while (blocks_todo > 0);
 
+	mmc->wr_stats.total_time += get_timer(start_time);
+	mmc->wr_stats.total_sz += blkcnt;
 	return blkcnt;
 }
diff -u -N U-Boot_SDcard/lib/fdtdec.c U-Boot_SDcard/lib/fdtdec.c
--- U-Boot_SDcard/lib/fdtdec.c	2019-09-12 15:54:26.000000225 -0500
+++ U-Boot_SDcard/lib/fdtdec.c	1969-12-31 19:29:19.000000455 -0600
@@ -4,6 +4,7 @@
  */
 
 #ifndef USE_HOSTCC
+#include <boot_fit.h>
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
@@ -112,7 +113,7 @@
 		return FDT_ADDR_T_NONE;
 	}
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_OF_LIBFDT)
+#if CONFIG_IS_ENABLED(OF_LIBFDT)
 	if (translate)
 		addr = fdt_translate_address(blob, node, prop_addr);
 	else
@@ -1243,6 +1244,15 @@
 		gd->fdt_blob = (ulong *)&_image_binary_end;
 	else
 		gd->fdt_blob = (ulong *)&__bss_end;
+
+#  elif defined CONFIG_FIT_EMBED
+	gd->fdt_blob = locate_dtb_in_fit(&_end);
+
+	if (gd->fdt_blob == NULL || gd->fdt_blob <= ((void *)&_end)) {
+		puts("Failed to find proper dtb in embedded FIT Image\n");
+		return -1;
+	}
+
 #  else
 	/* FDT is at end of image */
 	gd->fdt_blob = (ulong *)&_end;
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h	2019-09-12 15:54:23.000000125 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-omap5/sys_proto.h	1969-12-31 19:29:30.000000551 -0600
@@ -35,6 +35,13 @@
 	u32 val;
 };
 
+struct omap_hsmmc_pinctrl_state {
+	struct pad_conf_entry *padconf;
+	int npads;
+	struct iodelay_cfg_entry *iodelay;
+	int niodelays;
+};
+
 struct omap_sysinfo {
 	char *board_string;
 };
diff -u -N U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts
--- U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts	2019-09-12 15:54:31.000000890 -0500
+++ U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-revb1.dts	1969-12-31 19:29:23.000000227 -0600
@@ -1,24 +1,24 @@
-/*
- * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include "am57xx-beagle-x15-common.dtsi"
-
-/ {
-	model = "TI AM5728 BeagleBoard-X15 rev B1";
-};
-
-&tpd12s015 {
-	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
-		<&gpio2 30 GPIO_ACTIVE_HIGH>,	/* gpio2_30, LS OE */
-		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
-};
-
-&mmc1 {
-	vmmc-supply = <&vdd_3v3>;
-	vmmc-aux-supply = <&ldo1_reg>;
-};
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am57xx-beagle-x15-common.dtsi"
+
+/ {
+	model = "TI AM5728 BeagleBoard-X15 rev B1";
+};
+
+&tpd12s015 {
+	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
+		<&gpio2 30 GPIO_ACTIVE_HIGH>,	/* gpio2_30, LS OE */
+		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
+};
+
+&mmc1 {
+	vmmc-supply = <&vdd_3v3>;
+	vmmc_aux-supply = <&ldo1_reg>;
+};
diff -u -N U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c
--- U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c	2019-09-12 15:54:23.000000566 -0500
+++ U-Boot_SDcard/drivers/usb/musb-new/musb_uboot.c	1969-12-31 19:29:28.000000119 -0600
@@ -373,6 +373,7 @@
 #endif /* CONFIG_DM_USB */
 #endif /* CONFIG_USB_MUSB_HOST */
 
+#ifndef CONFIG_DM_USB
 #ifdef CONFIG_USB_MUSB_GADGET
 static struct musb *gadget;
 
@@ -453,3 +454,4 @@
 
 	return 0;
 }
+#endif /* CONFIG_DM_USB */
diff -u -N U-Boot_SDcard/tools/dtoc/dtoc.py U-Boot_SDcard/tools/dtoc/dtoc.py
--- U-Boot_SDcard/tools/dtoc/dtoc.py	2019-09-12 15:54:14.000000230 -0500
+++ U-Boot_SDcard/tools/dtoc/dtoc.py	1969-12-31 19:29:23.000000075 -0600
@@ -1,382 +1,384 @@
-#!/usr/bin/python
-#
-# Copyright (C) 2016 Google, Inc
-# Written by Simon Glass <sjg@chromium.org>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-import copy
-from optparse import OptionError, OptionParser
-import os
-import struct
-import sys
-
-# Bring in the patman libraries
-our_path = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(our_path, '../patman'))
-
-import fdt
-import fdt_select
-import fdt_util
-
-# When we see these properties we ignore them - i.e. do not create a structure member
-PROP_IGNORE_LIST = [
-    '#address-cells',
-    '#gpio-cells',
-    '#size-cells',
-    'compatible',
-    'linux,phandle',
-    "status",
-    'phandle',
-    'u-boot,dm-pre-reloc',
-]
-
-# C type declarations for the tyues we support
-TYPE_NAMES = {
-    fdt.TYPE_INT: 'fdt32_t',
-    fdt.TYPE_BYTE: 'unsigned char',
-    fdt.TYPE_STRING: 'const char *',
-    fdt.TYPE_BOOL: 'bool',
-};
-
-STRUCT_PREFIX = 'dtd_'
-VAL_PREFIX = 'dtv_'
-
-def Conv_name_to_c(name):
-    """Convert a device-tree name to a C identifier
-
-    Args:
-        name:   Name to convert
-    Return:
-        String containing the C version of this name
-    """
-    str = name.replace('@', '_at_')
-    str = str.replace('-', '_')
-    str = str.replace(',', '_')
-    str = str.replace('/', '__')
-    return str
-
-def TabTo(num_tabs, str):
-    if len(str) >= num_tabs * 8:
-        return str + ' '
-    return str + '\t' * (num_tabs - len(str) // 8)
-
-class DtbPlatdata:
-    """Provide a means to convert device tree binary data to platform data
-
-    The output of this process is C structures which can be used in space-
-    constrained encvironments where the ~3KB code overhead of device tree
-    code is not affordable.
-
-    Properties:
-        fdt: Fdt object, referencing the device tree
-        _dtb_fname: Filename of the input device tree binary file
-        _valid_nodes: A list of Node object with compatible strings
-        _options: Command-line options
-        _phandle_node: A dict of nodes indexed by phandle number (1, 2...)
-        _outfile: The current output file (sys.stdout or a real file)
-        _lines: Stashed list of output lines for outputting in the future
-        _phandle_node: A dict of Nodes indexed by phandle (an integer)
-    """
-    def __init__(self, dtb_fname, options):
-        self._dtb_fname = dtb_fname
-        self._valid_nodes = None
-        self._options = options
-        self._phandle_node = {}
-        self._outfile = None
-        self._lines = []
-
-    def SetupOutput(self, fname):
-        """Set up the output destination
-
-        Once this is done, future calls to self.Out() will output to this
-        file.
-
-        Args:
-            fname: Filename to send output to, or '-' for stdout
-        """
-        if fname == '-':
-            self._outfile = sys.stdout
-        else:
-            self._outfile = open(fname, 'w')
-
-    def Out(self, str):
-        """Output a string to the output file
-
-        Args:
-            str: String to output
-        """
-        self._outfile.write(str)
-
-    def Buf(self, str):
-        """Buffer up a string to send later
-
-        Args:
-            str: String to add to our 'buffer' list
-        """
-        self._lines.append(str)
-
-    def GetBuf(self):
-        """Get the contents of the output buffer, and clear it
-
-        Returns:
-            The output buffer, which is then cleared for future use
-        """
-        lines = self._lines
-        self._lines = []
-        return lines
-
-    def GetValue(self, type, value):
-        """Get a value as a C expression
-
-        For integers this returns a byte-swapped (little-endian) hex string
-        For bytes this returns a hex string, e.g. 0x12
-        For strings this returns a literal string enclosed in quotes
-        For booleans this return 'true'
-
-        Args:
-            type: Data type (fdt_util)
-            value: Data value, as a string of bytes
-        """
-        if type == fdt.TYPE_INT:
-            return '%#x' % fdt_util.fdt32_to_cpu(value)
-        elif type == fdt.TYPE_BYTE:
-            return '%#x' % ord(value[0])
-        elif type == fdt.TYPE_STRING:
-            return '"%s"' % value
-        elif type == fdt.TYPE_BOOL:
-            return 'true'
-
-    def GetCompatName(self, node):
-        """Get a node's first compatible string as a C identifier
-
-        Args:
-            node: Node object to check
-        Return:
-            C identifier for the first compatible string
-        """
-        compat = node.props['compatible'].value
-        if type(compat) == list:
-            compat = compat[0]
-        return Conv_name_to_c(compat)
-
-    def ScanDtb(self):
-        """Scan the device tree to obtain a tree of notes and properties
-
-        Once this is done, self.fdt.GetRoot() can be called to obtain the
-        device tree root node, and progress from there.
-        """
-        self.fdt = fdt_select.FdtScan(self._dtb_fname)
-
-    def ScanTree(self):
-        """Scan the device tree for useful information
-
-        This fills in the following properties:
-            _phandle_node: A dict of Nodes indexed by phandle (an integer)
-            _valid_nodes: A list of nodes we wish to consider include in the
-                platform data
-        """
-        node_list = []
-        self._phandle_node = {}
-        for node in self.fdt.GetRoot().subnodes:
-            if 'compatible' in node.props:
-                status = node.props.get('status')
-                if (not options.include_disabled and not status or
-                    status.value != 'disabled'):
-                    node_list.append(node)
-                    phandle_prop = node.props.get('phandle')
-                    if phandle_prop:
-                        phandle = phandle_prop.GetPhandle()
-                        self._phandle_node[phandle] = node
-
-        self._valid_nodes = node_list
-
-    def IsPhandle(self, prop):
-        """Check if a node contains phandles
-
-        We have no reliable way of detecting whether a node uses a phandle
-        or not. As an interim measure, use a list of known property names.
-
-        Args:
-            prop: Prop object to check
-        Return:
-            True if the object value contains phandles, else False
-        """
-        if prop.name in ['clocks']:
-            return True
-        return False
-
-    def ScanStructs(self):
-        """Scan the device tree building up the C structures we will use.
-
-        Build a dict keyed by C struct name containing a dict of Prop
-        object for each struct field (keyed by property name). Where the
-        same struct appears multiple times, try to use the 'widest'
-        property, i.e. the one with a type which can express all others.
-
-        Once the widest property is determined, all other properties are
-        updated to match that width.
-        """
-        structs = {}
-        for node in self._valid_nodes:
-            node_name = self.GetCompatName(node)
-            fields = {}
-
-            # Get a list of all the valid properties in this node.
-            for name, prop in node.props.items():
-                if name not in PROP_IGNORE_LIST and name[0] != '#':
-                    fields[name] = copy.deepcopy(prop)
-
-            # If we've seen this node_name before, update the existing struct.
-            if node_name in structs:
-                struct = structs[node_name]
-                for name, prop in fields.items():
-                    oldprop = struct.get(name)
-                    if oldprop:
-                        oldprop.Widen(prop)
-                    else:
-                        struct[name] = prop
-
-            # Otherwise store this as a new struct.
-            else:
-                structs[node_name] = fields
-
-        upto = 0
-        for node in self._valid_nodes:
-            node_name = self.GetCompatName(node)
-            struct = structs[node_name]
-            for name, prop in node.props.items():
-                if name not in PROP_IGNORE_LIST and name[0] != '#':
-                    prop.Widen(struct[name])
-            upto += 1
-        return structs
-
-    def GenerateStructs(self, structs):
-        """Generate struct defintions for the platform data
-
-        This writes out the body of a header file consisting of structure
-        definitions for node in self._valid_nodes. See the documentation in
-        README.of-plat for more information.
-        """
-        self.Out('#include <stdbool.h>\n')
-        self.Out('#include <libfdt.h>\n')
-
-        # Output the struct definition
-        for name in sorted(structs):
-            self.Out('struct %s%s {\n' % (STRUCT_PREFIX, name));
-            for pname in sorted(structs[name]):
-                prop = structs[name][pname]
-                if self.IsPhandle(prop):
-                    # For phandles, include a reference to the target
-                    self.Out('\t%s%s[%d]' % (TabTo(2, 'struct phandle_2_cell'),
-                                             Conv_name_to_c(prop.name),
-                                             len(prop.value) / 2))
-                else:
-                    ptype = TYPE_NAMES[prop.type]
-                    self.Out('\t%s%s' % (TabTo(2, ptype),
-                                         Conv_name_to_c(prop.name)))
-                    if type(prop.value) == list:
-                        self.Out('[%d]' % len(prop.value))
-                self.Out(';\n')
-            self.Out('};\n')
-
-    def GenerateTables(self):
-        """Generate device defintions for the platform data
-
-        This writes out C platform data initialisation data and
-        U_BOOT_DEVICE() declarations for each valid node. See the
-        documentation in README.of-plat for more information.
-        """
-        self.Out('#include <common.h>\n')
-        self.Out('#include <dm.h>\n')
-        self.Out('#include <dt-structs.h>\n')
-        self.Out('\n')
-        node_txt_list = []
-        for node in self._valid_nodes:
-            struct_name = self.GetCompatName(node)
-            var_name = Conv_name_to_c(node.name)
-            self.Buf('static struct %s%s %s%s = {\n' %
-                (STRUCT_PREFIX, struct_name, VAL_PREFIX, var_name))
-            for pname, prop in node.props.items():
-                if pname in PROP_IGNORE_LIST or pname[0] == '#':
-                    continue
-                ptype = TYPE_NAMES[prop.type]
-                member_name = Conv_name_to_c(prop.name)
-                self.Buf('\t%s= ' % TabTo(3, '.' + member_name))
-
-                # Special handling for lists
-                if type(prop.value) == list:
-                    self.Buf('{')
-                    vals = []
-                    # For phandles, output a reference to the platform data
-                    # of the target node.
-                    if self.IsPhandle(prop):
-                        # Process the list as pairs of (phandle, id)
-                        it = iter(prop.value)
-                        for phandle_cell, id_cell in zip(it, it):
-                            phandle = fdt_util.fdt32_to_cpu(phandle_cell)
-                            id = fdt_util.fdt32_to_cpu(id_cell)
-                            target_node = self._phandle_node[phandle]
-                            name = Conv_name_to_c(target_node.name)
-                            vals.append('{&%s%s, %d}' % (VAL_PREFIX, name, id))
-                    else:
-                        for val in prop.value:
-                            vals.append(self.GetValue(prop.type, val))
-                    self.Buf(', '.join(vals))
-                    self.Buf('}')
-                else:
-                    self.Buf(self.GetValue(prop.type, prop.value))
-                self.Buf(',\n')
-            self.Buf('};\n')
-
-            # Add a device declaration
-            self.Buf('U_BOOT_DEVICE(%s) = {\n' % var_name)
-            self.Buf('\t.name\t\t= "%s",\n' % struct_name)
-            self.Buf('\t.platdata\t= &%s%s,\n' % (VAL_PREFIX, var_name))
-            self.Buf('\t.platdata_size\t= sizeof(%s%s),\n' %
-                     (VAL_PREFIX, var_name))
-            self.Buf('};\n')
-            self.Buf('\n')
-
-            # Output phandle target nodes first, since they may be referenced
-            # by others
-            if 'phandle' in node.props:
-                self.Out(''.join(self.GetBuf()))
-            else:
-                node_txt_list.append(self.GetBuf())
-
-        # Output all the nodes which are not phandle targets themselves, but
-        # may reference them. This avoids the need for forward declarations.
-        for node_txt in node_txt_list:
-            self.Out(''.join(node_txt))
-
-
-if __name__ != "__main__":
-    pass
-
-parser = OptionParser()
-parser.add_option('-d', '--dtb-file', action='store',
-                  help='Specify the .dtb input file')
-parser.add_option('--include-disabled', action='store_true',
-                  help='Include disabled nodes')
-parser.add_option('-o', '--output', action='store', default='-',
-                  help='Select output filename')
-(options, args) = parser.parse_args()
-
-if not args:
-    raise ValueError('Please specify a command: struct, platdata')
-
-plat = DtbPlatdata(options.dtb_file, options)
-plat.ScanDtb()
-plat.ScanTree()
-plat.SetupOutput(options.output)
-structs = plat.ScanStructs()
-
-for cmd in args[0].split(','):
-    if cmd == 'struct':
-        plat.GenerateStructs(structs)
-    elif cmd == 'platdata':
-        plat.GenerateTables()
-    else:
-        raise ValueError("Unknown command '%s': (use: struct, platdata)" % cmd)
+#!/usr/bin/python
+#
+# Copyright (C) 2016 Google, Inc
+# Written by Simon Glass <sjg@chromium.org>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+import copy
+from optparse import OptionError, OptionParser
+import os
+import struct
+import sys
+
+# Bring in the patman libraries
+our_path = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(our_path, '../patman'))
+
+import fdt
+import fdt_select
+import fdt_util
+
+# When we see these properties we ignore them - i.e. do not create a structure member
+PROP_IGNORE_LIST = [
+    '#address-cells',
+    '#gpio-cells',
+    '#size-cells',
+    'compatible',
+    'linux,phandle',
+    "status",
+    'phandle',
+    'u-boot,dm-pre-reloc',
+    'u-boot,dm-tpl',
+    'u-boot,dm-spl',
+]
+
+# C type declarations for the tyues we support
+TYPE_NAMES = {
+    fdt.TYPE_INT: 'fdt32_t',
+    fdt.TYPE_BYTE: 'unsigned char',
+    fdt.TYPE_STRING: 'const char *',
+    fdt.TYPE_BOOL: 'bool',
+};
+
+STRUCT_PREFIX = 'dtd_'
+VAL_PREFIX = 'dtv_'
+
+def Conv_name_to_c(name):
+    """Convert a device-tree name to a C identifier
+
+    Args:
+        name:   Name to convert
+    Return:
+        String containing the C version of this name
+    """
+    str = name.replace('@', '_at_')
+    str = str.replace('-', '_')
+    str = str.replace(',', '_')
+    str = str.replace('/', '__')
+    return str
+
+def TabTo(num_tabs, str):
+    if len(str) >= num_tabs * 8:
+        return str + ' '
+    return str + '\t' * (num_tabs - len(str) // 8)
+
+class DtbPlatdata:
+    """Provide a means to convert device tree binary data to platform data
+
+    The output of this process is C structures which can be used in space-
+    constrained encvironments where the ~3KB code overhead of device tree
+    code is not affordable.
+
+    Properties:
+        fdt: Fdt object, referencing the device tree
+        _dtb_fname: Filename of the input device tree binary file
+        _valid_nodes: A list of Node object with compatible strings
+        _options: Command-line options
+        _phandle_node: A dict of nodes indexed by phandle number (1, 2...)
+        _outfile: The current output file (sys.stdout or a real file)
+        _lines: Stashed list of output lines for outputting in the future
+        _phandle_node: A dict of Nodes indexed by phandle (an integer)
+    """
+    def __init__(self, dtb_fname, options):
+        self._dtb_fname = dtb_fname
+        self._valid_nodes = None
+        self._options = options
+        self._phandle_node = {}
+        self._outfile = None
+        self._lines = []
+
+    def SetupOutput(self, fname):
+        """Set up the output destination
+
+        Once this is done, future calls to self.Out() will output to this
+        file.
+
+        Args:
+            fname: Filename to send output to, or '-' for stdout
+        """
+        if fname == '-':
+            self._outfile = sys.stdout
+        else:
+            self._outfile = open(fname, 'w')
+
+    def Out(self, str):
+        """Output a string to the output file
+
+        Args:
+            str: String to output
+        """
+        self._outfile.write(str)
+
+    def Buf(self, str):
+        """Buffer up a string to send later
+
+        Args:
+            str: String to add to our 'buffer' list
+        """
+        self._lines.append(str)
+
+    def GetBuf(self):
+        """Get the contents of the output buffer, and clear it
+
+        Returns:
+            The output buffer, which is then cleared for future use
+        """
+        lines = self._lines
+        self._lines = []
+        return lines
+
+    def GetValue(self, type, value):
+        """Get a value as a C expression
+
+        For integers this returns a byte-swapped (little-endian) hex string
+        For bytes this returns a hex string, e.g. 0x12
+        For strings this returns a literal string enclosed in quotes
+        For booleans this return 'true'
+
+        Args:
+            type: Data type (fdt_util)
+            value: Data value, as a string of bytes
+        """
+        if type == fdt.TYPE_INT:
+            return '%#x' % fdt_util.fdt32_to_cpu(value)
+        elif type == fdt.TYPE_BYTE:
+            return '%#x' % ord(value[0])
+        elif type == fdt.TYPE_STRING:
+            return '"%s"' % value
+        elif type == fdt.TYPE_BOOL:
+            return 'true'
+
+    def GetCompatName(self, node):
+        """Get a node's first compatible string as a C identifier
+
+        Args:
+            node: Node object to check
+        Return:
+            C identifier for the first compatible string
+        """
+        compat = node.props['compatible'].value
+        if type(compat) == list:
+            compat = compat[0]
+        return Conv_name_to_c(compat)
+
+    def ScanDtb(self):
+        """Scan the device tree to obtain a tree of notes and properties
+
+        Once this is done, self.fdt.GetRoot() can be called to obtain the
+        device tree root node, and progress from there.
+        """
+        self.fdt = fdt_select.FdtScan(self._dtb_fname)
+
+    def ScanTree(self):
+        """Scan the device tree for useful information
+
+        This fills in the following properties:
+            _phandle_node: A dict of Nodes indexed by phandle (an integer)
+            _valid_nodes: A list of nodes we wish to consider include in the
+                platform data
+        """
+        node_list = []
+        self._phandle_node = {}
+        for node in self.fdt.GetRoot().subnodes:
+            if 'compatible' in node.props:
+                status = node.props.get('status')
+                if (not options.include_disabled and not status or
+                    status.value != 'disabled'):
+                    node_list.append(node)
+                    phandle_prop = node.props.get('phandle')
+                    if phandle_prop:
+                        phandle = phandle_prop.GetPhandle()
+                        self._phandle_node[phandle] = node
+
+        self._valid_nodes = node_list
+
+    def IsPhandle(self, prop):
+        """Check if a node contains phandles
+
+        We have no reliable way of detecting whether a node uses a phandle
+        or not. As an interim measure, use a list of known property names.
+
+        Args:
+            prop: Prop object to check
+        Return:
+            True if the object value contains phandles, else False
+        """
+        if prop.name in ['clocks']:
+            return True
+        return False
+
+    def ScanStructs(self):
+        """Scan the device tree building up the C structures we will use.
+
+        Build a dict keyed by C struct name containing a dict of Prop
+        object for each struct field (keyed by property name). Where the
+        same struct appears multiple times, try to use the 'widest'
+        property, i.e. the one with a type which can express all others.
+
+        Once the widest property is determined, all other properties are
+        updated to match that width.
+        """
+        structs = {}
+        for node in self._valid_nodes:
+            node_name = self.GetCompatName(node)
+            fields = {}
+
+            # Get a list of all the valid properties in this node.
+            for name, prop in node.props.items():
+                if name not in PROP_IGNORE_LIST and name[0] != '#':
+                    fields[name] = copy.deepcopy(prop)
+
+            # If we've seen this node_name before, update the existing struct.
+            if node_name in structs:
+                struct = structs[node_name]
+                for name, prop in fields.items():
+                    oldprop = struct.get(name)
+                    if oldprop:
+                        oldprop.Widen(prop)
+                    else:
+                        struct[name] = prop
+
+            # Otherwise store this as a new struct.
+            else:
+                structs[node_name] = fields
+
+        upto = 0
+        for node in self._valid_nodes:
+            node_name = self.GetCompatName(node)
+            struct = structs[node_name]
+            for name, prop in node.props.items():
+                if name not in PROP_IGNORE_LIST and name[0] != '#':
+                    prop.Widen(struct[name])
+            upto += 1
+        return structs
+
+    def GenerateStructs(self, structs):
+        """Generate struct defintions for the platform data
+
+        This writes out the body of a header file consisting of structure
+        definitions for node in self._valid_nodes. See the documentation in
+        README.of-plat for more information.
+        """
+        self.Out('#include <stdbool.h>\n')
+        self.Out('#include <libfdt.h>\n')
+
+        # Output the struct definition
+        for name in sorted(structs):
+            self.Out('struct %s%s {\n' % (STRUCT_PREFIX, name));
+            for pname in sorted(structs[name]):
+                prop = structs[name][pname]
+                if self.IsPhandle(prop):
+                    # For phandles, include a reference to the target
+                    self.Out('\t%s%s[%d]' % (TabTo(2, 'struct phandle_2_cell'),
+                                             Conv_name_to_c(prop.name),
+                                             len(prop.value) / 2))
+                else:
+                    ptype = TYPE_NAMES[prop.type]
+                    self.Out('\t%s%s' % (TabTo(2, ptype),
+                                         Conv_name_to_c(prop.name)))
+                    if type(prop.value) == list:
+                        self.Out('[%d]' % len(prop.value))
+                self.Out(';\n')
+            self.Out('};\n')
+
+    def GenerateTables(self):
+        """Generate device defintions for the platform data
+
+        This writes out C platform data initialisation data and
+        U_BOOT_DEVICE() declarations for each valid node. See the
+        documentation in README.of-plat for more information.
+        """
+        self.Out('#include <common.h>\n')
+        self.Out('#include <dm.h>\n')
+        self.Out('#include <dt-structs.h>\n')
+        self.Out('\n')
+        node_txt_list = []
+        for node in self._valid_nodes:
+            struct_name = self.GetCompatName(node)
+            var_name = Conv_name_to_c(node.name)
+            self.Buf('static struct %s%s %s%s = {\n' %
+                (STRUCT_PREFIX, struct_name, VAL_PREFIX, var_name))
+            for pname, prop in node.props.items():
+                if pname in PROP_IGNORE_LIST or pname[0] == '#':
+                    continue
+                ptype = TYPE_NAMES[prop.type]
+                member_name = Conv_name_to_c(prop.name)
+                self.Buf('\t%s= ' % TabTo(3, '.' + member_name))
+
+                # Special handling for lists
+                if type(prop.value) == list:
+                    self.Buf('{')
+                    vals = []
+                    # For phandles, output a reference to the platform data
+                    # of the target node.
+                    if self.IsPhandle(prop):
+                        # Process the list as pairs of (phandle, id)
+                        it = iter(prop.value)
+                        for phandle_cell, id_cell in zip(it, it):
+                            phandle = fdt_util.fdt32_to_cpu(phandle_cell)
+                            id = fdt_util.fdt32_to_cpu(id_cell)
+                            target_node = self._phandle_node[phandle]
+                            name = Conv_name_to_c(target_node.name)
+                            vals.append('{&%s%s, %d}' % (VAL_PREFIX, name, id))
+                    else:
+                        for val in prop.value:
+                            vals.append(self.GetValue(prop.type, val))
+                    self.Buf(', '.join(vals))
+                    self.Buf('}')
+                else:
+                    self.Buf(self.GetValue(prop.type, prop.value))
+                self.Buf(',\n')
+            self.Buf('};\n')
+
+            # Add a device declaration
+            self.Buf('U_BOOT_DEVICE(%s) = {\n' % var_name)
+            self.Buf('\t.name\t\t= "%s",\n' % struct_name)
+            self.Buf('\t.platdata\t= &%s%s,\n' % (VAL_PREFIX, var_name))
+            self.Buf('\t.platdata_size\t= sizeof(%s%s),\n' %
+                     (VAL_PREFIX, var_name))
+            self.Buf('};\n')
+            self.Buf('\n')
+
+            # Output phandle target nodes first, since they may be referenced
+            # by others
+            if 'phandle' in node.props:
+                self.Out(''.join(self.GetBuf()))
+            else:
+                node_txt_list.append(self.GetBuf())
+
+        # Output all the nodes which are not phandle targets themselves, but
+        # may reference them. This avoids the need for forward declarations.
+        for node_txt in node_txt_list:
+            self.Out(''.join(node_txt))
+
+
+if __name__ != "__main__":
+    pass
+
+parser = OptionParser()
+parser.add_option('-d', '--dtb-file', action='store',
+                  help='Specify the .dtb input file')
+parser.add_option('--include-disabled', action='store_true',
+                  help='Include disabled nodes')
+parser.add_option('-o', '--output', action='store', default='-',
+                  help='Select output filename')
+(options, args) = parser.parse_args()
+
+if not args:
+    raise ValueError('Please specify a command: struct, platdata')
+
+plat = DtbPlatdata(options.dtb_file, options)
+plat.ScanDtb()
+plat.ScanTree()
+plat.SetupOutput(options.output)
+structs = plat.ScanStructs()
+
+for cmd in args[0].split(','):
+    if cmd == 'struct':
+        plat.GenerateStructs(structs)
+    elif cmd == 'platdata':
+        plat.GenerateTables()
+    else:
+        raise ValueError("Unknown command '%s': (use: struct, platdata)" % cmd)
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h	2019-09-12 15:54:37.000000613 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware.h	1969-12-31 19:29:30.000000929 -0600
@@ -52,6 +52,8 @@
 #define KS2_DDRPHY_ZQ2CR1_OFFSET        0x1A4
 #define KS2_DDRPHY_ZQ3CR1_OFFSET        0x1B4
 
+#define KS2_DDRPHY_DATX8_2_OFFSET       0x240
+#define KS2_DDRPHY_DATX8_3_OFFSET       0x280
 #define KS2_DDRPHY_DATX8_4_OFFSET       0x2C0
 #define KS2_DDRPHY_DATX8_5_OFFSET       0x300
 #define KS2_DDRPHY_DATX8_6_OFFSET       0x340
@@ -70,6 +72,7 @@
 #define PDQ_MASK                        0x00000070
 #define NOSRA_MASK                      0x08000000
 #define ECC_MASK                        0x00000001
+#define DXEN_MASK                       0x00000001
 
 /* DDR3 definitions */
 #define KS2_DDR3A_EMIF_CTRL_BASE	0x21010000
diff -u -N U-Boot_SDcard/tools/omapimage.c U-Boot_SDcard/tools/omapimage.c
--- U-Boot_SDcard/tools/omapimage.c	2019-09-12 15:54:40.000000181 -0500
+++ U-Boot_SDcard/tools/omapimage.c	1969-12-31 19:29:19.000000653 -0600
@@ -143,7 +143,7 @@
 	toc++;
 	memset(toc, 0xff, sizeof(*toc));
 
-	gph_set_header(gph, sbuf->st_size - OMAP_FILE_HDR_SIZE,
+	gph_set_header(gph, sbuf->st_size - OMAP_CH_HDR_SIZE + GPIMAGE_HDR_SIZE,
 		       params->addr, 0);
 
 	if (strncmp(params->imagename, "byteswap", 8) == 0) {
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h	2019-09-12 15:54:21.000000096 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/cpu.h	1969-12-31 19:29:30.000000327 -0600
@@ -49,7 +49,15 @@
 #define TI81XX				0xB81E
 #define DEVICE_ID			(CTRL_BASE + 0x0600)
 #define DEVICE_ID_MASK			0x1FFF
+#define PACKAGE_TYPE_SHIFT		16
+#define PACKAGE_TYPE_MASK		(3 << 16)
 
+/* Package Type */
+#define PACKAGE_TYPE_UNDEFINED		0x0
+#define PACKAGE_TYPE_ZCZ		0x1
+#define PACKAGE_TYPE_ZCE		0x2
+#define PACKAGE_TYPE_RESERVED		0x3
+
 /* MPU max frequencies */
 #define AM335X_ZCZ_300			0x1FEF
 #define AM335X_ZCZ_600			0x1FAF
@@ -86,6 +94,9 @@
 #define WDT_WCLR_PRE		BIT(5)
 #define WDT_WCLR_PTV_OFF	2
 
+/* EMIF Control register bits */
+#define EMIF_CTRL_DEVOFF	BIT(0)
+
 #ifndef __KERNEL_STRICT_NAMES
 #ifndef __ASSEMBLY__
 
@@ -404,8 +415,19 @@
 };
 
 struct prm_device_inst {
-	unsigned int prm_rstctrl;
-	unsigned int prm_rstst;
+	unsigned int rstctrl;
+	unsigned int rstst;
+	unsigned int rsttime;
+	unsigned int sram_count;
+	unsigned int ldo_sram_core_set;	/* offset 0x10 */
+	unsigned int ldo_sram_core_ctr;
+	unsigned int ldo_sram_mpu_setu;
+	unsigned int ldo_sram_mpu_ctrl;
+	unsigned int io_count;		/* offset 0x20 */
+	unsigned int io_pmctrl;
+	unsigned int vc_val_bypass;
+	unsigned int resv1;
+	unsigned int emif_ctrl;		/* offset 0x30 */
 };
 
 struct cm_dpll {
diff -u -N U-Boot_SDcard/board/lg/sniper/sniper.c U-Boot_SDcard/board/lg/sniper/sniper.c
--- U-Boot_SDcard/board/lg/sniper/sniper.c	2019-09-12 15:54:31.000000383 -0500
+++ U-Boot_SDcard/board/lg/sniper/sniper.c	1969-12-31 19:29:26.000000471 -0600
@@ -31,7 +31,8 @@
 static const struct ns16550_platdata serial_omap_platdata = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(sniper_serial) = {
@@ -178,12 +179,10 @@
 	return omap_reboot_mode_store("b");
 }
 
-#ifndef CONFIG_SPL_BUILD
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(1, 0, 0, -1, -1);
 }
-#endif
 
 void board_mmc_power_init(void)
 {
diff -u -N /dev/null U-Boot_SDcard/cmd/rio.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/cmd/rio.c	1969-12-31 19:31:37.000000899 -0600
@@ -0,0 +1,216 @@
+/*
+ * (C) Copyright 2017
+ * Texas Instruments Incorporated, <www.ti.com>
+ * Authors: Aurelien Jacquiot <a-jacquiot@ti.com>
+ *	    WingMan Kwok <w-kwok2@ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*
+ * RapidIO support
+ */
+#include <common.h>
+#include <command.h>
+#include <mapmem.h>
+#include <asm/io.h>
+#include <watchdog.h>
+#include <rio.h>
+
+static struct udevice *rio_dev;
+
+static int do_rio_local_write(cmd_tbl_t *cmdtp, int flag, int argc,
+			      char * const argv[])
+{
+	u32 offset, val;
+	int ret;
+
+	offset = simple_strtoul(argv[0], NULL, 16);
+	   val = simple_strtoul(argv[1], NULL, 16);
+
+	ret = rio_local_config_write(rio_dev, offset, sizeof(val), val);
+	if (ret) {
+		printf("cannot perform local write\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_rio_local_read(cmd_tbl_t *cmdtp, int flag, int argc,
+			     char * const argv[])
+{
+	u32 offset, val;
+	int ret;
+
+	offset = simple_strtoul(argv[0], NULL, 16);
+
+	ret = rio_local_config_read(rio_dev, offset, sizeof(val), &val);
+	if (ret) {
+		printf("cannot perform local read\n");
+		return CMD_RET_FAILURE;
+	}
+
+	/* Display value */
+	print_buffer(offset, (const void *)&val, sizeof(val), 1, 0);
+	return CMD_RET_SUCCESS;
+}
+
+static int do_rio_write(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	int portid;
+	u16 destid;
+	u8 hopcount;
+	u32 offset;
+	u32 val;
+	int ret;
+
+	portid = simple_strtol(argv[0], NULL, 10);
+	destid = simple_strtol(argv[1], NULL, 10) & 0xffff;
+	hopcount = simple_strtoul(argv[2], NULL, 10) & 0xff;
+	offset = simple_strtoul(argv[3], NULL, 16);
+	val = simple_strtoul(argv[4], NULL, 16);
+
+	/* Do maintenance write */
+	ret = rio_config_write(rio_dev, portid, destid, hopcount,
+			       offset, sizeof(val), val);
+
+	if (ret) {
+		printf("cannot perform maintenance write\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_rio_read(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	int portid;
+	u16 destid;
+	u8 hopcount;
+	u32 offset;
+	u32 val;
+	int ret;
+
+	portid = simple_strtol(argv[0], NULL, 10);
+	destid = simple_strtol(argv[1], NULL, 10) & 0xffff;
+	hopcount = simple_strtoul(argv[2], NULL, 10) & 0xff;
+	offset = simple_strtoul(argv[3], NULL, 16);
+
+	/* Do maintenance read */
+	ret = rio_config_read(rio_dev, portid, destid, hopcount,
+			      offset, sizeof(val), &val);
+
+	if (ret) {
+		printf("cannot perform maintenance read\n");
+		return CMD_RET_FAILURE;
+	}
+
+	/* Display value */
+	print_buffer(offset, (const void *)&val, sizeof(val), 1, 0);
+	return CMD_RET_SUCCESS;
+}
+
+static int do_rio_doorbell_rx(cmd_tbl_t *cmdtp, int flag, int argc,
+			      char * const argv[])
+{
+	u32 info = 0;
+	int ret;
+
+	if (!argc)
+		return CMD_RET_USAGE;
+
+	info = simple_strtoul(argv[0], NULL, 16);
+
+	ret = rio_doorbell_rx(rio_dev, info);
+	if (!ret)
+		return CMD_RET_SUCCESS;
+
+	return CMD_RET_FAILURE;
+}
+
+static int do_rio_remove(cmd_tbl_t *cmdtp, int flag, int argc,
+			 char * const argv[])
+{
+	rio_remove(rio_dev);
+	rio_dev = NULL;
+	return CMD_RET_SUCCESS;
+}
+
+static int do_rio_devices(cmd_tbl_t *cmdtp, int flag,
+			  int argc, char * const argv[])
+{
+	struct udevice *dev;
+	int i, ret;
+
+	puts("RapidIO uclass entries:\n");
+	printf("devnum    device             driver\n");
+
+	for (i = 0, ret = uclass_first_device(UCLASS_RIO, &dev);
+	     dev;
+	     ret = uclass_next_device(&dev)) {
+		printf("  %d       %s    %s\n",
+		       i++, dev->name, dev->driver->name);
+	}
+
+	return cmd_process_error(cmdtp, ret);
+}
+
+static cmd_tbl_t rio_commands[] = {
+	U_BOOT_CMD_MKENT(devices, 0, 1, do_rio_devices, "", ""),
+	U_BOOT_CMD_MKENT(remove, 1, 0, do_rio_remove, "", ""),
+	U_BOOT_CMD_MKENT(doorbell_rx, 2, 0, do_rio_doorbell_rx, "", ""),
+	U_BOOT_CMD_MKENT(r, 5, 1, do_rio_read, "", ""),
+	U_BOOT_CMD_MKENT(w, 6, 0, do_rio_write, "", ""),
+	U_BOOT_CMD_MKENT(lr, 2, 1, do_rio_local_read, "", ""),
+	U_BOOT_CMD_MKENT(lw, 3, 0, do_rio_local_write, "", ""),
+};
+
+static int do_rio(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *rio_cmd;
+	int devnum = 0;
+	int ret;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	rio_cmd = find_cmd_tbl(argv[1], rio_commands,
+			       ARRAY_SIZE(rio_commands));
+	argc -= 2;
+	argv += 2;
+
+	if ((!rio_cmd || argc > rio_cmd->maxargs) ||
+	    ((strcmp(rio_cmd->name, "devices")) && (argc < 1)))
+		return CMD_RET_USAGE;
+
+	if (argc) {
+		devnum = simple_strtoul(argv[0], NULL, 10);
+		ret = uclass_get_device(UCLASS_RIO, devnum, &rio_dev);
+		if (ret)
+			return cmd_process_error(cmdtp, ret);
+		argc--;
+		argv++;
+	} else {
+		rio_dev = NULL;
+		if (rio_cmd->cmd != do_rio_devices)
+			return CMD_RET_USAGE;
+	}
+
+	ret = rio_cmd->cmd(rio_cmd, flag, argc, argv);
+
+	return cmd_process_error(rio_cmd, ret);
+}
+
+U_BOOT_CMD(rio, CONFIG_SYS_MAXARGS, 0, do_rio,
+	   "RapidIO sub-system",
+	   "devices - show available RapidIO devices\n"
+	   "rio remove <devnum> - remove RapidIO device\n"
+	   "rio doorbell_rx <devnum> [info] - blocking wait for doorbell info\n"
+	   "rio r <devnum> port dst_id hopcount offset - perform config read\n"
+	   "rio w <devnum> port dst_id hopcount offset value - perform config write\n"
+	   "rio lr <devnum> offset - perform local config read\n"
+	   "rio lw <devnum> offset value - perform local config write\n"
+);
diff -u -N U-Boot_SDcard/common/env_sf.c U-Boot_SDcard/common/env_sf.c
--- U-Boot_SDcard/common/env_sf.c	2019-09-12 15:54:35.000000536 -0500
+++ U-Boot_SDcard/common/env_sf.c	1969-12-31 19:29:17.000000491 -0600
@@ -28,7 +28,7 @@
 # define CONFIG_ENV_SPI_MAX_HZ	1000000
 #endif
 #ifndef CONFIG_ENV_SPI_MODE
-# define CONFIG_ENV_SPI_MODE	SPI_MODE_3
+# define CONFIG_ENV_SPI_MODE	CONFIG_SF_DEFAULT_MODE
 #endif
 
 #ifdef CONFIG_ENV_OFFSET_REDUND
diff -u -N U-Boot_SDcard/Makefile U-Boot_SDcard/Makefile
--- U-Boot_SDcard/Makefile	2019-09-12 15:54:58.000000537 -0500
+++ U-Boot_SDcard/Makefile	1969-12-31 19:29:17.000000030 -0600
@@ -1,1635 +1,1651 @@
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-VERSION = 2017
-PATCHLEVEL = 01
-SUBLEVEL =
-EXTRAVERSION =
-NAME =
-
-# *DOCUMENTATION*
-# To see a list of typical targets execute "make help"
-# More info can be located in ./README
-# Comments in this file are targeted only to the developer, do not
-# expect to learn how to build the kernel reading this file.
-
-# o Do not use make's built-in rules and variables
-#   (this increases performance and avoids hard-to-debug behaviour);
-# o Look for make include files relative to root of kernel src
-MAKEFLAGS += -rR --include-dir=$(CURDIR)
-
-# Avoid funny character set dependencies
-unexport LC_ALL
-LC_COLLATE=C
-LC_NUMERIC=C
-export LC_COLLATE LC_NUMERIC
-
-# Avoid interference with shell env settings
-unexport GREP_OPTIONS
-
-# We are using a recursive build, so we need to do a little thinking
-# to get the ordering right.
-#
-# Most importantly: sub-Makefiles should only ever modify files in
-# their own directory. If in some directory we have a dependency on
-# a file in another dir (which doesn't happen often, but it's often
-# unavoidable when linking the built-in.o targets which finally
-# turn into vmlinux), we will call a sub make in that other dir, and
-# after that we are sure that everything which is in that other dir
-# is now up to date.
-#
-# The only cases where we need to modify files which have global
-# effects are thus separated out and done before the recursive
-# descending is started. They are now explicitly listed as the
-# prepare rule.
-
-# Beautify output
-# ---------------------------------------------------------------------------
-#
-# Normally, we echo the whole command before executing it. By making
-# that echo $($(quiet)$(cmd)), we now have the possibility to set
-# $(quiet) to choose other forms of output instead, e.g.
-#
-#         quiet_cmd_cc_o_c = Compiling $(RELDIR)/$@
-#         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
-#
-# If $(quiet) is empty, the whole command will be printed.
-# If it is set to "quiet_", only the short version will be printed.
-# If it is set to "silent_", nothing will be printed at all, since
-# the variable $(silent_cmd_cc_o_c) doesn't exist.
-#
-# A simple variant is to prefix commands with $(Q) - that's useful
-# for commands that shall be hidden in non-verbose mode.
-#
-#	$(Q)ln $@ :<
-#
-# If KBUILD_VERBOSE equals 0 then the above command will be hidden.
-# If KBUILD_VERBOSE equals 1 then the above command is displayed.
-#
-# To put more focus on warnings, be less verbose as default
-# Use 'make V=1' to see the full commands
-
-ifeq ("$(origin V)", "command line")
-  KBUILD_VERBOSE = $(V)
-endif
-ifndef KBUILD_VERBOSE
-  KBUILD_VERBOSE = 0
-endif
-
-ifeq ($(KBUILD_VERBOSE),1)
-  quiet =
-  Q =
-else
-  quiet=quiet_
-  Q = @
-endif
-
-# If the user is running make -s (silent mode), suppress echoing of
-# commands
-
-ifneq ($(filter 4.%,$(MAKE_VERSION)),)	# make-4
-ifneq ($(filter %s ,$(firstword x$(MAKEFLAGS))),)
-  quiet=silent_
-endif
-else					# make-3.8x
-ifneq ($(filter s% -s%,$(MAKEFLAGS)),)
-  quiet=silent_
-endif
-endif
-
-export quiet Q KBUILD_VERBOSE
-
-# kbuild supports saving output files in a separate directory.
-# To locate output files in a separate directory two syntaxes are supported.
-# In both cases the working directory must be the root of the kernel src.
-# 1) O=
-# Use "make O=dir/to/store/output/files/"
-#
-# 2) Set KBUILD_OUTPUT
-# Set the environment variable KBUILD_OUTPUT to point to the directory
-# where the output files shall be placed.
-# export KBUILD_OUTPUT=dir/to/store/output/files/
-# make
-#
-# The O= assignment takes precedence over the KBUILD_OUTPUT environment
-# variable.
-
-# KBUILD_SRC is set on invocation of make in OBJ directory
-# KBUILD_SRC is not intended to be used by the regular user (for now)
-ifeq ($(KBUILD_SRC),)
-
-# OK, Make called in directory where kernel src resides
-# Do we want to locate output files in a separate directory?
-ifeq ("$(origin O)", "command line")
-  KBUILD_OUTPUT := $(O)
-endif
-
-# That's our default target when none is given on the command line
-PHONY := _all
-_all:
-
-# Cancel implicit rules on top Makefile
-$(CURDIR)/Makefile Makefile: ;
-
-ifneq ($(KBUILD_OUTPUT),)
-# Invoke a second make in the output directory, passing relevant variables
-# check that the output directory actually exists
-saved-output := $(KBUILD_OUTPUT)
-KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) \
-								&& /bin/pwd)
-$(if $(KBUILD_OUTPUT),, \
-     $(error failed to create output directory "$(saved-output)"))
-
-PHONY += $(MAKECMDGOALS) sub-make
-
-$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
-	@:
-
-sub-make: FORCE
-	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
-	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))
-
-# Leave processing to above invocation of make
-skip-makefile := 1
-endif # ifneq ($(KBUILD_OUTPUT),)
-endif # ifeq ($(KBUILD_SRC),)
-
-# We process the rest of the Makefile if this is the final invocation of make
-ifeq ($(skip-makefile),)
-
-# Do not print "Entering directory ...",
-# but we want to display it when entering to the output directory
-# so that IDEs/editors are able to understand relative filenames.
-MAKEFLAGS += --no-print-directory
-
-# Call a source code checker (by default, "sparse") as part of the
-# C compilation.
-#
-# Use 'make C=1' to enable checking of only re-compiled files.
-# Use 'make C=2' to enable checking of *all* source files, regardless
-# of whether they are re-compiled or not.
-#
-# See the file "Documentation/sparse.txt" for more details, including
-# where to get the "sparse" utility.
-
-ifeq ("$(origin C)", "command line")
-  KBUILD_CHECKSRC = $(C)
-endif
-ifndef KBUILD_CHECKSRC
-  KBUILD_CHECKSRC = 0
-endif
-
-# Use make M=dir to specify directory of external module to build
-# Old syntax make ... SUBDIRS=$PWD is still supported
-# Setting the environment variable KBUILD_EXTMOD take precedence
-ifdef SUBDIRS
-  KBUILD_EXTMOD ?= $(SUBDIRS)
-endif
-
-ifeq ("$(origin M)", "command line")
-  KBUILD_EXTMOD := $(M)
-endif
-
-# If building an external module we do not care about the all: rule
-# but instead _all depend on modules
-PHONY += all
-ifeq ($(KBUILD_EXTMOD),)
-_all: all
-else
-_all: modules
-endif
-
-ifeq ($(KBUILD_SRC),)
-        # building in the source tree
-        srctree := .
-else
-        ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))
-                # building in a subdirectory of the source tree
-                srctree := ..
-        else
-                srctree := $(KBUILD_SRC)
-        endif
-endif
-objtree		:= .
-src		:= $(srctree)
-obj		:= $(objtree)
-
-VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
-
-export srctree objtree VPATH
-
-# Make sure CDPATH settings don't interfere
-unexport CDPATH
-
-#########################################################################
-
-HOSTARCH := $(shell uname -m | \
-	sed -e s/i.86/x86/ \
-	    -e s/sun4u/sparc64/ \
-	    -e s/arm.*/arm/ \
-	    -e s/sa110/arm/ \
-	    -e s/ppc64/powerpc/ \
-	    -e s/ppc/powerpc/ \
-	    -e s/macppc/powerpc/\
-	    -e s/sh.*/sh/)
-
-HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
-	    sed -e 's/\(cygwin\).*/cygwin/')
-
-export	HOSTARCH HOSTOS
-
-#########################################################################
-
-# set default to nothing for native builds
-ifeq ($(HOSTARCH),$(ARCH))
-CROSS_COMPILE ?=
-endif
-
-KCONFIG_CONFIG	?= .config
-export KCONFIG_CONFIG
-
-# SHELL used by kbuild
-CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
-	  else if [ -x /bin/bash ]; then echo /bin/bash; \
-	  else echo sh; fi ; fi)
-
-HOSTCC       = cc
-HOSTCXX      = c++
-HOSTCFLAGS   = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \
-		$(if $(CONFIG_TOOLS_DEBUG),-g)
-HOSTCXXFLAGS = -O2
-
-ifeq ($(HOSTOS),cygwin)
-HOSTCFLAGS	+= -ansi
-endif
-
-# Mac OS X / Darwin's C preprocessor is Apple specific.  It
-# generates numerous errors and warnings.  We want to bypass it
-# and use GNU C's cpp.	To do this we pass the -traditional-cpp
-# option to the compiler.  Note that the -traditional-cpp flag
-# DOES NOT have the same semantics as GNU C's flag, all it does
-# is invoke the GNU preprocessor in stock ANSI/ISO C fashion.
-#
-# Apple's linker is similar, thanks to the new 2 stage linking
-# multiple symbol definitions are treated as errors, hence the
-# -multiply_defined suppress option to turn off this error.
-#
-ifeq ($(HOSTOS),darwin)
-# get major and minor product version (e.g. '10' and '6' for Snow Leopard)
-DARWIN_MAJOR_VERSION	= $(shell sw_vers -productVersion | cut -f 1 -d '.')
-DARWIN_MINOR_VERSION	= $(shell sw_vers -productVersion | cut -f 2 -d '.')
-
-os_x_before	= $(shell if [ $(DARWIN_MAJOR_VERSION) -le $(1) -a \
-	$(DARWIN_MINOR_VERSION) -le $(2) ] ; then echo "$(3)"; else echo "$(4)"; fi ;)
-
-# Snow Leopards build environment has no longer restrictions as described above
-HOSTCC       = $(call os_x_before, 10, 5, "cc", "gcc")
-HOSTCFLAGS  += $(call os_x_before, 10, 4, "-traditional-cpp")
-HOSTLDFLAGS += $(call os_x_before, 10, 5, "-multiply_defined suppress")
-
-# since Lion (10.7) ASLR is on by default, but we use linker generated lists
-# in some host tools which is a problem then ... so disable ASLR for these
-# tools
-HOSTLDFLAGS += $(call os_x_before, 10, 7, "", "-Xlinker -no_pie")
-endif
-
-# Decide whether to build built-in, modular, or both.
-# Normally, just do built-in.
-
-KBUILD_MODULES :=
-KBUILD_BUILTIN := 1
-
-# If we have only "make modules", don't compile built-in objects.
-# When we're building modules with modversions, we need to consider
-# the built-in objects during the descend as well, in order to
-# make sure the checksums are up to date before we record them.
-
-ifeq ($(MAKECMDGOALS),modules)
-  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
-endif
-
-# If we have "make <whatever> modules", compile modules
-# in addition to whatever we do anyway.
-# Just "make" or "make all" shall build modules as well
-
-# U-Boot does not need modules
-#ifneq ($(filter all _all modules,$(MAKECMDGOALS)),)
-#  KBUILD_MODULES := 1
-#endif
-
-#ifeq ($(MAKECMDGOALS),)
-#  KBUILD_MODULES := 1
-#endif
-
-export KBUILD_MODULES KBUILD_BUILTIN
-export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
-
-# We need some generic definitions (do not try to remake the file).
-scripts/Kbuild.include: ;
-include scripts/Kbuild.include
-
-# Make variables (CC, etc...)
-
-AS		= $(CROSS_COMPILE)as
-# Always use GNU ld
-ifneq ($(shell $(CROSS_COMPILE)ld.bfd -v 2> /dev/null),)
-LD		= $(CROSS_COMPILE)ld.bfd
-else
-LD		= $(CROSS_COMPILE)ld
-endif
-CC		= $(CROSS_COMPILE)gcc
-CPP		= $(CC) -E
-AR		= $(CROSS_COMPILE)ar
-NM		= $(CROSS_COMPILE)nm
-LDR		= $(CROSS_COMPILE)ldr
-STRIP		= $(CROSS_COMPILE)strip
-OBJCOPY		= $(CROSS_COMPILE)objcopy
-OBJDUMP		= $(CROSS_COMPILE)objdump
-AWK		= awk
-PERL		= perl
-PYTHON		= python
-DTC		= dtc
-CHECK		= sparse
-
-CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
-		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)
-
-KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__
-
-KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
-		   -Wno-format-security \
-		   -fno-builtin -ffreestanding
-KBUILD_AFLAGS   := -D__ASSEMBLY__
-
-# Read UBOOTRELEASE from include/config/uboot.release (if it exists)
-UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
-UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
-
-export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
-export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
-export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
-export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
-export MAKE AWK PERL PYTHON
-export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS
-
-export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
-export KBUILD_CFLAGS KBUILD_AFLAGS
-
-# When compiling out-of-tree modules, put MODVERDIR in the module
-# tree rather than in the kernel tree. The kernel tree might
-# even be read-only.
-export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_versions
-
-# Files to ignore in find ... statements
-
-export RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o    \
-			  -name CVS -o -name .pc -o -name .hg -o -name .git \) \
-			  -prune -o
-export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
-			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
-
-# ===========================================================================
-# Rules shared between *config targets and build targets
-
-# Basic helpers built in scripts/
-PHONY += scripts_basic
-scripts_basic:
-	$(Q)$(MAKE) $(build)=scripts/basic
-	$(Q)rm -f .tmp_quiet_recordmcount
-
-# To avoid any implicit rule to kick in, define an empty command.
-scripts/basic/%: scripts_basic ;
-
-PHONY += outputmakefile
-# outputmakefile generates a Makefile in the output directory, if using a
-# separate output directory. This allows convenient use of make in the
-# output directory.
-outputmakefile:
-ifneq ($(KBUILD_SRC),)
-	$(Q)ln -fsn $(srctree) source
-	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
-	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
-endif
-
-# To make sure we do not include .config for any of the *config targets
-# catch them early, and hand them over to scripts/kconfig/Makefile
-# It is allowed to specify more targets when calling make, including
-# mixing *config targets and build targets.
-# For example 'make oldconfig all'.
-# Detect when mixed targets is specified, and make a second invocation
-# of make so .config is not included in this case either (for *config).
-
-version_h := include/generated/version_autogenerated.h
-timestamp_h := include/generated/timestamp_autogenerated.h
-
-no-dot-config-targets := clean clobber mrproper distclean \
-			 help %docs check% coccicheck \
-			 ubootversion backup tests
-
-config-targets := 0
-mixed-targets  := 0
-dot-config     := 1
-
-ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
-	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
-		dot-config := 0
-	endif
-endif
-
-ifeq ($(KBUILD_EXTMOD),)
-        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
-                config-targets := 1
-                ifneq ($(words $(MAKECMDGOALS)),1)
-                        mixed-targets := 1
-                endif
-        endif
-endif
-
-ifeq ($(mixed-targets),1)
-# ===========================================================================
-# We're called with mixed targets (*config and build targets).
-# Handle them one by one.
-
-PHONY += $(MAKECMDGOALS) __build_one_by_one
-
-$(filter-out __build_one_by_one, $(MAKECMDGOALS)): __build_one_by_one
-	@:
-
-__build_one_by_one:
-	$(Q)set -e; \
-	for i in $(MAKECMDGOALS); do \
-		$(MAKE) -f $(srctree)/Makefile $$i; \
-	done
-
-else
-ifeq ($(config-targets),1)
-# ===========================================================================
-# *config targets only - make sure prerequisites are updated, and descend
-# in scripts/kconfig to make the *config target
-
-KBUILD_DEFCONFIG := sandbox_defconfig
-export KBUILD_DEFCONFIG KBUILD_KCONFIG
-
-config: scripts_basic outputmakefile FORCE
-	$(Q)$(MAKE) $(build)=scripts/kconfig $@
-
-%config: scripts_basic outputmakefile FORCE
-	$(Q)$(MAKE) $(build)=scripts/kconfig $@
-
-else
-# ===========================================================================
-# Build targets only - this includes vmlinux, arch specific targets, clean
-# targets and others. In general all targets except *config targets.
-
-ifeq ($(dot-config),1)
-# Read in config
--include include/config/auto.conf
-
-# Read in dependencies to all Kconfig* files, make sure to run
-# oldconfig if changes are detected.
--include include/config/auto.conf.cmd
-
-# To avoid any implicit rule to kick in, define an empty command
-$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
-
-# If .config is newer than include/config/auto.conf, someone tinkered
-# with it and forgot to run make oldconfig.
-# if auto.conf.cmd is missing then we are probably in a cleaned tree so
-# we execute the config step to be sure to catch updated Kconfig files
-include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
-	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
-	@# If the following part fails, include/config/auto.conf should be
-	@# deleted so "make silentoldconfig" will be re-run on the next build.
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.autoconf || \
-		{ rm -f include/config/auto.conf; false; }
-	@# include/config.h has been updated after "make silentoldconfig".
-	@# We need to touch include/config/auto.conf so it gets newer
-	@# than include/config.h.
-	@# Otherwise, 'make silentoldconfig' would be invoked twice.
-	$(Q)touch include/config/auto.conf
-
--include include/autoconf.mk
--include include/autoconf.mk.dep
-
-# We want to include arch/$(ARCH)/config.mk only when include/config/auto.conf
-# is up-to-date. When we switch to a different board configuration, old CONFIG
-# macros are still remaining in include/config/auto.conf. Without the following
-# gimmick, wrong config.mk would be included leading nasty warnings/errors.
-ifneq ($(wildcard $(KCONFIG_CONFIG)),)
-ifneq ($(wildcard include/config/auto.conf),)
-autoconf_is_old := $(shell find . -path ./$(KCONFIG_CONFIG) -newer \
-						include/config/auto.conf)
-ifeq ($(autoconf_is_old),)
-include config.mk
-include arch/$(ARCH)/Makefile
-endif
-endif
-endif
-
-# These are set by the arch-specific config.mk. Make sure they are exported
-# so they can be used when building an EFI application.
-export EFI_LDS		# Filename of EFI link script in arch/$(ARCH)/lib
-export EFI_CRT0		# Filename of EFI CRT0 in arch/$(ARCH)/lib
-export EFI_RELOC	# Filename of EFU relocation code in arch/$(ARCH)/lib
-export CFLAGS_EFI	# Compiler flags to add when building EFI app
-export CFLAGS_NON_EFI	# Compiler flags to remove when building EFI app
-export EFI_TARGET	# binutils target if EFI is natively supported
-
-# If board code explicitly specified LDSCRIPT or CONFIG_SYS_LDSCRIPT, use
-# that (or fail if absent).  Otherwise, search for a linker script in a
-# standard location.
-
-ifndef LDSCRIPT
-	#LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds.debug
-	ifdef CONFIG_SYS_LDSCRIPT
-		# need to strip off double quotes
-		LDSCRIPT := $(srctree)/$(CONFIG_SYS_LDSCRIPT:"%"=%)
-	endif
-endif
-
-# If there is no specified link script, we look in a number of places for it
-ifndef LDSCRIPT
-	ifeq ($(wildcard $(LDSCRIPT)),)
-		LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds
-	endif
-	ifeq ($(wildcard $(LDSCRIPT)),)
-		LDSCRIPT := $(srctree)/$(CPUDIR)/u-boot.lds
-	endif
-	ifeq ($(wildcard $(LDSCRIPT)),)
-		LDSCRIPT := $(srctree)/arch/$(ARCH)/cpu/u-boot.lds
-	endif
-endif
-
-else
-# Dummy target needed, because used as prerequisite
-include/config/auto.conf: ;
-endif # $(dot-config)
-
-#
-# Xtensa linker script cannot be preprocessed with -ansi because of
-# preprocessor operations on strings that don't make C identifiers.
-#
-ifeq ($(CONFIG_XTENSA),)
-LDPPFLAGS	+= -ansi
-endif
-
-ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
-KBUILD_CFLAGS	+= -Os
-else
-KBUILD_CFLAGS	+= -O2
-endif
-
-KBUILD_CFLAGS += $(call cc-option,-fno-stack-protector)
-KBUILD_CFLAGS += $(call cc-option,-fno-delete-null-pointer-checks)
-
-KBUILD_CFLAGS	+= -g
-# $(KBUILD_AFLAGS) sets -g, which causes gcc to pass a suitable -g<format>
-# option to the assembler.
-KBUILD_AFLAGS	+= -g
-
-# Report stack usage if supported
-ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-stack-usage.sh $(CC)),y)
-	KBUILD_CFLAGS += -fstack-usage
-endif
-
-KBUILD_CFLAGS += $(call cc-option,-Wno-format-nonliteral)
-
-# turn jbsr into jsr for m68k
-ifeq ($(ARCH),m68k)
-ifeq ($(findstring 3.4,$(shell $(CC) --version)),3.4)
-KBUILD_AFLAGS += -Wa,-gstabs,-S
-endif
-endif
-
-# Prohibit date/time macros, which would make the build non-deterministic
-KBUILD_CFLAGS   += $(call cc-option,-Werror=date-time)
-
-include scripts/Makefile.extrawarn
-
-# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
-KBUILD_CPPFLAGS += $(KCPPFLAGS)
-KBUILD_AFLAGS += $(KAFLAGS)
-KBUILD_CFLAGS += $(KCFLAGS)
-
-# Use UBOOTINCLUDE when you must reference the include/ directory.
-# Needed to be compatible with the O= option
-UBOOTINCLUDE    := \
-		-Iinclude \
-		$(if $(KBUILD_SRC), -I$(srctree)/include) \
-		$(if $(CONFIG_SYS_THUMB_BUILD), $(if $(CONFIG_HAS_THUMB2),, \
-			-I$(srctree)/arch/$(ARCH)/thumb1/include),) \
-		-I$(srctree)/arch/$(ARCH)/include \
-		-include $(srctree)/include/linux/kconfig.h
-
-NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
-CHECKFLAGS     += $(NOSTDINC_FLAGS)
-
-# FIX ME
-cpp_flags := $(KBUILD_CPPFLAGS) $(PLATFORM_CPPFLAGS) $(UBOOTINCLUDE) \
-							$(NOSTDINC_FLAGS)
-c_flags := $(KBUILD_CFLAGS) $(cpp_flags)
-
-#########################################################################
-# U-Boot objects....order is important (i.e. start must be first)
-
-HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makefile),y,n)
-
-libs-y += lib/
-libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
-libs-$(CONFIG_OF_EMBED) += dts/
-libs-y += fs/
-libs-y += net/
-libs-y += disk/
-libs-y += drivers/
-libs-y += drivers/dma/
-libs-y += drivers/gpio/
-libs-y += drivers/i2c/
-libs-y += drivers/mmc/
-libs-y += drivers/mtd/
-libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
-libs-y += drivers/mtd/onenand/
-libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
-libs-y += drivers/mtd/spi/
-libs-y += drivers/net/
-libs-y += drivers/net/phy/
-libs-y += drivers/pci/
-libs-y += drivers/power/ \
-	drivers/power/domain/ \
-	drivers/power/fuel_gauge/ \
-	drivers/power/mfd/ \
-	drivers/power/pmic/ \
-	drivers/power/battery/ \
-	drivers/power/regulator/
-libs-y += drivers/spi/
-libs-$(CONFIG_FMAN_ENET) += drivers/net/fm/
-libs-$(CONFIG_SYS_FSL_DDR) += drivers/ddr/fsl/
-libs-$(CONFIG_SYS_FSL_MMDC) += drivers/ddr/fsl/
-libs-$(CONFIG_ALTERA_SDRAM) += drivers/ddr/altera/
-libs-y += drivers/serial/
-libs-y += drivers/usb/dwc3/
-libs-y += drivers/usb/common/
-libs-y += drivers/usb/emul/
-libs-y += drivers/usb/eth/
-libs-y += drivers/usb/gadget/
-libs-y += drivers/usb/gadget/udc/
-libs-y += drivers/usb/host/
-libs-y += drivers/usb/musb/
-libs-y += drivers/usb/musb-new/
-libs-y += drivers/usb/phy/
-libs-y += drivers/usb/ulpi/
-libs-y += cmd/
-libs-y += common/
-libs-$(CONFIG_API) += api/
-libs-$(CONFIG_HAS_POST) += post/
-libs-y += test/
-libs-y += test/dm/
-libs-$(CONFIG_UT_ENV) += test/env/
-libs-$(CONFIG_UT_OVERLAY) += test/overlay/
-
-libs-y += $(if $(BOARDDIR),board/$(BOARDDIR)/)
-
-libs-y := $(sort $(libs-y))
-
-u-boot-dirs	:= $(patsubst %/,%,$(filter %/, $(libs-y))) tools examples
-
-u-boot-alldirs	:= $(sort $(u-boot-dirs) $(patsubst %/,%,$(filter %/, $(libs-))))
-
-libs-y		:= $(patsubst %/, %/built-in.o, $(libs-y))
-
-u-boot-init := $(head-y)
-u-boot-main := $(libs-y)
-
-
-# Add GCC lib
-ifeq ($(CONFIG_USE_PRIVATE_LIBGCC),y)
-PLATFORM_LIBGCC = arch/$(ARCH)/lib/lib.a
-else
-PLATFORM_LIBGCC := -L $(shell dirname `$(CC) $(c_flags) -print-libgcc-file-name`) -lgcc
-endif
-PLATFORM_LIBS += $(PLATFORM_LIBGCC)
-export PLATFORM_LIBS
-export PLATFORM_LIBGCC
-
-# Special flags for CPP when processing the linker script.
-# Pass the version down so we can handle backwards compatibility
-# on the fly.
-LDPPFLAGS += \
-	-include $(srctree)/include/u-boot/u-boot.lds.h \
-	-DCPUDIR=$(CPUDIR) \
-	$(shell $(LD) --version | \
-	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
-
-#########################################################################
-#########################################################################
-
-ifneq ($(CONFIG_BOARD_SIZE_LIMIT),)
-BOARD_SIZE_CHECK = \
-	@actual=`wc -c $@ | awk '{print $$1}'`; \
-	limit=`printf "%d" $(CONFIG_BOARD_SIZE_LIMIT)`; \
-	if test $$actual -gt $$limit; then \
-		echo "$@ exceeds file size limit:" >&2 ; \
-		echo "  limit:  $$limit bytes" >&2 ; \
-		echo "  actual: $$actual bytes" >&2 ; \
-		echo "  excess: $$((actual - limit)) bytes" >&2; \
-		exit 1; \
-	fi
-else
-BOARD_SIZE_CHECK =
-endif
-
-# Statically apply RELA-style relocations (currently arm64 only)
-ifneq ($(CONFIG_STATIC_RELA),)
-# $(1) is u-boot ELF, $(2) is u-boot bin, $(3) is text base
-DO_STATIC_RELA = \
-	start=$$($(NM) $(1) | grep __rel_dyn_start | cut -f 1 -d ' '); \
-	end=$$($(NM) $(1) | grep __rel_dyn_end | cut -f 1 -d ' '); \
-	tools/relocate-rela $(2) $(3) $$start $$end
-else
-DO_STATIC_RELA =
-endif
-
-# Always append ALL so that arch config.mk's can add custom ones
-ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check
-
-ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin
-ifeq ($(CONFIG_SPL_FSL_PBL),y)
-ALL-$(CONFIG_RAMBOOT_PBL) += u-boot-with-spl-pbl.bin
-else
-ifneq ($(CONFIG_SECURE_BOOT), y)
-# For Secure Boot The Image needs to be signed and Header must also
-# be included. So The image has to be built explicitly
-ALL-$(CONFIG_RAMBOOT_PBL) += u-boot.pbl
-endif
-endif
-ALL-$(CONFIG_SPL) += spl/u-boot-spl.bin
-ifeq ($(CONFIG_MX6)$(CONFIG_SECURE_BOOT), yy)
-ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot-ivt.img
-else
-ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot.img
-endif
-ALL-$(CONFIG_TPL) += tpl/u-boot-tpl.bin
-ALL-$(CONFIG_OF_SEPARATE) += u-boot.dtb
-ifeq ($(CONFIG_SPL_FRAMEWORK),y)
-ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb.img
-endif
-ALL-$(CONFIG_OF_HOSTFILE) += u-boot.dtb
-ifneq ($(CONFIG_SPL_TARGET),)
-ALL-$(CONFIG_SPL) += $(CONFIG_SPL_TARGET:"%"=%)
-endif
-ALL-$(CONFIG_REMAKE_ELF) += u-boot.elf
-ALL-$(CONFIG_EFI_APP) += u-boot-app.efi
-ALL-$(CONFIG_EFI_STUB) += u-boot-payload.efi
-
-ifneq ($(BUILD_ROM),)
-ALL-$(CONFIG_X86_RESET_VECTOR) += u-boot.rom
-endif
-
-# enable combined SPL/u-boot/dtb rules for tegra
-ifeq ($(CONFIG_TEGRA)$(CONFIG_SPL),yy)
-ALL-y += u-boot-tegra.bin u-boot-nodtb-tegra.bin
-ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb-tegra.bin
-endif
-
-# Add optional build target if defined in board/cpu/soc headers
-ifneq ($(CONFIG_BUILD_TARGET),)
-ALL-y += $(CONFIG_BUILD_TARGET:"%"=%)
-endif
-
-LDFLAGS_u-boot += $(LDFLAGS_FINAL)
-ifneq ($(CONFIG_SYS_TEXT_BASE),)
-LDFLAGS_u-boot += -Ttext $(CONFIG_SYS_TEXT_BASE)
-endif
-
-# Normally we fill empty space with 0xff
-quiet_cmd_objcopy = OBJCOPY $@
-cmd_objcopy = $(OBJCOPY) --gap-fill=0xff $(OBJCOPYFLAGS) \
-	$(OBJCOPYFLAGS_$(@F)) $< $@
-
-# Provide a version which does not do this, for use by EFI
-quiet_cmd_zobjcopy = OBJCOPY $@
-cmd_zobjcopy = $(OBJCOPY) $(OBJCOPYFLAGS) $(OBJCOPYFLAGS_$(@F)) $< $@
-
-quiet_cmd_efipayload = OBJCOPY $@
-cmd_efipayload = $(OBJCOPY) -I binary -O $(EFIPAYLOAD_BFDTARGET) -B $(EFIPAYLOAD_BFDARCH) $< $@
-
-MKIMAGEOUTPUT ?= /dev/null
-
-quiet_cmd_mkimage = MKIMAGE $@
-cmd_mkimage = $(objtree)/tools/mkimage $(MKIMAGEFLAGS_$(@F)) -d $< $@ \
-	$(if $(KBUILD_VERBOSE:1=), >$(MKIMAGEOUTPUT))
-
-quiet_cmd_cat = CAT     $@
-cmd_cat = cat $(filter-out $(PHONY), $^) > $@
-
-append = cat $(filter-out $< $(PHONY), $^) >> $@
-
-quiet_cmd_pad_cat = CAT     $@
-cmd_pad_cat = $(cmd_objcopy) && $(append) || rm -f $@
-
-cfg: u-boot.cfg
-
-all:		$(ALL-y)
-ifeq ($(CONFIG_DM_I2C_COMPAT)$(CONFIG_SANDBOX),y)
-	@echo "===================== WARNING ======================"
-	@echo "This board uses CONFIG_DM_I2C_COMPAT. Please remove"
-	@echo "(possibly in a subsequent patch in your series)"
-	@echo "before sending patches to the mailing list."
-	@echo "===================================================="
-endif
-	@# Check that this build does not use CONFIG options that we do not
-	@# know about unless they are in Kconfig. All the existing CONFIG
-	@# options are whitelisted, so new ones should not be added.
-	$(srctree)/scripts/check-config.sh u-boot.cfg \
-		$(srctree)/scripts/config_whitelist.txt ${srctree} 1>&2
-
-PHONY += dtbs
-dtbs: dts/dt.dtb
-	@:
-dts/dt.dtb: checkdtc u-boot
-	$(Q)$(MAKE) $(build)=dts dtbs
-
-quiet_cmd_copy = COPY    $@
-      cmd_copy = cp $< $@
-
-ifeq ($(CONFIG_OF_SEPARATE),y)
-u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE
-	$(call if_changed,cat)
-
-u-boot.bin: u-boot-dtb.bin FORCE
-	$(call if_changed,copy)
-else
-u-boot.bin: u-boot-nodtb.bin FORCE
-	$(call if_changed,copy)
-endif
-
-%.imx: %.bin
-	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
-
-%.vyb: %.imx
-	$(Q)$(MAKE) $(build)=arch/arm/cpu/armv7/vf610 $@
-
-quiet_cmd_copy = COPY    $@
-      cmd_copy = cp $< $@
-
-u-boot.dtb: dts/dt.dtb
-	$(call cmd,copy)
-
-OBJCOPYFLAGS_u-boot.hex := -O ihex
-
-OBJCOPYFLAGS_u-boot.srec := -O srec
-
-u-boot.hex u-boot.srec: u-boot FORCE
-	$(call if_changed,objcopy)
-
-OBJCOPYFLAGS_u-boot-nodtb.bin := -O binary \
-		$(if $(CONFIG_X86_RESET_VECTOR),-R .start16 -R .resetvec)
-
-binary_size_check: u-boot-nodtb.bin FORCE
-	@file_size=$(shell wc -c u-boot-nodtb.bin | awk '{print $$1}') ; \
-	map_size=$(shell cat u-boot.map | \
-		awk '/_image_copy_start/ {start = $$1} /_image_binary_end/ {end = $$1} END {if (start != "" && end != "") print "ibase=16; " toupper(end) " - " toupper(start)}' \
-		| sed 's/0X//g' \
-		| bc); \
-	if [ "" != "$$map_size" ]; then \
-		if test $$map_size -ne $$file_size; then \
-			echo "u-boot.map shows a binary size of $$map_size" >&2 ; \
-			echo "  but u-boot-nodtb.bin shows $$file_size" >&2 ; \
-			exit 1; \
-		fi \
-	fi
-
-u-boot-nodtb.bin: u-boot FORCE
-	$(call if_changed,objcopy)
-	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
-	$(BOARD_SIZE_CHECK)
-
-u-boot.ldr:	u-boot
-		$(CREATE_LDR_ENV)
-		$(LDR) -T $(CONFIG_CPU) -c $@ $< $(LDR_FLAGS)
-		$(BOARD_SIZE_CHECK)
-
-# binman
-# ---------------------------------------------------------------------------
-quiet_cmd_binman = BINMAN  $@
-cmd_binman = $(srctree)/tools/binman/binman -d u-boot.dtb -O . \
-		-I . -I $(srctree)/board/$(BOARDDIR) $<
-
-OBJCOPYFLAGS_u-boot.ldr.hex := -I binary -O ihex
-
-OBJCOPYFLAGS_u-boot.ldr.srec := -I binary -O srec
-
-u-boot.ldr.hex u-boot.ldr.srec: u-boot.ldr FORCE
-	$(call if_changed,objcopy)
-
-#
-# U-Boot entry point, needed for booting of full-blown U-Boot
-# from the SPL U-Boot version.
-#
-ifndef CONFIG_SYS_UBOOT_START
-CONFIG_SYS_UBOOT_START := 0
-endif
-
-# Create a file containing the configuration options the image was built with
-quiet_cmd_cpp_cfg = CFG     $@
-cmd_cpp_cfg = $(CPP) -Wp,-MD,$(depfile) $(cpp_flags) $(LDPPFLAGS) -ansi \
-	-DDO_DEPS_ONLY -D__ASSEMBLY__ -x assembler-with-cpp -P -dM -E -o $@ $<
-
-ifdef CONFIG_SPL_LOAD_FIT
-MKIMAGEFLAGS_u-boot.img = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
-	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
-	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board" -E \
-	$(patsubst %,-b arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST)))
-else
-MKIMAGEFLAGS_u-boot.img = -A $(ARCH) -T firmware -C none -O u-boot \
-	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
-	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board"
-MKIMAGEFLAGS_u-boot-ivt.img = -A $(ARCH) -T firmware_ivt -C none -O u-boot \
-	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
-	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board"
-u-boot-ivt.img: MKIMAGEOUTPUT = u-boot-ivt.img.log
-CLEAN_FILES += u-boot-ivt.img.log u-boot-dtb.imx.log SPL.log u-boot.imx.log
-endif
-
-MKIMAGEFLAGS_u-boot-dtb.img = $(MKIMAGEFLAGS_u-boot.img)
-
-MKIMAGEFLAGS_u-boot.kwb = -n $(srctree)/$(CONFIG_SYS_KWD_CONFIG:"%"=%) \
-	-T kwbimage -a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE)
-
-MKIMAGEFLAGS_u-boot-spl.kwb = -n $(srctree)/$(CONFIG_SYS_KWD_CONFIG:"%"=%) \
-	-T kwbimage -a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE)
-
-MKIMAGEFLAGS_u-boot.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
-		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage
-
-u-boot-dtb.img u-boot.img u-boot.kwb u-boot.pbl u-boot-ivt.img: \
-		$(if $(CONFIG_SPL_LOAD_FIT),u-boot-nodtb.bin dts/dt.dtb,u-boot.bin) FORCE
-	$(call if_changed,mkimage)
-
-u-boot-spl.kwb: u-boot.img spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-u-boot.sha1:	u-boot.bin
-		tools/ubsha1 u-boot.bin
-
-u-boot.dis:	u-boot
-		$(OBJDUMP) -d $< > $@
-
-ifdef CONFIG_TPL
-SPL_PAYLOAD := tpl/u-boot-with-tpl.bin
-else
-SPL_PAYLOAD := u-boot.bin
-endif
-
-OBJCOPYFLAGS_u-boot-with-spl.bin = -I binary -O binary \
-				   --pad-to=$(CONFIG_SPL_PAD_TO)
-u-boot-with-spl.bin: spl/u-boot-spl.bin $(SPL_PAYLOAD) FORCE
-	$(call if_changed,pad_cat)
-
-MKIMAGEFLAGS_lpc32xx-spl.img = -T lpc32xximage -a $(CONFIG_SPL_TEXT_BASE)
-
-lpc32xx-spl.img: spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-OBJCOPYFLAGS_lpc32xx-boot-0.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
-
-lpc32xx-boot-0.bin: lpc32xx-spl.img FORCE
-	$(call if_changed,objcopy)
-
-OBJCOPYFLAGS_lpc32xx-boot-1.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
-
-lpc32xx-boot-1.bin: lpc32xx-spl.img FORCE
-	$(call if_changed,objcopy)
-
-lpc32xx-full.bin: lpc32xx-boot-0.bin lpc32xx-boot-1.bin u-boot.img FORCE
-	$(call if_changed,cat)
-
-CLEAN_FILES += lpc32xx-*
-
-OBJCOPYFLAGS_u-boot-with-tpl.bin = -I binary -O binary \
-				   --pad-to=$(CONFIG_TPL_PAD_TO)
-tpl/u-boot-with-tpl.bin: tpl/u-boot-tpl.bin u-boot.bin FORCE
-	$(call if_changed,pad_cat)
-
-SPL: spl/u-boot-spl.bin FORCE
-	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
-
-u-boot-with-spl.imx u-boot-with-nand-spl.imx: SPL u-boot.bin FORCE
-	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
-
-MKIMAGEFLAGS_u-boot.ubl = -n $(UBL_CONFIG) -T ublimage -e $(CONFIG_SYS_TEXT_BASE)
-
-u-boot.ubl: u-boot-with-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-MKIMAGEFLAGS_u-boot-spl.ais = -s -n $(if $(CONFIG_AIS_CONFIG_FILE), \
-	$(srctree)/$(CONFIG_AIS_CONFIG_FILE:"%"=%),"/dev/null") \
-	-T aisimage -e $(CONFIG_SPL_TEXT_BASE)
-spl/u-boot-spl.ais: spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-OBJCOPYFLAGS_u-boot.ais = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
-u-boot.ais: spl/u-boot-spl.ais u-boot.img FORCE
-	$(call if_changed,pad_cat)
-
-u-boot-signed.sb: u-boot.bin spl/u-boot-spl.bin
-	$(Q)$(MAKE) $(build)=arch/arm/cpu/arm926ejs/mxs u-boot-signed.sb
-u-boot.sb: u-boot.bin spl/u-boot-spl.bin
-	$(Q)$(MAKE) $(build)=arch/arm/cpu/arm926ejs/mxs u-boot.sb
-
-# On x600 (SPEAr600) U-Boot is appended to U-Boot SPL.
-# Both images are created using mkimage (crc etc), so that the ROM
-# bootloader can check its integrity. Padding needs to be done to the
-# SPL image (with mkimage header) and not the binary. Otherwise the resulting image
-# which is loaded/copied by the ROM bootloader to SRAM doesn't fit.
-# The resulting image containing both U-Boot images is called u-boot.spr
-MKIMAGEFLAGS_u-boot-spl.img = -A $(ARCH) -T firmware -C none \
-	-a $(CONFIG_SPL_TEXT_BASE) -e $(CONFIG_SPL_TEXT_BASE) -n XLOADER
-spl/u-boot-spl.img: spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-OBJCOPYFLAGS_u-boot.spr = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
-			  --gap-fill=0xff
-u-boot.spr: spl/u-boot-spl.img u-boot.img FORCE
-	$(call if_changed,pad_cat)
-
-ifneq ($(CONFIG_ARCH_SOCFPGA),)
-quiet_cmd_socboot = SOCBOOT $@
-cmd_socboot = cat	spl/u-boot-spl.sfp spl/u-boot-spl.sfp	\
-			spl/u-boot-spl.sfp spl/u-boot-spl.sfp	\
-			u-boot.img > $@ || rm -f $@
-u-boot-with-spl.sfp: spl/u-boot-spl.sfp u-boot.img FORCE
-	$(call if_changed,socboot)
-endif
-
-# x86 uses a large ROM. We fill it with 0xff, put the 16-bit stuff (including
-# reset vector) at the top, Intel ME descriptor at the bottom, and U-Boot in
-# the middle. This is handled by binman based on an image description in the
-# board's device tree.
-ifneq ($(CONFIG_X86_RESET_VECTOR),)
-rom: u-boot.rom FORCE
-
-refcode.bin: $(srctree)/board/$(BOARDDIR)/refcode.bin FORCE
-	$(call if_changed,copy)
-
-quiet_cmd_ldr = LD      $@
-cmd_ldr = $(LD) $(LDFLAGS_$(@F)) \
-	       $(filter-out FORCE,$^) -o $@
-
-u-boot.rom: u-boot-x86-16bit.bin u-boot.bin FORCE \
-		$(if $(CONFIG_HAVE_REFCODE),refcode.bin)
-	$(call if_changed,binman)
-
-OBJCOPYFLAGS_u-boot-x86-16bit.bin := -O binary -j .start16 -j .resetvec
-u-boot-x86-16bit.bin: u-boot FORCE
-	$(call if_changed,objcopy)
-endif
-
-ifneq ($(CONFIG_ARCH_SUNXI),)
-u-boot-sunxi-with-spl.bin: spl/sunxi-spl.bin u-boot.img u-boot.dtb FORCE
-	$(call if_changed,binman)
-endif
-
-ifneq ($(CONFIG_TEGRA),)
-OBJCOPYFLAGS_u-boot-nodtb-tegra.bin = -O binary --pad-to=$(CONFIG_SYS_TEXT_BASE)
-u-boot-nodtb-tegra.bin: spl/u-boot-spl u-boot-nodtb.bin FORCE
-	$(call if_changed,pad_cat)
-
-OBJCOPYFLAGS_u-boot-tegra.bin = -O binary --pad-to=$(CONFIG_SYS_TEXT_BASE)
-u-boot-tegra.bin: spl/u-boot-spl u-boot.bin FORCE
-	$(call if_changed,pad_cat)
-
-u-boot-dtb-tegra.bin: u-boot-tegra.bin FORCE
-	$(call if_changed,copy)
-endif
-
-OBJCOPYFLAGS_u-boot-app.efi := $(OBJCOPYFLAGS_EFI)
-u-boot-app.efi: u-boot FORCE
-	$(call if_changed,zobjcopy)
-
-u-boot.bin.o: u-boot.bin FORCE
-	$(call if_changed,efipayload)
-
-u-boot-payload.lds: $(LDSCRIPT_EFI) FORCE
-	$(call if_changed_dep,cpp_lds)
-
-# Rule to link the EFI payload which contains a stub and a U-Boot binary
-quiet_cmd_u-boot_payload ?= LD      $@
-      cmd_u-boot_payload ?= $(LD) $(LDFLAGS_EFI_PAYLOAD) -o $@ \
-      -T u-boot-payload.lds arch/x86/cpu/call32.o \
-      lib/efi/efi.o lib/efi/efi_stub.o u-boot.bin.o \
-      $(addprefix arch/$(ARCH)/lib/,$(EFISTUB))
-
-u-boot-payload: u-boot.bin.o u-boot-payload.lds FORCE
-	$(call if_changed,u-boot_payload)
-
-OBJCOPYFLAGS_u-boot-payload.efi := $(OBJCOPYFLAGS_EFI)
-u-boot-payload.efi: u-boot-payload FORCE
-	$(call if_changed,zobjcopy)
-
-u-boot-img.bin: spl/u-boot-spl.bin u-boot.img FORCE
-	$(call if_changed,cat)
-
-#Add a target to create boot binary having SPL binary in PBI format
-#concatenated with u-boot binary. It is need by PowerPC SoC having
-#internal SRAM <= 512KB.
-MKIMAGEFLAGS_u-boot-spl.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
-		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage \
-		-A $(ARCH) -a $(CONFIG_SPL_TEXT_BASE)
-
-spl/u-boot-spl.pbl: spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-ifeq ($(ARCH),arm)
-UBOOT_BINLOAD := u-boot.img
-else
-UBOOT_BINLOAD := u-boot.bin
-endif
-
-OBJCOPYFLAGS_u-boot-with-spl-pbl.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
-			  --gap-fill=0xff
-
-u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl $(UBOOT_BINLOAD) FORCE
-	$(call if_changed,pad_cat)
-
-# PPC4xx needs the SPL at the end of the image, since the reset vector
-# is located at 0xfffffffc. So we can't use the "u-boot-img.bin" target
-# and need to introduce a new build target with the full blown U-Boot
-# at the start padded up to the start of the SPL image. And then concat
-# the SPL image to the end.
-
-OBJCOPYFLAGS_u-boot-img-spl-at-end.bin := -I binary -O binary \
-	--pad-to=$(CONFIG_UBOOT_PAD_TO) --gap-fill=0xff
-u-boot-img-spl-at-end.bin: u-boot.img spl/u-boot-spl.bin FORCE
-	$(call if_changed,pad_cat)
-
-# Create a new ELF from a raw binary file.  This is useful for arm64
-# where static relocation needs to be performed on the raw binary,
-# but certain simulators only accept an ELF file (but don't do the
-# relocation).
-# FIXME refactor dts/Makefile to share target/arch detection
-u-boot.elf: u-boot.bin
-	@$(OBJCOPY)  -B aarch64 -I binary -O elf64-littleaarch64 \
-		$< u-boot-elf.o
-	@$(LD) u-boot-elf.o -o $@ \
-		--defsym=_start=$(CONFIG_SYS_TEXT_BASE) \
-		-Ttext=$(CONFIG_SYS_TEXT_BASE)
-
-# Rule to link u-boot
-# May be overridden by arch/$(ARCH)/config.mk
-quiet_cmd_u-boot__ ?= LD      $@
-      cmd_u-boot__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_u-boot) -o $@ \
-      -T u-boot.lds $(u-boot-init)                             \
-      --start-group $(u-boot-main) --end-group                 \
-      $(PLATFORM_LIBS) -Map u-boot.map
-
-quiet_cmd_smap = GEN     common/system_map.o
-cmd_smap = \
-	smap=`$(call SYSTEM_MAP,u-boot) | \
-		awk '$$2 ~ /[tTwW]/ {printf $$1 $$3 "\\\\000"}'` ; \
-	$(CC) $(c_flags) -DSYSTEM_MAP="\"$${smap}\"" \
-		-c $(srctree)/common/system_map.c -o common/system_map.o
-
-u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds FORCE
-	$(call if_changed,u-boot__)
-ifeq ($(CONFIG_KALLSYMS),y)
-	$(call cmd,smap)
-	$(call cmd,u-boot__) common/system_map.o
-endif
-
-quiet_cmd_sym ?= SYM     $@
-      cmd_sym ?= $(OBJDUMP) -t $< > $@
-u-boot.sym: u-boot FORCE
-	$(call if_changed,sym)
-
-# The actual objects are generated when descending,
-# make sure no implicit rule kicks in
-$(sort $(u-boot-init) $(u-boot-main)): $(u-boot-dirs) ;
-
-# Handle descending into subdirectories listed in $(vmlinux-dirs)
-# Preset locale variables to speed up the build process. Limit locale
-# tweaks to this spot to avoid wrong language settings when running
-# make menuconfig etc.
-# Error messages still appears in the original language
-
-PHONY += $(u-boot-dirs)
-$(u-boot-dirs): prepare scripts
-	$(Q)$(MAKE) $(build)=$@
-
-tools: prepare
-# The "tools" are needed early
-$(filter-out tools, $(u-boot-dirs)): tools
-# The "examples" conditionally depend on U-Boot (say, when USE_PRIVATE_LIBGCC
-# is "yes"), so compile examples after U-Boot is compiled.
-examples: $(filter-out examples, $(u-boot-dirs))
-
-define filechk_uboot.release
-	echo "$(UBOOTVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
-endef
-
-# Store (new) UBOOTRELEASE string in include/config/uboot.release
-include/config/uboot.release: include/config/auto.conf FORCE
-	$(call filechk,uboot.release)
-
-
-# Things we need to do before we recursively start building the kernel
-# or the modules are listed in "prepare".
-# A multi level approach is used. prepareN is processed before prepareN-1.
-# archprepare is used in arch Makefiles and when processed asm symlink,
-# version.h and scripts_basic is processed / created.
-
-# Listed in dependency order
-PHONY += prepare archprepare prepare0 prepare1 prepare2 prepare3
-
-# prepare3 is used to check if we are building in a separate output directory,
-# and if so do:
-# 1) Check that make has not been executed in the kernel src $(srctree)
-prepare3: include/config/uboot.release
-ifneq ($(KBUILD_SRC),)
-	@$(kecho) '  Using $(srctree) as source for U-Boot'
-	$(Q)if [ -f $(srctree)/.config -o -d $(srctree)/include/config ]; then \
-		echo >&2 "  $(srctree) is not clean, please run 'make mrproper'"; \
-		echo >&2 "  in the '$(srctree)' directory.";\
-		/bin/false; \
-	fi;
-endif
-
-# prepare2 creates a makefile if using a separate output directory
-prepare2: prepare3 outputmakefile
-
-prepare1: prepare2 $(version_h) $(timestamp_h) \
-                   include/config/auto.conf
-ifeq ($(wildcard $(LDSCRIPT)),)
-	@echo >&2 "  Could not find linker script."
-	@/bin/false
-endif
-
-archprepare: prepare1 scripts_basic
-
-prepare0: archprepare FORCE
-	$(Q)$(MAKE) $(build)=.
-
-# All the preparing..
-prepare: prepare0
-
-# Generate some files
-# ---------------------------------------------------------------------------
-
-define filechk_version.h
-	(echo \#define PLAIN_VERSION \"$(UBOOTRELEASE)\"; \
-	echo \#define U_BOOT_VERSION \"U-Boot \" PLAIN_VERSION; \
-	echo \#define CC_VERSION_STRING \"$$(LC_ALL=C $(CC) --version | head -n 1)\"; \
-	echo \#define LD_VERSION_STRING \"$$(LC_ALL=C $(LD) --version | head -n 1)\"; )
-endef
-
-# The SOURCE_DATE_EPOCH mechanism requires a date that behaves like GNU date.
-# The BSD date on the other hand behaves different and would produce errors
-# with the misused '-d' switch.  Respect that and search a working date with
-# well known pre- and suffixes for the GNU variant of date.
-define filechk_timestamp.h
-	(if test -n "$${SOURCE_DATE_EPOCH}"; then \
-		SOURCE_DATE="@$${SOURCE_DATE_EPOCH}"; \
-		DATE=""; \
-		for date in gdate date.gnu date; do \
-			$${date} -u -d "$${SOURCE_DATE}" >/dev/null 2>&1 && DATE="$${date}"; \
-		done; \
-		if test -n "$${DATE}"; then \
-			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_DATE "%b %d %C%y"'; \
-			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_TIME "%T"'; \
-			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_TZ "%z"'; \
-			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; \
-		else \
-			return 42; \
-		fi; \
-	else \
-		LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"'; \
-		LC_ALL=C date +'#define U_BOOT_TIME "%T"'; \
-		LC_ALL=C date +'#define U_BOOT_TZ "%z"'; \
-		LC_ALL=C date +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; \
-	fi)
-endef
-
-$(version_h): include/config/uboot.release FORCE
-	$(call filechk,version.h)
-
-$(timestamp_h): $(srctree)/Makefile FORCE
-	$(call filechk,timestamp.h)
-
-# ---------------------------------------------------------------------------
-quiet_cmd_cpp_lds = LDS     $@
-cmd_cpp_lds = $(CPP) -Wp,-MD,$(depfile) $(cpp_flags) $(LDPPFLAGS) \
-		-D__ASSEMBLY__ -x assembler-with-cpp -P -o $@ $<
-
-u-boot.lds: $(LDSCRIPT) prepare FORCE
-	$(call if_changed_dep,cpp_lds)
-
-spl/u-boot-spl.bin: spl/u-boot-spl
-	@:
-spl/u-boot-spl: tools prepare \
-		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb)
-	$(Q)$(MAKE) obj=spl -f $(srctree)/scripts/Makefile.spl all
-
-spl/sunxi-spl.bin: spl/u-boot-spl
-	@:
-
-spl/u-boot-spl.sfp: spl/u-boot-spl
-	@:
-
-spl/boot.bin: spl/u-boot-spl
-	@:
-
-tpl/u-boot-tpl.bin: tools prepare
-	$(Q)$(MAKE) obj=tpl -f $(srctree)/scripts/Makefile.spl all
-
-TAG_SUBDIRS := $(patsubst %,$(srctree)/%,$(u-boot-dirs) include)
-
-FIND := find
-FINDFLAGS := -L
-
-tags ctags:
-		ctags -w -o ctags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
-						-name '*.[chS]' -print`
-		ln -s ctags tags
-
-etags:
-		etags -a -o etags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
-						-name '*.[chS]' -print`
-cscope:
-		$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) -name '*.[chS]' -print > \
-						cscope.files
-		cscope -b -q -k
-
-SYSTEM_MAP = \
-		$(NM) $1 | \
-		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
-		LC_ALL=C sort
-System.map:	u-boot
-		@$(call SYSTEM_MAP,$<) > $@
-
-checkdtc:
-	@if test $(call dtc-version) -lt 0104; then \
-		echo '*** Your dtc is too old, please upgrade to dtc 1.4 or newer'; \
-		false; \
-	fi
-
-#########################################################################
-
-# ARM relocations should all be R_ARM_RELATIVE (32-bit) or
-# R_AARCH64_RELATIVE (64-bit).
-checkarmreloc: u-boot
-	@RELOC="`$(CROSS_COMPILE)readelf -r -W $< | cut -d ' ' -f 4 | \
-		grep R_A | sort -u`"; \
-	if test "$$RELOC" != "R_ARM_RELATIVE" -a \
-		 "$$RELOC" != "R_AARCH64_RELATIVE"; then \
-		echo "$< contains unexpected relocations: $$RELOC"; \
-		false; \
-	fi
-
-env: scripts_basic
-	$(Q)$(MAKE) $(build)=tools/$@
-
-tools-only: scripts_basic $(version_h) $(timestamp_h)
-	$(Q)$(MAKE) $(build)=tools
-
-tools-all: export HOST_TOOLS_ALL=y
-tools-all: env tools ;
-
-cross_tools: export CROSS_BUILD_TOOLS=y
-cross_tools: tools ;
-
-.PHONY : CHANGELOG
-CHANGELOG:
-	git log --no-merges U-Boot-1_1_5.. | \
-	unexpand -a | sed -e 's/\s\s*$$//' > $@
-
-#########################################################################
-
-###
-# Cleaning is done on three levels.
-# make clean     Delete most generated files
-#                Leave enough to build external modules
-# make mrproper  Delete the current configuration, and all generated files
-# make distclean Remove editor backup files, patch leftover files and the like
-
-# Directories & files removed with 'make clean'
-CLEAN_DIRS  += $(MODVERDIR) \
-	       $(foreach d, spl tpl, $(patsubst %,$d/%, \
-			$(filter-out include, $(shell ls -1 $d 2>/dev/null))))
-
-CLEAN_FILES += include/bmp_logo.h include/bmp_logo_data.h include/license.h \
-	       boot* u-boot* MLO* SPL System.map
-
-# Directories & files removed with 'make mrproper'
-MRPROPER_DIRS  += include/config include/generated spl tpl \
-		  .tmp_objdiff
-MRPROPER_FILES += .config .config.old include/autoconf.mk* include/config.h \
-		  ctags etags tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS
-
-# clean - Delete most, but leave enough to build external modules
-#
-clean: rm-dirs  := $(CLEAN_DIRS)
-clean: rm-files := $(CLEAN_FILES)
-
-clean-dirs	:= $(foreach f,$(u-boot-alldirs),$(if $(wildcard $(srctree)/$f/Makefile),$f))
-
-clean-dirs      := $(addprefix _clean_, $(clean-dirs) doc/DocBook)
-
-PHONY += $(clean-dirs) clean archclean
-$(clean-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
-
-# TODO: Do not use *.cfgtmp
-clean: $(clean-dirs)
-	$(call cmd,rmdirs)
-	$(call cmd,rmfiles)
-	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
-		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
-		-o -name '*.ko.*' -o -name '*.su' -o -name '*.cfgtmp' \
-		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
-		-o -name '*.symtypes' -o -name 'modules.order' \
-		-o -name modules.builtin -o -name '.tmp_*.o.*' \
-		-o -name 'dsdt.aml' -o -name 'dsdt.asl.tmp' -o -name 'dsdt.c' \
-		-o -name '*.gcno' \) -type f -print | xargs rm -f
-
-# mrproper - Delete all generated files, including .config
-#
-mrproper: rm-dirs  := $(wildcard $(MRPROPER_DIRS))
-mrproper: rm-files := $(wildcard $(MRPROPER_FILES))
-mrproper-dirs      := $(addprefix _mrproper_,scripts)
-
-PHONY += $(mrproper-dirs) mrproper archmrproper
-$(mrproper-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _mrproper_%,%,$@)
-
-mrproper: clean $(mrproper-dirs)
-	$(call cmd,rmdirs)
-	$(call cmd,rmfiles)
-	@rm -f arch/*/include/asm/arch
-
-# distclean
-#
-PHONY += distclean
-
-distclean: mrproper
-	@find $(srctree) $(RCS_FIND_IGNORE) \
-		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
-		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -name '*%' -o -name 'core' \
-		-o -name '*.pyc' \) \
-		-type f -print | xargs rm -f
-	@rm -f boards.cfg
-
-backup:
-	F=`basename $(srctree)` ; cd .. ; \
-	gtar --force-local -zcvf `LC_ALL=C date "+$$F-%Y-%m-%d-%T.tar.gz"` $$F
-
-help:
-	@echo  'Cleaning targets:'
-	@echo  '  clean		  - Remove most generated files but keep the config'
-	@echo  '  mrproper	  - Remove all generated files + config + various backup files'
-	@echo  '  distclean	  - mrproper + remove editor backup and patch files'
-	@echo  ''
-	@echo  'Configuration targets:'
-	@$(MAKE) -f $(srctree)/scripts/kconfig/Makefile help
-	@echo  ''
-	@echo  'Other generic targets:'
-	@echo  '  all		  - Build all necessary images depending on configuration'
-	@echo  '  tests		  - Build U-Boot for sandbox and run tests'
-	@echo  '* u-boot	  - Build the bare u-boot'
-	@echo  '  dir/            - Build all files in dir and below'
-	@echo  '  dir/file.[oisS] - Build specified target only'
-	@echo  '  dir/file.lst    - Build specified mixed source/assembly target only'
-	@echo  '                    (requires a recent binutils and recent build (System.map))'
-	@echo  '  tags/ctags	  - Generate ctags file for editors'
-	@echo  '  etags		  - Generate etags file for editors'
-	@echo  '  cscope	  - Generate cscope index'
-	@echo  '  ubootrelease	  - Output the release version string (use with make -s)'
-	@echo  '  ubootversion	  - Output the version stored in Makefile (use with make -s)'
-	@echo  "  cfg		  - Don't build, just create the .cfg files"
-	@echo  ''
-	@echo  'Static analysers'
-	@echo  '  checkstack      - Generate a list of stack hogs'
-	@echo  ''
-	@echo  'Documentation targets:'
-	@$(MAKE) -f $(srctree)/doc/DocBook/Makefile dochelp
-	@echo  ''
-	@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'
-	@echo  '  make V=2   [targets] 2 => give reason for rebuild of target'
-	@echo  '  make O=dir [targets] Locate all output files in "dir", including .config'
-	@echo  '  make C=1   [targets] Check all c source with $$CHECK (sparse by default)'
-	@echo  '  make C=2   [targets] Force check of all c source with $$CHECK'
-	@echo  '  make RECORDMCOUNT_WARN=1 [targets] Warn about ignored mcount sections'
-	@echo  '  make W=n   [targets] Enable extra gcc checks, n=1,2,3 where'
-	@echo  '		1: warnings which may be relevant and do not occur too often'
-	@echo  '		2: warnings which occur quite often but may still be relevant'
-	@echo  '		3: more obscure warnings, can most likely be ignored'
-	@echo  '		Multiple levels can be combined with W=12 or W=123'
-	@echo  ''
-	@echo  'Execute "make" or "make all" to build all targets marked with [*] '
-	@echo  'For further info see the ./README file'
-
-tests:
-	$(srctree)/test/run
-
-# Documentation targets
-# ---------------------------------------------------------------------------
-%docs: scripts_basic FORCE
-	$(Q)$(MAKE) $(build)=scripts build_docproc
-	$(Q)$(MAKE) $(build)=doc/DocBook $@
-
-# Dummies...
-PHONY += prepare scripts
-prepare: ;
-scripts: ;
-
-endif #ifeq ($(config-targets),1)
-endif #ifeq ($(mixed-targets),1)
-
-PHONY += checkstack ubootrelease ubootversion
-
-checkstack:
-	$(OBJDUMP) -d u-boot $$(find . -name u-boot-spl) | \
-	$(PERL) $(src)/scripts/checkstack.pl $(ARCH)
-
-ubootrelease:
-	@echo "$(UBOOTVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
-
-ubootversion:
-	@echo $(UBOOTVERSION)
-
-# Single targets
-# ---------------------------------------------------------------------------
-# Single targets are compatible with:
-# - build with mixed source and output
-# - build with separate output dir 'make O=...'
-# - external modules
-#
-#  target-dir => where to store outputfile
-#  build-dir  => directory in kernel source tree to use
-
-ifeq ($(KBUILD_EXTMOD),)
-        build-dir  = $(patsubst %/,%,$(dir $@))
-        target-dir = $(dir $@)
-else
-        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
-        build-dir  = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
-        target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
-endif
-
-%.s: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.i: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.lst: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.s: %.S prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.S prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.symtypes: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-
-# Modules
-/: prepare scripts FORCE
-	$(cmd_crmodverdir)
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
-	$(build)=$(build-dir)
-%/: prepare scripts FORCE
-	$(cmd_crmodverdir)
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
-	$(build)=$(build-dir)
-%.ko: prepare scripts FORCE
-	$(cmd_crmodverdir)
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
-	$(build)=$(build-dir) $(@:.ko=.o)
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
-
-# FIXME Should go into a make.lib or something
-# ===========================================================================
-
-quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
-      cmd_rmdirs = rm -rf $(rm-dirs)
-
-quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files)))
-      cmd_rmfiles = rm -f $(rm-files)
-
-# read all saved command lines
-
-targets := $(wildcard $(sort $(targets)))
-cmd_files := $(wildcard .*.cmd $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
-
-ifneq ($(cmd_files),)
-  $(cmd_files): ;	# Do not try to update included dependency files
-  include $(cmd_files)
-endif
-
-endif	# skip-makefile
-
-PHONY += FORCE
-FORCE:
-
-# Declare the contents of the .PHONY variable as phony.  We keep that
-# information in a variable so we can use it in if_changed and friends.
-.PHONY: $(PHONY)
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+VERSION = 2017
+PATCHLEVEL = 01
+SUBLEVEL =
+EXTRAVERSION =
+NAME =
+
+# *DOCUMENTATION*
+# To see a list of typical targets execute "make help"
+# More info can be located in ./README
+# Comments in this file are targeted only to the developer, do not
+# expect to learn how to build the kernel reading this file.
+
+# o Do not use make's built-in rules and variables
+#   (this increases performance and avoids hard-to-debug behaviour);
+# o Look for make include files relative to root of kernel src
+MAKEFLAGS += -rR --include-dir=$(CURDIR)
+
+# Avoid funny character set dependencies
+unexport LC_ALL
+LC_COLLATE=C
+LC_NUMERIC=C
+export LC_COLLATE LC_NUMERIC
+
+# Avoid interference with shell env settings
+unexport GREP_OPTIONS
+
+# We are using a recursive build, so we need to do a little thinking
+# to get the ordering right.
+#
+# Most importantly: sub-Makefiles should only ever modify files in
+# their own directory. If in some directory we have a dependency on
+# a file in another dir (which doesn't happen often, but it's often
+# unavoidable when linking the built-in.o targets which finally
+# turn into vmlinux), we will call a sub make in that other dir, and
+# after that we are sure that everything which is in that other dir
+# is now up to date.
+#
+# The only cases where we need to modify files which have global
+# effects are thus separated out and done before the recursive
+# descending is started. They are now explicitly listed as the
+# prepare rule.
+
+# Beautify output
+# ---------------------------------------------------------------------------
+#
+# Normally, we echo the whole command before executing it. By making
+# that echo $($(quiet)$(cmd)), we now have the possibility to set
+# $(quiet) to choose other forms of output instead, e.g.
+#
+#         quiet_cmd_cc_o_c = Compiling $(RELDIR)/$@
+#         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
+#
+# If $(quiet) is empty, the whole command will be printed.
+# If it is set to "quiet_", only the short version will be printed.
+# If it is set to "silent_", nothing will be printed at all, since
+# the variable $(silent_cmd_cc_o_c) doesn't exist.
+#
+# A simple variant is to prefix commands with $(Q) - that's useful
+# for commands that shall be hidden in non-verbose mode.
+#
+#	$(Q)ln $@ :<
+#
+# If KBUILD_VERBOSE equals 0 then the above command will be hidden.
+# If KBUILD_VERBOSE equals 1 then the above command is displayed.
+#
+# To put more focus on warnings, be less verbose as default
+# Use 'make V=1' to see the full commands
+
+ifeq ("$(origin V)", "command line")
+  KBUILD_VERBOSE = $(V)
+endif
+ifndef KBUILD_VERBOSE
+  KBUILD_VERBOSE = 0
+endif
+
+ifeq ($(KBUILD_VERBOSE),1)
+  quiet =
+  Q =
+else
+  quiet=quiet_
+  Q = @
+endif
+
+# If the user is running make -s (silent mode), suppress echoing of
+# commands
+
+ifneq ($(filter 4.%,$(MAKE_VERSION)),)	# make-4
+ifneq ($(filter %s ,$(firstword x$(MAKEFLAGS))),)
+  quiet=silent_
+endif
+else					# make-3.8x
+ifneq ($(filter s% -s%,$(MAKEFLAGS)),)
+  quiet=silent_
+endif
+endif
+
+export quiet Q KBUILD_VERBOSE
+
+# kbuild supports saving output files in a separate directory.
+# To locate output files in a separate directory two syntaxes are supported.
+# In both cases the working directory must be the root of the kernel src.
+# 1) O=
+# Use "make O=dir/to/store/output/files/"
+#
+# 2) Set KBUILD_OUTPUT
+# Set the environment variable KBUILD_OUTPUT to point to the directory
+# where the output files shall be placed.
+# export KBUILD_OUTPUT=dir/to/store/output/files/
+# make
+#
+# The O= assignment takes precedence over the KBUILD_OUTPUT environment
+# variable.
+
+# KBUILD_SRC is set on invocation of make in OBJ directory
+# KBUILD_SRC is not intended to be used by the regular user (for now)
+ifeq ($(KBUILD_SRC),)
+
+# OK, Make called in directory where kernel src resides
+# Do we want to locate output files in a separate directory?
+ifeq ("$(origin O)", "command line")
+  KBUILD_OUTPUT := $(O)
+endif
+
+# That's our default target when none is given on the command line
+PHONY := _all
+_all:
+
+# Cancel implicit rules on top Makefile
+$(CURDIR)/Makefile Makefile: ;
+
+ifneq ($(KBUILD_OUTPUT),)
+# Invoke a second make in the output directory, passing relevant variables
+# check that the output directory actually exists
+saved-output := $(KBUILD_OUTPUT)
+KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) \
+								&& /bin/pwd)
+$(if $(KBUILD_OUTPUT),, \
+     $(error failed to create output directory "$(saved-output)"))
+
+PHONY += $(MAKECMDGOALS) sub-make
+
+$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
+	@:
+
+sub-make: FORCE
+	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
+	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))
+
+# Leave processing to above invocation of make
+skip-makefile := 1
+endif # ifneq ($(KBUILD_OUTPUT),)
+endif # ifeq ($(KBUILD_SRC),)
+
+# We process the rest of the Makefile if this is the final invocation of make
+ifeq ($(skip-makefile),)
+
+# Do not print "Entering directory ...",
+# but we want to display it when entering to the output directory
+# so that IDEs/editors are able to understand relative filenames.
+MAKEFLAGS += --no-print-directory
+
+# Call a source code checker (by default, "sparse") as part of the
+# C compilation.
+#
+# Use 'make C=1' to enable checking of only re-compiled files.
+# Use 'make C=2' to enable checking of *all* source files, regardless
+# of whether they are re-compiled or not.
+#
+# See the file "Documentation/sparse.txt" for more details, including
+# where to get the "sparse" utility.
+
+ifeq ("$(origin C)", "command line")
+  KBUILD_CHECKSRC = $(C)
+endif
+ifndef KBUILD_CHECKSRC
+  KBUILD_CHECKSRC = 0
+endif
+
+# Use make M=dir to specify directory of external module to build
+# Old syntax make ... SUBDIRS=$PWD is still supported
+# Setting the environment variable KBUILD_EXTMOD take precedence
+ifdef SUBDIRS
+  KBUILD_EXTMOD ?= $(SUBDIRS)
+endif
+
+ifeq ("$(origin M)", "command line")
+  KBUILD_EXTMOD := $(M)
+endif
+
+# If building an external module we do not care about the all: rule
+# but instead _all depend on modules
+PHONY += all
+ifeq ($(KBUILD_EXTMOD),)
+_all: all
+else
+_all: modules
+endif
+
+ifeq ($(KBUILD_SRC),)
+        # building in the source tree
+        srctree := .
+else
+        ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))
+                # building in a subdirectory of the source tree
+                srctree := ..
+        else
+                srctree := $(KBUILD_SRC)
+        endif
+endif
+objtree		:= .
+src		:= $(srctree)
+obj		:= $(objtree)
+
+VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
+
+export srctree objtree VPATH
+
+# Make sure CDPATH settings don't interfere
+unexport CDPATH
+
+#########################################################################
+
+HOSTARCH := $(shell uname -m | \
+	sed -e s/i.86/x86/ \
+	    -e s/sun4u/sparc64/ \
+	    -e s/arm.*/arm/ \
+	    -e s/sa110/arm/ \
+	    -e s/ppc64/powerpc/ \
+	    -e s/ppc/powerpc/ \
+	    -e s/macppc/powerpc/\
+	    -e s/sh.*/sh/)
+
+HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
+	    sed -e 's/\(cygwin\).*/cygwin/')
+
+export	HOSTARCH HOSTOS
+
+#########################################################################
+
+# set default to nothing for native builds
+ifeq ($(HOSTARCH),$(ARCH))
+CROSS_COMPILE ?=
+endif
+
+KCONFIG_CONFIG	?= .config
+export KCONFIG_CONFIG
+
+# SHELL used by kbuild
+CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+	  else if [ -x /bin/bash ]; then echo /bin/bash; \
+	  else echo sh; fi ; fi)
+
+HOSTCC       = cc
+HOSTCXX      = c++
+HOSTCFLAGS   = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \
+		$(if $(CONFIG_TOOLS_DEBUG),-g)
+HOSTCXXFLAGS = -O2
+
+ifeq ($(HOSTOS),cygwin)
+HOSTCFLAGS	+= -ansi
+endif
+
+# Mac OS X / Darwin's C preprocessor is Apple specific.  It
+# generates numerous errors and warnings.  We want to bypass it
+# and use GNU C's cpp.	To do this we pass the -traditional-cpp
+# option to the compiler.  Note that the -traditional-cpp flag
+# DOES NOT have the same semantics as GNU C's flag, all it does
+# is invoke the GNU preprocessor in stock ANSI/ISO C fashion.
+#
+# Apple's linker is similar, thanks to the new 2 stage linking
+# multiple symbol definitions are treated as errors, hence the
+# -multiply_defined suppress option to turn off this error.
+#
+ifeq ($(HOSTOS),darwin)
+# get major and minor product version (e.g. '10' and '6' for Snow Leopard)
+DARWIN_MAJOR_VERSION	= $(shell sw_vers -productVersion | cut -f 1 -d '.')
+DARWIN_MINOR_VERSION	= $(shell sw_vers -productVersion | cut -f 2 -d '.')
+
+os_x_before	= $(shell if [ $(DARWIN_MAJOR_VERSION) -le $(1) -a \
+	$(DARWIN_MINOR_VERSION) -le $(2) ] ; then echo "$(3)"; else echo "$(4)"; fi ;)
+
+# Snow Leopards build environment has no longer restrictions as described above
+HOSTCC       = $(call os_x_before, 10, 5, "cc", "gcc")
+HOSTCFLAGS  += $(call os_x_before, 10, 4, "-traditional-cpp")
+HOSTLDFLAGS += $(call os_x_before, 10, 5, "-multiply_defined suppress")
+
+# since Lion (10.7) ASLR is on by default, but we use linker generated lists
+# in some host tools which is a problem then ... so disable ASLR for these
+# tools
+HOSTLDFLAGS += $(call os_x_before, 10, 7, "", "-Xlinker -no_pie")
+endif
+
+# Decide whether to build built-in, modular, or both.
+# Normally, just do built-in.
+
+KBUILD_MODULES :=
+KBUILD_BUILTIN := 1
+
+# If we have only "make modules", don't compile built-in objects.
+# When we're building modules with modversions, we need to consider
+# the built-in objects during the descend as well, in order to
+# make sure the checksums are up to date before we record them.
+
+ifeq ($(MAKECMDGOALS),modules)
+  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
+endif
+
+# If we have "make <whatever> modules", compile modules
+# in addition to whatever we do anyway.
+# Just "make" or "make all" shall build modules as well
+
+# U-Boot does not need modules
+#ifneq ($(filter all _all modules,$(MAKECMDGOALS)),)
+#  KBUILD_MODULES := 1
+#endif
+
+#ifeq ($(MAKECMDGOALS),)
+#  KBUILD_MODULES := 1
+#endif
+
+export KBUILD_MODULES KBUILD_BUILTIN
+export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
+
+# We need some generic definitions (do not try to remake the file).
+scripts/Kbuild.include: ;
+include scripts/Kbuild.include
+
+# Make variables (CC, etc...)
+
+AS		= $(CROSS_COMPILE)as
+# Always use GNU ld
+ifneq ($(shell $(CROSS_COMPILE)ld.bfd -v 2> /dev/null),)
+LD		= $(CROSS_COMPILE)ld.bfd
+else
+LD		= $(CROSS_COMPILE)ld
+endif
+CC		= $(CROSS_COMPILE)gcc
+CPP		= $(CC) -E
+AR		= $(CROSS_COMPILE)ar
+NM		= $(CROSS_COMPILE)nm
+LDR		= $(CROSS_COMPILE)ldr
+STRIP		= $(CROSS_COMPILE)strip
+OBJCOPY		= $(CROSS_COMPILE)objcopy
+OBJDUMP		= $(CROSS_COMPILE)objdump
+AWK		= awk
+PERL		= perl
+PYTHON		= python
+DTC		= dtc
+CHECK		= sparse
+
+CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
+		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)
+
+KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__
+
+KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
+		   -Wno-format-security \
+		   -fno-builtin -ffreestanding
+KBUILD_AFLAGS   := -D__ASSEMBLY__
+
+# Read UBOOTRELEASE from include/config/uboot.release (if it exists)
+UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
+UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
+
+export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
+export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
+export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
+export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
+export MAKE AWK PERL PYTHON
+export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS
+
+export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
+export KBUILD_CFLAGS KBUILD_AFLAGS
+
+# When compiling out-of-tree modules, put MODVERDIR in the module
+# tree rather than in the kernel tree. The kernel tree might
+# even be read-only.
+export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_versions
+
+# Files to ignore in find ... statements
+
+export RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o    \
+			  -name CVS -o -name .pc -o -name .hg -o -name .git \) \
+			  -prune -o
+export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
+			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
+
+# ===========================================================================
+# Rules shared between *config targets and build targets
+
+# Basic helpers built in scripts/
+PHONY += scripts_basic
+scripts_basic:
+	$(Q)$(MAKE) $(build)=scripts/basic
+	$(Q)rm -f .tmp_quiet_recordmcount
+
+# To avoid any implicit rule to kick in, define an empty command.
+scripts/basic/%: scripts_basic ;
+
+PHONY += outputmakefile
+# outputmakefile generates a Makefile in the output directory, if using a
+# separate output directory. This allows convenient use of make in the
+# output directory.
+outputmakefile:
+ifneq ($(KBUILD_SRC),)
+	$(Q)ln -fsn $(srctree) source
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
+	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
+endif
+
+# To make sure we do not include .config for any of the *config targets
+# catch them early, and hand them over to scripts/kconfig/Makefile
+# It is allowed to specify more targets when calling make, including
+# mixing *config targets and build targets.
+# For example 'make oldconfig all'.
+# Detect when mixed targets is specified, and make a second invocation
+# of make so .config is not included in this case either (for *config).
+
+version_h := include/generated/version_autogenerated.h
+timestamp_h := include/generated/timestamp_autogenerated.h
+
+no-dot-config-targets := clean clobber mrproper distclean \
+			 help %docs check% coccicheck \
+			 ubootversion backup tests
+
+config-targets := 0
+mixed-targets  := 0
+dot-config     := 1
+
+ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
+	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
+		dot-config := 0
+	endif
+endif
+
+ifeq ($(KBUILD_EXTMOD),)
+        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
+                config-targets := 1
+                ifneq ($(words $(MAKECMDGOALS)),1)
+                        mixed-targets := 1
+                endif
+        endif
+endif
+
+ifeq ($(mixed-targets),1)
+# ===========================================================================
+# We're called with mixed targets (*config and build targets).
+# Handle them one by one.
+
+PHONY += $(MAKECMDGOALS) __build_one_by_one
+
+$(filter-out __build_one_by_one, $(MAKECMDGOALS)): __build_one_by_one
+	@:
+
+__build_one_by_one:
+	$(Q)set -e; \
+	for i in $(MAKECMDGOALS); do \
+		$(MAKE) -f $(srctree)/Makefile $$i; \
+	done
+
+else
+ifeq ($(config-targets),1)
+# ===========================================================================
+# *config targets only - make sure prerequisites are updated, and descend
+# in scripts/kconfig to make the *config target
+
+KBUILD_DEFCONFIG := sandbox_defconfig
+export KBUILD_DEFCONFIG KBUILD_KCONFIG
+
+config: scripts_basic outputmakefile FORCE
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+%config: scripts_basic outputmakefile FORCE
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+else
+# ===========================================================================
+# Build targets only - this includes vmlinux, arch specific targets, clean
+# targets and others. In general all targets except *config targets.
+
+ifeq ($(dot-config),1)
+# Read in config
+-include include/config/auto.conf
+
+# Read in dependencies to all Kconfig* files, make sure to run
+# oldconfig if changes are detected.
+-include include/config/auto.conf.cmd
+
+# To avoid any implicit rule to kick in, define an empty command
+$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
+
+# If .config is newer than include/config/auto.conf, someone tinkered
+# with it and forgot to run make oldconfig.
+# if auto.conf.cmd is missing then we are probably in a cleaned tree so
+# we execute the config step to be sure to catch updated Kconfig files
+include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
+	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
+	@# If the following part fails, include/config/auto.conf should be
+	@# deleted so "make silentoldconfig" will be re-run on the next build.
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.autoconf || \
+		{ rm -f include/config/auto.conf; false; }
+	@# include/config.h has been updated after "make silentoldconfig".
+	@# We need to touch include/config/auto.conf so it gets newer
+	@# than include/config.h.
+	@# Otherwise, 'make silentoldconfig' would be invoked twice.
+	$(Q)touch include/config/auto.conf
+
+-include include/autoconf.mk
+-include include/autoconf.mk.dep
+
+# We want to include arch/$(ARCH)/config.mk only when include/config/auto.conf
+# is up-to-date. When we switch to a different board configuration, old CONFIG
+# macros are still remaining in include/config/auto.conf. Without the following
+# gimmick, wrong config.mk would be included leading nasty warnings/errors.
+ifneq ($(wildcard $(KCONFIG_CONFIG)),)
+ifneq ($(wildcard include/config/auto.conf),)
+autoconf_is_old := $(shell find . -path ./$(KCONFIG_CONFIG) -newer \
+						include/config/auto.conf)
+ifeq ($(autoconf_is_old),)
+include config.mk
+include arch/$(ARCH)/Makefile
+endif
+endif
+endif
+
+# These are set by the arch-specific config.mk. Make sure they are exported
+# so they can be used when building an EFI application.
+export EFI_LDS		# Filename of EFI link script in arch/$(ARCH)/lib
+export EFI_CRT0		# Filename of EFI CRT0 in arch/$(ARCH)/lib
+export EFI_RELOC	# Filename of EFU relocation code in arch/$(ARCH)/lib
+export CFLAGS_EFI	# Compiler flags to add when building EFI app
+export CFLAGS_NON_EFI	# Compiler flags to remove when building EFI app
+export EFI_TARGET	# binutils target if EFI is natively supported
+
+# If board code explicitly specified LDSCRIPT or CONFIG_SYS_LDSCRIPT, use
+# that (or fail if absent).  Otherwise, search for a linker script in a
+# standard location.
+
+ifndef LDSCRIPT
+	#LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds.debug
+	ifdef CONFIG_SYS_LDSCRIPT
+		# need to strip off double quotes
+		LDSCRIPT := $(srctree)/$(CONFIG_SYS_LDSCRIPT:"%"=%)
+	endif
+endif
+
+# If there is no specified link script, we look in a number of places for it
+ifndef LDSCRIPT
+	ifeq ($(wildcard $(LDSCRIPT)),)
+		LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds
+	endif
+	ifeq ($(wildcard $(LDSCRIPT)),)
+		LDSCRIPT := $(srctree)/$(CPUDIR)/u-boot.lds
+	endif
+	ifeq ($(wildcard $(LDSCRIPT)),)
+		LDSCRIPT := $(srctree)/arch/$(ARCH)/cpu/u-boot.lds
+	endif
+endif
+
+else
+# Dummy target needed, because used as prerequisite
+include/config/auto.conf: ;
+endif # $(dot-config)
+
+#
+# Xtensa linker script cannot be preprocessed with -ansi because of
+# preprocessor operations on strings that don't make C identifiers.
+#
+ifeq ($(CONFIG_XTENSA),)
+LDPPFLAGS	+= -ansi
+endif
+
+ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+KBUILD_CFLAGS	+= -Os
+else
+KBUILD_CFLAGS	+= -O2
+endif
+
+KBUILD_CFLAGS += $(call cc-option,-fno-stack-protector)
+KBUILD_CFLAGS += $(call cc-option,-fno-delete-null-pointer-checks)
+
+KBUILD_CFLAGS	+= -g
+# $(KBUILD_AFLAGS) sets -g, which causes gcc to pass a suitable -g<format>
+# option to the assembler.
+KBUILD_AFLAGS	+= -g
+
+# Report stack usage if supported
+ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-stack-usage.sh $(CC)),y)
+	KBUILD_CFLAGS += -fstack-usage
+endif
+
+KBUILD_CFLAGS += $(call cc-option,-Wno-format-nonliteral)
+
+# turn jbsr into jsr for m68k
+ifeq ($(ARCH),m68k)
+ifeq ($(findstring 3.4,$(shell $(CC) --version)),3.4)
+KBUILD_AFLAGS += -Wa,-gstabs,-S
+endif
+endif
+
+# Prohibit date/time macros, which would make the build non-deterministic
+KBUILD_CFLAGS   += $(call cc-option,-Werror=date-time)
+
+include scripts/Makefile.extrawarn
+
+# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
+KBUILD_CPPFLAGS += $(KCPPFLAGS)
+KBUILD_AFLAGS += $(KAFLAGS)
+KBUILD_CFLAGS += $(KCFLAGS)
+
+# Use UBOOTINCLUDE when you must reference the include/ directory.
+# Needed to be compatible with the O= option
+UBOOTINCLUDE    := \
+		-Iinclude \
+		$(if $(KBUILD_SRC), -I$(srctree)/include) \
+		$(if $(CONFIG_SYS_THUMB_BUILD), $(if $(CONFIG_HAS_THUMB2),, \
+			-I$(srctree)/arch/$(ARCH)/thumb1/include),) \
+		-I$(srctree)/arch/$(ARCH)/include \
+		-include $(srctree)/include/linux/kconfig.h
+
+NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+CHECKFLAGS     += $(NOSTDINC_FLAGS)
+
+# FIX ME
+cpp_flags := $(KBUILD_CPPFLAGS) $(PLATFORM_CPPFLAGS) $(UBOOTINCLUDE) \
+							$(NOSTDINC_FLAGS)
+c_flags := $(KBUILD_CFLAGS) $(cpp_flags)
+
+#########################################################################
+# U-Boot objects....order is important (i.e. start must be first)
+
+HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makefile),y,n)
+
+libs-y += lib/
+libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
+libs-$(CONFIG_OF_EMBED) += dts/
+libs-y += fs/
+libs-y += net/
+libs-y += disk/
+libs-y += drivers/
+libs-y += drivers/dma/
+libs-y += drivers/gpio/
+libs-y += drivers/i2c/
+libs-y += drivers/mmc/
+libs-y += drivers/mtd/
+libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
+libs-y += drivers/mtd/onenand/
+libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
+libs-y += drivers/mtd/spi/
+libs-y += drivers/net/
+libs-y += drivers/net/phy/
+libs-y += drivers/pci/
+libs-y += drivers/power/ \
+	drivers/power/domain/ \
+	drivers/power/fuel_gauge/ \
+	drivers/power/mfd/ \
+	drivers/power/pmic/ \
+	drivers/power/battery/ \
+	drivers/power/regulator/
+libs-y += drivers/spi/
+libs-$(CONFIG_FMAN_ENET) += drivers/net/fm/
+libs-$(CONFIG_SYS_FSL_DDR) += drivers/ddr/fsl/
+libs-$(CONFIG_SYS_FSL_MMDC) += drivers/ddr/fsl/
+libs-$(CONFIG_ALTERA_SDRAM) += drivers/ddr/altera/
+libs-y += drivers/serial/
+libs-y += drivers/usb/dwc3/
+libs-y += drivers/usb/common/
+libs-y += drivers/usb/emul/
+libs-y += drivers/usb/eth/
+libs-y += drivers/usb/gadget/
+libs-y += drivers/usb/gadget/udc/
+libs-y += drivers/usb/host/
+libs-y += drivers/usb/musb/
+libs-y += drivers/usb/musb-new/
+libs-y += drivers/usb/phy/
+libs-y += drivers/usb/ulpi/
+libs-y += drivers/rapidio/
+libs-y += cmd/
+libs-y += common/
+libs-$(CONFIG_API) += api/
+libs-$(CONFIG_HAS_POST) += post/
+libs-y += test/
+libs-y += test/dm/
+libs-$(CONFIG_UT_ENV) += test/env/
+libs-$(CONFIG_UT_OVERLAY) += test/overlay/
+
+libs-y += $(if $(BOARDDIR),board/$(BOARDDIR)/)
+
+libs-y := $(sort $(libs-y))
+
+u-boot-dirs	:= $(patsubst %/,%,$(filter %/, $(libs-y))) tools examples
+
+u-boot-alldirs	:= $(sort $(u-boot-dirs) $(patsubst %/,%,$(filter %/, $(libs-))))
+
+libs-y		:= $(patsubst %/, %/built-in.o, $(libs-y))
+
+u-boot-init := $(head-y)
+u-boot-main := $(libs-y)
+
+
+# Add GCC lib
+ifeq ($(CONFIG_USE_PRIVATE_LIBGCC),y)
+PLATFORM_LIBGCC = arch/$(ARCH)/lib/lib.a
+else
+PLATFORM_LIBGCC := -L $(shell dirname `$(CC) $(c_flags) -print-libgcc-file-name`) -lgcc
+endif
+PLATFORM_LIBS += $(PLATFORM_LIBGCC)
+export PLATFORM_LIBS
+export PLATFORM_LIBGCC
+
+# Special flags for CPP when processing the linker script.
+# Pass the version down so we can handle backwards compatibility
+# on the fly.
+LDPPFLAGS += \
+	-include $(srctree)/include/u-boot/u-boot.lds.h \
+	-DCPUDIR=$(CPUDIR) \
+	$(shell $(LD) --version | \
+	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
+
+#########################################################################
+#########################################################################
+
+ifneq ($(CONFIG_BOARD_SIZE_LIMIT),)
+BOARD_SIZE_CHECK = \
+	@actual=`wc -c $@ | awk '{print $$1}'`; \
+	limit=`printf "%d" $(CONFIG_BOARD_SIZE_LIMIT)`; \
+	if test $$actual -gt $$limit; then \
+		echo "$@ exceeds file size limit:" >&2 ; \
+		echo "  limit:  $$limit bytes" >&2 ; \
+		echo "  actual: $$actual bytes" >&2 ; \
+		echo "  excess: $$((actual - limit)) bytes" >&2; \
+		exit 1; \
+	fi
+else
+BOARD_SIZE_CHECK =
+endif
+
+# Statically apply RELA-style relocations (currently arm64 only)
+ifneq ($(CONFIG_STATIC_RELA),)
+# $(1) is u-boot ELF, $(2) is u-boot bin, $(3) is text base
+DO_STATIC_RELA = \
+	start=$$($(NM) $(1) | grep __rel_dyn_start | cut -f 1 -d ' '); \
+	end=$$($(NM) $(1) | grep __rel_dyn_end | cut -f 1 -d ' '); \
+	tools/relocate-rela $(2) $(3) $$start $$end
+else
+DO_STATIC_RELA =
+endif
+
+# Always append ALL so that arch config.mk's can add custom ones
+ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check
+
+ALL-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin
+ifeq ($(CONFIG_SPL_FSL_PBL),y)
+ALL-$(CONFIG_RAMBOOT_PBL) += u-boot-with-spl-pbl.bin
+else
+ifneq ($(CONFIG_SECURE_BOOT), y)
+# For Secure Boot The Image needs to be signed and Header must also
+# be included. So The image has to be built explicitly
+ALL-$(CONFIG_RAMBOOT_PBL) += u-boot.pbl
+endif
+endif
+ALL-$(CONFIG_SPL) += spl/u-boot-spl.bin
+ifeq ($(CONFIG_MX6)$(CONFIG_SECURE_BOOT), yy)
+ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot-ivt.img
+else
+ALL-$(CONFIG_SPL_FRAMEWORK) += u-boot.img
+endif
+ALL-$(CONFIG_TPL) += tpl/u-boot-tpl.bin
+ALL-$(CONFIG_OF_SEPARATE) += u-boot.dtb
+ifeq ($(CONFIG_SPL_FRAMEWORK),y)
+ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb.img
+endif
+ALL-$(CONFIG_OF_HOSTFILE) += u-boot.dtb
+ifneq ($(CONFIG_SPL_TARGET),)
+ALL-$(CONFIG_SPL) += $(CONFIG_SPL_TARGET:"%"=%)
+endif
+ALL-$(CONFIG_REMAKE_ELF) += u-boot.elf
+ALL-$(CONFIG_EFI_APP) += u-boot-app.efi
+ALL-$(CONFIG_EFI_STUB) += u-boot-payload.efi
+
+ifneq ($(BUILD_ROM),)
+ALL-$(CONFIG_X86_RESET_VECTOR) += u-boot.rom
+endif
+
+# enable combined SPL/u-boot/dtb rules for tegra
+ifeq ($(CONFIG_TEGRA)$(CONFIG_SPL),yy)
+ALL-y += u-boot-tegra.bin u-boot-nodtb-tegra.bin
+ALL-$(CONFIG_OF_SEPARATE) += u-boot-dtb-tegra.bin
+endif
+
+# Add optional build target if defined in board/cpu/soc headers
+ifneq ($(CONFIG_BUILD_TARGET),)
+ALL-y += $(CONFIG_BUILD_TARGET:"%"=%)
+endif
+
+LDFLAGS_u-boot += $(LDFLAGS_FINAL)
+ifneq ($(CONFIG_SYS_TEXT_BASE),)
+LDFLAGS_u-boot += -Ttext $(CONFIG_SYS_TEXT_BASE)
+endif
+
+# Normally we fill empty space with 0xff
+quiet_cmd_objcopy = OBJCOPY $@
+cmd_objcopy = $(OBJCOPY) --gap-fill=0xff $(OBJCOPYFLAGS) \
+	$(OBJCOPYFLAGS_$(@F)) $< $@
+
+# Provide a version which does not do this, for use by EFI
+quiet_cmd_zobjcopy = OBJCOPY $@
+cmd_zobjcopy = $(OBJCOPY) $(OBJCOPYFLAGS) $(OBJCOPYFLAGS_$(@F)) $< $@
+
+quiet_cmd_efipayload = OBJCOPY $@
+cmd_efipayload = $(OBJCOPY) -I binary -O $(EFIPAYLOAD_BFDTARGET) -B $(EFIPAYLOAD_BFDARCH) $< $@
+
+MKIMAGEOUTPUT ?= /dev/null
+
+quiet_cmd_mkimage = MKIMAGE $@
+cmd_mkimage = $(objtree)/tools/mkimage $(MKIMAGEFLAGS_$(@F)) -d $< $@ \
+	$(if $(KBUILD_VERBOSE:1=), >$(MKIMAGEOUTPUT))
+
+quiet_cmd_cat = CAT     $@
+cmd_cat = cat $(filter-out $(PHONY), $^) > $@
+
+append = cat $(filter-out $< $(PHONY), $^) >> $@
+
+quiet_cmd_pad_cat = CAT     $@
+cmd_pad_cat = $(cmd_objcopy) && $(append) || rm -f $@
+
+cfg: u-boot.cfg
+
+all:		$(ALL-y)
+ifneq ($(CONFIG_OMAP),y)
+ifeq ($(CONFIG_DM_I2C_COMPAT)$(CONFIG_SANDBOX),y)
+	@echo "===================== WARNING ======================"
+	@echo "This board uses CONFIG_DM_I2C_COMPAT. Please remove"
+	@echo "(possibly in a subsequent patch in your series)"
+	@echo "before sending patches to the mailing list."
+	@echo "===================================================="
+endif
+endif
+	@# Check that this build does not use CONFIG options that we do not
+	@# know about unless they are in Kconfig. All the existing CONFIG
+	@# options are whitelisted, so new ones should not be added.
+	$(srctree)/scripts/check-config.sh u-boot.cfg \
+		$(srctree)/scripts/config_whitelist.txt ${srctree} 1>&2
+
+PHONY += dtbs
+dtbs: dts/dt.dtb
+	@:
+dts/dt.dtb: checkdtc u-boot
+	$(Q)$(MAKE) $(build)=dts dtbs
+
+quiet_cmd_copy = COPY    $@
+      cmd_copy = cp $< $@
+
+ifeq ($(CONFIG_FIT_EMBED),y)
+fit-dtb.blob: dts/dt.dtb FORCE
+	$(call if_changed,mkimage)
+
+MKIMAGEFLAGS_fit-dtb.blob = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
+	-a 0 -e 0 -E \
+	$(patsubst %,-b arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST))) -d /dev/null
+
+u-boot-fit-dtb.bin: u-boot-nodtb.bin fit-dtb.blob
+	$(call if_changed,cat)
+
+u-boot.bin: u-boot-fit-dtb.bin FORCE
+	$(call if_changed,copy)
+else ifeq ($(CONFIG_OF_SEPARATE),y)
+u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE
+	$(call if_changed,cat)
+
+u-boot.bin: u-boot-dtb.bin FORCE
+	$(call if_changed,copy)
+else
+u-boot.bin: u-boot-nodtb.bin FORCE
+	$(call if_changed,copy)
+endif
+
+%.imx: %.bin
+	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
+
+%.vyb: %.imx
+	$(Q)$(MAKE) $(build)=arch/arm/cpu/armv7/vf610 $@
+
+quiet_cmd_copy = COPY    $@
+      cmd_copy = cp $< $@
+
+u-boot.dtb: dts/dt.dtb
+	$(call cmd,copy)
+
+OBJCOPYFLAGS_u-boot.hex := -O ihex
+
+OBJCOPYFLAGS_u-boot.srec := -O srec
+
+u-boot.hex u-boot.srec: u-boot FORCE
+	$(call if_changed,objcopy)
+
+OBJCOPYFLAGS_u-boot-nodtb.bin := -O binary \
+		$(if $(CONFIG_X86_RESET_VECTOR),-R .start16 -R .resetvec)
+
+binary_size_check: u-boot-nodtb.bin FORCE
+	@file_size=$(shell wc -c u-boot-nodtb.bin | awk '{print $$1}') ; \
+	map_size=$(shell cat u-boot.map | \
+		awk '/_image_copy_start/ {start = $$1} /_image_binary_end/ {end = $$1} END {if (start != "" && end != "") print "ibase=16; " toupper(end) " - " toupper(start)}' \
+		| sed 's/0X//g' \
+		| bc); \
+	if [ "" != "$$map_size" ]; then \
+		if test $$map_size -ne $$file_size; then \
+			echo "u-boot.map shows a binary size of $$map_size" >&2 ; \
+			echo "  but u-boot-nodtb.bin shows $$file_size" >&2 ; \
+			exit 1; \
+		fi \
+	fi
+
+u-boot-nodtb.bin: u-boot FORCE
+	$(call if_changed,objcopy)
+	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
+	$(BOARD_SIZE_CHECK)
+
+u-boot.ldr:	u-boot
+		$(CREATE_LDR_ENV)
+		$(LDR) -T $(CONFIG_CPU) -c $@ $< $(LDR_FLAGS)
+		$(BOARD_SIZE_CHECK)
+
+# binman
+# ---------------------------------------------------------------------------
+quiet_cmd_binman = BINMAN  $@
+cmd_binman = $(srctree)/tools/binman/binman -d u-boot.dtb -O . \
+		-I . -I $(srctree)/board/$(BOARDDIR) $<
+
+OBJCOPYFLAGS_u-boot.ldr.hex := -I binary -O ihex
+
+OBJCOPYFLAGS_u-boot.ldr.srec := -I binary -O srec
+
+u-boot.ldr.hex u-boot.ldr.srec: u-boot.ldr FORCE
+	$(call if_changed,objcopy)
+
+#
+# U-Boot entry point, needed for booting of full-blown U-Boot
+# from the SPL U-Boot version.
+#
+ifndef CONFIG_SYS_UBOOT_START
+CONFIG_SYS_UBOOT_START := 0
+endif
+
+# Create a file containing the configuration options the image was built with
+quiet_cmd_cpp_cfg = CFG     $@
+cmd_cpp_cfg = $(CPP) -Wp,-MD,$(depfile) $(cpp_flags) $(LDPPFLAGS) -ansi \
+	-DDO_DEPS_ONLY -D__ASSEMBLY__ -x assembler-with-cpp -P -dM -E -o $@ $<
+
+ifdef CONFIG_SPL_LOAD_FIT
+MKIMAGEFLAGS_u-boot.img = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
+	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
+	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board" -E \
+	$(patsubst %,-b arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST)))
+else
+MKIMAGEFLAGS_u-boot.img = -A $(ARCH) -T firmware -C none -O u-boot \
+	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
+	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board"
+MKIMAGEFLAGS_u-boot-ivt.img = -A $(ARCH) -T firmware_ivt -C none -O u-boot \
+	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
+	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board"
+u-boot-ivt.img: MKIMAGEOUTPUT = u-boot-ivt.img.log
+CLEAN_FILES += u-boot-ivt.img.log u-boot-dtb.imx.log SPL.log u-boot.imx.log
+endif
+
+MKIMAGEFLAGS_u-boot-dtb.img = $(MKIMAGEFLAGS_u-boot.img)
+
+MKIMAGEFLAGS_u-boot.kwb = -n $(srctree)/$(CONFIG_SYS_KWD_CONFIG:"%"=%) \
+	-T kwbimage -a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE)
+
+MKIMAGEFLAGS_u-boot-spl.kwb = -n $(srctree)/$(CONFIG_SYS_KWD_CONFIG:"%"=%) \
+	-T kwbimage -a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE)
+
+MKIMAGEFLAGS_u-boot.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
+		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage
+
+u-boot-dtb.img u-boot.img u-boot.kwb u-boot.pbl u-boot-ivt.img: \
+		$(if $(CONFIG_SPL_LOAD_FIT),u-boot-nodtb.bin dts/dt.dtb,u-boot.bin) FORCE
+	$(call if_changed,mkimage)
+
+u-boot-spl.kwb: u-boot.img spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+u-boot.sha1:	u-boot.bin
+		tools/ubsha1 u-boot.bin
+
+u-boot.dis:	u-boot
+		$(OBJDUMP) -d $< > $@
+
+ifdef CONFIG_TPL
+SPL_PAYLOAD := tpl/u-boot-with-tpl.bin
+else
+SPL_PAYLOAD := u-boot.bin
+endif
+
+OBJCOPYFLAGS_u-boot-with-spl.bin = -I binary -O binary \
+				   --pad-to=$(CONFIG_SPL_PAD_TO)
+u-boot-with-spl.bin: spl/u-boot-spl.bin $(SPL_PAYLOAD) FORCE
+	$(call if_changed,pad_cat)
+
+MKIMAGEFLAGS_lpc32xx-spl.img = -T lpc32xximage -a $(CONFIG_SPL_TEXT_BASE)
+
+lpc32xx-spl.img: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+OBJCOPYFLAGS_lpc32xx-boot-0.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
+
+lpc32xx-boot-0.bin: lpc32xx-spl.img FORCE
+	$(call if_changed,objcopy)
+
+OBJCOPYFLAGS_lpc32xx-boot-1.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
+
+lpc32xx-boot-1.bin: lpc32xx-spl.img FORCE
+	$(call if_changed,objcopy)
+
+lpc32xx-full.bin: lpc32xx-boot-0.bin lpc32xx-boot-1.bin u-boot.img FORCE
+	$(call if_changed,cat)
+
+CLEAN_FILES += lpc32xx-*
+
+OBJCOPYFLAGS_u-boot-with-tpl.bin = -I binary -O binary \
+				   --pad-to=$(CONFIG_TPL_PAD_TO)
+tpl/u-boot-with-tpl.bin: tpl/u-boot-tpl.bin u-boot.bin FORCE
+	$(call if_changed,pad_cat)
+
+SPL: spl/u-boot-spl.bin FORCE
+	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
+
+u-boot-with-spl.imx u-boot-with-nand-spl.imx: SPL u-boot.bin FORCE
+	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
+
+MKIMAGEFLAGS_u-boot.ubl = -n $(UBL_CONFIG) -T ublimage -e $(CONFIG_SYS_TEXT_BASE)
+
+u-boot.ubl: u-boot-with-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+MKIMAGEFLAGS_u-boot-spl.ais = -s -n $(if $(CONFIG_AIS_CONFIG_FILE), \
+	$(srctree)/$(CONFIG_AIS_CONFIG_FILE:"%"=%),"/dev/null") \
+	-T aisimage -e $(CONFIG_SPL_TEXT_BASE)
+spl/u-boot-spl.ais: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+OBJCOPYFLAGS_u-boot.ais = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO)
+u-boot.ais: spl/u-boot-spl.ais u-boot.img FORCE
+	$(call if_changed,pad_cat)
+
+u-boot-signed.sb: u-boot.bin spl/u-boot-spl.bin
+	$(Q)$(MAKE) $(build)=arch/arm/cpu/arm926ejs/mxs u-boot-signed.sb
+u-boot.sb: u-boot.bin spl/u-boot-spl.bin
+	$(Q)$(MAKE) $(build)=arch/arm/cpu/arm926ejs/mxs u-boot.sb
+
+# On x600 (SPEAr600) U-Boot is appended to U-Boot SPL.
+# Both images are created using mkimage (crc etc), so that the ROM
+# bootloader can check its integrity. Padding needs to be done to the
+# SPL image (with mkimage header) and not the binary. Otherwise the resulting image
+# which is loaded/copied by the ROM bootloader to SRAM doesn't fit.
+# The resulting image containing both U-Boot images is called u-boot.spr
+MKIMAGEFLAGS_u-boot-spl.img = -A $(ARCH) -T firmware -C none \
+	-a $(CONFIG_SPL_TEXT_BASE) -e $(CONFIG_SPL_TEXT_BASE) -n XLOADER
+spl/u-boot-spl.img: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+OBJCOPYFLAGS_u-boot.spr = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
+			  --gap-fill=0xff
+u-boot.spr: spl/u-boot-spl.img u-boot.img FORCE
+	$(call if_changed,pad_cat)
+
+ifneq ($(CONFIG_ARCH_SOCFPGA),)
+quiet_cmd_socboot = SOCBOOT $@
+cmd_socboot = cat	spl/u-boot-spl.sfp spl/u-boot-spl.sfp	\
+			spl/u-boot-spl.sfp spl/u-boot-spl.sfp	\
+			u-boot.img > $@ || rm -f $@
+u-boot-with-spl.sfp: spl/u-boot-spl.sfp u-boot.img FORCE
+	$(call if_changed,socboot)
+endif
+
+# x86 uses a large ROM. We fill it with 0xff, put the 16-bit stuff (including
+# reset vector) at the top, Intel ME descriptor at the bottom, and U-Boot in
+# the middle. This is handled by binman based on an image description in the
+# board's device tree.
+ifneq ($(CONFIG_X86_RESET_VECTOR),)
+rom: u-boot.rom FORCE
+
+refcode.bin: $(srctree)/board/$(BOARDDIR)/refcode.bin FORCE
+	$(call if_changed,copy)
+
+quiet_cmd_ldr = LD      $@
+cmd_ldr = $(LD) $(LDFLAGS_$(@F)) \
+	       $(filter-out FORCE,$^) -o $@
+
+u-boot.rom: u-boot-x86-16bit.bin u-boot.bin FORCE \
+		$(if $(CONFIG_HAVE_REFCODE),refcode.bin)
+	$(call if_changed,binman)
+
+OBJCOPYFLAGS_u-boot-x86-16bit.bin := -O binary -j .start16 -j .resetvec
+u-boot-x86-16bit.bin: u-boot FORCE
+	$(call if_changed,objcopy)
+endif
+
+ifneq ($(CONFIG_ARCH_SUNXI),)
+u-boot-sunxi-with-spl.bin: spl/sunxi-spl.bin u-boot.img u-boot.dtb FORCE
+	$(call if_changed,binman)
+endif
+
+ifneq ($(CONFIG_TEGRA),)
+OBJCOPYFLAGS_u-boot-nodtb-tegra.bin = -O binary --pad-to=$(CONFIG_SYS_TEXT_BASE)
+u-boot-nodtb-tegra.bin: spl/u-boot-spl u-boot-nodtb.bin FORCE
+	$(call if_changed,pad_cat)
+
+OBJCOPYFLAGS_u-boot-tegra.bin = -O binary --pad-to=$(CONFIG_SYS_TEXT_BASE)
+u-boot-tegra.bin: spl/u-boot-spl u-boot.bin FORCE
+	$(call if_changed,pad_cat)
+
+u-boot-dtb-tegra.bin: u-boot-tegra.bin FORCE
+	$(call if_changed,copy)
+endif
+
+OBJCOPYFLAGS_u-boot-app.efi := $(OBJCOPYFLAGS_EFI)
+u-boot-app.efi: u-boot FORCE
+	$(call if_changed,zobjcopy)
+
+u-boot.bin.o: u-boot.bin FORCE
+	$(call if_changed,efipayload)
+
+u-boot-payload.lds: $(LDSCRIPT_EFI) FORCE
+	$(call if_changed_dep,cpp_lds)
+
+# Rule to link the EFI payload which contains a stub and a U-Boot binary
+quiet_cmd_u-boot_payload ?= LD      $@
+      cmd_u-boot_payload ?= $(LD) $(LDFLAGS_EFI_PAYLOAD) -o $@ \
+      -T u-boot-payload.lds arch/x86/cpu/call32.o \
+      lib/efi/efi.o lib/efi/efi_stub.o u-boot.bin.o \
+      $(addprefix arch/$(ARCH)/lib/,$(EFISTUB))
+
+u-boot-payload: u-boot.bin.o u-boot-payload.lds FORCE
+	$(call if_changed,u-boot_payload)
+
+OBJCOPYFLAGS_u-boot-payload.efi := $(OBJCOPYFLAGS_EFI)
+u-boot-payload.efi: u-boot-payload FORCE
+	$(call if_changed,zobjcopy)
+
+u-boot-img.bin: spl/u-boot-spl.bin u-boot.img FORCE
+	$(call if_changed,cat)
+
+#Add a target to create boot binary having SPL binary in PBI format
+#concatenated with u-boot binary. It is need by PowerPC SoC having
+#internal SRAM <= 512KB.
+MKIMAGEFLAGS_u-boot-spl.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
+		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage \
+		-A $(ARCH) -a $(CONFIG_SPL_TEXT_BASE)
+
+spl/u-boot-spl.pbl: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+ifeq ($(ARCH),arm)
+UBOOT_BINLOAD := u-boot.img
+else
+UBOOT_BINLOAD := u-boot.bin
+endif
+
+OBJCOPYFLAGS_u-boot-with-spl-pbl.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
+			  --gap-fill=0xff
+
+u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl $(UBOOT_BINLOAD) FORCE
+	$(call if_changed,pad_cat)
+
+# PPC4xx needs the SPL at the end of the image, since the reset vector
+# is located at 0xfffffffc. So we can't use the "u-boot-img.bin" target
+# and need to introduce a new build target with the full blown U-Boot
+# at the start padded up to the start of the SPL image. And then concat
+# the SPL image to the end.
+
+OBJCOPYFLAGS_u-boot-img-spl-at-end.bin := -I binary -O binary \
+	--pad-to=$(CONFIG_UBOOT_PAD_TO) --gap-fill=0xff
+u-boot-img-spl-at-end.bin: u-boot.img spl/u-boot-spl.bin FORCE
+	$(call if_changed,pad_cat)
+
+# Create a new ELF from a raw binary file.  This is useful for arm64
+# where static relocation needs to be performed on the raw binary,
+# but certain simulators only accept an ELF file (but don't do the
+# relocation).
+# FIXME refactor dts/Makefile to share target/arch detection
+u-boot.elf: u-boot.bin
+	@$(OBJCOPY)  -B aarch64 -I binary -O elf64-littleaarch64 \
+		$< u-boot-elf.o
+	@$(LD) u-boot-elf.o -o $@ \
+		--defsym=_start=$(CONFIG_SYS_TEXT_BASE) \
+		-Ttext=$(CONFIG_SYS_TEXT_BASE)
+
+# Rule to link u-boot
+# May be overridden by arch/$(ARCH)/config.mk
+quiet_cmd_u-boot__ ?= LD      $@
+      cmd_u-boot__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_u-boot) -o $@ \
+      -T u-boot.lds $(u-boot-init)                             \
+      --start-group $(u-boot-main) --end-group                 \
+      $(PLATFORM_LIBS) -Map u-boot.map
+
+quiet_cmd_smap = GEN     common/system_map.o
+cmd_smap = \
+	smap=`$(call SYSTEM_MAP,u-boot) | \
+		awk '$$2 ~ /[tTwW]/ {printf $$1 $$3 "\\\\000"}'` ; \
+	$(CC) $(c_flags) -DSYSTEM_MAP="\"$${smap}\"" \
+		-c $(srctree)/common/system_map.c -o common/system_map.o
+
+u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds FORCE
+	$(call if_changed,u-boot__)
+ifeq ($(CONFIG_KALLSYMS),y)
+	$(call cmd,smap)
+	$(call cmd,u-boot__) common/system_map.o
+endif
+
+quiet_cmd_sym ?= SYM     $@
+      cmd_sym ?= $(OBJDUMP) -t $< > $@
+u-boot.sym: u-boot FORCE
+	$(call if_changed,sym)
+
+# The actual objects are generated when descending,
+# make sure no implicit rule kicks in
+$(sort $(u-boot-init) $(u-boot-main)): $(u-boot-dirs) ;
+
+# Handle descending into subdirectories listed in $(vmlinux-dirs)
+# Preset locale variables to speed up the build process. Limit locale
+# tweaks to this spot to avoid wrong language settings when running
+# make menuconfig etc.
+# Error messages still appears in the original language
+
+PHONY += $(u-boot-dirs)
+$(u-boot-dirs): prepare scripts
+	$(Q)$(MAKE) $(build)=$@
+
+tools: prepare
+# The "tools" are needed early
+$(filter-out tools, $(u-boot-dirs)): tools
+# The "examples" conditionally depend on U-Boot (say, when USE_PRIVATE_LIBGCC
+# is "yes"), so compile examples after U-Boot is compiled.
+examples: $(filter-out examples, $(u-boot-dirs))
+
+define filechk_uboot.release
+	echo "$(UBOOTVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
+endef
+
+# Store (new) UBOOTRELEASE string in include/config/uboot.release
+include/config/uboot.release: include/config/auto.conf FORCE
+	$(call filechk,uboot.release)
+
+
+# Things we need to do before we recursively start building the kernel
+# or the modules are listed in "prepare".
+# A multi level approach is used. prepareN is processed before prepareN-1.
+# archprepare is used in arch Makefiles and when processed asm symlink,
+# version.h and scripts_basic is processed / created.
+
+# Listed in dependency order
+PHONY += prepare archprepare prepare0 prepare1 prepare2 prepare3
+
+# prepare3 is used to check if we are building in a separate output directory,
+# and if so do:
+# 1) Check that make has not been executed in the kernel src $(srctree)
+prepare3: include/config/uboot.release
+ifneq ($(KBUILD_SRC),)
+	@$(kecho) '  Using $(srctree) as source for U-Boot'
+	$(Q)if [ -f $(srctree)/.config -o -d $(srctree)/include/config ]; then \
+		echo >&2 "  $(srctree) is not clean, please run 'make mrproper'"; \
+		echo >&2 "  in the '$(srctree)' directory.";\
+		/bin/false; \
+	fi;
+endif
+
+# prepare2 creates a makefile if using a separate output directory
+prepare2: prepare3 outputmakefile
+
+prepare1: prepare2 $(version_h) $(timestamp_h) \
+                   include/config/auto.conf
+ifeq ($(wildcard $(LDSCRIPT)),)
+	@echo >&2 "  Could not find linker script."
+	@/bin/false
+endif
+
+archprepare: prepare1 scripts_basic
+
+prepare0: archprepare FORCE
+	$(Q)$(MAKE) $(build)=.
+
+# All the preparing..
+prepare: prepare0
+
+# Generate some files
+# ---------------------------------------------------------------------------
+
+define filechk_version.h
+	(echo \#define PLAIN_VERSION \"$(UBOOTRELEASE)\"; \
+	echo \#define U_BOOT_VERSION \"U-Boot \" PLAIN_VERSION; \
+	echo \#define CC_VERSION_STRING \"$$(LC_ALL=C $(CC) --version | head -n 1)\"; \
+	echo \#define LD_VERSION_STRING \"$$(LC_ALL=C $(LD) --version | head -n 1)\"; )
+endef
+
+# The SOURCE_DATE_EPOCH mechanism requires a date that behaves like GNU date.
+# The BSD date on the other hand behaves different and would produce errors
+# with the misused '-d' switch.  Respect that and search a working date with
+# well known pre- and suffixes for the GNU variant of date.
+define filechk_timestamp.h
+	(if test -n "$${SOURCE_DATE_EPOCH}"; then \
+		SOURCE_DATE="@$${SOURCE_DATE_EPOCH}"; \
+		DATE=""; \
+		for date in gdate date.gnu date; do \
+			$${date} -u -d "$${SOURCE_DATE}" >/dev/null 2>&1 && DATE="$${date}"; \
+		done; \
+		if test -n "$${DATE}"; then \
+			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_DATE "%b %d %C%y"'; \
+			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_TIME "%T"'; \
+			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_TZ "%z"'; \
+			LC_ALL=C $${DATE} -u -d "$${SOURCE_DATE}" +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; \
+		else \
+			return 42; \
+		fi; \
+	else \
+		LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"'; \
+		LC_ALL=C date +'#define U_BOOT_TIME "%T"'; \
+		LC_ALL=C date +'#define U_BOOT_TZ "%z"'; \
+		LC_ALL=C date +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; \
+	fi)
+endef
+
+$(version_h): include/config/uboot.release FORCE
+	$(call filechk,version.h)
+
+$(timestamp_h): $(srctree)/Makefile FORCE
+	$(call filechk,timestamp.h)
+
+# ---------------------------------------------------------------------------
+quiet_cmd_cpp_lds = LDS     $@
+cmd_cpp_lds = $(CPP) -Wp,-MD,$(depfile) $(cpp_flags) $(LDPPFLAGS) \
+		-D__ASSEMBLY__ -x assembler-with-cpp -P -o $@ $<
+
+u-boot.lds: $(LDSCRIPT) prepare FORCE
+	$(call if_changed_dep,cpp_lds)
+
+spl/u-boot-spl.bin: spl/u-boot-spl
+	@:
+spl/u-boot-spl: tools prepare \
+		$(if $(CONFIG_OF_SEPARATE)$(CONFIG_SPL_OF_PLATDATA),dts/dt.dtb)
+	$(Q)$(MAKE) obj=spl -f $(srctree)/scripts/Makefile.spl all
+
+spl/sunxi-spl.bin: spl/u-boot-spl
+	@:
+
+spl/u-boot-spl.sfp: spl/u-boot-spl
+	@:
+
+spl/boot.bin: spl/u-boot-spl
+	@:
+
+tpl/u-boot-tpl.bin: tools prepare
+	$(Q)$(MAKE) obj=tpl -f $(srctree)/scripts/Makefile.spl all
+
+TAG_SUBDIRS := $(patsubst %,$(srctree)/%,$(u-boot-dirs) include)
+
+FIND := find
+FINDFLAGS := -L
+
+tags ctags:
+		ctags -w -o ctags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
+						-name '*.[chS]' -print`
+		ln -s ctags tags
+
+etags:
+		etags -a -o etags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
+						-name '*.[chS]' -print`
+cscope:
+		$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) -name '*.[chS]' -print > \
+						cscope.files
+		cscope -b -q -k
+
+SYSTEM_MAP = \
+		$(NM) $1 | \
+		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
+		LC_ALL=C sort
+System.map:	u-boot
+		@$(call SYSTEM_MAP,$<) > $@
+
+checkdtc:
+	@if test $(call dtc-version) -lt 0104; then \
+		echo '*** Your dtc is too old, please upgrade to dtc 1.4 or newer'; \
+		false; \
+	fi
+
+#########################################################################
+
+# ARM relocations should all be R_ARM_RELATIVE (32-bit) or
+# R_AARCH64_RELATIVE (64-bit).
+checkarmreloc: u-boot
+	@RELOC="`$(CROSS_COMPILE)readelf -r -W $< | cut -d ' ' -f 4 | \
+		grep R_A | sort -u`"; \
+	if test "$$RELOC" != "R_ARM_RELATIVE" -a \
+		 "$$RELOC" != "R_AARCH64_RELATIVE"; then \
+		echo "$< contains unexpected relocations: $$RELOC"; \
+		false; \
+	fi
+
+env: scripts_basic
+	$(Q)$(MAKE) $(build)=tools/$@
+
+tools-only: scripts_basic $(version_h) $(timestamp_h)
+	$(Q)$(MAKE) $(build)=tools
+
+tools-all: export HOST_TOOLS_ALL=y
+tools-all: env tools ;
+
+cross_tools: export CROSS_BUILD_TOOLS=y
+cross_tools: tools ;
+
+.PHONY : CHANGELOG
+CHANGELOG:
+	git log --no-merges U-Boot-1_1_5.. | \
+	unexpand -a | sed -e 's/\s\s*$$//' > $@
+
+#########################################################################
+
+###
+# Cleaning is done on three levels.
+# make clean     Delete most generated files
+#                Leave enough to build external modules
+# make mrproper  Delete the current configuration, and all generated files
+# make distclean Remove editor backup files, patch leftover files and the like
+
+# Directories & files removed with 'make clean'
+CLEAN_DIRS  += $(MODVERDIR) \
+	       $(foreach d, spl tpl, $(patsubst %,$d/%, \
+			$(filter-out include, $(shell ls -1 $d 2>/dev/null))))
+
+CLEAN_FILES += include/bmp_logo.h include/bmp_logo_data.h include/license.h \
+	       boot* u-boot* MLO* SPL System.map fit-dtb.blob
+
+# Directories & files removed with 'make mrproper'
+MRPROPER_DIRS  += include/config include/generated spl tpl \
+		  .tmp_objdiff
+MRPROPER_FILES += .config .config.old include/autoconf.mk* include/config.h \
+		  ctags etags tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS
+
+# clean - Delete most, but leave enough to build external modules
+#
+clean: rm-dirs  := $(CLEAN_DIRS)
+clean: rm-files := $(CLEAN_FILES)
+
+clean-dirs	:= $(foreach f,$(u-boot-alldirs),$(if $(wildcard $(srctree)/$f/Makefile),$f))
+
+clean-dirs      := $(addprefix _clean_, $(clean-dirs) doc/DocBook)
+
+PHONY += $(clean-dirs) clean archclean
+$(clean-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+
+# TODO: Do not use *.cfgtmp
+clean: $(clean-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
+		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
+		-o -name '*.ko.*' -o -name '*.su' -o -name '*.cfgtmp' \
+		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
+		-o -name '*.symtypes' -o -name 'modules.order' \
+		-o -name modules.builtin -o -name '.tmp_*.o.*' \
+		-o -name 'dsdt.aml' -o -name 'dsdt.asl.tmp' -o -name 'dsdt.c' \
+		-o -name '*.gcno' \) -type f -print | xargs rm -f
+
+# mrproper - Delete all generated files, including .config
+#
+mrproper: rm-dirs  := $(wildcard $(MRPROPER_DIRS))
+mrproper: rm-files := $(wildcard $(MRPROPER_FILES))
+mrproper-dirs      := $(addprefix _mrproper_,scripts)
+
+PHONY += $(mrproper-dirs) mrproper archmrproper
+$(mrproper-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _mrproper_%,%,$@)
+
+mrproper: clean $(mrproper-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+	@rm -f arch/*/include/asm/arch
+
+# distclean
+#
+PHONY += distclean
+
+distclean: mrproper
+	@find $(srctree) $(RCS_FIND_IGNORE) \
+		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
+		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
+		-o -name '.*.rej' -o -name '*%' -o -name 'core' \
+		-o -name '*.pyc' \) \
+		-type f -print | xargs rm -f
+	@rm -f boards.cfg
+
+backup:
+	F=`basename $(srctree)` ; cd .. ; \
+	gtar --force-local -zcvf `LC_ALL=C date "+$$F-%Y-%m-%d-%T.tar.gz"` $$F
+
+help:
+	@echo  'Cleaning targets:'
+	@echo  '  clean		  - Remove most generated files but keep the config'
+	@echo  '  mrproper	  - Remove all generated files + config + various backup files'
+	@echo  '  distclean	  - mrproper + remove editor backup and patch files'
+	@echo  ''
+	@echo  'Configuration targets:'
+	@$(MAKE) -f $(srctree)/scripts/kconfig/Makefile help
+	@echo  ''
+	@echo  'Other generic targets:'
+	@echo  '  all		  - Build all necessary images depending on configuration'
+	@echo  '  tests		  - Build U-Boot for sandbox and run tests'
+	@echo  '* u-boot	  - Build the bare u-boot'
+	@echo  '  dir/            - Build all files in dir and below'
+	@echo  '  dir/file.[oisS] - Build specified target only'
+	@echo  '  dir/file.lst    - Build specified mixed source/assembly target only'
+	@echo  '                    (requires a recent binutils and recent build (System.map))'
+	@echo  '  tags/ctags	  - Generate ctags file for editors'
+	@echo  '  etags		  - Generate etags file for editors'
+	@echo  '  cscope	  - Generate cscope index'
+	@echo  '  ubootrelease	  - Output the release version string (use with make -s)'
+	@echo  '  ubootversion	  - Output the version stored in Makefile (use with make -s)'
+	@echo  "  cfg		  - Don't build, just create the .cfg files"
+	@echo  ''
+	@echo  'Static analysers'
+	@echo  '  checkstack      - Generate a list of stack hogs'
+	@echo  ''
+	@echo  'Documentation targets:'
+	@$(MAKE) -f $(srctree)/doc/DocBook/Makefile dochelp
+	@echo  ''
+	@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'
+	@echo  '  make V=2   [targets] 2 => give reason for rebuild of target'
+	@echo  '  make O=dir [targets] Locate all output files in "dir", including .config'
+	@echo  '  make C=1   [targets] Check all c source with $$CHECK (sparse by default)'
+	@echo  '  make C=2   [targets] Force check of all c source with $$CHECK'
+	@echo  '  make RECORDMCOUNT_WARN=1 [targets] Warn about ignored mcount sections'
+	@echo  '  make W=n   [targets] Enable extra gcc checks, n=1,2,3 where'
+	@echo  '		1: warnings which may be relevant and do not occur too often'
+	@echo  '		2: warnings which occur quite often but may still be relevant'
+	@echo  '		3: more obscure warnings, can most likely be ignored'
+	@echo  '		Multiple levels can be combined with W=12 or W=123'
+	@echo  ''
+	@echo  'Execute "make" or "make all" to build all targets marked with [*] '
+	@echo  'For further info see the ./README file'
+
+tests:
+	$(srctree)/test/run
+
+# Documentation targets
+# ---------------------------------------------------------------------------
+%docs: scripts_basic FORCE
+	$(Q)$(MAKE) $(build)=scripts build_docproc
+	$(Q)$(MAKE) $(build)=doc/DocBook $@
+
+# Dummies...
+PHONY += prepare scripts
+prepare: ;
+scripts: ;
+
+endif #ifeq ($(config-targets),1)
+endif #ifeq ($(mixed-targets),1)
+
+PHONY += checkstack ubootrelease ubootversion
+
+checkstack:
+	$(OBJDUMP) -d u-boot $$(find . -name u-boot-spl) | \
+	$(PERL) $(src)/scripts/checkstack.pl $(ARCH)
+
+ubootrelease:
+	@echo "$(UBOOTVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
+
+ubootversion:
+	@echo $(UBOOTVERSION)
+
+# Single targets
+# ---------------------------------------------------------------------------
+# Single targets are compatible with:
+# - build with mixed source and output
+# - build with separate output dir 'make O=...'
+# - external modules
+#
+#  target-dir => where to store outputfile
+#  build-dir  => directory in kernel source tree to use
+
+ifeq ($(KBUILD_EXTMOD),)
+        build-dir  = $(patsubst %/,%,$(dir $@))
+        target-dir = $(dir $@)
+else
+        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
+        build-dir  = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
+        target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
+endif
+
+%.s: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.i: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.lst: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.s: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.symtypes: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+
+# Modules
+/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%.ko: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
+	$(build)=$(build-dir) $(@:.ko=.o)
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+
+# FIXME Should go into a make.lib or something
+# ===========================================================================
+
+quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
+      cmd_rmdirs = rm -rf $(rm-dirs)
+
+quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files)))
+      cmd_rmfiles = rm -f $(rm-files)
+
+# read all saved command lines
+
+targets := $(wildcard $(sort $(targets)))
+cmd_files := $(wildcard .*.cmd $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
+
+ifneq ($(cmd_files),)
+  $(cmd_files): ;	# Do not try to update included dependency files
+  include $(cmd_files)
+endif
+
+endif	# skip-makefile
+
+PHONY += FORCE
+FORCE:
+
+# Declare the contents of the .PHONY variable as phony.  We keep that
+# information in a variable so we can use it in if_changed and friends.
+.PHONY: $(PHONY)
diff -u -N U-Boot_SDcard/common/spl/spl_ext.c U-Boot_SDcard/common/spl/spl_ext.c
--- U-Boot_SDcard/common/spl/spl_ext.c	2019-09-12 15:54:35.000000204 -0500
+++ U-Boot_SDcard/common/spl/spl_ext.c	1969-12-31 19:29:20.000000768 -0600
@@ -9,7 +9,6 @@
 #include <errno.h>
 #include <image.h>
 
-#ifdef CONFIG_SPL_EXT_SUPPORT
 int spl_load_image_ext(struct spl_image_info *spl_image,
 		       struct blk_desc *block_dev, int partition,
 		       const char *filename)
@@ -146,4 +145,3 @@
 	return -ENOSYS;
 }
 #endif
-#endif
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h	2019-09-12 15:54:12.000000755 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clock.h	1969-12-31 19:29:30.000000324 -0600
@@ -12,6 +12,7 @@
 #define _CLOCKS_H_
 
 #include <asm/arch/clocks_am33xx.h>
+#include <asm/arch/hardware.h>
 
 #ifdef CONFIG_TI81XX
 #include <asm/arch/clock_ti81xx.h>
@@ -103,6 +104,12 @@
 extern const struct dpll_regs dpll_core_regs;
 extern const struct dpll_regs dpll_per_regs;
 extern const struct dpll_regs dpll_ddr_regs;
+extern const struct dpll_params dpll_mpu_opp[NUM_CRYSTAL_FREQ][NUM_OPPS];
+extern const struct dpll_params dpll_core_1000MHz[NUM_CRYSTAL_FREQ];
+extern const struct dpll_params dpll_per_192MHz[NUM_CRYSTAL_FREQ];
+extern const struct dpll_params dpll_ddr2_266MHz[NUM_CRYSTAL_FREQ];
+extern const struct dpll_params dpll_ddr3_303MHz[NUM_CRYSTAL_FREQ];
+extern const struct dpll_params dpll_ddr3_400MHz[NUM_CRYSTAL_FREQ];
 
 extern struct cm_wkuppll *const cmwkup;
 
@@ -114,6 +121,12 @@
 void do_setup_dpll(const struct dpll_regs *, const struct dpll_params *);
 void prcm_init(void);
 void enable_basic_clocks(void);
+
+void rtc_only_update_board_type(u32 btype);
+u32 rtc_only_get_board_type(void);
+void rtc_only_prcm_init(void);
+void rtc_only_enable_basic_clocks(void);
+
 void do_enable_clocks(u32 *const *, u32 *const *, u8);
 void do_disable_clocks(u32 *const *, u32 *const *, u8);
 
diff -u -N U-Boot_SDcard/common/env_nand.c U-Boot_SDcard/common/env_nand.c
--- U-Boot_SDcard/common/env_nand.c	2019-09-12 15:55:02.000000501 -0500
+++ U-Boot_SDcard/common/env_nand.c	1969-12-31 19:29:17.000000485 -0600
@@ -130,17 +130,22 @@
 	size_t end = offset + CONFIG_ENV_RANGE;
 	size_t amount_saved = 0;
 	size_t blocksize, len;
+	struct mtd_info *mtd;
 	u_char *char_ptr;
 
-	blocksize = nand_info[0]->erasesize;
+	mtd = get_nand_dev_by_index(0);
+	if (!mtd)
+		return 1;
+
+	blocksize = mtd->erasesize;
 	len = min(blocksize, (size_t)CONFIG_ENV_SIZE);
 
 	while (amount_saved < CONFIG_ENV_SIZE && offset < end) {
-		if (nand_block_isbad(nand_info[0], offset)) {
+		if (nand_block_isbad(mtd, offset)) {
 			offset += blocksize;
 		} else {
 			char_ptr = &buf[amount_saved];
-			if (nand_write(nand_info[0], offset, &len, char_ptr))
+			if (nand_write(mtd, offset, &len, char_ptr))
 				return 1;
 
 			offset += blocksize;
@@ -161,13 +166,15 @@
 static int erase_and_write_env(const struct env_location *location,
 		u_char *env_new)
 {
+	struct mtd_info *mtd;
 	int ret = 0;
 
-	if (!nand_info[0])
+	mtd = get_nand_dev_by_index(0);
+	if (!mtd)
 		return 1;
 
 	printf("Erasing %s...\n", location->name);
-	if (nand_erase_opts(nand_info[0], &location->erase_opts))
+	if (nand_erase_opts(mtd, &location->erase_opts))
 		return 1;
 
 	printf("Writing to %s... ", location->name);
@@ -248,22 +255,24 @@
 	size_t end = offset + CONFIG_ENV_RANGE;
 	size_t amount_loaded = 0;
 	size_t blocksize, len;
+	struct mtd_info *mtd;
 	u_char *char_ptr;
 
-	if (!nand_info[0])
+	mtd = get_nand_dev_by_index(0);
+	if (!mtd)
 		return 1;
 
-	blocksize = nand_info[0]->erasesize;
+	blocksize = mtd->erasesize;
 	len = min(blocksize, (size_t)CONFIG_ENV_SIZE);
 
 	while (amount_loaded < CONFIG_ENV_SIZE && offset < end) {
-		if (nand_block_isbad(nand_info[0], offset)) {
+		if (nand_block_isbad(mtd, offset)) {
 			offset += blocksize;
 		} else {
 			char_ptr = &buf[amount_loaded];
-			if (nand_read_skip_bad(nand_info[0], offset,
+			if (nand_read_skip_bad(mtd, offset,
 					       &len, NULL,
-					       nand_info[0]->size, char_ptr))
+					       mtd->size, char_ptr))
 				return 1;
 
 			offset += blocksize;
@@ -390,12 +399,12 @@
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
 
 #if defined(CONFIG_ENV_OFFSET_OOB)
+	struct mtd_info *mtd  = get_nand_dev_by_index(0);
 	/*
 	 * If unable to read environment offset from NAND OOB then fall through
 	 * to the normal environment reading code below
 	 */
-	if (nand_info[0] && !get_nand_env_oob(nand_info[0],
-					      &nand_env_oob_offset)) {
+	if (mtd && !get_nand_env_oob(mtd, &nand_env_oob_offset)) {
 		printf("Found Environment offset in OOB..\n");
 	} else {
 		set_default_env("!no env offset in OOB");
diff -u -N U-Boot_SDcard/drivers/mmc/sdhci.c U-Boot_SDcard/drivers/mmc/sdhci.c
--- U-Boot_SDcard/drivers/mmc/sdhci.c	2019-09-12 15:54:25.000000221 -0500
+++ U-Boot_SDcard/drivers/mmc/sdhci.c	1969-12-31 19:29:21.000000213 -0600
@@ -424,7 +424,7 @@
 {
 	struct mmc *mmc = mmc_get_mmc_dev(dev);
 #else
-static void sdhci_set_ios(struct mmc *mmc)
+static int sdhci_set_ios(struct mmc *mmc)
 {
 #endif
 	u32 ctrl;
@@ -462,9 +462,8 @@
 		ctrl &= ~SDHCI_CTRL_HISPD;
 
 	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
-#ifdef CONFIG_DM_MMC_OPS
+
 	return 0;
-#endif
 }
 
 static int sdhci_init(struct mmc *mmc)
diff -u -N /dev/null U-Boot_SDcard/arch/arm/mach-omap2/fdt-common.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-omap2/fdt-common.c	1969-12-31 19:31:37.000000948 -0600
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2016-2017 Texas Instruments, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+#include <asm/omap_common.h>
+#include <asm/omap_sec_common.h>
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+
+/* Give zero values if not already defined */
+#ifndef TI_OMAP5_SECURE_BOOT_RESV_SRAM_SZ
+#define TI_OMAP5_SECURE_BOOT_RESV_SRAM_SZ (0)
+#endif
+#ifndef CONFIG_SECURE_RUNTIME_RESV_SRAM_SZ
+#define CONFIG_SECURE_RUNTIME_RESV_SRAM_SZ (0)
+#endif
+
+int ft_hs_disable_rng(void *fdt, bd_t *bd)
+{
+	const char *path;
+	int offs;
+	int ret;
+
+	/* Make HW RNG reserved for secure world use */
+	path = "/ocp/rng";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0) {
+		debug("Node %s not found.\n", path);
+		return 0;
+	}
+	ret = fdt_setprop_string(fdt, offs,
+				 "status", "disabled");
+	if (ret < 0) {
+		printf("Could not add status property to node %s: %s\n",
+		       path, fdt_strerror(ret));
+		return ret;
+	}
+	return 0;
+}
+
+#if (CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE != 0)
+/*
+ * fdt_pack_reg - pack address and size array into the "reg"-suitable stream
+ */
+static int fdt_pack_reg(const void *fdt, void *buf, u64 address, u64 size)
+{
+	int address_cells = fdt_address_cells(fdt, 0);
+	int size_cells = fdt_size_cells(fdt, 0);
+	char *p = buf;
+
+	if (address_cells == 2)
+		*(fdt64_t *)p = cpu_to_fdt64(address);
+	else
+		*(fdt32_t *)p = cpu_to_fdt32(address);
+	p += 4 * address_cells;
+
+	if (size_cells == 2)
+		*(fdt64_t *)p = cpu_to_fdt64(size);
+	else
+		*(fdt32_t *)p = cpu_to_fdt32(size);
+	p += 4 * size_cells;
+
+	return p - (char *)buf;
+}
+
+int ft_hs_fixup_dram(void *fdt, bd_t *bd)
+{
+	const char *path, *subpath;
+	int offs, len;
+	u32 sec_mem_start = get_sec_mem_start();
+	u32 sec_mem_size = CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE;
+	fdt32_t address_cells = cpu_to_fdt32(fdt_address_cells(fdt, 0));
+	fdt32_t size_cells = cpu_to_fdt32(fdt_size_cells(fdt, 0));
+	u8 temp[16]; /* Up to 64-bit address + 64-bit size */
+
+	/* Delete any original secure_reserved node */
+	path = "/reserved-memory/secure_reserved";
+	offs = fdt_path_offset(fdt, path);
+	if (offs >= 0)
+		fdt_del_node(fdt, offs);
+
+	/* Add new secure_reserved node */
+	path = "/reserved-memory";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0) {
+		debug("Node %s not found\n", path);
+		path = "/";
+		subpath = "reserved-memory";
+		offs = fdt_path_offset(fdt, path);
+		offs = fdt_add_subnode(fdt, offs, subpath);
+		if (offs < 0) {
+			printf("Could not create %s%s node.\n", path, subpath);
+			return 1;
+		}
+		path = "/reserved-memory";
+		offs = fdt_path_offset(fdt, path);
+
+		fdt_setprop(fdt, offs, "#address-cells", &address_cells, sizeof(address_cells));
+		fdt_setprop(fdt, offs, "#size-cells", &size_cells, sizeof(size_cells));
+		fdt_setprop(fdt, offs, "ranges", NULL, 0);
+	}
+
+	subpath = "secure_reserved";
+	offs = fdt_add_subnode(fdt, offs, subpath);
+	if (offs < 0) {
+		printf("Could not create %s%s node.\n", path, subpath);
+		return 1;
+	}
+
+	fdt_setprop_string(fdt, offs, "compatible", "ti,secure-memory");
+	fdt_setprop_string(fdt, offs, "status", "okay");
+	fdt_setprop(fdt, offs, "no-map", NULL, 0);
+	len = fdt_pack_reg(fdt, temp, sec_mem_start, sec_mem_size);
+	fdt_setprop(fdt, offs, "reg", temp, len);
+
+	return 0;
+}
+#else
+int ft_hs_fixup_dram(void *fdt, bd_t *bd) { return 0; }
+#endif
+
+int ft_hs_add_tee(void *fdt, bd_t *bd)
+{
+	const char *path, *subpath;
+	int offs;
+
+	extern int tee_loaded;
+	if (!tee_loaded)
+		return 0;
+
+	path = "/firmware";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0) {
+		path = "/";
+		offs = fdt_path_offset(fdt, path);
+		if (offs < 0) {
+			printf("Could not find root node.\n");
+			return 1;
+		}
+
+		subpath = "firmware";
+		offs = fdt_add_subnode(fdt, offs, subpath);
+		if (offs < 0) {
+			printf("Could not create %s node.\n", subpath);
+			return 1;
+		}
+	}
+
+	subpath = "optee";
+	offs = fdt_add_subnode(fdt, offs, subpath);
+	if (offs < 0) {
+		printf("Could not create %s node.\n", subpath);
+		return 1;
+	}
+
+	fdt_setprop_string(fdt, offs, "compatible", "linaro,optee-tz");
+	fdt_setprop_string(fdt, offs, "method", "smc");
+
+	return 0;
+}
+
+#endif
diff -u -N U-Boot_SDcard/arch/arm/dts/am572x-idk.dts U-Boot_SDcard/arch/arm/dts/am572x-idk.dts
--- U-Boot_SDcard/arch/arm/dts/am572x-idk.dts	2019-09-12 15:54:51.000000473 -0500
+++ U-Boot_SDcard/arch/arm/dts/am572x-idk.dts	1969-12-31 19:29:23.000000225 -0600
@@ -1,85 +1,293 @@
-/*
- * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/dts-v1/;
-
-#include "dra74x.dtsi"
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/interrupt-controller/irq.h>
-#include "am57xx-idk-common.dtsi"
-
-/ {
-	model = "TI AM5728 IDK";
-	compatible = "ti,am5728-idk", "ti,am5728", "ti,dra742", "ti,dra74",
-		     "ti,dra7";
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x80000000>;
-	};
-
-	extcon_usb2: extcon_usb2 {
-		compatible = "linux,extcon-usb-gpio";
-		id-gpio = <&gpio3 16 GPIO_ACTIVE_HIGH>;
-	};
-
-	status-leds {
-		compatible = "gpio-leds";
-		cpu0-led {
-			label = "status0:red:cpu0";
-			gpios = <&gpio4 0 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "cpu0";
-		};
-
-		usr0-led {
-			label = "status0:green:usr";
-			gpios = <&gpio3 11 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-		};
-
-		heartbeat-led {
-			label = "status0:blue:heartbeat";
-			gpios = <&gpio3 12 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "heartbeat";
-		};
-
-		cpu1-led {
-			label = "status1:red:cpu1";
-			gpios = <&gpio3 10 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "cpu1";
-		};
-
-		usr1-led {
-			label = "status1:green:usr";
-			gpios = <&gpio7 23 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-		};
-
-		mmc0-led {
-			label = "status1:blue:mmc0";
-			gpios = <&gpio7 22 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "mmc0";
-		};
-	};
-};
-
-&omap_dwc3_2 {
-	extcon = <&extcon_usb2>;
-};
-
-&mmc1 {
-	status = "okay";
-	vmmc-supply = <&v3_3d>;
-	vmmc_aux-supply = <&ldo1_reg>;
-	bus-width = <4>;
-	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>; /* gpio 219 */
-};
+/*
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "dra74x.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am57xx-idk-common.dtsi"
+
+/ {
+	model = "TI AM5728 IDK";
+	compatible = "ti,am5728-idk", "ti,am5728", "ti,dra742", "ti,dra74",
+		     "ti,dra7";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;
+	};
+
+	extcon_usb2: extcon_usb2 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+	};
+
+	status-leds {
+		compatible = "gpio-leds";
+		cpu0-led {
+			label = "status0:red:cpu0";
+			gpios = <&gpio4 0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "cpu0";
+		};
+
+		usr0-led {
+			label = "status0:green:usr";
+			gpios = <&gpio3 11 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		heartbeat-led {
+			label = "status0:blue:heartbeat";
+			gpios = <&gpio3 12 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "heartbeat";
+		};
+
+		cpu1-led {
+			label = "status1:red:cpu1";
+			gpios = <&gpio3 10 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "cpu1";
+		};
+
+		usr1-led {
+			label = "status1:green:usr";
+			gpios = <&gpio7 23 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		mmc0-led {
+			label = "status1:blue:mmc0";
+			gpios = <&gpio7 22 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "mmc0";
+		};
+	};
+};
+
+&dra7_pmx_core {
+	mmc1_pins_default: mmc1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MUX_MODE0)	    /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MUX_MODE0)	    /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MUX_MODE0)	    /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: mmc1_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MUX_VIRTUAL_MODE11 | MUX_MODE0)	 /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MUX_VIRTUAL_MODE10 | MUX_MODE0)	 /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MUX_VIRTUAL_MODE10 | MUX_MODE0)	 /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MUX_VIRTUAL_MODE10 | MUX_MODE0)	 /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MUX_VIRTUAL_MODE10 | MUX_MODE0)	 /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MUX_VIRTUAL_MODE10 | MUX_MODE0)	 /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT | MODE_SELECT | MUX_MODE0)	  /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1)/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT | MUX_MODE1)	   /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT | MUX_MODE1)	   /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT | MUX_MODE1)	   /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT | MUX_MODE1)	   /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT | MUX_MODE1)	   /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT | MUX_MODE1)	   /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT | MUX_MODE1)	   /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT | MUX_MODE1)	   /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT | MUX_MODE1)	   /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1)/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT | MUX_MODE1)	   /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT | MUX_MODE1)	   /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT | MUX_MODE1)	   /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT | MUX_MODE1)	   /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT | MUX_MODE1)	   /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT | MUX_MODE1)	   /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT | MUX_MODE1)	   /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT | MUX_MODE1)	   /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT | MUX_MODE1)	   /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: mmc2_pins_ddr_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT | MODE_SELECT | MUX_MODE1)	 /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_conf: mmc1_iodelay_ddr50_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CLK_IN */
+			0x620 A_DELAY_PS(1271) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x624 A_DELAY_PS(229) G_DELAY_PS(0)	/* CFG_MMC1_CMD_IN */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x630 A_DELAY_PS(850) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x63C A_DELAY_PS(468) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x648 A_DELAY_PS(466) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x654 A_DELAY_PS(399) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(600) G_DELAY_PS(400)	/* CFG_MMC1_CLK_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(30) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x64c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc2_iodelay_ddr_1_8v_conf: mmc2_iodelay_ddr_1_8v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(270) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(170) G_DELAY_PS(0)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(758) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(81) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(286) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(123) G_DELAY_PS(0)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(346) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(55) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(422) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(642) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(128) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(395) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(623) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(54) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_conf>;
+};
+
+&omap_dwc3_2 {
+	extcon = <&extcon_usb2>;
+};
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/mon.c U-Boot_SDcard/arch/arm/mach-keystone/mon.c
--- U-Boot_SDcard/arch/arm/mach-keystone/mon.c	2019-09-12 15:54:37.000000345 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/mon.c	1969-12-31 19:29:23.000000855 -0600
@@ -10,9 +10,10 @@
 #include <common.h>
 #include <command.h>
 #include <mach/mon.h>
+#include <spl.h>
 asm(".arch_extension sec\n\t");
 
-int mon_install(u32 addr, u32 dpsc, u32 freq)
+int mon_install(u32 addr, u32 dpsc, u32 freq, u32 bm_addr)
 {
 	int result;
 
@@ -21,11 +22,13 @@
 		"mov r0, %1\n"
 		"mov r1, %2\n"
 		"mov r2, %3\n"
+		"mov r3, %4\n"
 		"blx r0\n"
+		"mov %0, r0\n"
 		"ldmfd r13!, {lr}\n"
 		: "=&r" (result)
-		: "r" (addr), "r" (dpsc), "r" (freq)
-		: "cc", "r0", "r1", "r2", "memory");
+		: "r" (addr), "r" (dpsc), "r" (freq), "r" (bm_addr)
+		: "cc", "r0", "r1", "r2", "r3", "memory");
 	return result;
 }
 
@@ -39,6 +42,7 @@
 		"mov r2, %2\n"
 		"mov r0, #0\n"
 		"smc	#0\n"
+		"mov %0, r0\n"
 		"ldmfd  r13!, {lr}\n"
 		: "=&r" (result)
 		: "r" (core_id), "r" (ep)
@@ -55,9 +59,83 @@
 		"mov r1, %1\n"
 		"mov r0, #1\n"
 		"smc	#1\n"
+		"mov %0, r0\n"
 		"ldmfd  r13!, {lr}\n"
 		: "=&r" (result)
 		: "r" (core_id)
 		: "cc", "r0", "r1", "memory");
 	return  result;
 }
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+#define KS2_HS_SEC_HEADER_LEN	0x60
+#define KS2_HS_SEC_TAG_OFFSET	0x34
+#define KS2_AUTH_CMD		130
+
+/**
+ * k2_hs_bm_auth() - Invokes security functions using a
+ * proprietary TI interface. This binary and source for
+ * this is available in the secure development package or
+ * SECDEV. For details on how to access this please refer
+ * doc/README.ti-secure
+ *
+ * @cmd: Secure monitor command
+ * @arg1: Argument for command
+ *
+ * returns non-zero value on success, zero on error
+ */
+static int k2_hs_bm_auth(int cmd, void *arg1)
+{
+	int result;
+
+	asm volatile (
+		"stmfd  r13!, {r4-r12, lr}\n"
+		"mov r0, %1\n"
+		"mov r1, %2\n"
+		"smc #2\n"
+		"mov %0, r0\n"
+		"ldmfd r13!, {r4-r12, lr}\n"
+		: "=&r" (result)
+		: "r" (cmd), "r" (arg1)
+		: "cc", "r0", "r1", "memory");
+
+	return  result;
+}
+
+void board_fit_image_post_process(void **p_image, size_t *p_size)
+{
+	int result = 0;
+	void *image = *p_image;
+
+	if (strncmp(image + KS2_HS_SEC_TAG_OFFSET, "KEYS", 4)) {
+		printf("No signature found in image!\n");
+		hang();
+	}
+
+	result = k2_hs_bm_auth(KS2_AUTH_CMD, image);
+	if (result == 0) {
+		printf("Authentication failed!\n");
+		hang();
+	}
+
+	/*
+	 * Overwrite the image headers after authentication
+	 * and decryption. Update size to reflect removal
+	 * of header.
+	 */
+	*p_size -= KS2_HS_SEC_HEADER_LEN;
+	memcpy(image, image + KS2_HS_SEC_HEADER_LEN, *p_size);
+
+	/*
+	 * Output notification of successful authentication to re-assure the
+	 * user that the secure code is being processed as expected. However
+	 * suppress any such log output in case of building for SPL and booting
+	 * via YMODEM. This is done to avoid disturbing the YMODEM serial
+	 * protocol transactions.
+	 */
+	if (!(IS_ENABLED(CONFIG_SPL_BUILD) &&
+	      IS_ENABLED(CONFIG_SPL_YMODEM_SUPPORT) &&
+	      spl_boot_device() == BOOT_DEVICE_UART))
+		printf("Authentication passed\n");
+}
+#endif
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2g-generic.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2g-generic.dts	1969-12-31 19:31:37.000000935 -0600
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2017 Texas Instruments, Inc.
+ *
+ * 66AK2G0X Generic File
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone-k2g.dtsi"
+
+/ {
+	compatible =  "ti,k2g-generic", "ti,k2g", "ti,keystone";
+	model = "Texas Instruments 66AK2G02 Generic";
+
+	chosen {
+		stdout-path = &uart0;
+	};
+};
diff -u -N U-Boot_SDcard/include/configs/imx6_spl.h U-Boot_SDcard/include/configs/imx6_spl.h
--- U-Boot_SDcard/include/configs/imx6_spl.h	2019-09-12 15:54:21.000000106 -0500
+++ U-Boot_SDcard/include/configs/imx6_spl.h	1969-12-31 19:29:22.000000229 -0600
@@ -45,14 +45,14 @@
 #if defined(CONFIG_SPL_MMC_SUPPORT)
 #define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	1
 #define CONFIG_SYS_MONITOR_LEN			409600	/* 400 KB */
-#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+#undef CONFIG_SPL_RAW_IMAGE_SUPPORT
 #endif
 
 /* SATA support */
 #if defined(CONFIG_SPL_SATA_SUPPORT)
 #define CONFIG_SPL_SATA_BOOT_DEVICE		0
 #define CONFIG_SYS_SATA_FAT_BOOT_PARTITION	1
-#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+#undef CONFIG_SPL_RAW_IMAGE_SUPPORT
 #endif
 
 /* Define the payload for FAT/EXT support */
diff -u -N U-Boot_SDcard/include/power/tps65910.h U-Boot_SDcard/include/power/tps65910.h
--- U-Boot_SDcard/include/power/tps65910.h	2019-09-12 15:54:29.000000231 -0500
+++ U-Boot_SDcard/include/power/tps65910.h	1969-12-31 19:29:22.000000772 -0600
@@ -62,6 +62,7 @@
 
 #define TPS65910_OP_REG_SEL_MASK			(0x7F)
 #define TPS65910_OP_REG_SEL_0_9_5			(0x1F)	/* 0.9500 V */
+#define TPS65910_OP_REG_SEL_1_1_0			(0x2B)	/* 1.1000 V */
 #define TPS65910_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
 #define TPS65910_OP_REG_SEL_1_2_0			(0x33)	/* 1.2000 V */
 #define TPS65910_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
diff -u -N U-Boot_SDcard/common/spl/spl_net.c U-Boot_SDcard/common/spl/spl_net.c
--- U-Boot_SDcard/common/spl/spl_net.c	2019-09-12 15:54:37.000000622 -0500
+++ U-Boot_SDcard/common/spl/spl_net.c	1969-12-31 19:29:20.000000773 -0600
@@ -11,19 +11,32 @@
 #include <errno.h>
 #include <spl.h>
 #include <net.h>
+#include <libfdt.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_SPL_ETH_SUPPORT) || defined(CONFIG_SPL_USBETH_SUPPORT)
+static ulong spl_net_load_read(struct spl_load_info *load, ulong sector,
+			       ulong count, void *buf)
+{
+	debug("%s: sector %lx, count %lx, buf %lx\n",
+	      __func__, sector, count, (ulong)buf);
+	memcpy(buf, (void *)(load_addr + sector), count);
+	return count;
+}
+
 static int spl_net_load_image(struct spl_image_info *spl_image,
 			      struct spl_boot_device *bootdev)
 {
+	struct image_header *header = (struct image_header *)load_addr;
 	int rv;
 
 	env_init();
 	env_relocate();
 	setenv("autoload", "yes");
-	load_addr = CONFIG_SYS_TEXT_BASE - sizeof(struct image_header);
+	if (!IS_ENABLED(CONFIG_SPL_LOAD_FIT))
+		load_addr = CONFIG_SYS_TEXT_BASE - sizeof(struct image_header);
+
 	rv = eth_initialize();
 	if (rv == 0) {
 		printf("No Ethernet devices found\n");
@@ -36,8 +49,22 @@
 		printf("Problem booting with BOOTP\n");
 		return rv;
 	}
-	return spl_parse_image_header(spl_image,
-				      (struct image_header *)load_addr);
+
+	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	    image_get_magic(header) == FDT_MAGIC) {
+		struct spl_load_info load;
+
+		debug("Found FIT\n");
+		load.bl_len = 1;
+		load.read = spl_net_load_read;
+		rv = spl_load_simple_fit(spl_image, &load, 0, header);
+	} else {
+		debug("Legacy image\n");
+
+		rv = spl_parse_image_header(spl_image, header);
+	}
+
+	return rv;
 }
 #endif
 
diff -u -N U-Boot_SDcard/board/corscience/tricorder/tricorder.c U-Boot_SDcard/board/corscience/tricorder/tricorder.c
--- U-Boot_SDcard/board/corscience/tricorder/tricorder.c	2019-09-12 15:54:54.000000279 -0500
+++ U-Boot_SDcard/board/corscience/tricorder/tricorder.c	1969-12-31 19:29:25.000000157 -0600
@@ -140,7 +140,7 @@
 	MUX_TRICORDER();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !(defined(CONFIG_SPL_BUILD))
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/board/ti/am57xx/mux_data.h U-Boot_SDcard/board/ti/am57xx/mux_data.h
--- U-Boot_SDcard/board/ti/am57xx/mux_data.h	2019-09-12 15:54:52.000000609 -0500
+++ U-Boot_SDcard/board/ti/am57xx/mux_data.h	1969-12-31 19:29:27.000000176 -0600
@@ -67,8 +67,8 @@
 	{GPMC_WEN, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_wen.gpio2_25 */
 	{GPMC_BEN0, (M9 | PIN_INPUT_PULLDOWN)},	/* gpmc_ben0.dma_evt3 */
 	{GPMC_BEN1, (M9 | PIN_INPUT_PULLDOWN)},	/* gpmc_ben1.dma_evt4 */
-	{GPMC_WAIT0, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_wait0.gpio2_28 */
-	{VIN1B_CLK1, (M14 | PIN_INPUT_PULLDOWN)},	/* vin1b_clk1.gpio2_31 */
+	{GPMC_WAIT0, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* gpmc_wait0.gpio2_28 */
+	{VIN1B_CLK1, (M14 | PIN_INPUT_SLEW)},	/* vin1b_clk1.gpio2_31 */
 	{VIN1A_D2, (M14 | PIN_INPUT_PULLDOWN)},	/* vin1a_d2.gpio3_6 */
 	{VIN1A_D3, (M14 | PIN_INPUT_PULLDOWN)},	/* vin1a_d3.gpio3_7 */
 	{VIN1A_D4, (M14 | PIN_INPUT_PULLDOWN)},	/* vin1a_d4.gpio3_8 */
@@ -87,14 +87,14 @@
 	{VIN2A_CLK0, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_clk0.gpio3_28 */
 	{VIN2A_DE0, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_de0.gpio3_29 */
 	{VIN2A_FLD0, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_fld0.gpio3_30 */
-	{VIN2A_HSYNC0, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_hsync0.pr1_uart0_cts_n */
+	{VIN2A_HSYNC0, (M11 | PIN_INPUT_PULLUP)},	/* vin2a_hsync0.pr1_uart0_cts_n */
 	{VIN2A_VSYNC0, (M11 | PIN_OUTPUT_PULLUP)},	/* vin2a_vsync0.pr1_uart0_rts_n */
-	{VIN2A_D0, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d0.pr1_uart0_rxd */
-	{VIN2A_D1, (M11 | PIN_OUTPUT_PULLDOWN)},	/* vin2a_d1.pr1_uart0_txd */
-	{VIN2A_D2, (M8 | PIN_INPUT_PULLDOWN)},	/* vin2a_d2.uart10_rxd */
-	{VIN2A_D3, (M8 | PIN_OUTPUT_PULLDOWN)},	/* vin2a_d3.uart10_txd */
-	{VIN2A_D4, (M8 | PIN_INPUT_PULLDOWN)},	/* vin2a_d4.uart10_ctsn */
-	{VIN2A_D5, (M8 | PIN_OUTPUT_PULLDOWN)},	/* vin2a_d5.uart10_rtsn */
+	{VIN2A_D0, (M11 | PIN_INPUT_PULLUP)},	/* vin2a_d0.pr1_uart0_rxd */
+	{VIN2A_D1, (M11 | PIN_OUTPUT)},	/* vin2a_d1.pr1_uart0_txd */
+	{VIN2A_D2, (M8 | PIN_INPUT_PULLUP)},	/* vin2a_d2.uart10_rxd */
+	{VIN2A_D3, (M8 | PIN_OUTPUT)},	/* vin2a_d3.uart10_txd */
+	{VIN2A_D4, (M8 | PIN_INPUT_PULLUP)},	/* vin2a_d4.uart10_ctsn */
+	{VIN2A_D5, (M8 | PIN_OUTPUT_PULLUP)},	/* vin2a_d5.uart10_rtsn */
 	{VIN2A_D6, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_d6.gpio4_7 */
 	{VIN2A_D7, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_d7.gpio4_8 */
 	{VIN2A_D8, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_d8.gpio4_9 */
@@ -113,40 +113,12 @@
 	{VIN2A_D21, (M3 | PIN_INPUT | MANUAL_MODE)},	/* vin2a_d21.rgmii1_rxd2 */
 	{VIN2A_D22, (M3 | PIN_INPUT | MANUAL_MODE)},	/* vin2a_d22.rgmii1_rxd1 */
 	{VIN2A_D23, (M3 | PIN_INPUT | MANUAL_MODE)},	/* vin2a_d23.rgmii1_rxd0 */
-	{VOUT1_CLK, (M0 | PIN_OUTPUT)},	/* vout1_clk.vout1_clk */
-	{VOUT1_DE, (M0 | PIN_OUTPUT)},	/* vout1_de.vout1_de */
 	{VOUT1_FLD, (M14 | PIN_INPUT)},	/* vout1_fld.gpio4_21 */
-	{VOUT1_HSYNC, (M0 | PIN_OUTPUT)},	/* vout1_hsync.vout1_hsync */
-	{VOUT1_VSYNC, (M0 | PIN_OUTPUT)},	/* vout1_vsync.vout1_vsync */
-	{VOUT1_D0, (M0 | PIN_OUTPUT)},	/* vout1_d0.vout1_d0 */
-	{VOUT1_D1, (M0 | PIN_OUTPUT)},	/* vout1_d1.vout1_d1 */
-	{VOUT1_D2, (M0 | PIN_OUTPUT)},	/* vout1_d2.vout1_d2 */
-	{VOUT1_D3, (M0 | PIN_OUTPUT)},	/* vout1_d3.vout1_d3 */
-	{VOUT1_D4, (M0 | PIN_OUTPUT)},	/* vout1_d4.vout1_d4 */
-	{VOUT1_D5, (M0 | PIN_OUTPUT)},	/* vout1_d5.vout1_d5 */
-	{VOUT1_D6, (M0 | PIN_OUTPUT)},	/* vout1_d6.vout1_d6 */
-	{VOUT1_D7, (M0 | PIN_OUTPUT)},	/* vout1_d7.vout1_d7 */
-	{VOUT1_D8, (M0 | PIN_OUTPUT)},	/* vout1_d8.vout1_d8 */
-	{VOUT1_D9, (M0 | PIN_OUTPUT)},	/* vout1_d9.vout1_d9 */
-	{VOUT1_D10, (M0 | PIN_OUTPUT)},	/* vout1_d10.vout1_d10 */
-	{VOUT1_D11, (M0 | PIN_OUTPUT)},	/* vout1_d11.vout1_d11 */
-	{VOUT1_D12, (M0 | PIN_OUTPUT)},	/* vout1_d12.vout1_d12 */
-	{VOUT1_D13, (M0 | PIN_OUTPUT)},	/* vout1_d13.vout1_d13 */
-	{VOUT1_D14, (M0 | PIN_OUTPUT)},	/* vout1_d14.vout1_d14 */
-	{VOUT1_D15, (M0 | PIN_OUTPUT)},	/* vout1_d15.vout1_d15 */
-	{VOUT1_D16, (M0 | PIN_OUTPUT)},	/* vout1_d16.vout1_d16 */
-	{VOUT1_D17, (M0 | PIN_OUTPUT)},	/* vout1_d17.vout1_d17 */
-	{VOUT1_D18, (M0 | PIN_OUTPUT)},	/* vout1_d18.vout1_d18 */
-	{VOUT1_D19, (M0 | PIN_OUTPUT)},	/* vout1_d19.vout1_d19 */
-	{VOUT1_D20, (M0 | PIN_OUTPUT)},	/* vout1_d20.vout1_d20 */
-	{VOUT1_D21, (M0 | PIN_OUTPUT)},	/* vout1_d21.vout1_d21 */
-	{VOUT1_D22, (M0 | PIN_OUTPUT)},	/* vout1_d22.vout1_d22 */
-	{VOUT1_D23, (M0 | PIN_OUTPUT)},	/* vout1_d23.vout1_d23 */
-	{MDIO_MCLK, (M0 | PIN_OUTPUT)},	/* mdio_mclk.mdio_mclk */
-	{MDIO_D, (M0 | PIN_INPUT)},	/* mdio_d.mdio_d */
+	{MDIO_MCLK, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* mdio_mclk.mdio_mclk */
+	{MDIO_D, (M0 | PIN_INPUT | SLEWCONTROL)},	/* mdio_d.mdio_d */
 	{RMII_MHZ_50_CLK, (M14 | PIN_INPUT_PULLUP)},	/* RMII_MHZ_50_CLK.gpio5_17 */
-	{UART3_RXD, (M14 | PIN_INPUT_PULLDOWN)},	/* uart3_rxd.gpio5_18 */
-	{UART3_TXD, (M14 | PIN_INPUT_PULLDOWN)},	/* uart3_txd.gpio5_19 */
+	{UART3_RXD, (M14 | PIN_INPUT_SLEW)},	/* uart3_rxd.gpio5_18 */
+	{UART3_TXD, (M14 | PIN_INPUT_SLEW)},	/* uart3_txd.gpio5_19 */
 	{RGMII0_TXC, (M0 | PIN_OUTPUT | MANUAL_MODE)},	/* rgmii0_txc.rgmii0_txc */
 	{RGMII0_TXCTL, (M0 | PIN_OUTPUT | MANUAL_MODE)},	/* rgmii0_txctl.rgmii0_txctl */
 	{RGMII0_TXD3, (M0 | PIN_OUTPUT | MANUAL_MODE)},	/* rgmii0_txd3.rgmii0_txd3 */
@@ -159,8 +131,8 @@
 	{RGMII0_RXD2, (M0 | PIN_INPUT | MANUAL_MODE)},	/* rgmii0_rxd2.rgmii0_rxd2 */
 	{RGMII0_RXD1, (M0 | PIN_INPUT | MANUAL_MODE)},	/* rgmii0_rxd1.rgmii0_rxd1 */
 	{RGMII0_RXD0, (M0 | PIN_INPUT | MANUAL_MODE)},	/* rgmii0_rxd0.rgmii0_rxd0 */
-	{USB1_DRVVBUS, (M0 | PIN_OUTPUT)},	/* usb1_drvvbus.usb1_drvvbus */
-	{USB2_DRVVBUS, (M0 | PIN_OUTPUT_PULLDOWN)},	/* usb2_drvvbus.usb2_drvvbus */
+	{USB1_DRVVBUS, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* usb1_drvvbus.usb1_drvvbus */
+	{USB2_DRVVBUS, (M0 | PIN_OUTPUT_PULLDOWN | SLEWCONTROL)},	/* usb2_drvvbus.usb2_drvvbus */
 	{GPIO6_14, (M10 | PIN_INPUT_PULLUP)},	/* gpio6_14.timer1 */
 	{GPIO6_15, (M10 | PIN_INPUT_PULLUP)},	/* gpio6_15.timer2 */
 	{GPIO6_16, (M10 | PIN_INPUT_PULLUP)},	/* gpio6_16.timer3 */
@@ -169,89 +141,77 @@
 	{XREF_CLK2, (M14 | PIN_INPUT_PULLDOWN)},	/* xref_clk2.gpio6_19 */
 	{XREF_CLK3, (M9 | PIN_OUTPUT_PULLDOWN)},	/* xref_clk3.clkout3 */
 	{MCASP1_ACLKX, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_aclkx.i2c3_sda */
-	{MCASP1_FSX, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_fsx.i2c3_scl */
+	{MCASP1_FSX, (M10 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_fsx.i2c3_scl */
 	{MCASP1_ACLKR, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_aclkr.i2c4_sda */
 	{MCASP1_FSR, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_fsr.i2c4_scl */
-	{MCASP1_AXR0, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_axr0.i2c5_sda */
-	{MCASP1_AXR1, (M10 | PIN_INPUT_PULLUP)},	/* mcasp1_axr1.i2c5_scl */
+	{MCASP1_AXR0, (M10 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr0.i2c5_sda */
+	{MCASP1_AXR1, (M10 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr1.i2c5_scl */
 	{MCASP1_AXR2, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr2.gpio5_4 */
 	{MCASP1_AXR3, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr3.gpio5_5 */
 	{MCASP1_AXR4, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr4.gpio5_6 */
 	{MCASP1_AXR5, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr5.gpio5_7 */
 	{MCASP1_AXR6, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr6.gpio5_8 */
 	{MCASP1_AXR7, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr7.gpio5_9 */
-	{MCASP1_AXR8, (M14 | PIN_INPUT)},	/* mcasp1_axr8.gpio5_10 */
-	{MCASP1_AXR9, (M14 | PIN_INPUT)},	/* mcasp1_axr9.gpio5_11 */
-	{MCASP1_AXR10, (M14 | PIN_INPUT)},	/* mcasp1_axr10.gpio5_12 */
-	{MCASP1_AXR11, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_axr11.gpio4_17 */
-	{MCASP1_AXR12, (M1 | PIN_INPUT | VIRTUAL_MODE10)},	/* mcasp1_axr12.mcasp7_axr0 */
-	{MCASP1_AXR13, (M1 | PIN_INPUT | VIRTUAL_MODE10)},	/* mcasp1_axr13.mcasp7_axr1 */
-	{MCASP1_AXR14, (M1 | PIN_INPUT | VIRTUAL_MODE10)},	/* mcasp1_axr14.mcasp7_aclkx */
-	{MCASP1_AXR15, (M1 | PIN_INPUT | VIRTUAL_MODE10)},	/* mcasp1_axr15.mcasp7_fsx */
-	{MCASP2_ACLKX, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_aclkx.mcasp2_aclkx */
-	{MCASP2_FSX, (M0 | PIN_INPUT)},	/* mcasp2_fsx.mcasp2_fsx */
-	{MCASP2_ACLKR, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_aclkr.mcasp2_aclkr */
-	{MCASP2_FSR, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_fsr.mcasp2_fsr */
-	{MCASP2_AXR0, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr0.mcasp2_axr0 */
-	{MCASP2_AXR1, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr1.mcasp2_axr1 */
-	{MCASP2_AXR2, (M0 | PIN_INPUT)},	/* mcasp2_axr2.mcasp2_axr2 */
-	{MCASP2_AXR3, (M0 | PIN_INPUT)},	/* mcasp2_axr3.mcasp2_axr3 */
-	{MCASP2_AXR4, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr4.mcasp2_axr4 */
-	{MCASP2_AXR5, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr5.mcasp2_axr5 */
-	{MCASP2_AXR6, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr6.mcasp2_axr6 */
-	{MCASP2_AXR7, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr7.mcasp2_axr7 */
+	{MCASP1_AXR8, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mcasp1_axr8.gpio5_10 */
+	{MCASP1_AXR9, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mcasp1_axr9.gpio5_11 */
+	{MCASP1_AXR10, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mcasp1_axr10.gpio5_12 */
+	{MCASP1_AXR11, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr11.gpio4_17 */
+	{MCASP1_AXR12, (M1 | PIN_INPUT_SLEW | VIRTUAL_MODE10)},	/* mcasp1_axr12.mcasp7_axr0 */
+	{MCASP1_AXR13, (M1 | PIN_INPUT_SLEW | VIRTUAL_MODE10)},	/* mcasp1_axr13.mcasp7_axr1 */
+	{MCASP1_AXR14, (M1 | PIN_INPUT_SLEW | VIRTUAL_MODE10)},	/* mcasp1_axr14.mcasp7_aclkx */
+	{MCASP1_AXR15, (M1 | PIN_INPUT_SLEW | VIRTUAL_MODE10)},	/* mcasp1_axr15.mcasp7_fsx */
 	{MCASP3_ACLKX, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp3_aclkx.mcasp3_aclkx */
-	{MCASP3_FSX, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp3_fsx.mcasp3_fsx */
-	{MCASP3_AXR0, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp3_axr0.mcasp3_axr0 */
-	{MCASP3_AXR1, (M0 | PIN_INPUT_PULLDOWN)},	/* mcasp3_axr1.mcasp3_axr1 */
+	{MCASP3_FSX, (M0 | PIN_INPUT_SLEW)},	/* mcasp3_fsx.mcasp3_fsx */
+	{MCASP3_AXR0, (M0 | PIN_INPUT_SLEW)},	/* mcasp3_axr0.mcasp3_axr0 */
+	{MCASP3_AXR1, (M0 | PIN_INPUT_SLEW)},	/* mcasp3_axr1.mcasp3_axr1 */
 	{MCASP4_ACLKX, (M3 | PIN_INPUT_PULLUP)},	/* mcasp4_aclkx.uart8_rxd */
-	{MCASP4_FSX, (M3 | PIN_OUTPUT_PULLDOWN)},	/* mcasp4_fsx.uart8_txd */
-	{MCASP4_AXR0, (M3 | PIN_INPUT_PULLDOWN)},	/* mcasp4_axr0.uart8_ctsn */
+	{MCASP4_FSX, (M3 | PIN_OUTPUT)},	/* mcasp4_fsx.uart8_txd */
+	{MCASP4_AXR0, (M3 | PIN_INPUT_PULLUP)},	/* mcasp4_axr0.uart8_ctsn */
 	{MCASP4_AXR1, (M3 | PIN_OUTPUT_PULLUP)},	/* mcasp4_axr1.uart8_rtsn */
 	{MCASP5_ACLKX, (M3 | PIN_INPUT_PULLUP)},	/* mcasp5_aclkx.uart9_rxd */
-	{MCASP5_FSX, (M3 | PIN_OUTPUT_PULLDOWN)},	/* mcasp5_fsx.uart9_txd */
-	{MCASP5_AXR0, (M3 | PIN_INPUT_PULLDOWN)},	/* mcasp5_axr0.uart9_ctsn */
+	{MCASP5_FSX, (M3 | PIN_OUTPUT)},	/* mcasp5_fsx.uart9_txd */
+	{MCASP5_AXR0, (M3 | PIN_INPUT_PULLUP)},	/* mcasp5_axr0.uart9_ctsn */
 	{MCASP5_AXR1, (M3 | PIN_OUTPUT_PULLUP)},	/* mcasp5_axr1.uart9_rtsn */
-	{MMC1_CLK, (M0 | PIN_OUTPUT_PULLUP)},	/* mmc1_clk.mmc1_clk */
+	{MMC1_CLK, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_clk.mmc1_clk */
 	{MMC1_CMD, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_cmd.mmc1_cmd */
 	{MMC1_DAT0, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat0.mmc1_dat0 */
 	{MMC1_DAT1, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat1.mmc1_dat1 */
 	{MMC1_DAT2, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat2.mmc1_dat2 */
 	{MMC1_DAT3, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat3.mmc1_dat3 */
-	{MMC1_SDCD, (M14 | PIN_INPUT_PULLUP)},	/* mmc1_sdcd.gpio6_27 */
+	{MMC1_SDCD, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mmc1_sdcd.gpio6_27 */
 	{GPIO6_10, (M10 | PIN_OUTPUT_PULLDOWN)},	/* gpio6_10.ehrpwm2A */
 	{GPIO6_11, (M0 | PIN_INPUT_PULLUP)},	/* gpio6_11.gpio6_11 */
-	{MMC3_CLK, (M0 | PIN_OUTPUT_PULLUP | MANUAL_MODE)},	/* mmc3_clk.mmc3_clk */
+	{MMC3_CLK, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_clk.mmc3_clk */
 	{MMC3_CMD, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_cmd.mmc3_cmd */
 	{MMC3_DAT0, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat0.mmc3_dat0 */
 	{MMC3_DAT1, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat1.mmc3_dat1 */
 	{MMC3_DAT2, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat2.mmc3_dat2 */
 	{MMC3_DAT3, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat3.mmc3_dat3 */
-	{MMC3_DAT4, (M1 | PIN_OUTPUT_PULLDOWN)},	/* mmc3_dat4.spi4_sclk */
-	{MMC3_DAT5, (M1 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat5.spi4_d1 */
-	{MMC3_DAT6, (M1 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat6.spi4_d0 */
-	{MMC3_DAT7, (M1 | PIN_OUTPUT_PULLUP)},	/* mmc3_dat7.spi4_cs0 */
+	{MMC3_DAT4, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat4.mmc3_dat4 */
+	{MMC3_DAT5, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat5.mmc3_dat5 */
+	{MMC3_DAT6, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat6.mmc3_dat6 */
+	{MMC3_DAT7, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* mmc3_dat7.mmc3_dat7 */
 	{SPI1_SCLK, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_sclk.gpio7_7 */
 	{SPI1_D1, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_d1.gpio7_8 */
 	{SPI1_D0, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_d0.gpio7_9 */
 	{SPI1_CS0, (M14 | PIN_INPUT)},	/* spi1_cs0.gpio7_10 */
 	{SPI1_CS1, (M14 | PIN_INPUT)},	/* spi1_cs1.gpio7_11 */
-	{SPI1_CS2, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_cs2.gpio7_12 */
-	{SPI1_CS3, (M6 | PIN_INPUT_PULLUP)},	/* spi1_cs3.hdmi1_cec */
+	{SPI1_CS2, (M14 | PIN_INPUT_SLEW)},	/* spi1_cs2.gpio7_12 */
+	{SPI1_CS3, (M6 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi1_cs3.hdmi1_cec */
 	{SPI2_SCLK, (M14 | PIN_INPUT_PULLDOWN)},	/* spi2_sclk.gpio7_14 */
-	{SPI2_D1, (M14 | PIN_INPUT_PULLDOWN)},	/* spi2_d1.gpio7_15 */
-	{SPI2_D0, (M14 | PIN_INPUT_PULLUP)},	/* spi2_d0.gpio7_16 */
-	{SPI2_CS0, (M14 | PIN_INPUT_PULLUP)},	/* spi2_cs0.gpio7_17 */
-	{DCAN1_TX, (M15 | PULL_UP)},	/* dcan1_tx.safe for dcan1_tx */
-	{DCAN1_RX, (M15 | PULL_UP)},	/* dcan1_rx.safe for dcan1_rx */
-	{UART1_RXD, (M0 | PIN_INPUT_PULLUP)},	/* uart1_rxd.uart1_rxd */
-	{UART1_TXD, (M0 | PIN_OUTPUT_PULLDOWN)},	/* uart1_txd.uart1_txd */
+	{SPI2_D1, (M14 | PIN_INPUT_SLEW)},	/* spi2_d1.gpio7_15 */
+	{SPI2_D0, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi2_d0.gpio7_16 */
+	{SPI2_CS0, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi2_cs0.gpio7_17 */
+	{DCAN1_TX, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* dcan1_tx.dcan1_tx */
+	{DCAN1_RX, (M0 | PIN_INPUT | SLEWCONTROL)},	/* dcan1_rx.dcan1_rx */
+	{UART1_RXD, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* uart1_rxd.uart1_rxd */
+	{UART1_TXD, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* uart1_txd.uart1_txd */
 	{UART1_CTSN, (M14 | PIN_INPUT_PULLDOWN)},	/* uart1_ctsn.gpio7_24 */
 	{UART1_RTSN, (M14 | PIN_INPUT)},	/* uart1_rtsn.gpio7_25 */
 	{UART2_RXD, (M14 | PIN_INPUT_PULLDOWN)},	/* uart2_rxd.gpio7_26 */
 	{UART2_TXD, (M14 | PIN_INPUT_PULLDOWN)},	/* uart2_txd.gpio7_27 */
 	{UART2_CTSN, (M2 | PIN_INPUT_PULLUP)},	/* uart2_ctsn.uart3_rxd */
-	{UART2_RTSN, (M1 | PIN_OUTPUT_PULLDOWN)},	/* uart2_rtsn.uart3_txd */
+	{UART2_RTSN, (M1 | PIN_OUTPUT)},	/* uart2_rtsn.uart3_txd */
 	{I2C1_SDA, (M0 | PIN_INPUT_PULLUP)},	/* i2c1_sda.i2c1_sda */
 	{I2C1_SCL, (M0 | PIN_INPUT_PULLUP)},	/* i2c1_scl.i2c1_scl */
 	{I2C2_SDA, (M1 | PIN_INPUT_PULLUP)},	/* i2c2_sda.hdmi1_ddc_scl */
@@ -263,7 +223,7 @@
 	{ON_OFF, (M0 | PIN_OUTPUT)},	/* on_off.on_off */
 	{RTC_PORZ, (M0 | PIN_INPUT)},	/* rtc_porz.rtc_porz */
 	{TMS, (M0 | PIN_INPUT_PULLUP)},	/* tms.tms */
-	{TDI, (M0 | PIN_INPUT_PULLUP)},	/* tdi.tdi */
+	{TDI, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* tdi.tdi */
 	{TDO, (M0 | PIN_OUTPUT)},	/* tdo.tdo */
 	{TCLK, (M0 | PIN_INPUT_PULLDOWN)},	/* tclk.tclk */
 	{TRSTN, (M0 | PIN_INPUT)},	/* trstn.trstn */
@@ -275,11 +235,67 @@
 };
 
 const struct pad_conf_entry core_padconf_array_delta_x15_sr1_1[] = {
-	{MMC1_SDWP, (M14 | PIN_OUTPUT)},	/* mmc1_sdwp.gpio6_28 */
+	{MMC1_SDWP, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mmc1_sdwp.gpio6_28 */
+	{VOUT1_CLK, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_clk.vout1_clk */
+	{VOUT1_DE, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_de.vout1_de */
+	{VOUT1_HSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_hsync.vout1_hsync */
+	{VOUT1_VSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_vsync.vout1_vsync */
+	{VOUT1_D0, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d0.vout1_d0 */
+	{VOUT1_D1, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d1.vout1_d1 */
+	{VOUT1_D2, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d2.vout1_d2 */
+	{VOUT1_D3, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d3.vout1_d3 */
+	{VOUT1_D4, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d4.vout1_d4 */
+	{VOUT1_D5, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d5.vout1_d5 */
+	{VOUT1_D6, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d6.vout1_d6 */
+	{VOUT1_D7, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d7.vout1_d7 */
+	{VOUT1_D8, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d8.vout1_d8 */
+	{VOUT1_D9, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d9.vout1_d9 */
+	{VOUT1_D10, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d10.vout1_d10 */
+	{VOUT1_D11, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d11.vout1_d11 */
+	{VOUT1_D12, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d12.vout1_d12 */
+	{VOUT1_D13, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d13.vout1_d13 */
+	{VOUT1_D14, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d14.vout1_d14 */
+	{VOUT1_D15, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d15.vout1_d15 */
+	{VOUT1_D16, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d16.vout1_d16 */
+	{VOUT1_D17, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d17.vout1_d17 */
+	{VOUT1_D18, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d18.vout1_d18 */
+	{VOUT1_D19, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d19.vout1_d19 */
+	{VOUT1_D20, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d20.vout1_d20 */
+	{VOUT1_D21, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d21.vout1_d21 */
+	{VOUT1_D22, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d22.vout1_d22 */
+	{VOUT1_D23, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d23.vout1_d23 */
 };
 
 const struct pad_conf_entry core_padconf_array_delta_x15_sr2_0[] = {
 	{VIN1A_CLK0, (M14 | PIN_INPUT)},	/* vin1a_clk0.gpio2_30 */
+	{VOUT1_CLK, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_clk.vout1_clk */
+	{VOUT1_DE, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_de.vout1_de */
+	{VOUT1_HSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_hsync.vout1_hsync */
+	{VOUT1_VSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_vsync.vout1_vsync */
+	{VOUT1_D0, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d0.vout1_d0 */
+	{VOUT1_D1, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d1.vout1_d1 */
+	{VOUT1_D2, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d2.vout1_d2 */
+	{VOUT1_D3, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d3.vout1_d3 */
+	{VOUT1_D4, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d4.vout1_d4 */
+	{VOUT1_D5, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d5.vout1_d5 */
+	{VOUT1_D6, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d6.vout1_d6 */
+	{VOUT1_D7, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d7.vout1_d7 */
+	{VOUT1_D8, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d8.vout1_d8 */
+	{VOUT1_D9, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d9.vout1_d9 */
+	{VOUT1_D10, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d10.vout1_d10 */
+	{VOUT1_D11, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d11.vout1_d11 */
+	{VOUT1_D12, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d12.vout1_d12 */
+	{VOUT1_D13, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d13.vout1_d13 */
+	{VOUT1_D14, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d14.vout1_d14 */
+	{VOUT1_D15, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d15.vout1_d15 */
+	{VOUT1_D16, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d16.vout1_d16 */
+	{VOUT1_D17, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d17.vout1_d17 */
+	{VOUT1_D18, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d18.vout1_d18 */
+	{VOUT1_D19, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d19.vout1_d19 */
+	{VOUT1_D20, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d20.vout1_d20 */
+	{VOUT1_D21, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d21.vout1_d21 */
+	{VOUT1_D22, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d22.vout1_d22 */
+	{VOUT1_D23, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d23.vout1_d23 */
 };
 
 const struct pad_conf_entry core_padconf_array_essential_am572x_idk[] = {
@@ -302,16 +318,16 @@
 	{GPMC_A16, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a16.qspi1_d0 */
 	{GPMC_A17, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a17.qspi1_d1 */
 	{GPMC_A18, (M1 | PIN_OUTPUT | MANUAL_MODE)},	/* gpmc_a18.qspi1_sclk */
-	{GPMC_A19, (M1 | PIN_INPUT)},	/* gpmc_a19.mmc2_dat4 */
-	{GPMC_A20, (M1 | PIN_INPUT)},	/* gpmc_a20.mmc2_dat5 */
-	{GPMC_A21, (M1 | PIN_INPUT)},	/* gpmc_a21.mmc2_dat6 */
-	{GPMC_A22, (M1 | PIN_INPUT)},	/* gpmc_a22.mmc2_dat7 */
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a19.mmc2_dat4 */
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a20.mmc2_dat5 */
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a21.mmc2_dat6 */
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a22.mmc2_dat7 */
 	{GPMC_A23, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a23.mmc2_clk */
-	{GPMC_A24, (M1 | PIN_INPUT)},	/* gpmc_a24.mmc2_dat0 */
-	{GPMC_A25, (M1 | PIN_INPUT)},	/* gpmc_a25.mmc2_dat1 */
-	{GPMC_A26, (M1 | PIN_INPUT)},	/* gpmc_a26.mmc2_dat2 */
-	{GPMC_A27, (M1 | PIN_INPUT)},	/* gpmc_a27.mmc2_dat3 */
-	{GPMC_CS1, (M1 | PIN_INPUT)},	/* gpmc_cs1.mmc2_cmd */
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a24.mmc2_dat0 */
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a25.mmc2_dat1 */
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a26.mmc2_dat2 */
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a27.mmc2_dat3 */
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_cs1.mmc2_cmd */
 	{GPMC_CS2, (M1 | PIN_OUTPUT | MANUAL_MODE)},	/* gpmc_cs2.qspi1_cs0 */
 	{VIN1A_D5, (M14 | PIN_OUTPUT)},	/* vin1a_d5.gpio3_9 */
 	{VIN1A_D6, (M14 | PIN_OUTPUT)},	/* vin1a_d6.gpio3_10 */
@@ -351,37 +367,37 @@
 	{VIN2A_D21, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d21.rgmii1_rxd2 */
 	{VIN2A_D22, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d22.rgmii1_rxd1 */
 	{VIN2A_D23, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d23.rgmii1_rxd0 */
-	{VOUT1_CLK, (M0 | PIN_OUTPUT)},	/* vout1_clk.vout1_clk */
-	{VOUT1_DE, (M0 | PIN_OUTPUT)},	/* vout1_de.vout1_de */
+	{VOUT1_CLK, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_clk.vout1_clk */
+	{VOUT1_DE, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_de.vout1_de */
 	{VOUT1_FLD, (M14 | PIN_OUTPUT)},	/* vout1_fld.gpio4_21 */
-	{VOUT1_HSYNC, (M0 | PIN_OUTPUT)},	/* vout1_hsync.vout1_hsync */
-	{VOUT1_VSYNC, (M0 | PIN_OUTPUT)},	/* vout1_vsync.vout1_vsync */
-	{VOUT1_D0, (M0 | PIN_OUTPUT)},	/* vout1_d0.vout1_d0 */
-	{VOUT1_D1, (M0 | PIN_OUTPUT)},	/* vout1_d1.vout1_d1 */
-	{VOUT1_D2, (M0 | PIN_OUTPUT)},	/* vout1_d2.vout1_d2 */
-	{VOUT1_D3, (M0 | PIN_OUTPUT)},	/* vout1_d3.vout1_d3 */
-	{VOUT1_D4, (M0 | PIN_OUTPUT)},	/* vout1_d4.vout1_d4 */
-	{VOUT1_D5, (M0 | PIN_OUTPUT)},	/* vout1_d5.vout1_d5 */
-	{VOUT1_D6, (M0 | PIN_OUTPUT)},	/* vout1_d6.vout1_d6 */
-	{VOUT1_D7, (M0 | PIN_OUTPUT)},	/* vout1_d7.vout1_d7 */
-	{VOUT1_D8, (M0 | PIN_OUTPUT)},	/* vout1_d8.vout1_d8 */
-	{VOUT1_D9, (M0 | PIN_OUTPUT)},	/* vout1_d9.vout1_d9 */
-	{VOUT1_D10, (M0 | PIN_OUTPUT)},	/* vout1_d10.vout1_d10 */
-	{VOUT1_D11, (M0 | PIN_OUTPUT)},	/* vout1_d11.vout1_d11 */
-	{VOUT1_D12, (M0 | PIN_OUTPUT)},	/* vout1_d12.vout1_d12 */
-	{VOUT1_D13, (M0 | PIN_OUTPUT)},	/* vout1_d13.vout1_d13 */
-	{VOUT1_D14, (M0 | PIN_OUTPUT)},	/* vout1_d14.vout1_d14 */
-	{VOUT1_D15, (M0 | PIN_OUTPUT)},	/* vout1_d15.vout1_d15 */
-	{VOUT1_D16, (M0 | PIN_OUTPUT)},	/* vout1_d16.vout1_d16 */
-	{VOUT1_D17, (M0 | PIN_OUTPUT)},	/* vout1_d17.vout1_d17 */
-	{VOUT1_D18, (M0 | PIN_OUTPUT)},	/* vout1_d18.vout1_d18 */
-	{VOUT1_D19, (M0 | PIN_OUTPUT)},	/* vout1_d19.vout1_d19 */
-	{VOUT1_D20, (M0 | PIN_OUTPUT)},	/* vout1_d20.vout1_d20 */
-	{VOUT1_D21, (M0 | PIN_OUTPUT)},	/* vout1_d21.vout1_d21 */
-	{VOUT1_D22, (M0 | PIN_OUTPUT)},	/* vout1_d22.vout1_d22 */
-	{VOUT1_D23, (M0 | PIN_OUTPUT)},	/* vout1_d23.vout1_d23 */
-	{MDIO_MCLK, (M0 | PIN_OUTPUT_PULLDOWN)},	/* mdio_mclk.mdio_mclk */
-	{MDIO_D, (M0 | PIN_INPUT)},	/* mdio_d.mdio_d */
+	{VOUT1_HSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_hsync.vout1_hsync */
+	{VOUT1_VSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_vsync.vout1_vsync */
+	{VOUT1_D0, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d0.vout1_d0 */
+	{VOUT1_D1, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d1.vout1_d1 */
+	{VOUT1_D2, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d2.vout1_d2 */
+	{VOUT1_D3, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d3.vout1_d3 */
+	{VOUT1_D4, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d4.vout1_d4 */
+	{VOUT1_D5, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d5.vout1_d5 */
+	{VOUT1_D6, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d6.vout1_d6 */
+	{VOUT1_D7, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d7.vout1_d7 */
+	{VOUT1_D8, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d8.vout1_d8 */
+	{VOUT1_D9, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d9.vout1_d9 */
+	{VOUT1_D10, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d10.vout1_d10 */
+	{VOUT1_D11, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d11.vout1_d11 */
+	{VOUT1_D12, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d12.vout1_d12 */
+	{VOUT1_D13, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d13.vout1_d13 */
+	{VOUT1_D14, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d14.vout1_d14 */
+	{VOUT1_D15, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d15.vout1_d15 */
+	{VOUT1_D16, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d16.vout1_d16 */
+	{VOUT1_D17, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d17.vout1_d17 */
+	{VOUT1_D18, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d18.vout1_d18 */
+	{VOUT1_D19, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d19.vout1_d19 */
+	{VOUT1_D20, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d20.vout1_d20 */
+	{VOUT1_D21, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d21.vout1_d21 */
+	{VOUT1_D22, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d22.vout1_d22 */
+	{VOUT1_D23, (M0 | PIN_OUTPUT | SLEWCONTROL | MANUAL_MODE)},	/* vout1_d23.vout1_d23 */
+	{MDIO_MCLK, (M0 | PIN_INPUT_SLEW)},	/* mdio_mclk.mdio_mclk */
+	{MDIO_D, (M0 | PIN_INPUT | SLEWCONTROL)},	/* mdio_d.mdio_d */
 	{RGMII0_TXC, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txc.rgmii0_txc */
 	{RGMII0_TXCTL, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txctl.rgmii0_txctl */
 	{RGMII0_TXD3, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd3.rgmii0_txd3 */
@@ -394,8 +410,8 @@
 	{RGMII0_RXD2, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd2.rgmii0_rxd2 */
 	{RGMII0_RXD1, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd1.rgmii0_rxd1 */
 	{RGMII0_RXD0, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd0.rgmii0_rxd0 */
-	{USB1_DRVVBUS, (M0 | PIN_OUTPUT)},	/* usb1_drvvbus.usb1_drvvbus */
-	{USB2_DRVVBUS, (M0 | PIN_OUTPUT)},	/* usb2_drvvbus.usb2_drvvbus */
+	{USB1_DRVVBUS, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* usb1_drvvbus.usb1_drvvbus */
+	{USB2_DRVVBUS, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* usb2_drvvbus.usb2_drvvbus */
 	{GPIO6_14, (M0 | PIN_OUTPUT)},	/* gpio6_14.gpio6_14 */
 	{GPIO6_15, (M0 | PIN_OUTPUT)},	/* gpio6_15.gpio6_15 */
 	{GPIO6_16, (M0 | PIN_INPUT_PULLUP)},	/* gpio6_16.gpio6_16 */
@@ -404,50 +420,50 @@
 	{XREF_CLK2, (M14 | PIN_OUTPUT)},	/* xref_clk2.gpio6_19 */
 	{XREF_CLK3, (M9 | PIN_OUTPUT_PULLDOWN)},	/* xref_clk3.clkout3 */
 	{MCASP1_ACLKX, (M11 | PIN_OUTPUT_PULLDOWN)},	/* mcasp1_aclkx.pr2_mdio_mdclk */
-	{MCASP1_FSX, (M11 | PIN_INPUT)},	/* mcasp1_fsx.pr2_mdio_data */
+	{MCASP1_FSX, (M11 | PIN_INPUT | SLEWCONTROL)},	/* mcasp1_fsx.pr2_mdio_data */
 	{MCASP1_ACLKR, (M14 | PIN_INPUT)},	/* mcasp1_aclkr.gpio5_0 */
 	{MCASP1_FSR, (M14 | PIN_INPUT)},	/* mcasp1_fsr.gpio5_1 */
-	{MCASP1_AXR0, (M11 | PIN_INPUT_PULLUP)},	/* mcasp1_axr0.pr2_mii0_rxer */
-	{MCASP1_AXR1, (M11 | PIN_INPUT_PULLUP)},	/* mcasp1_axr1.pr2_mii_mt0_clk */
+	{MCASP1_AXR0, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr0.pr2_mii0_rxer */
+	{MCASP1_AXR1, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr1.pr2_mii_mt0_clk */
 	{MCASP1_AXR2, (M14 | PIN_INPUT)},	/* mcasp1_axr2.gpio5_4 */
 	{MCASP1_AXR3, (M14 | PIN_INPUT)},	/* mcasp1_axr3.gpio5_5 */
 	{MCASP1_AXR4, (M14 | PIN_OUTPUT)},	/* mcasp1_axr4.gpio5_6 */
 	{MCASP1_AXR5, (M14 | PIN_OUTPUT)},	/* mcasp1_axr5.gpio5_7 */
 	{MCASP1_AXR6, (M14 | PIN_OUTPUT)},	/* mcasp1_axr6.gpio5_8 */
 	{MCASP1_AXR7, (M14 | PIN_OUTPUT)},	/* mcasp1_axr7.gpio5_9 */
-	{MCASP1_AXR8, (M11 | PIN_OUTPUT_PULLUP)},	/* mcasp1_axr8.pr2_mii0_txen */
-	{MCASP1_AXR9, (M11 | PIN_OUTPUT_PULLUP)},	/* mcasp1_axr9.pr2_mii0_txd3 */
-	{MCASP1_AXR10, (M11 | PIN_OUTPUT_PULLUP)},	/* mcasp1_axr10.pr2_mii0_txd2 */
-	{MCASP1_AXR11, (M11 | PIN_OUTPUT_PULLUP)},	/* mcasp1_axr11.pr2_mii0_txd1 */
-	{MCASP1_AXR12, (M11 | PIN_OUTPUT_PULLUP)},	/* mcasp1_axr12.pr2_mii0_txd0 */
-	{MCASP1_AXR13, (M11 | PIN_INPUT_PULLUP)},	/* mcasp1_axr13.pr2_mii_mr0_clk */
-	{MCASP1_AXR14, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr14.pr2_mii0_rxdv */
-	{MCASP1_AXR15, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr15.pr2_mii0_rxd3 */
+	{MCASP1_AXR8, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr8.pr2_mii0_txen */
+	{MCASP1_AXR9, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr9.pr2_mii0_txd3 */
+	{MCASP1_AXR10, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr10.pr2_mii0_txd2 */
+	{MCASP1_AXR11, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr11.pr2_mii0_txd1 */
+	{MCASP1_AXR12, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr12.pr2_mii0_txd0 */
+	{MCASP1_AXR13, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr13.pr2_mii_mr0_clk */
+	{MCASP1_AXR14, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr14.pr2_mii0_rxdv */
+	{MCASP1_AXR15, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr15.pr2_mii0_rxd3 */
 	{MCASP2_ACLKX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp2_aclkx.pr2_mii0_rxd2 */
-	{MCASP2_FSX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp2_fsx.pr2_mii0_rxd1 */
-	{MCASP2_AXR2, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr2.pr2_mii0_rxd0 */
-	{MCASP2_AXR3, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr3.pr2_mii0_rxlink */
+	{MCASP2_FSX, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_fsx.pr2_mii0_rxd1 */
+	{MCASP2_AXR2, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_axr2.pr2_mii0_rxd0 */
+	{MCASP2_AXR3, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_axr3.pr2_mii0_rxlink */
 	{MCASP2_AXR4, (M14 | PIN_OUTPUT)},	/* mcasp2_axr4.gpio1_4 */
 	{MCASP2_AXR5, (M14 | PIN_OUTPUT)},	/* mcasp2_axr5.gpio6_7 */
 	{MCASP2_AXR6, (M14 | PIN_OUTPUT)},	/* mcasp2_axr6.gpio2_29 */
 	{MCASP2_AXR7, (M14 | PIN_OUTPUT)},	/* mcasp2_axr7.gpio1_5 */
 	{MCASP3_ACLKX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp3_aclkx.pr2_mii0_crs */
-	{MCASP3_FSX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp3_fsx.pr2_mii0_col */
-	{MCASP3_AXR0, (M11 | PIN_INPUT_PULLUP)},	/* mcasp3_axr0.pr2_mii1_rxer */
-	{MCASP3_AXR1, (M11 | PIN_INPUT_PULLUP)},	/* mcasp3_axr1.pr2_mii1_rxlink */
+	{MCASP3_FSX, (M11 | PIN_INPUT_SLEW)},	/* mcasp3_fsx.pr2_mii0_col */
+	{MCASP3_AXR0, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp3_axr0.pr2_mii1_rxer */
+	{MCASP3_AXR1, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp3_axr1.pr2_mii1_rxlink */
 	{MCASP4_ACLKX, (M2 | PIN_INPUT)},	/* mcasp4_aclkx.spi3_sclk */
 	{MCASP4_FSX, (M2 | PIN_INPUT)},	/* mcasp4_fsx.spi3_d1 */
-	{MCASP4_AXR1, (M2 | PIN_OUTPUT_PULLUP)},	/* mcasp4_axr1.spi3_cs0 */
+	{MCASP4_AXR1, (M2 | PIN_INPUT_PULLUP)},	/* mcasp4_axr1.spi3_cs0 */
 	{MCASP5_ACLKX, (M13 | PIN_OUTPUT | MANUAL_MODE)},	/* mcasp5_aclkx.pr2_pru1_gpo1 */
 	{MCASP5_FSX, (M12 | PIN_INPUT | MANUAL_MODE)},	/* mcasp5_fsx.pr2_pru1_gpi2 */
 	{MMC1_CLK, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_clk.mmc1_clk */
-	{MMC1_CMD, (M0 | PIN_INPUT)},	/* mmc1_cmd.mmc1_cmd */
-	{MMC1_DAT0, (M0 | PIN_INPUT)},	/* mmc1_dat0.mmc1_dat0 */
-	{MMC1_DAT1, (M0 | PIN_INPUT)},	/* mmc1_dat1.mmc1_dat1 */
-	{MMC1_DAT2, (M0 | PIN_INPUT)},	/* mmc1_dat2.mmc1_dat2 */
-	{MMC1_DAT3, (M0 | PIN_INPUT)},	/* mmc1_dat3.mmc1_dat3 */
-	{MMC1_SDCD, (M14 | PIN_INPUT)},	/* mmc1_sdcd.gpio6_27 */
-	{MMC1_SDWP, (M14 | PIN_INPUT)},	/* mmc1_sdwp.gpio6_28 */
+	{MMC1_CMD, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_cmd.mmc1_cmd */
+	{MMC1_DAT0, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat0.mmc1_dat0 */
+	{MMC1_DAT1, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat1.mmc1_dat1 */
+	{MMC1_DAT2, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat2.mmc1_dat2 */
+	{MMC1_DAT3, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat3.mmc1_dat3 */
+	{MMC1_SDCD, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mmc1_sdcd.gpio6_27 */
+	{MMC1_SDWP, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mmc1_sdwp.gpio6_28 */
 	{GPIO6_10, (M11 | PIN_INPUT_PULLUP)},	/* gpio6_10.pr2_mii_mt1_clk */
 	{GPIO6_11, (M11 | PIN_OUTPUT_PULLUP)},	/* gpio6_11.pr2_mii1_txen */
 	{MMC3_CLK, (M11 | PIN_OUTPUT_PULLUP)},	/* mmc3_clk.pr2_mii1_txd3 */
@@ -465,16 +481,16 @@
 	{SPI1_D0, (M14 | PIN_OUTPUT)},	/* spi1_d0.gpio7_9 */
 	{SPI1_CS0, (M14 | PIN_OUTPUT)},	/* spi1_cs0.gpio7_10 */
 	{SPI1_CS1, (M14 | PIN_OUTPUT)},	/* spi1_cs1.gpio7_11 */
-	{SPI1_CS2, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_cs2.gpio7_12 */
-	{SPI1_CS3, (M6 | PIN_INPUT_PULLUP)},	/* spi1_cs3.hdmi1_cec */
+	{SPI1_CS2, (M14 | PIN_INPUT_SLEW)},	/* spi1_cs2.gpio7_12 */
+	{SPI1_CS3, (M6 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi1_cs3.hdmi1_cec */
+	{SPI2_SCLK, (M0 | PIN_INPUT)},	/* spi2_sclk.spi2_sclk */
+	{SPI2_D1, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_d1.spi2_d1 */
+	{SPI2_D0, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_d0.spi2_d0 */
+	{SPI2_CS0, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_cs0.spi2_cs0 */
 	{DCAN1_TX, (M15 | PULL_UP)},	/* dcan1_tx.safe for dcan1_tx */
 	{DCAN1_RX, (M15 | PULL_UP)},	/* dcan1_rx.safe for dcan1_rx */
-	{SPI2_SCLK, (M0 | PIN_INPUT)},	/* spi2_sclk.spi2_sclk */
-	{SPI2_D1, (M0 | PIN_OUTPUT)},	/* spi2_d1.spi2_d1 */
-	{SPI2_D0, (M0 | PIN_INPUT)},	/* spi2_d0.spi2_d0 */
-	{SPI2_CS0, (M0 | PIN_OUTPUT)},	/* spi2_cs0.spi2_cs0 */
-	{UART1_RXD, (M14 | PIN_OUTPUT)},	/* uart1_rxd.gpio7_22 */
-	{UART1_TXD, (M14 | PIN_OUTPUT)},	/* uart1_txd.gpio7_23 */
+	{UART1_RXD, (M14 | PIN_OUTPUT | SLEWCONTROL)},	/* uart1_rxd.gpio7_22 */
+	{UART1_TXD, (M14 | PIN_OUTPUT | SLEWCONTROL)},	/* uart1_txd.gpio7_23 */
 	{UART2_RXD, (M4 | PIN_INPUT)},	/* uart2_rxd.uart2_rxd */
 	{UART2_TXD, (M0 | PIN_OUTPUT)},	/* uart2_txd.uart2_txd */
 	{UART2_CTSN, (M2 | PIN_INPUT)},	/* uart2_ctsn.uart3_rxd */
@@ -490,7 +506,7 @@
 	{ON_OFF, (M0 | PIN_OUTPUT)},	/* on_off.on_off */
 	{RTC_PORZ, (M0 | PIN_INPUT)},	/* rtc_porz.rtc_porz */
 	{TMS, (M0 | PIN_INPUT_PULLUP)},	/* tms.tms */
-	{TDI, (M0 | PIN_INPUT_PULLUP)},	/* tdi.tdi */
+	{TDI, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* tdi.tdi */
 	{TDO, (M0 | PIN_OUTPUT_PULLUP)},	/* tdo.tdo */
 	{TCLK, (M0 | PIN_INPUT_PULLUP)},	/* tclk.tclk */
 	{TRSTN, (M0 | PIN_INPUT_PULLDOWN)},	/* trstn.trstn */
@@ -498,29 +514,30 @@
 	{EMU0, (M0 | PIN_INPUT_PULLUP)},	/* emu0.emu0 */
 	{EMU1, (M0 | PIN_INPUT_PULLUP)},	/* emu1.emu1 */
 	{RESETN, (M0 | PIN_INPUT)},	/* resetn.resetn */
+	{NMIN_DSP, (M0 | PIN_INPUT)},	/* nmin_dsp.nmin_dsp */
 	{RSTOUTN, (M0 | PIN_OUTPUT)},	/* rstoutn.rstoutn */
 };
 
 const struct pad_conf_entry core_padconf_array_essential_am571x_idk[] = {
-	{GPMC_A0, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a0.vin1b_d0 */
-	{GPMC_A1, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a1.vin1b_d1 */
-	{GPMC_A2, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a2.vin1b_d2 */
-	{GPMC_A3, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE11)},	/* gpmc_a3.vin1b_d3 */
-	{GPMC_A4, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE11)},	/* gpmc_a4.vin1b_d4 */
-	{GPMC_A5, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a5.vin1b_d5 */
-	{GPMC_A6, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a6.vin1b_d6 */
-	{GPMC_A7, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a7.vin1b_d7 */
-	{GPMC_A8, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE14)},	/* gpmc_a8.vin1b_hsync1 */
-	{GPMC_A9, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE14)},	/* gpmc_a9.vin1b_vsync1 */
-	{GPMC_A10, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE14)},	/* gpmc_a10.vin1b_clk1 */
-	{GPMC_A11, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE13)},	/* gpmc_a11.vin1b_de1 */
-	{GPMC_A12, (M6 | PIN_INPUT_PULLDOWN | VIRTUAL_MODE14)},	/* gpmc_a12.vin1b_fld1 */
-	{GPMC_A13, (M1 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* gpmc_a13.qspi1_rtclk */
-	{GPMC_A14, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* gpmc_a14.qspi1_d3 */
-	{GPMC_A15, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* gpmc_a15.qspi1_d2 */
-	{GPMC_A16, (M1 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* gpmc_a16.qspi1_d0 */
-	{GPMC_A17, (M1 | PIN_INPUT_PULLDOWN) | MANUAL_MODE},	/* gpmc_a17.qspi1_d1 */
-	{GPMC_A18, (M1 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* gpmc_a18.qspi1_sclk */
+	{GPMC_A0, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a0.vin1b_d0 */
+	{GPMC_A1, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a1.vin1b_d1 */
+	{GPMC_A2, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a2.vin1b_d2 */
+	{GPMC_A3, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a3.vin1b_d3 */
+	{GPMC_A4, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a4.vin1b_d4 */
+	{GPMC_A5, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a5.vin1b_d5 */
+	{GPMC_A6, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a6.vin1b_d6 */
+	{GPMC_A7, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a7.vin1b_d7 */
+	{GPMC_A8, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a8.vin1b_hsync1 */
+	{GPMC_A9, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a9.vin1b_vsync1 */
+	{GPMC_A10, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a10.vin1b_clk1 */
+	{GPMC_A11, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a11.vin1b_de1 */
+	{GPMC_A12, (M6 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a12.vin1b_fld1 */
+	{GPMC_A13, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a13.qspi1_rtclk */
+	{GPMC_A14, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a14.qspi1_d3 */
+	{GPMC_A15, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a15.qspi1_d2 */
+	{GPMC_A16, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a16.qspi1_d0 */
+	{GPMC_A17, (M1 | PIN_INPUT | MANUAL_MODE)},	/* gpmc_a17.qspi1_d1 */
+	{GPMC_A18, (M1 | PIN_OUTPUT | MANUAL_MODE)},	/* gpmc_a18.qspi1_sclk */
 	{GPMC_A19, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a19.mmc2_dat4 */
 	{GPMC_A20, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a20.mmc2_dat5 */
 	{GPMC_A21, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a21.mmc2_dat6 */
@@ -531,200 +548,230 @@
 	{GPMC_A26, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a26.mmc2_dat2 */
 	{GPMC_A27, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_a27.mmc2_dat3 */
 	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP)},	/* gpmc_cs1.mmc2_cmd */
-	{GPMC_CS0, (M14 | PIN_INPUT_PULLDOWN)},	/* gpmc_cs0.gpio2_19 */
-	{GPMC_CS2, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* gpmc_cs2.qspi1_cs0 */
-	{GPMC_CS3, (M14 | PIN_INPUT_PULLDOWN)},	/* gpmc_cs3.gpio2_21 */
-	{GPMC_CLK, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_clk.gpio2_22 */
-	{GPMC_ADVN_ALE, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_advn_ale.gpio2_23 */
-	{GPMC_OEN_REN, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_oen_ren.gpio2_24 */
-	{GPMC_WEN, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_wen.gpio2_25 */
-	{GPMC_BEN0, (M14 | PIN_INPUT_PULLDOWN)},	/* gpmc_ben0.gpio2_26 */
-	{GPMC_BEN1, (M14 | PIN_INPUT_PULLUP)},	/* gpmc_ben1.gpio2_27 */
-	{GPMC_WAIT0, (M14 | PIN_INPUT_PULLDOWN | SLEWCONTROL)},	/* gpmc_wait0.gpio2_28 */
+	{GPMC_CS0, (M14 | PIN_OUTPUT)},	/* gpmc_cs0.gpio2_19 */
+	{GPMC_CS2, (M1 | PIN_OUTPUT | MANUAL_MODE)},	/* gpmc_cs2.qspi1_cs0 */
+	{GPMC_CS3, (M14 | PIN_OUTPUT)},	/* gpmc_cs3.gpio2_21 */
+	{GPMC_CLK, (M14 | PIN_INPUT)},	/* gpmc_clk.gpio2_22 */
+	{GPMC_ADVN_ALE, (M14 | PIN_OUTPUT)},	/* gpmc_advn_ale.gpio2_23 */
+	{GPMC_OEN_REN, (M14 | PIN_OUTPUT)},	/* gpmc_oen_ren.gpio2_24 */
+	{GPMC_WEN, (M14 | PIN_OUTPUT)},	/* gpmc_wen.gpio2_25 */
+	{GPMC_BEN0, (M14 | PIN_OUTPUT)},	/* gpmc_ben0.gpio2_26 */
+	{GPMC_BEN1, (M14 | PIN_OUTPUT)},	/* gpmc_ben1.gpio2_27 */
+	{GPMC_WAIT0, (M14 | PIN_OUTPUT | SLEWCONTROL)},	/* gpmc_wait0.gpio2_28 */
 	{VIN2A_CLK0, (M14 | PIN_INPUT_PULLUP)},	/* vin2a_clk0.gpio3_28 */
 	{VIN2A_DE0, (M14 | PIN_INPUT_PULLUP)},	/* vin2a_de0.gpio3_29 */
 	{VIN2A_FLD0, (M14 | PIN_INPUT_PULLUP)},	/* vin2a_fld0.gpio3_30 */
 	{VIN2A_HSYNC0, (M14 | PIN_INPUT_PULLUP)},	/* vin2a_hsync0.gpio3_31 */
-	{VIN2A_VSYNC0, (M14 | PIN_INPUT_PULLDOWN)},	/* vin2a_vsync0.gpio4_0 */
-	{VIN2A_D0, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d0.pr1_uart0_rxd */
-	{VIN2A_D1, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d1.pr1_uart0_txd */
-	{VIN2A_D2, (M10 | PIN_INPUT_PULLDOWN)},	/* vin2a_d2.eCAP1_in_PWM1_out */
-	{VIN2A_D3, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d3.pr1_mi1_col */
-	{VIN2A_D4, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d4.pr1_mii1_txd1 */
-	{VIN2A_D5, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d5.pr1_mii1_txd0 */
-	{VIN2A_D6, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d6.pr1_mii_mt1_clk */
-	{VIN2A_D7, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d7.pr1_mii1_txen */
-	{VIN2A_D8, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d8.pr1_mii1_txd3 */
-	{VIN2A_D9, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d9.pr1_mii1_txd2 */
-	{VIN2A_D10, (M11 | PIN_INPUT_PULLDOWN)},	/* vin2a_d10.pr1_mdio_mdclk */
-	{VIN2A_D11, (M11 | PIN_INPUT_PULLUP)},	/* vin2a_d11.pr1_mdio_data */
-	{VIN2A_D12, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d12.rgmii1_txc */
-	{VIN2A_D13, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d13.rgmii1_txctl */
-	{VIN2A_D14, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d14.rgmii1_txd3 */
-	{VIN2A_D15, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d15.rgmii1_txd2 */
-	{VIN2A_D16, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d16.rgmii1_txd1 */
-	{VIN2A_D17, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d17.rgmii1_txd0 */
+	{VIN2A_VSYNC0, (M14 | PIN_OUTPUT)},	/* vin2a_vsync0.gpio4_0 */
+	{VIN2A_D0, (M11 | PIN_INPUT)},	/* vin2a_d0.pr1_uart0_rxd */
+	{VIN2A_D1, (M11 | PIN_OUTPUT)},	/* vin2a_d1.pr1_uart0_txd */
+	{VIN2A_D2, (M10 | PIN_OUTPUT)},	/* vin2a_d2.eCAP1_in_PWM1_out */
+	{VIN2A_D10, (M11 | PIN_OUTPUT_PULLDOWN)},	/* vin2a_d10.pr1_mdio_mdclk */
+	{VIN2A_D11, (M11 | PIN_INPUT)},	/* vin2a_d11.pr1_mdio_data */
+	{VIN2A_D12, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d12.rgmii1_txc */
+	{VIN2A_D13, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d13.rgmii1_txctl */
+	{VIN2A_D14, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d14.rgmii1_txd3 */
+	{VIN2A_D15, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d15.rgmii1_txd2 */
+	{VIN2A_D16, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d16.rgmii1_txd1 */
+	{VIN2A_D17, (M3 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d17.rgmii1_txd0 */
 	{VIN2A_D18, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d18.rgmii1_rxc */
-	{VIN2A_D19, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d19.rgmii1_rxctl */
+	{VIN2A_D19, (M3 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d19.rgmii1_rxctl */
 	{VIN2A_D20, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d20.rgmii1_rxd3 */
 	{VIN2A_D21, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d21.rgmii1_rxd2 */
 	{VIN2A_D22, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d22.rgmii1_rxd1 */
 	{VIN2A_D23, (M3 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* vin2a_d23.rgmii1_rxd0 */
-	{VOUT1_CLK, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_clk.vout1_clk */
-	{VOUT1_DE, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_de.vout1_de */
-	{VOUT1_FLD, (M14 | PIN_INPUT_PULLUP)},	/* vout1_fld.gpio4_21 */
-	{VOUT1_HSYNC, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_hsync.vout1_hsync */
-	{VOUT1_VSYNC, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_vsync.vout1_vsync */
-	{VOUT1_D0, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d0.vout1_d0 */
-	{VOUT1_D1, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d1.vout1_d1 */
-	{VOUT1_D2, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d2.vout1_d2 */
-	{VOUT1_D3, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d3.vout1_d3 */
-	{VOUT1_D4, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d4.vout1_d4 */
-	{VOUT1_D5, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d5.vout1_d5 */
-	{VOUT1_D6, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d6.vout1_d6 */
-	{VOUT1_D7, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d7.vout1_d7 */
-	{VOUT1_D8, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d8.vout1_d8 */
-	{VOUT1_D9, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d9.vout1_d9 */
-	{VOUT1_D10, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d10.vout1_d10 */
-	{VOUT1_D11, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d11.vout1_d11 */
-	{VOUT1_D12, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d12.vout1_d12 */
-	{VOUT1_D13, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d13.vout1_d13 */
-	{VOUT1_D14, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d14.vout1_d14 */
-	{VOUT1_D15, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d15.vout1_d15 */
-	{VOUT1_D16, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d16.vout1_d16 */
-	{VOUT1_D17, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d17.vout1_d17 */
-	{VOUT1_D18, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d18.vout1_d18 */
-	{VOUT1_D19, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d19.vout1_d19 */
-	{VOUT1_D20, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d20.vout1_d20 */
-	{VOUT1_D21, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d21.vout1_d21 */
-	{VOUT1_D22, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d22.vout1_d22 */
-	{VOUT1_D23, (M0 | PIN_INPUT_PULLDOWN)},	/* vout1_d23.vout1_d23 */
-	{MDIO_MCLK, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mdio_mclk.mdio_mclk */
-	{MDIO_D, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mdio_d.mdio_d */
-	{RMII_MHZ_50_CLK, (M13 | PIN_INPUT_PULLDOWN)},	/* RMII_MHZ_50_CLK.pr2_pru1_gpo2 */
-	{UART3_RXD, (M14 | PIN_INPUT_SLEW)},	/* uart3_rxd.gpio5_18 */
-	{UART3_TXD, (M14 | PIN_INPUT_SLEW)},	/* uart3_txd.gpio5_19 */
-	{RGMII0_TXC, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txc.rgmii0_txc */
-	{RGMII0_TXCTL, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txctl.rgmii0_txctl */
-	{RGMII0_TXD3, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd3.rgmii0_txd3 */
-	{RGMII0_TXD2, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd2.rgmii0_txd2 */
-	{RGMII0_TXD1, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd1.rgmii0_txd1 */
-	{RGMII0_TXD0, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd0.rgmii0_txd0 */
+	{VOUT1_FLD, (M14 | PIN_OUTPUT)},	/* vout1_fld.gpio4_21 */
+	{MDIO_MCLK, (M0 | PIN_OUTPUT_PULLDOWN | SLEWCONTROL)},	/* mdio_mclk.mdio_mclk */
+	{MDIO_D, (M0 | PIN_INPUT | SLEWCONTROL)},	/* mdio_d.mdio_d */
+	{UART3_RXD, (M14 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* uart3_rxd.gpio5_18 */
+	{UART3_TXD, (M14 | PIN_OUTPUT_PULLDOWN | SLEWCONTROL)},	/* uart3_txd.gpio5_19 */
+	{RGMII0_TXC, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txc.rgmii0_txc */
+	{RGMII0_TXCTL, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txctl.rgmii0_txctl */
+	{RGMII0_TXD3, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd3.rgmii0_txd3 */
+	{RGMII0_TXD2, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd2.rgmii0_txd2 */
+	{RGMII0_TXD1, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd1.rgmii0_txd1 */
+	{RGMII0_TXD0, (M0 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_txd0.rgmii0_txd0 */
 	{RGMII0_RXC, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxc.rgmii0_rxc */
-	{RGMII0_RXCTL, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},/* rgmii0_rxctl.rgmii0_rxctl */
-	{RGMII0_RXD3, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxd3.rgmii0_rxd3 */
-	{RGMII0_RXD2, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxd2.rgmii0_rxd2 */
-	{RGMII0_RXD1, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxd1.rgmii0_rxd1 */
-	{RGMII0_RXD0, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxd0.rgmii0_rxd0 */
-	{USB1_DRVVBUS, (M0 | PIN_INPUT_SLEW)},	/* usb1_drvvbus.usb1_drvvbus */
-	{USB2_DRVVBUS, (M0 | PIN_INPUT_SLEW)},	/* usb2_drvvbus.usb2_drvvbus */
-	{GPIO6_14, (M14 | PIN_INPUT_PULLUP)},	/* gpio6_14.gpio6_14 */
-	{GPIO6_15, (M14 | PIN_INPUT_PULLUP)},	/* gpio6_15.gpio6_15 */
-	{GPIO6_16, (M14 | PIN_INPUT_PULLDOWN)},	/* gpio6_16.gpio6_16 */
+	{RGMII0_RXCTL, (M0 | PIN_INPUT_PULLDOWN | MANUAL_MODE)},	/* rgmii0_rxctl.rgmii0_rxctl */
+	{RGMII0_RXD3, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd3.rgmii0_rxd3 */
+	{RGMII0_RXD2, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd2.rgmii0_rxd2 */
+	{RGMII0_RXD1, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd1.rgmii0_rxd1 */
+	{RGMII0_RXD0, (M0 | PIN_INPUT_PULLUP | MANUAL_MODE)},	/* rgmii0_rxd0.rgmii0_rxd0 */
+	{USB1_DRVVBUS, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* usb1_drvvbus.usb1_drvvbus */
+	{USB2_DRVVBUS, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* usb2_drvvbus.usb2_drvvbus */
+	{GPIO6_14, (M0 | PIN_OUTPUT)},	/* gpio6_14.gpio6_14 */
+	{GPIO6_15, (M0 | PIN_OUTPUT)},	/* gpio6_15.gpio6_15 */
+	{GPIO6_16, (M0 | PIN_INPUT_PULLUP)},	/* gpio6_16.gpio6_16 */
 	{XREF_CLK0, (M11 | PIN_INPUT_PULLDOWN)},	/* xref_clk0.pr2_mii1_col */
 	{XREF_CLK1, (M11 | PIN_INPUT_PULLDOWN)},	/* xref_clk1.pr2_mii1_crs */
-	{XREF_CLK2, (M14 | PIN_INPUT_PULLDOWN)},	/* xref_clk2.gpio6_19 */
-	{XREF_CLK3, (M15 | PIN_INPUT_PULLDOWN)},	/* xref_clk3.Driveroff */
-	{MCASP1_ACLKX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp1_aclkx.pr2_mdio_mdclk */
-	{MCASP1_FSX, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_fsx.pr2_mdio_data */
-	{MCASP1_ACLKR, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_aclkr.gpio5_0 */
-	{MCASP1_FSR, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_fsr.gpio5_1 */
+	{XREF_CLK2, (M14 | PIN_OUTPUT)},	/* xref_clk2.gpio6_19 */
+	{XREF_CLK3, (M7 | PIN_INPUT)},	/* xref_clk3.hdq0 */
+	{MCASP1_ACLKX, (M11 | PIN_OUTPUT_PULLDOWN)},	/* mcasp1_aclkx.pr2_mdio_mdclk */
+	{MCASP1_FSX, (M11 | PIN_INPUT | SLEWCONTROL)},	/* mcasp1_fsx.pr2_mdio_data */
+	{MCASP1_ACLKR, (M14 | PIN_INPUT)},	/* mcasp1_aclkr.gpio5_0 */
+	{MCASP1_FSR, (M14 | PIN_INPUT)},	/* mcasp1_fsr.gpio5_1 */
 	{MCASP1_AXR0, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr0.pr2_mii0_rxer */
-	{MCASP1_AXR1, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr1.pr2_mii_mt0_clk */
-	{MCASP1_AXR2, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr2.gpio5_4 */
-	{MCASP1_AXR3, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_axr3.gpio5_5 */
+	{MCASP1_AXR1, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr1.pr2_mii_mt0_clk */
+	{MCASP1_AXR2, (M14 | PIN_INPUT)},	/* mcasp1_axr2.gpio5_4 */
+	{MCASP1_AXR3, (M14 | PIN_INPUT)},	/* mcasp1_axr3.gpio5_5 */
 	{MCASP1_AXR4, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr4.gpio5_6 */
-	{MCASP1_AXR5, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp1_axr5.gpio5_7 */
-	{MCASP1_AXR6, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_axr6.gpio5_8 */
-	{MCASP1_AXR7, (M14 | PIN_INPUT_PULLUP)},	/* mcasp1_axr7.gpio5_9 */
-	{MCASP1_AXR8, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr8.pr2_mii0_txen */
-	{MCASP1_AXR9, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr9.pr2_mii0_txd3 */
-	{MCASP1_AXR10, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr10.pr2_mii0_txd2 */
-	{MCASP1_AXR11, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr11.pr2_mii0_txd1 */
-	{MCASP1_AXR12, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr12.pr2_mii0_txd0 */
-	{MCASP1_AXR13, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr13.pr2_mii_mr0_clk */
-	{MCASP1_AXR14, (M11 | PIN_INPUT_PULLDOWN | SLEWCONTROL)},	/* mcasp1_axr14.pr2_mii0_rxdv */
+	{MCASP1_AXR5, (M14 | PIN_INPUT)},	/* mcasp1_axr5.gpio5_7 */
+	{MCASP1_AXR6, (M14 | PIN_OUTPUT)},	/* mcasp1_axr6.gpio5_8 */
+	{MCASP1_AXR7, (M14 | PIN_OUTPUT)},	/* mcasp1_axr7.gpio5_9 */
+	{MCASP1_AXR8, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr8.pr2_mii0_txen */
+	{MCASP1_AXR9, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr9.pr2_mii0_txd3 */
+	{MCASP1_AXR10, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr10.pr2_mii0_txd2 */
+	{MCASP1_AXR11, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr11.pr2_mii0_txd1 */
+	{MCASP1_AXR12, (M11 | PIN_OUTPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr12.pr2_mii0_txd0 */
+	{MCASP1_AXR13, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp1_axr13.pr2_mii_mr0_clk */
+	{MCASP1_AXR14, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr14.pr2_mii0_rxdv */
 	{MCASP1_AXR15, (M11 | PIN_INPUT_SLEW)},	/* mcasp1_axr15.pr2_mii0_rxd3 */
-	{MCASP2_ACLKX, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_aclkx.pr2_mii0_rxd2 */
+	{MCASP2_ACLKX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp2_aclkx.pr2_mii0_rxd2 */
 	{MCASP2_FSX, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_fsx.pr2_mii0_rxd1 */
-	{MCASP2_ACLKR, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp2_aclkr.Driveroff */
-	{MCASP2_FSR, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp2_fsr.Driveroff */
-	{MCASP2_AXR0, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr0.Driveroff */
-	{MCASP2_AXR1, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr1.Driveroff */
 	{MCASP2_AXR2, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_axr2.pr2_mii0_rxd0 */
-	{MCASP2_AXR3, (M11 | PIN_INPUT_PULLDOWN | SLEWCONTROL)},	/* mcasp2_axr3.pr2_mii0_rxlink */
-	{MCASP2_AXR4, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr4.gpio1_4 */
-	{MCASP2_AXR5, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr5.gpio6_7 */
-	{MCASP2_AXR6, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr6.gpio2_29 */
-	{MCASP2_AXR7, (M14 | PIN_INPUT_PULLDOWN)},	/* mcasp2_axr7.gpio1_5 */
+	{MCASP2_AXR3, (M11 | PIN_INPUT_SLEW)},	/* mcasp2_axr3.pr2_mii0_rxlink */
+	{MCASP2_AXR4, (M14 | PIN_OUTPUT)},	/* mcasp2_axr4.gpio1_4 */
+	{MCASP2_AXR5, (M14 | PIN_OUTPUT)},	/* mcasp2_axr5.gpio6_7 */
+	{MCASP2_AXR6, (M14 | PIN_OUTPUT)},	/* mcasp2_axr6.gpio2_29 */
+	{MCASP2_AXR7, (M14 | PIN_OUTPUT)},	/* mcasp2_axr7.gpio1_5 */
 	{MCASP3_ACLKX, (M11 | PIN_INPUT_PULLDOWN)},	/* mcasp3_aclkx.pr2_mii0_crs */
 	{MCASP3_FSX, (M11 | PIN_INPUT_SLEW)},	/* mcasp3_fsx.pr2_mii0_col */
 	{MCASP3_AXR0, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp3_axr0.pr2_mii1_rxer */
 	{MCASP3_AXR1, (M11 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* mcasp3_axr1.pr2_mii1_rxlink */
-	{MCASP4_ACLKX, (M2 | PIN_INPUT_PULLDOWN)},	/* mcasp4_aclkx.spi3_sclk */
-	{MCASP4_FSX, (M2 | PIN_INPUT_PULLDOWN)},	/* mcasp4_fsx.spi3_d1 */
-	{MCASP4_AXR0, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp4_axr0.Driveroff */
-	{MCASP4_AXR1, (M2 | PIN_INPUT_PULLDOWN)},	/* mcasp4_axr1.spi3_cs0 */
-	{MCASP5_ACLKX, (M13 | PIN_INPUT_PULLDOWN)},	/* mcasp5_aclkx.pr2_pru1_gpo1 */
-	{MCASP5_FSX, (M12 | PIN_INPUT_PULLDOWN)},	/* mcasp5_fsx.pr2_pru1_gpi2 */
-	{MCASP5_AXR0, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp5_axr0.Driveroff */
-	{MCASP5_AXR1, (M15 | PIN_INPUT_PULLDOWN)},	/* mcasp5_axr1.Driveroff */
+	{MCASP4_ACLKX, (M2 | PIN_OUTPUT)},	/* mcasp4_aclkx.spi3_sclk */
+	{MCASP4_FSX, (M2 | PIN_INPUT)},	/* mcasp4_fsx.spi3_d1 */
+	{MCASP4_AXR1, (M2 | PIN_OUTPUT_PULLUP)},	/* mcasp4_axr1.spi3_cs0 */
+	{MCASP5_AXR0, (M4 | PIN_INPUT)},	/* mcasp5_axr0.uart3_rxd */
+	{MCASP5_AXR1, (M4 | PIN_OUTPUT)},	/* mcasp5_axr1.uart3_txd */
 	{MMC1_CLK, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_clk.mmc1_clk */
 	{MMC1_CMD, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_cmd.mmc1_cmd */
 	{MMC1_DAT0, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat0.mmc1_dat0 */
 	{MMC1_DAT1, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat1.mmc1_dat1 */
 	{MMC1_DAT2, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat2.mmc1_dat2 */
 	{MMC1_DAT3, (M0 | PIN_INPUT_PULLUP)},	/* mmc1_dat3.mmc1_dat3 */
-	{MMC1_SDCD, (M14 | PIN_INPUT_PULLUP)},	/* mmc1_sdcd.gpio6_27 */
-	{MMC1_SDWP, (M0 | PIN_OUTPUT)},	/* mmc1_sdwp.mmc1_sdwp */
+	{MMC1_SDCD, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mmc1_sdcd.gpio6_27 */
+	{MMC1_SDWP, (M14 | PIN_INPUT | SLEWCONTROL)},	/* mmc1_sdwp.gpio6_28 */
 	{GPIO6_10, (M11 | PIN_INPUT_PULLUP)},	/* gpio6_10.pr2_mii_mt1_clk */
-	{GPIO6_11, (M11 | PIN_INPUT_PULLUP)},	/* gpio6_11.pr2_mii1_txen */
-	{MMC3_CLK, (M11 | PIN_INPUT_PULLUP)},	/* mmc3_clk.pr2_mii1_txd3 */
-	{MMC3_CMD, (M11 | PIN_INPUT_PULLUP)},	/* mmc3_cmd.pr2_mii1_txd2 */
-	{MMC3_DAT0, (M11 | PIN_INPUT_PULLUP)},	/* mmc3_dat0.pr2_mii1_txd1 */
-	{MMC3_DAT1, (M11 | PIN_INPUT_PULLUP)},	/* mmc3_dat1.pr2_mii1_txd0 */
+	{GPIO6_11, (M11 | PIN_OUTPUT_PULLUP)},	/* gpio6_11.pr2_mii1_txen */
+	{MMC3_CLK, (M11 | PIN_OUTPUT_PULLUP)},	/* mmc3_clk.pr2_mii1_txd3 */
+	{MMC3_CMD, (M11 | PIN_OUTPUT_PULLUP)},	/* mmc3_cmd.pr2_mii1_txd2 */
+	{MMC3_DAT0, (M11 | PIN_OUTPUT_PULLUP)},	/* mmc3_dat0.pr2_mii1_txd1 */
+	{MMC3_DAT1, (M11 | PIN_OUTPUT_PULLUP)},	/* mmc3_dat1.pr2_mii1_txd0 */
 	{MMC3_DAT2, (M11 | PIN_INPUT_PULLUP)},	/* mmc3_dat2.pr2_mii_mr1_clk */
 	{MMC3_DAT3, (M11 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat3.pr2_mii1_rxdv */
 	{MMC3_DAT4, (M11 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat4.pr2_mii1_rxd3 */
 	{MMC3_DAT5, (M11 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat5.pr2_mii1_rxd2 */
 	{MMC3_DAT6, (M11 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat6.pr2_mii1_rxd1 */
 	{MMC3_DAT7, (M11 | PIN_INPUT_PULLDOWN)},	/* mmc3_dat7.pr2_mii1_rxd0 */
-	{SPI1_SCLK, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_sclk.gpio7_7 */
-	{SPI1_D1, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_d1.gpio7_8 */
-	{SPI1_D0, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_d0.gpio7_9 */
-	{SPI1_CS0, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_cs0.gpio7_10 */
-	{SPI1_CS1, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_cs1.gpio7_11 */
-	{SPI1_CS2, (M14 | PIN_INPUT_PULLDOWN)},	/* spi1_cs2.gpio7_12 */
-	{SPI1_CS3, (M6 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi1_cs3.hdmi1_cec */
-	{SPI2_SCLK, (M0 | PIN_INPUT_PULLDOWN)},	/* spi2_sclk.spi2_sclk */
-	{SPI2_D1, (M0 | PIN_INPUT_SLEW)},	/* spi2_d1.spi2_d1 */
-	{SPI2_D0, (M0 | PIN_INPUT_SLEW)},	/* spi2_d0.spi2_d0 */
-	{SPI2_CS0, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* spi2_cs0.spi2_cs0 */
+	{SPI1_SCLK, (M14 | PIN_OUTPUT)},	/* spi1_sclk.gpio7_7 */
+	{SPI1_D1, (M14 | PIN_OUTPUT)},	/* spi1_d1.gpio7_8 */
+	{SPI1_D0, (M14 | PIN_OUTPUT)},	/* spi1_d0.gpio7_9 */
+	{SPI1_CS0, (M14 | PIN_OUTPUT)},	/* spi1_cs0.gpio7_10 */
+	{SPI1_CS1, (M14 | PIN_OUTPUT)},	/* spi1_cs1.gpio7_11 */
+	{SPI1_CS2, (M14 | PIN_INPUT_SLEW)},	/* spi1_cs2.gpio7_12 */
+	{SPI1_CS3, (M6 | PIN_INPUT | SLEWCONTROL)},	/* spi1_cs3.hdmi1_cec */
+	{SPI2_SCLK, (M0 | PIN_INPUT)},	/* spi2_sclk.spi2_sclk */
+	{SPI2_D1, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_d1.spi2_d1 */
+	{SPI2_D0, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_d0.spi2_d0 */
+	{SPI2_CS0, (M0 | PIN_INPUT | SLEWCONTROL)},	/* spi2_cs0.spi2_cs0 */
 	{DCAN1_TX, (M15 | PULL_UP)},	/* dcan1_tx.safe for dcan1_tx */
 	{DCAN1_RX, (M15 | PULL_UP)},	/* dcan1_rx.safe for dcan1_rx */
-	{UART1_RXD, (M14 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* uart1_rxd.gpio7_22 */
-	{UART1_CTSN, (M14 | PIN_INPUT_PULLDOWN)},	/* uart1_ctsn.gpio7_24 */
-	{UART1_RTSN, (M14 | PIN_INPUT_PULLDOWN)},	/* uart1_rtsn.gpio7_25 */
-	{UART2_RXD, (M0 | PIN_INPUT_PULLUP)},	/* uart2_rxd.uart2_rxd */
-	{UART2_TXD, (M0 | PIN_INPUT_PULLUP)},	/* uart2_txd.uart2_txd */
-	{UART2_CTSN, (M2 | PIN_INPUT_PULLUP)},	/* uart2_ctsn.uart3_rxd */
-	{UART2_RTSN, (M1 | PIN_INPUT_PULLUP)},	/* uart2_rtsn.uart3_txd */
-	{I2C2_SDA, (M1 | PIN_INPUT_PULLUP)},	/* i2c2_sda.hdmi1_ddc_scl */
-	{I2C2_SCL, (M1 | PIN_INPUT_PULLUP)},	/* i2c2_scl.hdmi1_ddc_sda */
-	{WAKEUP0, (M0 | PIN_OUTPUT_PULLDOWN)},	/* Wakeup0.Wakeup0 */
-	{WAKEUP3, (M0 | PIN_OUTPUT_PULLDOWN)},	/* Wakeup3.Wakeup3 */
-	{ON_OFF, (M0 | PIN_OUTPUT_PULLUP)},	/* on_off.on_off */
-	{RTC_PORZ, (M0 | PIN_OUTPUT)},	/* rtc_porz.rtc_porz */
+	{UART1_RXD, (M14 | PIN_INPUT | SLEWCONTROL)},	/* uart1_rxd.gpio7_22 */
+	{UART1_CTSN, (M14 | PIN_OUTPUT)},	/* uart1_ctsn.gpio7_24 */
+	{UART1_RTSN, (M14 | PIN_OUTPUT)},	/* uart1_rtsn.gpio7_25 */
+	{I2C1_SDA, (M0 | PIN_INPUT)},	/* i2c1_sda.i2c1_sda */
+	{I2C1_SCL, (M0 | PIN_INPUT)},	/* i2c1_scl.i2c1_scl */
+	{I2C2_SDA, (M1 | PIN_INPUT)},	/* i2c2_sda.hdmi1_ddc_scl */
+	{I2C2_SCL, (M1 | PIN_INPUT)},	/* i2c2_scl.hdmi1_ddc_sda */
+	{WAKEUP0, (M0 | PIN_INPUT)},	/* Wakeup0.Wakeup0 */
+	{WAKEUP3, (M0 | PIN_INPUT)},	/* Wakeup3.Wakeup3 */
+	{ON_OFF, (M0 | PIN_OUTPUT)},	/* on_off.on_off */
+	{RTC_PORZ, (M0 | PIN_INPUT)},	/* rtc_porz.rtc_porz */
 	{TMS, (M0 | PIN_INPUT_PULLUP)},	/* tms.tms */
 	{TDI, (M0 | PIN_INPUT_PULLUP | SLEWCONTROL)},	/* tdi.tdi */
-	{TDO, (M0 | PIN_INPUT_PULLUP)},	/* tdo.tdo */
+	{TDO, (M0 | PIN_OUTPUT_PULLUP)},	/* tdo.tdo */
 	{TCLK, (M0 | PIN_INPUT_PULLUP)},	/* tclk.tclk */
-	{TRSTN, (M0 | PIN_INPUT_PULLDOWN)},	/* trstn.trstn */
-	{RTCK, (M0 | PIN_INPUT)},	/* rtck.rtck */
-	{EMU0, (M0 | PIN_INPUT_PULLUP)},	/* emu0.emu0 */
-	{EMU1, (M0 | PIN_INPUT_PULLUP)},	/* emu1.emu1 */
-	{RESETN, (M0 | PIN_OUTPUT_PULLUP)},	/* resetn.resetn */
-	{RSTOUTN, (M0 | PIN_OUTPUT_PULLDOWN)},	/* rstoutn.rstoutn */
+	{TRSTN, (M0 | PIN_INPUT)},	/* trstn.trstn */
+	{RTCK, (M0 | PIN_OUTPUT_PULLUP)},	/* rtck.rtck */
+	{EMU0, (M0 | PIN_INPUT)},	/* emu0.emu0 */
+	{EMU1, (M0 | PIN_INPUT)},	/* emu1.emu1 */
+	{RESETN, (M0 | PIN_INPUT)},	/* resetn.resetn */
+	{RSTOUTN, (M0 | PIN_OUTPUT)},	/* rstoutn.rstoutn */
+};
+
+const struct pad_conf_entry core_padconf_array_icss1eth_am571x_idk[] = {
+	/* PR1 MII0 */
+	{VOUT1_D8, (M12 | PIN_INPUT_PULLUP)},	/* vout1_d8.pr1_mii_mt0_clk */
+	{VOUT1_D9, (M13 | PIN_OUTPUT_PULLUP)},	/* vout1_d9.pr1_mii0_txd3 */
+	{VOUT1_D10, (M13 | PIN_OUTPUT_PULLUP)},	/* vout1_d10.pr1_mii0_txd2 */
+	{VOUT1_D11, (M13 | PIN_OUTPUT_PULLUP)},	/* vout1_d11.pr1_mii0_txen */
+	{VOUT1_D12, (M13 | PIN_OUTPUT_PULLUP)},	/* vout1_d12.pr1_mii0_txd1 */
+	{VOUT1_D13, (M13 | PIN_OUTPUT_PULLUP)},	/* vout1_d13.pr1_mii0_txd0 */
+	{VOUT1_D14, (M12 | PIN_INPUT_PULLUP)},	/* vout1_d14.pr1_mii_mr0_clk */
+	{VOUT1_D15, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d15.pr1_mii0_rxdv */
+	{VOUT1_D16, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d16.pr1_mii0_rxd3 */
+	{VOUT1_D17, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d17.pr1_mii0_rxd2 */
+	{VOUT1_D18, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d18.pr1_mii0_rxd1 */
+	{VOUT1_D19, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d19.pr1_mii0_rxd0 */
+	{VOUT1_D20, (M12 | PIN_INPUT_PULLUP)},	/* vout1_d20.pr1_mii0_rxer */
+	{VOUT1_D21, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d21.pr1_mii0_rxlink */
+	{VOUT1_D22, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d22.pr1_mii0_col */
+	{VOUT1_D23, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d23.pr1_mii0_crs */
+
+	/* PR1 MII1 */
+	{VIN2A_D3, (M12 | PIN_INPUT_PULLDOWN)},	/* vin2a_d3.pr1_mii1_col */
+	{VIN2A_D4, (M13 | PIN_OUTPUT_PULLUP)},	/* vin2a_d4.pr1_mii1_txd1 */
+	{VIN2A_D5, (M13 | PIN_OUTPUT_PULLUP)},	/* vin2a_d5.pr1_mii1_txd0 */
+	{VIN2A_D6, (M11 | PIN_INPUT_PULLUP)},	/* vin2a_d6.pr1_mii_mt1_clk */
+	{VIN2A_D7, (M11 | PIN_OUTPUT_PULLUP)},	/* vin2a_d7.pr1_mii1_txen */
+	{VIN2A_D8, (M11 | PIN_OUTPUT_PULLUP)},	/* vin2a_d8.pr1_mii1_txd3 */
+	{VIN2A_D9, (M11 | PIN_OUTPUT_PULLUP)},	/* vin2a_d9.pr1_mii1_txd2 */
+	{VOUT1_VSYNC, (M12 | PIN_INPUT_PULLUP)},	/* vout1_vsync.pr1_mii1_rxer */
+	{VOUT1_D0, (M12 | PIN_INPUT_PULLUP)},	/* vout1_d0.pr1_mii1_rxlink */
+	{VOUT1_D1, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d1.pr1_mii1_crs */
+	{VOUT1_D2, (M12 | PIN_INPUT_PULLUP)},	/* vout1_d2.pr1_mii_mr1_clk */
+	{VOUT1_D3, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d3.pr1_mii1_rxdv */
+	{VOUT1_D4, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d4.pr1_mii1_rxd3 */
+	{VOUT1_D5, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d5.pr1_mii1_rxd2 */
+	{VOUT1_D6, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d6.pr1_mii1_rxd1 */
+	{VOUT1_D7, (M12 | PIN_INPUT_PULLDOWN)},	/* vout1_d7.pr1_mii1_rxd0 */
+};
+
+const struct pad_conf_entry core_padconf_array_vout_am571x_idk[] = {
+	{VOUT1_CLK, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_clk.vout1_clk */
+	{VOUT1_DE, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_de.vout1_de */
+	{VOUT1_HSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_hsync.vout1_hsync */
+	{VOUT1_VSYNC, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_vsync.vout1_vsync */
+	{VOUT1_D0, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d0.vout1_d0 */
+	{VOUT1_D1, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d1.vout1_d1 */
+	{VOUT1_D2, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d2.vout1_d2 */
+	{VOUT1_D3, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d3.vout1_d3 */
+	{VOUT1_D4, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d4.vout1_d4 */
+	{VOUT1_D5, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d5.vout1_d5 */
+	{VOUT1_D6, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d6.vout1_d6 */
+	{VOUT1_D7, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d7.vout1_d7 */
+	{VOUT1_D8, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d8.vout1_d8 */
+	{VOUT1_D9, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d9.vout1_d9 */
+	{VOUT1_D10, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d10.vout1_d10 */
+	{VOUT1_D11, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d11.vout1_d11 */
+	{VOUT1_D12, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d12.vout1_d12 */
+	{VOUT1_D13, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d13.vout1_d13 */
+	{VOUT1_D14, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d14.vout1_d14 */
+	{VOUT1_D15, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d15.vout1_d15 */
+	{VOUT1_D16, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d16.vout1_d16 */
+	{VOUT1_D17, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d17.vout1_d17 */
+	{VOUT1_D18, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d18.vout1_d18 */
+	{VOUT1_D19, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d19.vout1_d19 */
+	{VOUT1_D20, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d20.vout1_d20 */
+	{VOUT1_D21, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d21.vout1_d21 */
+	{VOUT1_D22, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d22.vout1_d22 */
+	{VOUT1_D23, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* vout1_d23.vout1_d23 */
+
+	{MCASP5_ACLKX, (M12 | PIN_INPUT | MANUAL_MODE)},	/* mcasp5_aclkx.pr2_pru1_gpi1 */
+	{MCASP5_FSX, (M12 | PIN_INPUT | MANUAL_MODE)},	/* mcasp5_fsx.pr2_pru1_gpi2 */
+	{UART2_RXD, (M0 | PIN_INPUT)},	/* uart2_rxd.uart2_rxd */
+	{UART2_TXD, (M0 | PIN_OUTPUT)},	/* uart2_txd.uart2_txd */
+	{VIN2A_D5, (M13 | PIN_OUTPUT_PULLDOWN | MANUAL_MODE)},	/* vin2a_d5.pr1_pru1_gpo2 */
 };
 
 const struct pad_conf_entry early_padconf[] = {
@@ -764,6 +811,36 @@
 	{0x0300, 2389, 0},	/* CFG_GPMC_AD7_IN */
 	{0x030C, 2672, 0},	/* CFG_GPMC_AD8_IN */
 	{0x0318, 2334, 0},	/* CFG_GPMC_AD9_IN */
+	{0x0378, 0, 0},	/* CFG_GPMC_CS3_IN */
+	{0x0678, 406, 0},	/* CFG_MMC3_CLK_IN */
+	{0x0680, 659, 0},	/* CFG_MMC3_CLK_OUT */
+	{0x0684, 0, 0},	/* CFG_MMC3_CMD_IN */
+	{0x0688, 0, 0},	/* CFG_MMC3_CMD_OEN */
+	{0x068C, 0, 0},	/* CFG_MMC3_CMD_OUT */
+	{0x0690, 130, 0},	/* CFG_MMC3_DAT0_IN */
+	{0x0694, 0, 0},	/* CFG_MMC3_DAT0_OEN */
+	{0x0698, 0, 0},	/* CFG_MMC3_DAT0_OUT */
+	{0x069C, 169, 0},	/* CFG_MMC3_DAT1_IN */
+	{0x06A0, 0, 0},	/* CFG_MMC3_DAT1_OEN */
+	{0x06A4, 0, 0},	/* CFG_MMC3_DAT1_OUT */
+	{0x06A8, 0, 0},	/* CFG_MMC3_DAT2_IN */
+	{0x06AC, 0, 0},	/* CFG_MMC3_DAT2_OEN */
+	{0x06B0, 0, 0},	/* CFG_MMC3_DAT2_OUT */
+	{0x06B4, 457, 0},	/* CFG_MMC3_DAT3_IN */
+	{0x06B8, 0, 0},	/* CFG_MMC3_DAT3_OEN */
+	{0x06BC, 0, 0},	/* CFG_MMC3_DAT3_OUT */
+	{0x06C0, 702, 0},	/* CFG_MMC3_DAT4_IN */
+	{0x06C4, 0, 0},	/* CFG_MMC3_DAT4_OEN */
+	{0x06C8, 0, 0},	/* CFG_MMC3_DAT4_OUT */
+	{0x06CC, 738, 0},	/* CFG_MMC3_DAT5_IN */
+	{0x06D0, 0, 0},	/* CFG_MMC3_DAT5_OEN */
+	{0x06D4, 0, 0},	/* CFG_MMC3_DAT5_OUT */
+	{0x06D8, 856, 0},	/* CFG_MMC3_DAT6_IN */
+	{0x06DC, 0, 0},	/* CFG_MMC3_DAT6_OEN */
+	{0x06E0, 0, 0},	/* CFG_MMC3_DAT6_OUT */
+	{0x06E4, 610, 0},	/* CFG_MMC3_DAT7_IN */
+	{0x06E8, 0, 0},	/* CFG_MMC3_DAT7_OEN */
+	{0x06EC, 0, 0},	/* CFG_MMC3_DAT7_OUT */
 	{0x06F0, 480, 0},	/* CFG_RGMII0_RXC_IN */
 	{0x06FC, 111, 1641},	/* CFG_RGMII0_RXCTL_IN */
 	{0x0708, 272, 1116},	/* CFG_RGMII0_RXD0_IN */
@@ -781,7 +858,7 @@
 	{0x0A88, 876, 0},	/* CFG_VIN2A_D14_OUT */
 	{0x0A94, 312, 0},	/* CFG_VIN2A_D15_OUT */
 	{0x0AA0, 58, 0},	/* CFG_VIN2A_D16_OUT */
-	{0x0AAC, 0, 0},		/* CFG_VIN2A_D17_OUT */
+	{0x0AAC, 0, 0},	/* CFG_VIN2A_D17_OUT */
 	{0x0AB0, 702, 0},	/* CFG_VIN2A_D18_IN */
 	{0x0ABC, 136, 976},	/* CFG_VIN2A_D19_IN */
 	{0x0AD4, 210, 1357},	/* CFG_VIN2A_D20_IN */
@@ -837,6 +914,18 @@
 	{0x06B4, 474, 0},	/* CFG_MMC3_DAT3_IN */
 	{0x06B8, 0, 0},	/* CFG_MMC3_DAT3_OEN */
 	{0x06BC, 0, 0},	/* CFG_MMC3_DAT3_OUT */
+	{0x06C0, 792, 0},	/* CFG_MMC3_DAT4_IN */
+	{0x06C4, 0, 0},	/* CFG_MMC3_DAT4_OEN */
+	{0x06C8, 0, 0},	/* CFG_MMC3_DAT4_OUT */
+	{0x06CC, 782, 0},	/* CFG_MMC3_DAT5_IN */
+	{0x06D0, 0, 0},	/* CFG_MMC3_DAT5_OEN */
+	{0x06D4, 0, 0},	/* CFG_MMC3_DAT5_OUT */
+	{0x06D8, 942, 0},	/* CFG_MMC3_DAT6_IN */
+	{0x06DC, 0, 0},	/* CFG_MMC3_DAT6_OEN */
+	{0x06E0, 0, 0},	/* CFG_MMC3_DAT6_OUT */
+	{0x06E4, 636, 0},	/* CFG_MMC3_DAT7_IN */
+	{0x06E8, 0, 0},	/* CFG_MMC3_DAT7_OEN */
+	{0x06EC, 0, 0},	/* CFG_MMC3_DAT7_OUT */
 	{0x06F0, 260, 0},	/* CFG_RGMII0_RXC_IN */
 	{0x06FC, 0, 1412},	/* CFG_RGMII0_RXCTL_IN */
 	{0x0708, 123, 1047},	/* CFG_RGMII0_RXD0_IN */
@@ -861,6 +950,34 @@
 	{0x0AE0, 192, 836},	/* CFG_VIN2A_D21_IN */
 	{0x0AEC, 294, 669},	/* CFG_VIN2A_D22_IN */
 	{0x0AF8, 50, 700},	/* CFG_VIN2A_D23_IN */
+	{0x0B9C, 0, 706},	/* CFG_VOUT1_CLK_OUT */
+	{0x0BA8, 2313, 0},	/* CFG_VOUT1_D0_OUT */
+	{0x0BB4, 2199, 0},	/* CFG_VOUT1_D10_OUT */
+	{0x0BC0, 2266, 0},	/* CFG_VOUT1_D11_OUT */
+	{0x0BCC, 3159, 0},	/* CFG_VOUT1_D12_OUT */
+	{0x0BD8, 2100, 0},	/* CFG_VOUT1_D13_OUT */
+	{0x0BE4, 2229, 0},	/* CFG_VOUT1_D14_OUT */
+	{0x0BF0, 2202, 0},	/* CFG_VOUT1_D15_OUT */
+	{0x0BFC, 2084, 0},	/* CFG_VOUT1_D16_OUT */
+	{0x0C08, 2195, 0},	/* CFG_VOUT1_D17_OUT */
+	{0x0C14, 2342, 0},	/* CFG_VOUT1_D18_OUT */
+	{0x0C20, 2463, 0},	/* CFG_VOUT1_D19_OUT */
+	{0x0C2C, 2439, 0},	/* CFG_VOUT1_D1_OUT */
+	{0x0C38, 2304, 0},	/* CFG_VOUT1_D20_OUT */
+	{0x0C44, 2103, 0},	/* CFG_VOUT1_D21_OUT */
+	{0x0C50, 2145, 0},	/* CFG_VOUT1_D22_OUT */
+	{0x0C5C, 1932, 0},	/* CFG_VOUT1_D23_OUT */
+	{0x0C68, 2200, 0},	/* CFG_VOUT1_D2_OUT */
+	{0x0C74, 2355, 0},	/* CFG_VOUT1_D3_OUT */
+	{0x0C80, 3215, 0},	/* CFG_VOUT1_D4_OUT */
+	{0x0C8C, 2314, 0},	/* CFG_VOUT1_D5_OUT */
+	{0x0C98, 2238, 0},	/* CFG_VOUT1_D6_OUT */
+	{0x0CA4, 2381, 0},	/* CFG_VOUT1_D7_OUT */
+	{0x0CB0, 2138, 0},	/* CFG_VOUT1_D8_OUT */
+	{0x0CBC, 2383, 0},	/* CFG_VOUT1_D9_OUT */
+	{0x0CC8, 1984, 0},	/* CFG_VOUT1_DE_OUT */
+	{0x0CE0, 1947, 0},	/* CFG_VOUT1_HSYNC_OUT */
+	{0x0CEC, 2739, 0},	/* CFG_VOUT1_VSYNC_OUT */
 };
 
 const struct iodelay_cfg_entry iodelay_cfg_array_am572x_idk[] = {
@@ -887,67 +1004,244 @@
 	{0x0374, 0, 0},	/* CFG_GPMC_CS2_OUT */
 	{0x0590, 1000, 4200},	/* CFG_MCASP5_ACLKX_OUT */
 	{0x05AC, 800, 3800},	/* CFG_MCASP5_FSX_IN */
-	{0x06F0, 471, 0},	/* CFG_RGMII0_RXC_IN */
-	{0x06FC, 30, 1919},	/* CFG_RGMII0_RXCTL_IN */
-	{0x0708, 74, 1688},	/* CFG_RGMII0_RXD0_IN */
-	{0x0714, 94, 1697},	/* CFG_RGMII0_RXD1_IN */
-	{0x0720, 0, 1703},	/* CFG_RGMII0_RXD2_IN */
-	{0x072C, 70, 1804},	/* CFG_RGMII0_RXD3_IN */
-	{0x0740, 90, 70},	/* CFG_RGMII0_TXC_OUT */
-	{0x074C, 70, 70},	/* CFG_RGMII0_TXCTL_OUT */
-	{0x0758, 180, 70},	/* CFG_RGMII0_TXD0_OUT */
-	{0x0764, 35, 70},	/* CFG_RGMII0_TXD1_OUT */
-	{0x0770, 0, 0},	/* CFG_RGMII0_TXD2_OUT */
-	{0x077C, 180, 70},	/* CFG_RGMII0_TXD3_OUT */
-	{0x0A70, 65, 70},	/* CFG_VIN2A_D12_OUT */
-	{0x0A7C, 125, 70},	/* CFG_VIN2A_D13_OUT */
-	{0x0A88, 0, 70},	/* CFG_VIN2A_D14_OUT */
-	{0x0A94, 0, 70},	/* CFG_VIN2A_D15_OUT */
-	{0x0AA0, 65, 70},	/* CFG_VIN2A_D16_OUT */
-	{0x0AAC, 0, 0},	/* CFG_VIN2A_D17_OUT */
-	{0x0AB0, 612, 0},	/* CFG_VIN2A_D18_IN */
-	{0x0ABC, 4, 927},	/* CFG_VIN2A_D19_IN */
-	{0x0AD4, 136, 1340},	/* CFG_VIN2A_D20_IN */
-	{0x0AE0, 130, 1450},	/* CFG_VIN2A_D21_IN */
-	{0x0AEC, 144, 1269},	/* CFG_VIN2A_D22_IN */
-	{0x0AF8, 0, 1330},	/* CFG_VIN2A_D23_IN */
+	{0x06F0, 260, 0},	/* CFG_RGMII0_RXC_IN */
+	{0x06FC, 0, 1412},	/* CFG_RGMII0_RXCTL_IN */
+	{0x0708, 123, 1047},	/* CFG_RGMII0_RXD0_IN */
+	{0x0714, 139, 1081},	/* CFG_RGMII0_RXD1_IN */
+	{0x0720, 195, 1100},	/* CFG_RGMII0_RXD2_IN */
+	{0x072C, 239, 1216},	/* CFG_RGMII0_RXD3_IN */
+	{0x0740, 89, 0},	/* CFG_RGMII0_TXC_OUT */
+	{0x074C, 15, 125},	/* CFG_RGMII0_TXCTL_OUT */
+	{0x0758, 339, 162},	/* CFG_RGMII0_TXD0_OUT */
+	{0x0764, 146, 94},	/* CFG_RGMII0_TXD1_OUT */
+	{0x0770, 0, 27},	/* CFG_RGMII0_TXD2_OUT */
+	{0x077C, 291, 205},	/* CFG_RGMII0_TXD3_OUT */
+	{0x0A70, 0, 0},	/* CFG_VIN2A_D12_OUT */
+	{0x0A7C, 219, 101},	/* CFG_VIN2A_D13_OUT */
+	{0x0A88, 92, 58},	/* CFG_VIN2A_D14_OUT */
+	{0x0A94, 135, 100},	/* CFG_VIN2A_D15_OUT */
+	{0x0AA0, 154, 101},	/* CFG_VIN2A_D16_OUT */
+	{0x0AAC, 78, 27},	/* CFG_VIN2A_D17_OUT */
+	{0x0AB0, 411, 0},	/* CFG_VIN2A_D18_IN */
+	{0x0ABC, 0, 382},	/* CFG_VIN2A_D19_IN */
+	{0x0AD4, 320, 750},	/* CFG_VIN2A_D20_IN */
+	{0x0AE0, 192, 836},	/* CFG_VIN2A_D21_IN */
+	{0x0AEC, 294, 669},	/* CFG_VIN2A_D22_IN */
+	{0x0AF8, 50, 700},	/* CFG_VIN2A_D23_IN */
 	{0x0B30, 0, 0},	/* CFG_VIN2A_D5_OUT */
+	{0x0B9C, 1126, 751},	/* CFG_VOUT1_CLK_OUT */
+	{0x0BA8, 395, 0},	/* CFG_VOUT1_D0_OUT */
+	{0x0BB4, 282, 0},	/* CFG_VOUT1_D10_OUT */
+	{0x0BC0, 348, 0},	/* CFG_VOUT1_D11_OUT */
+	{0x0BCC, 1240, 0},	/* CFG_VOUT1_D12_OUT */
+	{0x0BD8, 182, 0},	/* CFG_VOUT1_D13_OUT */
+	{0x0BE4, 311, 0},	/* CFG_VOUT1_D14_OUT */
+	{0x0BF0, 285, 0},	/* CFG_VOUT1_D15_OUT */
+	{0x0BFC, 166, 0},	/* CFG_VOUT1_D16_OUT */
+	{0x0C08, 278, 0},	/* CFG_VOUT1_D17_OUT */
+	{0x0C14, 425, 0},	/* CFG_VOUT1_D18_OUT */
+	{0x0C20, 516, 0},	/* CFG_VOUT1_D19_OUT */
+	{0x0C2C, 521, 0},	/* CFG_VOUT1_D1_OUT */
+	{0x0C38, 386, 0},	/* CFG_VOUT1_D20_OUT */
+	{0x0C44, 111, 0},	/* CFG_VOUT1_D21_OUT */
+	{0x0C50, 227, 0},	/* CFG_VOUT1_D22_OUT */
+	{0x0C5C, 0, 0},	/* CFG_VOUT1_D23_OUT */
+	{0x0C68, 282, 0},	/* CFG_VOUT1_D2_OUT */
+	{0x0C74, 438, 0},	/* CFG_VOUT1_D3_OUT */
+	{0x0C80, 1298, 0},	/* CFG_VOUT1_D4_OUT */
+	{0x0C8C, 397, 0},	/* CFG_VOUT1_D5_OUT */
+	{0x0C98, 321, 0},	/* CFG_VOUT1_D6_OUT */
+	{0x0CA4, 155, 309},	/* CFG_VOUT1_D7_OUT */
+	{0x0CB0, 212, 0},	/* CFG_VOUT1_D8_OUT */
+	{0x0CBC, 466, 0},	/* CFG_VOUT1_D9_OUT */
+	{0x0CC8, 0, 0},	/* CFG_VOUT1_DE_OUT */
+	{0x0CE0, 0, 0},	/* CFG_VOUT1_HSYNC_OUT */
+	{0x0CEC, 139, 701},	/* CFG_VOUT1_VSYNC_OUT */
 };
 
 const struct iodelay_cfg_entry iodelay_cfg_array_am571x_idk[] = {
-	{0x0144, 0, 0},		/* CFG_GPMC_A13_IN */
-	{0x0150, 2062, 2277},	/* CFG_GPMC_A14_IN */
-	{0x015C, 1960, 2289},	/* CFG_GPMC_A15_IN */
-	{0x0168, 2058, 2386},	/* CFG_GPMC_A16_IN */
-	{0x0170, 0, 0},		/* CFG_GPMC_A16_OUT */
-	{0x0174, 2062, 2350},	/* CFG_GPMC_A17_IN */
-	{0x0188, 0, 0},		/* CFG_GPMC_A18_OUT */
-	{0x0374, 121, 0},       /* CFG_GPMC_CS2_OUT */
-	{0x06F0, 413, 0},       /* CFG_RGMII0_RXC_IN */
-	{0x06FC, 27, 2296},     /* CFG_RGMII0_RXCTL_IN */
-	{0x0708, 3, 1721},      /* CFG_RGMII0_RXD0_IN */
-	{0x0714, 134, 1786},    /* CFG_RGMII0_RXD1_IN */
-	{0x0720, 40, 1966},     /* CFG_RGMII0_RXD2_IN */
-	{0x072C, 0, 2057},      /* CFG_RGMII0_RXD3_IN */
-	{0x0740, 0, 60},        /* CFG_RGMII0_TXC_OUT */
-	{0x074C, 0, 60},        /* CFG_RGMII0_TXCTL_OUT */
-	{0x0758, 0, 60},        /* CFG_RGMII0_TXD0_OUT */
-	{0x0764, 0, 0},         /* CFG_RGMII0_TXD1_OUT */
-	{0x0770, 0, 60},        /* CFG_RGMII0_TXD2_OUT */
-	{0x077C, 0, 120},       /* CFG_RGMII0_TXD3_OUT */
-	{0x0A70, 0, 0},         /* CFG_VIN2A_D12_OUT */
-	{0x0A7C, 170, 0},       /* CFG_VIN2A_D13_OUT */
-	{0x0A88, 150, 0},       /* CFG_VIN2A_D14_OUT */
-	{0x0A94, 0, 0},         /* CFG_VIN2A_D15_OUT */
-	{0x0AA0, 60, 0},        /* CFG_VIN2A_D16_OUT */
-	{0x0AAC, 60, 0},        /* CFG_VIN2A_D17_OUT */
-	{0x0AB0, 530, 0},       /* CFG_VIN2A_D18_IN */
-	{0x0ABC, 71, 1099},     /* CFG_VIN2A_D19_IN */
-	{0x0AC8, 2229, 10},     /* CFG_VIN2A_D1_IN */
-	{0x0AD4, 142, 1337},    /* CFG_VIN2A_D20_IN */
-	{0x0AE0, 114, 1517},    /* CFG_VIN2A_D21_IN */
-	{0x0AEC, 171, 1331},    /* CFG_VIN2A_D22_IN */
-	{0x0AF8, 0, 1328},      /* CFG_VIN2A_D23_IN */
+	{0x0114, 1873, 702},	/* CFG_GPMC_A0_IN */
+	{0x0120, 0, 0},	/* CFG_GPMC_A10_IN */
+	{0x012C, 1851, 1011},	/* CFG_GPMC_A11_IN */
+	{0x0138, 2009, 601},	/* CFG_GPMC_A12_IN */
+	{0x0144, 0, 0},	/* CFG_GPMC_A13_IN */
+	{0x0150, 2247, 1186},	/* CFG_GPMC_A14_IN */
+	{0x015C, 2176, 1197},	/* CFG_GPMC_A15_IN */
+	{0x0168, 2229, 1268},	/* CFG_GPMC_A16_IN */
+	{0x0170, 0, 0},	/* CFG_GPMC_A16_OUT */
+	{0x0174, 2251, 1217},	/* CFG_GPMC_A17_IN */
+	{0x0188, 0, 0},	/* CFG_GPMC_A18_OUT */
+	{0x0198, 1629, 772},	/* CFG_GPMC_A1_IN */
+	{0x0204, 1734, 898},	/* CFG_GPMC_A2_IN */
+	{0x0210, 1757, 1076},	/* CFG_GPMC_A3_IN */
+	{0x021C, 1794, 893},	/* CFG_GPMC_A4_IN */
+	{0x0228, 1726, 853},	/* CFG_GPMC_A5_IN */
+	{0x0234, 1792, 612},	/* CFG_GPMC_A6_IN */
+	{0x0240, 2117, 610},	/* CFG_GPMC_A7_IN */
+	{0x024C, 1758, 653},	/* CFG_GPMC_A8_IN */
+	{0x0258, 1705, 899},	/* CFG_GPMC_A9_IN */
+	{0x0374, 0, 0},	/* CFG_GPMC_CS2_OUT */
+	{0x06F0, 413, 0},	/* CFG_RGMII0_RXC_IN */
+	{0x06FC, 27, 2296},	/* CFG_RGMII0_RXCTL_IN */
+	{0x0708, 3, 1721},	/* CFG_RGMII0_RXD0_IN */
+	{0x0714, 134, 1786},	/* CFG_RGMII0_RXD1_IN */
+	{0x0720, 40, 1966},	/* CFG_RGMII0_RXD2_IN */
+	{0x072C, 0, 2057},	/* CFG_RGMII0_RXD3_IN */
+	{0x0740, 0, 60},	/* CFG_RGMII0_TXC_OUT */
+	{0x074C, 0, 60},	/* CFG_RGMII0_TXCTL_OUT */
+	{0x0758, 0, 60},	/* CFG_RGMII0_TXD0_OUT */
+	{0x0764, 0, 0},	/* CFG_RGMII0_TXD1_OUT */
+	{0x0770, 0, 60},	/* CFG_RGMII0_TXD2_OUT */
+	{0x077C, 0, 120},	/* CFG_RGMII0_TXD3_OUT */
+	{0x0A70, 0, 0},	/* CFG_VIN2A_D12_OUT */
+	{0x0A7C, 170, 0},	/* CFG_VIN2A_D13_OUT */
+	{0x0A88, 150, 0},	/* CFG_VIN2A_D14_OUT */
+	{0x0A94, 0, 0},	/* CFG_VIN2A_D15_OUT */
+	{0x0AA0, 60, 0},	/* CFG_VIN2A_D16_OUT */
+	{0x0AAC, 60, 0},	/* CFG_VIN2A_D17_OUT */
+	{0x0AB0, 530, 0},	/* CFG_VIN2A_D18_IN */
+	{0x0ABC, 71, 1099},	/* CFG_VIN2A_D19_IN */
+	{0x0AD4, 142, 1337},	/* CFG_VIN2A_D20_IN */
+	{0x0AE0, 114, 1517},	/* CFG_VIN2A_D21_IN */
+	{0x0AEC, 171, 1331},	/* CFG_VIN2A_D22_IN */
+	{0x0AF8, 0, 1328},	/* CFG_VIN2A_D23_IN */
+};
+
+const struct iodelay_cfg_entry iodelay_cfg_array_am571x_idk_4port[] = {
+	{0x0588, 2100, 1959},	/* CFG_MCASP5_ACLKX_IN */
+	{0x05AC, 2100, 1780},	/* CFG_MCASP5_FSX_IN */
+	{0x0B30, 0, 400},	/* CFG_VIN2A_D5_OUT */
+};
+#endif
+
+#if defined(CONFIG_IODELAY_RECALIBRATION) && \
+	(defined(CONFIG_SPL_BUILD) || !defined(CONFIG_DM_MMC))
+
+static struct iodelay_cfg_entry mmc2_iodelay_ddr_am572[] = {
+	{0x18c, 270, 0	/* CFG_GPMC_A19_IN */},
+	{0x1a4, 0, 0	/* CFG_GPMC_A20_IN */},
+	{0x1b0, 170, 0	/* CFG_GPMC_A21_IN */},
+	{0x1bc, 758, 0	/* CFG_GPMC_A22_IN */},
+	{0x1c8, 0, 0	/* CFG_GPMC_A23_IN */},
+	{0x1d4, 81, 0	/* CFG_GPMC_A24_IN */},
+	{0x1e0, 286, 0	/* CFG_GPMC_A25_IN */},
+	{0x1ec, 0, 0	/* CFG_GPMC_A26_IN */},
+	{0x1f8, 123, 0	/* CFG_GPMC_A27_IN */},
+	{0x360, 346, 0	/* CFG_GPMC_CS1_IN */},
+	{0x190, 0, 0	/* CFG_GPMC_A19_OEN */},
+	{0x194, 55, 0	/* CFG_GPMC_A19_OUT */},
+	{0x1a8, 0, 0	/* CFG_GPMC_A20_OEN */},
+	{0x1ac, 422, 0	/* CFG_GPMC_A20_OUT */},
+	{0x1b4, 642, 0	/* CFG_GPMC_A21_OEN */},
+	{0x1b8, 0, 0	/* CFG_GPMC_A21_OUT */},
+	{0x1c0, 0, 0	/* CFG_GPMC_A22_OEN */},
+	{0x1c4, 128, 0	/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 0, 0	/* CFG_GPMC_A23_OUT */},
+	{0x1d8, 0, 0	/* CFG_GPMC_A24_OEN */},
+	{0x1dc, 395, 0	/* CFG_GPMC_A24_OUT */},
+	{0x1e4, 0, 0	/* CFG_GPMC_A25_OEN */},
+	{0x1e8, 0, 0	/* CFG_GPMC_A25_OUT */},
+	{0x1f0, 623, 0	/* CFG_GPMC_A26_OEN */},
+	{0x1f4, 0, 0	/* CFG_GPMC_A26_OUT */},
+	{0x1fc, 54, 0	/* CFG_GPMC_A27_OEN */},
+	{0x200, 0, 0	/* CFG_GPMC_A27_OUT */},
+	{0x364, 0, 0	/* CFG_GPMC_CS1_OEN */},
+	{0x368, 0, 0	/* CFG_GPMC_CS1_OUT */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_ddr_am571[] = {
+	{0x18c, 0, 0,	/* CFG_GPMC_A19_IN */},
+	{0x1a4, 121, 0,	/* CFG_GPMC_A20_IN */},
+	{0x1b0, 0, 0,	/* CFG_GPMC_A21_IN */},
+	{0x1bc, 20, 0,	/* CFG_GPMC_A22_IN */},
+	{0x1c8, 108, 0,	/* CFG_GPMC_A23_IN */},
+	{0x1d4, 31, 0,	/* CFG_GPMC_A24_IN */},
+	{0x1e0, 0, 0,	/* CFG_GPMC_A25_IN */},
+	{0x1ec, 24, 0,	/* CFG_GPMC_A26_IN */},
+	{0x1f8, 0, 0,	/* CFG_GPMC_A27_IN */},
+	{0x360, 0, 0,	/* CFG_GPMC_CS1_IN */},
+	{0x194, 152, 0,	/* CFG_GPMC_A19_OUT */},
+	{0x1ac, 206, 0,	/* CFG_GPMC_A20_OUT */},
+	{0x1b8, 78, 0,	/* CFG_GPMC_A21_OUT */},
+	{0x1c4, 2, 0,	/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 266, 0,	/* CFG_GPMC_A23_OUT */},
+	{0x1dc, 0, 0,	/* CFG_GPMC_A24_OUT */},
+	{0x1e8, 0, 0,	/* CFG_GPMC_A25_OUT */},
+	{0x1f4, 43, 0,	/* CFG_GPMC_A26_OUT */},
+	{0x200, 0, 0,	/* CFG_GPMC_A27_OUT */},
+	{0x368, 0, 0,	/* CFG_GPMC_CS1_OUT */},
+	{0x190, 0, 0,	/* CFG_GPMC_A19_OEN */},
+	{0x1a8, 0, 0,	/* CFG_GPMC_A20_OEN */},
+	{0x1b4, 0, 0,	/* CFG_GPMC_A21_OEN */},
+	{0x1c0, 0, 0,	/* CFG_GPMC_A22_OEN */},
+	{0x1d8, 0, 0,	/* CFG_GPMC_A24_OEN */},
+	{0x1e4, 0, 0,	/* CFG_GPMC_A25_OEN */},
+	{0x1f0, 0, 0,	/* CFG_GPMC_A26_OEN */},
+	{0x1fc, 0, 0,	/* CFG_GPMC_A27_OEN */},
+	{0x364, 0, 0,	/* CFG_GPMC_CS1_OEN */},
+};
+
+static struct pad_conf_entry hsmmc1_default_padconf[] = {
+	{MMC1_CLK,  (M0 | PIN_INPUT_PULLUP) /* mmc1_clk.clk */},
+	{MMC1_CMD,  (M0 | PIN_INPUT_PULLUP) /* mmc1_cmd.cmd */},
+	{MMC1_DAT0, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat0.dat0 */},
+	{MMC1_DAT1, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat1.dat1 */},
+	{MMC1_DAT2, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat2.dat2 */},
+	{MMC1_DAT3, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat3.dat3 */},
+};
+
+static struct pad_conf_entry mmc2_pins_ddr[] = {
+	{GPMC_A23, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a23.mmc2_clk */},
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_cs1.mmc2_cmd */},
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a24.mmc2_dat0 */},
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a25.mmc2_dat1 */},
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a26.mmc2_dat2 */},
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a27.mmc2_dat3 */},
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a19.mmc2_dat4 */},
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a20.mmc2_dat5 */},
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a21.mmc2_dat6 */},
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a22.mmc2_dat7 */},
+};
+
+static struct pad_conf_entry mmc2_pins_default_hs[] = {
+	{GPMC_A23, (M1 | PIN_INPUT_PULLUP) /* g pmc_a23.mmc2_clk */},
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP) /* gpmc_cs1.mmc2_cmd */},
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP) /* gpmc_a24.mmc2_dat0 */},
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP) /* gpmc_a25.mmc2_dat1 */},
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP) /* gpmc_a26.mmc2_dat2 */},
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP) /* gpmc_a27.mmc2_dat3 */},
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP) /* gpmc_a19.mmc2_dat4 */},
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP) /* gpmc_a20.mmc2_dat5 */},
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP) /* gpmc_a21.mmc2_dat6 */},
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP) /* gpmc_a22.mmc2_dat7 */},
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc1_default = {
+	.padconf = hsmmc1_default_padconf,
+	.npads = ARRAY_SIZE(hsmmc1_default_padconf),
+	.iodelay = NULL,
+	.niodelays = 0,
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_default_hs = {
+	.padconf = mmc2_pins_default_hs,
+	.npads = ARRAY_SIZE(mmc2_pins_default_hs),
+	.iodelay = NULL,
+	.niodelays = 0,
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_ddr_am572 = {
+	.padconf = mmc2_pins_ddr,
+	.npads = ARRAY_SIZE(mmc2_pins_ddr),
+	.iodelay = mmc2_iodelay_ddr_am572,
+	.niodelays = ARRAY_SIZE(mmc2_iodelay_ddr_am572),
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_ddr_am571 = {
+	.padconf = mmc2_pins_ddr,
+	.npads = ARRAY_SIZE(mmc2_pins_ddr),
+	.iodelay = mmc2_iodelay_ddr_am571,
+	.niodelays = ARRAY_SIZE(mmc2_iodelay_ddr_am571),
 };
 
 #endif
diff -u -N U-Boot_SDcard/common/Makefile U-Boot_SDcard/common/Makefile
--- U-Boot_SDcard/common/Makefile	2019-09-12 15:54:50.000000638 -0500
+++ U-Boot_SDcard/common/Makefile	1969-12-31 19:29:17.000000451 -0600
@@ -1,181 +1,182 @@
-#
-# (C) Copyright 2004-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-# core
-ifndef CONFIG_SPL_BUILD
-obj-y += init/
-obj-y += main.o
-obj-y += exports.o
-obj-y += hash.o
-obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
-obj-$(CONFIG_AUTOBOOT) += autoboot.o
-
-# This option is not just y/n - it can have a numeric value
-ifdef CONFIG_BOOT_RETRY_TIME
-obj-y += bootretry.o
-endif
-
-# boards
-obj-y += board_f.o
-obj-y += board_r.o
-obj-$(CONFIG_DISPLAY_BOARDINFO) += board_info.o
-obj-$(CONFIG_DISPLAY_BOARDINFO_LATE) += board_info.o
-
-obj-$(CONFIG_CMD_BOOTM) += bootm.o bootm_os.o
-obj-$(CONFIG_CMD_BOOTZ) += bootm.o bootm_os.o
-obj-$(CONFIG_CMD_BOOTI) += bootm.o bootm_os.o
-
-# environment
-obj-y += env_attr.o
-obj-y += env_callback.o
-obj-y += env_flags.o
-obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
-obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
-extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
-obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o
-extra-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o
-obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o
-obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
-obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o
-obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
-obj-$(CONFIG_ENV_IS_IN_EXT4) += env_ext4.o
-obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
-obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
-obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
-obj-$(CONFIG_ENV_IS_IN_SATA) += env_sata.o
-obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
-obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
-obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
-obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
-
-obj-$(CONFIG_CMD_BEDBUG) += bedbug.o
-obj-$(CONFIG_$(SPL_)OF_LIBFDT) += fdt_support.o
-
-obj-$(CONFIG_MII) += miiphyutil.o
-obj-$(CONFIG_CMD_MII) += miiphyutil.o
-obj-$(CONFIG_PHYLIB) += miiphyutil.o
-
-ifdef CONFIG_CMD_USB
-obj-y += usb.o usb_hub.o
-obj-$(CONFIG_USB_STORAGE) += usb_storage.o
-endif
-
-# others
-obj-$(CONFIG_BOOTSTAGE) += bootstage.o
-obj-$(CONFIG_CONSOLE_MUX) += iomux.o
-obj-y += flash.o
-obj-$(CONFIG_CMD_KGDB) += kgdb.o kgdb_stubs.o
-obj-$(CONFIG_I2C_EDID) += edid.o
-obj-$(CONFIG_KALLSYMS) += kallsyms.o
-obj-y += splash.o
-obj-$(CONFIG_SPLASH_SOURCE) += splash_source.o
-ifndef CONFIG_DM_VIDEO
-obj-$(CONFIG_LCD) += lcd.o lcd_console.o
-endif
-obj-$(CONFIG_LCD_ROTATION) += lcd_console_rotation.o
-obj-$(CONFIG_LCD_DT_SIMPLEFB) += lcd_simplefb.o
-obj-$(CONFIG_LYNXKDI) += lynxkdi.o
-obj-$(CONFIG_MENU) += menu.o
-obj-$(CONFIG_CMD_SATA) += sata.o
-obj-$(CONFIG_SCSI) += scsi.o
-obj-$(CONFIG_UPDATE_TFTP) += update.o
-obj-$(CONFIG_DFU_TFTP) += update.o
-obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
-
-endif # !CONFIG_SPL_BUILD
-
-ifdef CONFIG_SPL_BUILD
-obj-$(CONFIG_SPL_DFU_SUPPORT) += dfu.o
-obj-$(CONFIG_SPL_DFU_SUPPORT) += cli_hush.o
-obj-$(CONFIG_SPL_HASH_SUPPORT) += hash.o
-obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
-obj-$(CONFIG_SPL_YMODEM_SUPPORT) += xyzModem.o
-obj-$(CONFIG_SPL_NET_SUPPORT) += miiphyutil.o
-obj-$(CONFIG_SPL_OF_TRANSLATE) += fdt_support.o
-ifdef CONFIG_SPL_USB_HOST_SUPPORT
-obj-$(CONFIG_SPL_USB_SUPPORT) += usb.o usb_hub.o
-obj-$(CONFIG_USB_STORAGE) += usb_storage.o
-endif
-# environment
-ifdef CONFIG_TPL_BUILD
-obj-$(CONFIG_TPL_ENV_SUPPORT) += env_attr.o
-obj-$(CONFIG_TPL_ENV_SUPPORT) += env_flags.o
-obj-$(CONFIG_TPL_ENV_SUPPORT) += env_callback.o
-else
-obj-$(CONFIG_SPL_ENV_SUPPORT) += env_attr.o
-obj-$(CONFIG_SPL_ENV_SUPPORT) += env_flags.o
-obj-$(CONFIG_SPL_ENV_SUPPORT) += env_callback.o
-endif
-ifneq ($(CONFIG_TPL_ENV_SUPPORT)$(CONFIG_SPL_ENV_SUPPORT),)
-obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
-obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o
-obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
-obj-$(CONFIG_ENV_IS_IN_EXT4) += env_ext4.o
-obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
-obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
-obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
-endif
-ifdef CONFIG_SPL_SATA_SUPPORT
-obj-$(CONFIG_SCSI) += scsi.o
-endif
-endif
-#environment
-obj-y += env_common.o
-#others
-obj-$(CONFIG_DDR_SPD) += ddr_spd.o
-obj-$(CONFIG_SPD_EEPROM) += ddr_spd.o
-obj-$(CONFIG_HWCONFIG) += hwconfig.o
-obj-$(CONFIG_BOUNCE_BUFFER) += bouncebuf.o
-ifdef CONFIG_SPL_BUILD
-ifdef CONFIG_TPL_BUILD
-obj-$(CONFIG_TPL_SERIAL_SUPPORT) += console.o
-else
-obj-$(CONFIG_SPL_SERIAL_SUPPORT) += console.o
-endif
-else
-obj-y += console.o
-endif
-obj-$(CONFIG_CROS_EC) += cros_ec.o
-obj-y += dlmalloc.o
-ifdef CONFIG_SYS_MALLOC_F_LEN
-obj-y += malloc_simple.o
-endif
-obj-$(CONFIG_CMD_IDE) += ide.o
-obj-y += image.o
-obj-$(CONFIG_ANDROID_BOOT_IMAGE) += image-android.o
-obj-$(CONFIG_$(SPL_)OF_LIBFDT) += image-fdt.o
-obj-$(CONFIG_$(SPL_)FIT) += image-fit.o
-obj-$(CONFIG_$(SPL_)FIT_SIGNATURE) += image-sig.o
-obj-$(CONFIG_IO_TRACE) += iotrace.o
-obj-y += memsize.o
-obj-y += stdio.o
-
-# This option is not just y/n - it can have a numeric value
-ifdef CONFIG_FASTBOOT_FLASH
-obj-y += image-sparse.o
-ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
-obj-y += fb_mmc.o
-endif
-ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
-obj-y += fb_nand.o
-endif
-endif
-
-ifdef CONFIG_CMD_EEPROM_LAYOUT
-obj-y += eeprom/eeprom_field.o eeprom/eeprom_layout.o
-endif
-# We always have this since drivers/ddr/fs/interactive.c needs it
-obj-$(CONFIG_CMDLINE) += cli_simple.o
-
-obj-y += cli.o
-obj-$(CONFIG_CMDLINE) += cli_readline.o
-obj-$(CONFIG_CMD_DFU) += dfu.o
-obj-y += command.o
-obj-y += s_record.o
-obj-y += xyzModem.o
-
-CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
+#
+# (C) Copyright 2004-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+# core
+ifndef CONFIG_SPL_BUILD
+obj-y += init/
+obj-y += main.o
+obj-y += exports.o
+obj-y += hash.o
+obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
+obj-$(CONFIG_AUTOBOOT) += autoboot.o
+
+# This option is not just y/n - it can have a numeric value
+ifdef CONFIG_BOOT_RETRY_TIME
+obj-y += bootretry.o
+endif
+
+# boards
+obj-y += board_f.o
+obj-y += board_r.o
+obj-$(CONFIG_DISPLAY_BOARDINFO) += board_info.o
+obj-$(CONFIG_DISPLAY_BOARDINFO_LATE) += board_info.o
+
+obj-$(CONFIG_CMD_BOOTM) += bootm.o bootm_os.o
+obj-$(CONFIG_CMD_BOOTZ) += bootm.o bootm_os.o
+obj-$(CONFIG_CMD_BOOTI) += bootm.o bootm_os.o
+
+# environment
+obj-y += env_attr.o
+obj-y += env_callback.o
+obj-y += env_flags.o
+obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
+obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
+extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
+obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o
+extra-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o
+obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o
+obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
+obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o
+obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
+obj-$(CONFIG_ENV_IS_IN_EXT4) += env_ext4.o
+obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
+obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
+obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
+obj-$(CONFIG_ENV_IS_IN_SATA) += env_sata.o
+obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
+obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
+obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
+obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
+
+obj-$(CONFIG_CMD_BEDBUG) += bedbug.o
+obj-$(CONFIG_$(SPL_)OF_LIBFDT) += fdt_support.o
+
+obj-$(CONFIG_MII) += miiphyutil.o
+obj-$(CONFIG_CMD_MII) += miiphyutil.o
+obj-$(CONFIG_PHYLIB) += miiphyutil.o
+
+ifdef CONFIG_CMD_USB
+obj-y += usb.o usb_hub.o
+obj-$(CONFIG_USB_STORAGE) += usb_storage.o
+endif
+
+# others
+obj-$(CONFIG_BOOTSTAGE) += bootstage.o
+obj-$(CONFIG_CONSOLE_MUX) += iomux.o
+obj-y += flash.o
+obj-$(CONFIG_CMD_KGDB) += kgdb.o kgdb_stubs.o
+obj-$(CONFIG_I2C_EDID) += edid.o
+obj-$(CONFIG_KALLSYMS) += kallsyms.o
+obj-y += splash.o
+obj-$(CONFIG_SPLASH_SOURCE) += splash_source.o
+ifndef CONFIG_DM_VIDEO
+obj-$(CONFIG_LCD) += lcd.o lcd_console.o
+endif
+obj-$(CONFIG_LCD_ROTATION) += lcd_console_rotation.o
+obj-$(CONFIG_LCD_DT_SIMPLEFB) += lcd_simplefb.o
+obj-$(CONFIG_LYNXKDI) += lynxkdi.o
+obj-$(CONFIG_MENU) += menu.o
+obj-$(CONFIG_CMD_SATA) += sata.o
+obj-$(CONFIG_SCSI) += scsi.o
+obj-$(CONFIG_UPDATE_TFTP) += update.o
+obj-$(CONFIG_DFU_TFTP) += update.o
+obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
+
+endif # !CONFIG_SPL_BUILD
+
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_SPL_DFU_SUPPORT) += dfu.o
+obj-$(CONFIG_SPL_HASH_SUPPORT) += hash.o
+obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
+obj-$(CONFIG_SPL_YMODEM_SUPPORT) += xyzModem.o
+obj-$(CONFIG_SPL_LOAD_FIT) += common_fit.o
+obj-$(CONFIG_SPL_NET_SUPPORT) += miiphyutil.o
+obj-$(CONFIG_SPL_OF_LIBFDT) += fdt_support.o
+ifdef CONFIG_SPL_USB_HOST_SUPPORT
+obj-$(CONFIG_SPL_USB_SUPPORT) += usb.o usb_hub.o
+obj-$(CONFIG_USB_STORAGE) += usb_storage.o
+endif
+# environment
+ifdef CONFIG_TPL_BUILD
+obj-$(CONFIG_TPL_ENV_SUPPORT) += env_attr.o
+obj-$(CONFIG_TPL_ENV_SUPPORT) += env_flags.o
+obj-$(CONFIG_TPL_ENV_SUPPORT) += env_callback.o
+else
+obj-$(CONFIG_SPL_ENV_SUPPORT) += env_attr.o
+obj-$(CONFIG_SPL_ENV_SUPPORT) += env_flags.o
+obj-$(CONFIG_SPL_ENV_SUPPORT) += env_callback.o
+endif
+ifneq ($(CONFIG_TPL_ENV_SUPPORT)$(CONFIG_SPL_ENV_SUPPORT),)
+obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
+obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o
+obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
+obj-$(CONFIG_ENV_IS_IN_EXT4) += env_ext4.o
+obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
+obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
+obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
+endif
+ifdef CONFIG_SPL_SATA_SUPPORT
+obj-$(CONFIG_SCSI) += scsi.o
+endif
+endif
+#environment
+obj-y += env_common.o
+#others
+obj-$(CONFIG_DDR_SPD) += ddr_spd.o
+obj-$(CONFIG_SPD_EEPROM) += ddr_spd.o
+obj-$(CONFIG_HWCONFIG) += hwconfig.o
+obj-$(CONFIG_BOUNCE_BUFFER) += bouncebuf.o
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_TPL_BUILD
+obj-$(CONFIG_TPL_SERIAL_SUPPORT) += console.o
+else
+obj-$(CONFIG_SPL_SERIAL_SUPPORT) += console.o
+endif
+else
+obj-y += console.o
+endif
+obj-$(CONFIG_CROS_EC) += cros_ec.o
+obj-y += dlmalloc.o
+ifdef CONFIG_SYS_MALLOC_F_LEN
+obj-y += malloc_simple.o
+endif
+obj-$(CONFIG_CMD_IDE) += ide.o
+obj-y += image.o
+obj-$(CONFIG_ANDROID_BOOT_IMAGE) += image-android.o
+obj-$(CONFIG_$(SPL_)OF_LIBFDT) += image-fdt.o
+obj-$(CONFIG_$(SPL_)FIT) += image-fit.o
+obj-$(CONFIG_FIT_EMBED) += boot_fit.o common_fit.o
+obj-$(CONFIG_$(SPL_)FIT_SIGNATURE) += image-sig.o
+obj-$(CONFIG_IO_TRACE) += iotrace.o
+obj-y += memsize.o
+obj-y += stdio.o
+
+# This option is not just y/n - it can have a numeric value
+ifdef CONFIG_FASTBOOT_FLASH
+obj-y += image-sparse.o
+ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
+obj-y += fb_mmc.o
+endif
+ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
+obj-y += fb_nand.o
+endif
+endif
+
+ifdef CONFIG_CMD_EEPROM_LAYOUT
+obj-y += eeprom/eeprom_field.o eeprom/eeprom_layout.o
+endif
+# We always have this since drivers/ddr/fs/interactive.c needs it
+obj-$(CONFIG_CMDLINE) += cli_simple.o
+
+obj-y += cli.o
+obj-$(CONFIG_CMDLINE) += cli_readline.o
+obj-$(CONFIG_CMD_DFU) += dfu.o
+obj-y += command.o
+obj-y += s_record.o
+obj-y += xyzModem.o
+
+CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2g-evm.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2g-evm.dts	1969-12-31 19:31:37.000000934 -0600
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Galileo EVM device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone-k2g.dtsi"
+
+/ {
+	compatible =  "ti,k2g-evm","ti,keystone";
+	model = "Texas Instruments Keystone 2 Galileo EVM";
+
+	chosen {
+		stdout-path = &uart0;
+	};
+};
+
+&mdio {
+	status = "okay";
+	ethphy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&gbe0 {
+	phy-handle = <&ethphy0>;
+};
+
+&netcp {
+	status = "okay";
+};
+
+&spi1 {
+	status = "okay";
+
+	spi_nor: flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <50000000>;
+		m25p,fast-read;
+		reg = <0>;
+
+		partition@0 {
+			label = "u-boot-spl";
+			reg = <0x0 0x80000>;
+			read-only;
+		};
+
+		partition@1 {
+			label = "misc";
+			reg = <0x80000 0xf80000>;
+		};
+	};
+};
+
+&qspi {
+	status = "okay";
+
+        flash0: m25p80@0 {
+                compatible = "s25fl512s","spi-flash";
+                reg = <0>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <4>;
+                spi-max-frequency = <96000000>;
+                #address-cells = <1>;
+                #size-cells = <1>;
+                tshsl-ns = <392>;
+                tsd2d-ns = <392>;
+                tchsh-ns = <100>;
+                tslch-ns = <100>;
+		block-size = <18>;
+
+
+                partition@0 {
+                        label = "QSPI.u-boot-spl-os";
+                        reg = <0x00000000 0x00100000>;
+                };
+                partition@1 {
+                        label = "QSPI.u-boot-env";
+                        reg = <0x00100000 0x00040000>;
+                };
+                partition@2 {
+                        label = "QSPI.skern";
+                        reg = <0x00140000 0x0040000>;
+                };
+                partition@3 {
+                        label = "QSPI.pmmc-firmware";
+                        reg = <0x00180000 0x0040000>;
+                };
+                partition@4 {
+                        label = "QSPI.kernel";
+                        reg = <0x001C0000 0x0800000>;
+                };
+                partition@5 {
+                        label = "QSPI.file-system";
+                        reg = <0x009C0000 0x3640000>;
+                };
+        };
+};
+
+&mmc0 {
+	status = "okay";
+};
+
+&mmc1 {
+	status = "okay";
+};
+
+&gpmc {
+	status = "okay";
+	ranges = <0 0 0x30000000 0x01000000>;	/* CS0 space. Min partition = 16MB */
+	nand@0,0 {
+		compatible = "ti,omap2-nand";
+		reg = <0 0 4>;			/* CS0, I/O window 4 bytes */
+		interrupts = <GIC_SPI 196 IRQ_TYPE_EDGE_RISING>;
+		ti,nand-ecc-opt = "bch16";
+		ti,elm-id = <&elm>;
+		nand-bus-width = <16>;
+		gpmc,device-width = <2>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <40>;
+		gpmc,cs-wr-off-ns = <40>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <25>;
+		gpmc,adv-wr-off-ns = <25>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <20>;
+		gpmc,oe-on-ns = <3>;
+		gpmc,oe-off-ns = <30>;
+		gpmc,access-ns = <30>;
+		gpmc,rd-cycle-ns = <40>;
+		gpmc,wr-cycle-ns = <40>;
+		gpmc,wait-pin = <0>;
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		/* MTD partition table */
+		/* All SPL-* partitions are sized to minimal length
+		 * which can be independently programmable. For
+		 * NAND flash this is equal to size of erase-block
+		 */
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		nand-on-flash-bbt;
+		/* MT29F2G16ABAFAWP - 256MB */
+		partition@0 {
+			label = "u-boot";
+			reg = <0x0 0x100000>;
+			read-only;
+		};
+		partition@100000 {
+			label = "params";
+			reg = <0x100000 0x80000>;
+		};
+
+		partition@180000 {
+			label = "ubifs";
+			reg = <0x180000 0xfe80000>;
+		};
+	};
+};
diff -u -N U-Boot_SDcard/drivers/usb/gadget/rndis.c U-Boot_SDcard/drivers/usb/gadget/rndis.c
--- U-Boot_SDcard/drivers/usb/gadget/rndis.c	2019-09-12 15:54:39.000000315 -0500
+++ U-Boot_SDcard/drivers/usb/gadget/rndis.c	1969-12-31 19:29:28.000000021 -0600
@@ -1121,7 +1121,11 @@
 	return -ENOTSUPP;
 }
 
+#ifndef CONFIG_DM_ETH
 int rndis_register(int (*rndis_control_ack)(struct eth_device *))
+#else
+int rndis_register(int (*rndis_control_ack)(struct udevice *))
+#endif
 {
 	u8 i;
 
@@ -1149,8 +1153,13 @@
 	return;
 }
 
-int rndis_set_param_dev(u8 configNr, struct eth_device *dev, int mtu,
-			struct net_device_stats *stats,	u16 *cdc_filter)
+#ifndef CONFIG_DM_ETH
+int  rndis_set_param_dev(u8 configNr, struct eth_device *dev, int mtu,
+			 struct net_device_stats *stats, u16 *cdc_filter)
+#else
+int  rndis_set_param_dev(u8 configNr, struct udevice *dev, int mtu,
+			 struct net_device_stats *stats, u16 *cdc_filter)
+#endif
 {
 	debug("%s: configNr = %d\n", __func__, configNr);
 	if (!dev || !stats)
diff -u -N U-Boot_SDcard/drivers/spi/ti_qspi.c U-Boot_SDcard/drivers/spi/ti_qspi.c
--- U-Boot_SDcard/drivers/spi/ti_qspi.c	2019-09-12 15:54:46.000000873 -0500
+++ U-Boot_SDcard/drivers/spi/ti_qspi.c	1969-12-31 19:29:21.000000631 -0600
@@ -17,6 +17,8 @@
 #include <asm/omap_common.h>
 #include <asm/ti-common/ti-edma3.h>
 #include <linux/kernel.h>
+#include <regmap.h>
+#include <syscon.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -549,21 +551,56 @@
 	return 0;
 }
 
+static void *map_syscon_chipselects(struct udevice *bus)
+{
+#if CONFIG_IS_ENABLED(SYSCON)
+	struct udevice *syscon;
+	struct regmap *regmap;
+	const fdt32_t *cell;
+	int len, err;
+
+	err = uclass_get_device_by_phandle(UCLASS_SYSCON, bus,
+					   "syscon-chipselects", &syscon);
+	if (err) {
+		debug("%s: unable to find syscon device (%d)\n", __func__,
+		      err);
+		return NULL;
+	}
+
+	regmap = syscon_get_regmap(syscon);
+	if (IS_ERR(regmap)) {
+		debug("%s: unable to find regmap (%ld)\n", __func__,
+		      PTR_ERR(regmap));
+		return NULL;
+	}
+
+	cell = fdt_getprop(gd->fdt_blob, bus->of_offset, "syscon-chipselects",
+			   &len);
+	if (len < 2*sizeof(fdt32_t)) {
+		debug("%s: offset not available\n", __func__);
+		return NULL;
+	}
+
+	return fdtdec_get_number(cell + 1, 1) + regmap_get_range(regmap, 0);
+#else
+	fdt_addr_t addr;
+	addr = dev_get_addr_index(bus, 2);
+	return (addr == FDT_ADDR_T_NONE) ? NULL :
+		map_physmem(addr, 0, MAP_NOCACHE);
+#endif
+}
+
 static int ti_qspi_ofdata_to_platdata(struct udevice *bus)
 {
 	struct ti_qspi_priv *priv = dev_get_priv(bus);
 	const void *blob = gd->fdt_blob;
 	int node = bus->of_offset;
-	fdt_addr_t addr;
-	void *mmap;
 
+	priv->ctrl_mod_mmap = map_syscon_chipselects(bus);
 	priv->base = map_physmem(dev_get_addr(bus), sizeof(struct ti_qspi_regs),
 				 MAP_NOCACHE);
 	priv->memory_map = map_physmem(dev_get_addr_index(bus, 1), 0,
 				       MAP_NOCACHE);
-	addr = dev_get_addr_index(bus, 2);
-	mmap = map_physmem(dev_get_addr_index(bus, 2), 0, MAP_NOCACHE);
-	priv->ctrl_mod_mmap = (addr == FDT_ADDR_T_NONE) ? NULL : mmap;
 
 	priv->max_hz = fdtdec_get_int(blob, node, "spi-max-frequency", -1);
 	if (priv->max_hz < 0) {
diff -u -N U-Boot_SDcard/include/dm/util.h U-Boot_SDcard/include/dm/util.h
--- U-Boot_SDcard/include/dm/util.h	2019-09-12 15:54:47.000000418 -0500
+++ U-Boot_SDcard/include/dm/util.h	1969-12-31 19:29:22.000000618 -0600
@@ -48,4 +48,30 @@
 }
 #endif
 
+/**
+ * Check if a dt node should be or was bound before relocation.
+ *
+ * Devicetree nodes can be marked as needed to be bound
+ * in the loader stages via special devicetree properties.
+ *
+ * Before relocation this function can be used to check if nodes
+ * are required in either SPL or TPL stages.
+ *
+ * After relocation and jumping into the real U-Boot binary
+ * it is possible to determine if a node was bound in one of
+ * SPL/TPL stages.
+ *
+ * There are 3 settings currently in use
+ * -
+ * - u-boot,dm-pre-reloc: legacy and indicates any of TPL or SPL
+ *   Existing platforms only use it to indicate nodes needee in
+ *   SPL. Should probably be replaced by u-boot,dm-spl for
+ *   existing platforms.
+ * @blob: devicetree
+ * @offset: node offset
+ *
+ * Returns true if node is needed in SPL/TL, false otherwise.
+ */
+int dm_fdt_pre_reloc(const void *blob, int offset);
+
 #endif
diff -u -N U-Boot_SDcard/include/configs/dra7xx_evm.h U-Boot_SDcard/include/configs/dra7xx_evm.h
--- U-Boot_SDcard/include/configs/dra7xx_evm.h	2019-09-12 15:54:43.000000735 -0500
+++ U-Boot_SDcard/include/configs/dra7xx_evm.h	1969-12-31 19:29:22.000000168 -0600
@@ -17,9 +17,7 @@
 #define CONFIG_DRA7XX
 #define CONFIG_BOARD_EARLY_INIT_F
 
-#ifdef CONFIG_SPL_BUILD
 #define CONFIG_IODELAY_RECALIBRATION
-#endif
 
 #define CONFIG_VERY_BIG_RAM
 #define CONFIG_NR_DRAM_BANKS		2
@@ -30,7 +28,7 @@
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SLOT2: eMMC(1) */
 #define CONFIG_ENV_SIZE			(128 << 10)
-#define CONFIG_ENV_OFFSET		0xE0000
+#define CONFIG_ENV_OFFSET		0x260000
 #define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
 #define CONFIG_SYS_REDUNDAND_ENVIRONMENT
 #endif
@@ -57,8 +55,8 @@
 	"partitions_android=" \
 	"uuid_disk=${uuid_gpt_disk};" \
 	"name=xloader,start=128K,size=256K,uuid=${uuid_gpt_xloader};" \
-	"name=bootloader,size=768K,uuid=${uuid_gpt_bootloader};" \
-	"name=environment,size=128K,uuid=${uuid_gpt_environment};" \
+	"name=bootloader,size=2304K,uuid=${uuid_gpt_bootloader};" \
+	"name=environment,size=256K,uuid=${uuid_gpt_environment};" \
 	"name=misc,size=128K,uuid=${uuid_gpt_misc};" \
 	"name=reserved,size=256K,uuid=${uuid_gpt_reserved};" \
 	"name=efs,size=16M,uuid=${uuid_gpt_efs};" \
@@ -126,11 +124,6 @@
 #define CONFIG_SF_DEFAULT_MODE                 SPI_MODE_0
 #define CONFIG_QSPI_QUAD_SUPPORT
 
-#ifdef CONFIG_SPL_BUILD
-#undef CONFIG_DM_SPI
-#undef CONFIG_DM_SPI_FLASH
-#endif
-
 /*
  * Default to using SPI for environment, etc.
  * 0x000000 - 0x040000 : QSPI.SPL (256KiB)
@@ -266,8 +259,4 @@
 #endif
 #endif  /* NOR support */
 
-/* EEPROM */
-#define CONFIG_EEPROM_CHIP_ADDRESS 0x50
-#define CONFIG_EEPROM_BUS_ADDRESS 0
-
 #endif /* __CONFIG_DRA7XX_EVM_H */
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h	2019-09-12 15:55:01.000000312 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/mon.h	1969-12-31 19:29:30.000000932 -0600
@@ -10,7 +10,7 @@
 #ifndef _MACH_MON_H_
 #define _MACH_MON_H_
 
-int mon_install(u32 addr, u32 dpsc, u32 freq);
+int mon_install(u32 addr, u32 dpsc, u32 freq, u32 bm_addr);
 int mon_power_on(int core_id, void *ep);
 int mon_power_off(int core_id);
 
diff -u -N U-Boot_SDcard/include/net.h U-Boot_SDcard/include/net.h
--- U-Boot_SDcard/include/net.h	2019-09-12 15:54:38.000000412 -0500
+++ U-Boot_SDcard/include/net.h	1969-12-31 19:29:19.000000281 -0600
@@ -255,6 +255,13 @@
 
 
 /*
+ * Initialize USB ethernet device with CONFIG_DM_ETH
+ * Returns:
+ *	0 is success, non-zero is error status.
+ */
+int usb_ether_init(void);
+
+/*
  * Get the hardware address for an ethernet interface .
  * Args:
  *	base_name - base name for device (normally "eth")
diff -u -N U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c
--- U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c	2019-09-12 15:54:42.000000695 -0500
+++ U-Boot_SDcard/board/logicpd/am3517evm/am3517evm.c	1969-12-31 19:29:26.000000484 -0600
@@ -152,7 +152,7 @@
 	MUX_AM3517EVM();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/include/configs/k2hk_evm.h U-Boot_SDcard/include/configs/k2hk_evm.h
--- U-Boot_SDcard/include/configs/k2hk_evm.h	2019-09-12 15:54:11.000000583 -0500
+++ U-Boot_SDcard/include/configs/k2hk_evm.h	1969-12-31 19:29:22.000000248 -0600
@@ -13,9 +13,18 @@
 /* Platform type */
 #define CONFIG_SOC_K2HK
 
+#ifdef CONFIG_TI_SECURE_DEVICE
+#define DEFAULT_SEC_BOOT_ENV						\
+	DEFAULT_FIT_TI_ARGS						\
+	"findfdt=setenv fdtfile ${name_fdt}\0"
+#else
+#define DEFAULT_SEC_BOOT_ENV
+#endif
+
 /* U-Boot general configuration */
 #define CONFIG_EXTRA_ENV_KS2_BOARD_SETTINGS				\
 	DEFAULT_FW_INITRAMFS_BOOT_ENV					\
+	DEFAULT_SEC_BOOT_ENV						\
 	"boot=ubi\0"							\
 	"args_ubi=setenv bootargs ${bootargs} rootfstype=ubifs "	\
 	"root=ubi0:rootfs rootflags=sync rw ubi.mtd=ubifs,2048\0"	\
@@ -25,14 +34,22 @@
 	"name_uboot=u-boot-spi-k2hk-evm.gph\0"				\
 	"name_fs=arago-console-image-k2hk-evm.cpio.gz\0"
 
+/* NAND Configuration */
+#define CONFIG_SYS_NAND_PAGE_2K
+#define CONFIG_NAND_DAVINCI
+#define CONFIG_KEYSTONE_RBL_NAND
+#define CONFIG_KEYSTONE_NAND_MAX_RBL_SIZE	CONFIG_ENV_OFFSET
+#define CONFIG_SYS_NAND_MASK_CLE		0x4000
+#define CONFIG_SYS_NAND_MASK_ALE		0x2000
+#define CONFIG_SYS_NAND_CS			2
+#define CONFIG_SYS_NAND_4BIT_HW_ECC_OOBFIRST
+#define CONFIG_SYS_NAND_LARGEPAGE
+
 #include <configs/ti_armv7_keystone2.h>
 
 /* SPL SPI Loader Configuration */
 #define CONFIG_SPL_TEXT_BASE		0x0c200000
 
-/* NAND Configuration */
-#define CONFIG_SYS_NAND_PAGE_2K
-
 /* Network */
 #define CONFIG_KSNET_NETCP_V1_0
 #define CONFIG_KSNET_CPSW_NUM_PORTS	5
diff -u -N U-Boot_SDcard/include/nand.h U-Boot_SDcard/include/nand.h
--- U-Boot_SDcard/include/nand.h	2019-09-12 15:54:23.000000737 -0500
+++ U-Boot_SDcard/include/nand.h	1969-12-31 19:29:19.000000279 -0600
@@ -145,3 +145,12 @@
 
 /* platform specific init functions */
 void sunxi_nand_init(void);
+
+/*
+ * get_nand_dev_by_index - Get the nand info based in index.
+ *
+ * @dev - index to the nand device.
+ *
+ * returns pointer to the nand device info structure or NULL on failure.
+ */
+struct mtd_info *get_nand_dev_by_index(int dev);
diff -u -N U-Boot_SDcard/include/image.h U-Boot_SDcard/include/image.h
--- U-Boot_SDcard/include/image.h	2019-09-12 15:54:30.000000576 -0500
+++ U-Boot_SDcard/include/image.h	1969-12-31 19:29:19.000000209 -0600
@@ -18,6 +18,7 @@
 
 #include "compiler.h"
 #include <asm/byteorder.h>
+#include <linux/kconfig.h>
 
 /* Define this to avoid #ifdefs later on */
 struct lmb;
@@ -281,6 +282,7 @@
 	IH_TYPE_VYBRIDIMAGE,	/* VYBRID .vyb Image */
 	IH_TYPE_TEE,            /* Trusted Execution Environment OS Image */
 	IH_TYPE_FIRMWARE_IVT,		/* Firmware Image with HABv4 IVT */
+	IH_TYPE_PMMC,            /* TI Power Management Micro-Controller Firmware */
 
 	IH_TYPE_COUNT,			/* Number of image types */
 };
@@ -1256,7 +1258,8 @@
  */
 int board_fit_config_name_match(const char *name);
 
-#ifdef CONFIG_SPL_FIT_IMAGE_POST_PROCESS
+#if defined(CONFIG_SPL_FIT_IMAGE_POST_PROCESS) || \
+	defined(CONFIG_FIT_IMAGE_POST_PROCESS)
 /**
  * board_fit_image_post_process() - Do any post-process on FIT binary data
  *
@@ -1273,6 +1276,13 @@
 void board_fit_image_post_process(void **p_image, size_t *p_size);
 #endif /* CONFIG_SPL_FIT_IMAGE_POST_PROCESS */
 
+#if IS_ENABLED(CONFIG_SPL_LOAD_FIT) || IS_ENABLED(CONFIG_FIT_EMBED)
+
+ulong fdt_getprop_u32(const void *fdt, int node, const char *prop);
+int fit_select_fdt(const void *fdt, int images, int *fdt_offsetp);
+
+#endif
+
 /**
  * Mapping of image types to function handlers to be invoked on the associated
  * loaded images
diff -u -N U-Boot_SDcard/board/ti/ti814x/evm.c U-Boot_SDcard/board/ti/ti814x/evm.c
--- U-Boot_SDcard/board/ti/ti814x/evm.c	2019-09-12 15:54:40.000000107 -0500
+++ U-Boot_SDcard/board/ti/ti814x/evm.c	1969-12-31 19:29:27.000000235 -0600
@@ -111,7 +111,7 @@
 	return 0;
 }
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(1, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/.gitignore /dev/null
--- U-Boot_SDcard/.gitignore	2019-09-12 15:54:47.000000642 -0500
+++ /dev/null	1969-12-31 18:00:00.000000000 -0600
@@ -1,86 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.su
-*.mod.c
-*.i
-*.lst
-*.order
-*.elf
-*.swp
-*.bin
-*.patch
-*.cfgtmp
-
-# host programs on Cygwin
-*.exe
-
-# Build tree
-/build-*
-
-#
-# Top-level generic files
-#
-/MLO*
-/SPL*
-/System.map
-/u-boot*
-/boards.cfg
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated files
-#
-/LOG
-/spl/
-/tpl/
-/defconfig
-
-#
-# Generated include files
-#
-/include/config/
-/include/generated/
-
-# stgit generated dirs
-patches-*
-.stgit-edit.txt
-
-# quilt's files
-patches
-series
-
-# gdb files
-.gdb_history
-
-# cscope files
-cscope.*
-
-# tags files
-/tags
-/ctags
-/etags
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
diff -u -N U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c
--- U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c	2019-09-12 15:54:14.000000420 -0500
+++ U-Boot_SDcard/drivers/mtd/nand/am335x_spl_bch.c	1969-12-31 19:29:27.000000686 -0600
@@ -49,6 +49,13 @@
 
 	if (cmd == NAND_CMD_RESET) {
 		hwctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+
+		/*
+		 * Apply this short delay always to ensure that we do wait
+		 * tWB in any case on any machine.
+		 */
+		ndelay(150);
+
 		while (!this->dev_ready(mtd))
 			;
 		return 0;
@@ -78,22 +85,43 @@
 
 	hwctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
-	if (cmd == NAND_CMD_READ0) {
+
+	/*
+	 * Program and erase have their own busy handlers status, sequential
+	 * in and status need no delay.
+	 */
+	switch (cmd) {
+	case NAND_CMD_CACHEDPROG:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_RNDIN:
+	case NAND_CMD_STATUS:
+		return 0;
+
+	case NAND_CMD_RNDOUT:
+		/* No ready / busy check necessary */
+		hwctrl(mtd, NAND_CMD_RNDOUTSTART, NAND_CTRL_CLE |
+		       NAND_CTRL_CHANGE);
+		hwctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+		return 0;
+
+	case NAND_CMD_READ0:
 		/* Latch in address */
 		hwctrl(mtd, NAND_CMD_READSTART,
-			   NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+		       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
 		hwctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+	}
+
+	/*
+	 * Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine.
+	 */
+	ndelay(150);
 
-		/*
-		 * Wait a while for the data to be ready
-		 */
-		while (!this->dev_ready(mtd))
-			;
-	} else if (cmd == NAND_CMD_RNDOUT) {
-		hwctrl(mtd, NAND_CMD_RNDOUTSTART, NAND_CTRL_CLE |
-					NAND_CTRL_CHANGE);
-		hwctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
-	}
+	while (!this->dev_ready(mtd))
+		;
 
 	return 0;
 }
diff -u -N U-Boot_SDcard/cmd/nand.c U-Boot_SDcard/cmd/nand.c
--- U-Boot_SDcard/cmd/nand.c	2019-09-12 15:54:54.000000653 -0500
+++ U-Boot_SDcard/cmd/nand.c	1969-12-31 19:29:17.000000401 -0600
@@ -115,20 +115,20 @@
 
 static int set_dev(int dev)
 {
-	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[dev]) {
-		puts("No such device\n");
-		return -1;
-	}
+	struct mtd_info *mtd = get_nand_dev_by_index(dev);
+
+	if (!mtd)
+		return -ENODEV;
 
 	if (nand_curr_device == dev)
 		return 0;
 
-	printf("Device %d: %s", dev, nand_info[dev]->name);
+	printf("Device %d: %s", dev, mtd->name);
 	puts("... is now current device\n");
 	nand_curr_device = dev;
 
 #ifdef CONFIG_SYS_NAND_SELECT_DEVICE
-	board_nand_select_device(nand_info[dev]->priv, dev);
+	board_nand_select_device(mtd_to_nand(mtd), dev);
 #endif
 
 	return 0;
@@ -188,7 +188,7 @@
 {
 	int ret;
 	uint32_t oob_buf[ENV_OFFSET_SIZE/sizeof(uint32_t)];
-	struct mtd_info *mtd = nand_info[0];
+	struct mtd_info *mtd = get_nand_dev_by_index(0);
 	char *cmd = argv[1];
 
 	if (CONFIG_SYS_MAX_NAND_DEVICE == 0 || !mtd) {
@@ -213,9 +213,10 @@
 		if (argc < 3)
 			goto usage;
 
+		mtd = get_nand_dev_by_index(idx);
 		/* We don't care about size, or maxsize. */
 		if (mtd_arg_off(argv[2], &idx, &addr, &maxsize, &maxsize,
-				MTD_DEV_TYPE_NAND, nand_info[idx]->size)) {
+				MTD_DEV_TYPE_NAND, mtd->size)) {
 			puts("Offset or partition name expected\n");
 			return 1;
 		}
@@ -283,9 +284,14 @@
 
 static void nand_print_and_set_info(int idx)
 {
-	struct mtd_info *mtd = nand_info[idx];
-	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+
+	mtd = get_nand_dev_by_index(idx);
+	if (!mtd)
+		return;
 
+	chip = mtd_to_nand(mtd);
 	printf("Device %d: ", idx);
 	if (chip->numchips > 1)
 		printf("%dx ", chip->numchips);
@@ -348,7 +354,7 @@
 	/* We grab the nand info object here fresh because this is usually
 	 * called after arg_off_size() which can change the value of dev.
 	 */
-	struct mtd_info *mtd = nand_info[dev];
+	struct mtd_info *mtd = get_nand_dev_by_index(dev);
 	loff_t maxoffset = offset + *size;
 	int badblocks = 0;
 
@@ -397,10 +403,8 @@
 	if (strcmp(cmd, "info") == 0) {
 
 		putc('\n');
-		for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
-			if (nand_info[i])
-				nand_print_and_set_info(i);
-		}
+		for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
+			nand_print_and_set_info(i);
 		return 0;
 	}
 
@@ -432,12 +436,11 @@
 	 * one before these commands can run, even if a partition specifier
 	 * for another device is to be used.
 	 */
-	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
-	    !nand_info[dev]) {
+	mtd = get_nand_dev_by_index(dev);
+	if (!mtd) {
 		puts("\nno devices available\n");
 		return 1;
 	}
-	mtd = nand_info[dev];
 
 	if (strcmp(cmd, "bad") == 0) {
 		printf("\nDevice %d bad blocks:\n", dev);
@@ -496,13 +499,13 @@
 		/* skip first two or three arguments, look for offset and size */
 		if (mtd_arg_off_size(argc - o, argv + o, &dev, &off, &size,
 				     &maxsize, MTD_DEV_TYPE_NAND,
-				     nand_info[dev]->size) != 0)
+				     mtd->size) != 0)
 			return 1;
 
 		if (set_dev(dev))
 			return 1;
 
-		mtd = nand_info[dev];
+		mtd = get_nand_dev_by_index(dev);
 
 		memset(&opts, 0, sizeof(opts));
 		opts.offset = off;
@@ -565,13 +568,13 @@
 
 			if (mtd_arg_off(argv[3], &dev, &off, &size, &maxsize,
 					MTD_DEV_TYPE_NAND,
-					nand_info[dev]->size))
+					mtd->size))
 				return 1;
 
 			if (set_dev(dev))
 				return 1;
 
-			mtd = nand_info[dev];
+			mtd = get_nand_dev_by_index(dev);
 
 			if (argc > 4 && !str2long(argv[4], &pagecount)) {
 				printf("'%s' is not a number\n", argv[4]);
@@ -588,7 +591,7 @@
 			if (mtd_arg_off_size(argc - 3, argv + 3, &dev, &off,
 					     &size, &maxsize,
 					     MTD_DEV_TYPE_NAND,
-					     nand_info[dev]->size) != 0)
+					     mtd->size) != 0)
 				return 1;
 
 			if (set_dev(dev))
@@ -600,7 +603,7 @@
 			rwsize = size;
 		}
 
-		mtd = nand_info[dev];
+		mtd = get_nand_dev_by_index(dev);
 
 		if (!s || !strcmp(s, ".jffs2") ||
 		    !strcmp(s, ".e") || !strcmp(s, ".i")) {
@@ -760,13 +763,15 @@
 
 		if (mtd_arg_off_size(argc - 2, argv + 2, &dev, &off, &size,
 				     &maxsize, MTD_DEV_TYPE_NAND,
-				     nand_info[dev]->size) < 0)
+				     mtd->size) < 0)
 			return 1;
 
 		if (set_dev(dev))
 			return 1;
 
-		if (!nand_unlock(nand_info[dev], off, size, allexcept)) {
+		mtd = get_nand_dev_by_index(dev);
+
+		if (!nand_unlock(mtd, off, size, allexcept)) {
 			puts("NAND flash successfully unlocked\n");
 		} else {
 			puts("Error unlocking NAND flash, "
@@ -929,6 +934,7 @@
 	char *boot_device = NULL;
 	int idx;
 	ulong addr, offset = 0;
+	struct mtd_info *mtd;
 #if defined(CONFIG_CMD_MTDPARTS)
 	struct mtd_device *dev;
 	struct part_info *part;
@@ -948,8 +954,10 @@
 				addr = simple_strtoul(argv[1], NULL, 16);
 			else
 				addr = CONFIG_SYS_LOAD_ADDR;
-			return nand_load_image(cmdtp, nand_info[dev->id->num],
-					       part->offset, addr, argv[0]);
+
+			mtd = get_nand_dev_by_index(dev->id->num);
+			return nand_load_image(cmdtp, mtd, part->offset,
+					       addr, argv[0]);
 		}
 	}
 #endif
@@ -991,14 +999,15 @@
 
 	idx = simple_strtoul(boot_device, NULL, 16);
 
-	if (idx < 0 || idx >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[idx]) {
+	mtd = get_nand_dev_by_index(idx);
+	if (!mtd) {
 		printf("\n** Device %d not available\n", idx);
 		bootstage_error(BOOTSTAGE_ID_NAND_AVAILABLE);
 		return 1;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);
 
-	return nand_load_image(cmdtp, nand_info[idx], offset, addr, argv[0]);
+	return nand_load_image(cmdtp, mtd, offset, addr, argv[0]);
 }
 
 U_BOOT_CMD(nboot, 4, 1, do_nandboot,
diff -u -N U-Boot_SDcard/board/ti/am335x/board.h U-Boot_SDcard/board/ti/am335x/board.h
--- U-Boot_SDcard/board/ti/am335x/board.h	2019-09-12 15:54:18.000000346 -0500
+++ U-Boot_SDcard/board/ti/am335x/board.h	1969-12-31 19:29:27.000000158 -0600
@@ -39,6 +39,11 @@
 	return board_is_bone_lt() && !strncmp(board_ti_get_rev(), "BBG1", 4);
 }
 
+static inline int board_is_beaglebonex(void)
+{
+	return board_is_bone() || board_is_bone_lt() || board_is_bbg1();
+}
+
 static inline int board_is_evm_sk(void)
 {
 	return board_ti_is("A335X_SK");
diff -u -N U-Boot_SDcard/board/ti/dra7xx/mux_data.h U-Boot_SDcard/board/ti/dra7xx/mux_data.h
--- U-Boot_SDcard/board/ti/dra7xx/mux_data.h	2019-09-12 15:54:10.000000829 -0500
+++ U-Boot_SDcard/board/ti/dra7xx/mux_data.h	1969-12-31 19:29:27.000000192 -0600
@@ -828,4 +828,264 @@
 };
 #endif
 
+
+#if defined(CONFIG_IODELAY_RECALIBRATION) && defined(CONFIG_SPL_BUILD) && \
+    defined(CONFIG_OMAP_HSMMC)
+
+static struct pad_conf_entry hsmmc1_default_padconf[] = {
+	{MMC1_CLK,  (M0 | PIN_INPUT_PULLUP) /* mmc1_clk.clk */},
+	{MMC1_CMD,  (M0 | PIN_INPUT_PULLUP) /* mmc1_cmd.cmd */},
+	{MMC1_DAT0, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat0.dat0 */},
+	{MMC1_DAT1, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat1.dat1 */},
+	{MMC1_DAT2, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat2.dat2 */},
+	{MMC1_DAT3, (M0 | PIN_INPUT_PULLUP) /* mmc1_dat3.dat3 */},
+};
+
+static struct pad_conf_entry mmc2_pins_default_hs[] = {
+	{GPMC_A23, (M1 | PIN_INPUT_PULLUP) /* g pmc_a23.mmc2_clk */},
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP) /* gpmc_cs1.mmc2_cmd */},
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP) /* gpmc_a24.mmc2_dat0 */},
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP) /* gpmc_a25.mmc2_dat1 */},
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP) /* gpmc_a26.mmc2_dat2 */},
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP) /* gpmc_a27.mmc2_dat3 */},
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP) /* gpmc_a19.mmc2_dat4 */},
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP) /* gpmc_a20.mmc2_dat5 */},
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP) /* gpmc_a21.mmc2_dat6 */},
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP) /* gpmc_a22.mmc2_dat7 */},
+};
+
+static struct pad_conf_entry mmc2_pins_ddr_hs200_1_8v[] = {
+	{GPMC_A23, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a23.mmc2_clk */},
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_cs1.mmc2_cmd */},
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a24.mmc2_dat0 */},
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a25.mmc2_dat1 */},
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a26.mmc2_dat2 */},
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a27.mmc2_dat3 */},
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a19.mmc2_dat4 */},
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a20.mmc2_dat5 */},
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a21.mmc2_dat6 */},
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP | MANUAL_MODE) /* gpmc_a22.mmc2_dat7 */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_hs200_1_8v_rev11_conf[] = {
+	{0x190, 621, 600	/* CFG_GPMC_A19_OEN */},
+	{0x194, 300, 0		/* CFG_GPMC_A19_OUT */},
+	{0x1a8, 739, 600	/* CFG_GPMC_A20_OEN */},
+	{0x1ac, 240, 0		/* CFG_GPMC_A20_OUT */},
+	{0x1b4, 812, 600	/* CFG_GPMC_A21_OEN */},
+	{0x1b8, 240, 0		/* CFG_GPMC_A21_OUT */},
+	{0x1c0, 954, 600	/* CFG_GPMC_A22_OEN */},
+	{0x1c4, 60, 0		/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 1340, 420	/* CFG_GPMC_A23_OUT */},
+	{0x1d8, 935, 600	/* CFG_GPMC_A24_OEN */},
+	{0x1dc, 0, 0		/* CFG_GPMC_A24_OUT */},
+	{0x1e4, 525, 600	/* CFG_GPMC_A25_OEN */},
+	{0x1e8, 120, 0		/* CFG_GPMC_A25_OUT */},
+	{0x1f0, 767, 600	/* CFG_GPMC_A26_OEN */},
+	{0x1f4, 225, 0		/* CFG_GPMC_A26_OUT */},
+	{0x1fc, 565, 600	/* CFG_GPMC_A27_OEN */},
+	{0x200, 60, 0		/* CFG_GPMC_A27_OUT */},
+	{0x364, 969, 600	/* CFG_GPMC_CS1_OEN */},
+	{0x368, 180, 0		/* CFG_GPMC_CS1_OUT */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_hs200_1_8v_rev20_conf[] = {
+	{0x190, 274, 0  /* CFG_GPMC_A19_OEN */},
+	{0x194, 162, 0  /* CFG_GPMC_A19_OUT */},
+	{0x1a8, 401, 0  /* CFG_GPMC_A20_OEN */},
+	{0x1ac, 73, 0   /* CFG_GPMC_A20_OUT */},
+	{0x1b4, 465, 0  /* CFG_GPMC_A21_OEN */},
+	{0x1b8, 115, 0  /* CFG_GPMC_A21_OUT */},
+	{0x1c0, 633, 0  /* CFG_GPMC_A22_OEN */},
+	{0x1c4, 47, 0   /* CFG_GPMC_A22_OUT */},
+	{0x1d0, 935, 280 /* CFG_GPMC_A23_OUT */},
+	{0x1d8, 621, 0  /* CFG_GPMC_A24_OEN */},
+	{0x1dc, 0, 0    /* CFG_GPMC_A24_OUT */},
+	{0x1e4, 183, 0  /* CFG_GPMC_A25_OEN */},
+	{0x1e8, 0, 0    /* CFG_GPMC_A25_OUT */},
+	{0x1f0, 467, 0  /* CFG_GPMC_A26_OEN */},
+	{0x1f4, 0, 0    /* CFG_GPMC_A26_OUT */},
+	{0x1fc, 262, 0  /* CFG_GPMC_A27_OEN */},
+	{0x200, 46, 0   /* CFG_GPMC_A27_OUT */},
+	{0x364, 684, 0  /* CFG_GPMC_CS1_OEN */},
+	{0x368, 76, 0   /* CFG_GPMC_CS1_OUT */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_ddr_1_8v_rev11_conf[] = {
+	{0x18c, 0, 0		/* CFG_GPMC_A19_IN */},
+	{0x1a4, 274, 240	/* CFG_GPMC_A20_IN */},
+	{0x1b0, 0, 60		/* CFG_GPMC_A21_IN */},
+	{0x1bc, 0, 60		/* CFG_GPMC_A22_IN */},
+	{0x1c8, 514, 360	/* CFG_GPMC_A23_IN */},
+	{0x1d4, 187, 120	/* CFG_GPMC_A24_IN */},
+	{0x1e0, 0, 0		/* CFG_GPMC_A25_IN */},
+	{0x1ec, 0, 60		/* CFG_GPMC_A26_IN */},
+	{0x1f8, 121, 60		/* CFG_GPMC_A27_IN */},
+	{0x360, 0, 0		/* CFG_GPMC_CS1_IN */},
+	{0x190, 0, 0		/* CFG_GPMC_A19_OEN */},
+	{0x194, 174, 0		/* CFG_GPMC_A19_OUT */},
+	{0x1a8, 0, 0		/* CFG_GPMC_A20_OEN */},
+	{0x1ac, 168, 0		/* CFG_GPMC_A20_OUT */},
+	{0x1b4, 0, 0		/* CFG_GPMC_A21_OEN */},
+	{0x1b8, 136, 0		/* CFG_GPMC_A21_OUT */},
+	{0x1c0, 0, 0		/* CFG_GPMC_A22_OEN */},
+	{0x1c4, 0, 0		/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 879, 0		/* CFG_GPMC_A23_OUT */},
+	{0x1d8, 0, 0		/* CFG_GPMC_A24_OEN */},
+	{0x1dc, 0, 0		/* CFG_GPMC_A24_OUT */},
+	{0x1e4, 0, 0		/* CFG_GPMC_A25_OEN */},
+	{0x1e8, 34, 0		/* CFG_GPMC_A25_OUT */},
+	{0x1f0, 0, 0		/* CFG_GPMC_A26_OEN */},
+	{0x1f4, 120, 0		/* CFG_GPMC_A26_OUT */},
+	{0x1fc, 0, 0		/* CFG_GPMC_A27_OEN */},
+	{0x200, 0, 0		/* CFG_GPMC_A27_OUT */},
+	{0x364, 0, 0		/* CFG_GPMC_CS1_OEN */},
+	{0x368, 11, 0		/* CFG_GPMC_CS1_OUT */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_ddr_1_8v_rev20_conf[] = {
+	{0x18c, 270, 0	/* CFG_GPMC_A19_IN */},
+	{0x1a4, 0, 0	/* CFG_GPMC_A20_IN */},
+	{0x1b0, 170, 0	/* CFG_GPMC_A21_IN */},
+	{0x1bc, 758, 0	/* CFG_GPMC_A22_IN */},
+	{0x1c8, 0, 0	/* CFG_GPMC_A23_IN */},
+	{0x1d4, 81, 0	/* CFG_GPMC_A24_IN */},
+	{0x1e0, 286, 0	/* CFG_GPMC_A25_IN */},
+	{0x1ec, 0, 0	/* CFG_GPMC_A26_IN */},
+	{0x1f8, 123, 0	/* CFG_GPMC_A27_IN */},
+	{0x360, 346, 0	/* CFG_GPMC_CS1_IN */},
+	{0x190, 0, 0	/* CFG_GPMC_A19_OEN */},
+	{0x194, 55, 0	/* CFG_GPMC_A19_OUT */},
+	{0x1a8, 0, 0	/* CFG_GPMC_A20_OEN */},
+	{0x1ac, 422, 0	/* CFG_GPMC_A20_OUT */},
+	{0x1b4, 642, 0	/* CFG_GPMC_A21_OEN */},
+	{0x1b8, 0, 0	/* CFG_GPMC_A21_OUT */},
+	{0x1c0, 0, 0	/* CFG_GPMC_A22_OEN */},
+	{0x1c4, 128, 0	/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 0, 0	/* CFG_GPMC_A23_OUT */},
+	{0x1d8, 0, 0	/* CFG_GPMC_A24_OEN */},
+	{0x1dc, 395, 0	/* CFG_GPMC_A24_OUT */},
+	{0x1e4, 0, 0	/* CFG_GPMC_A25_OEN */},
+	{0x1e8, 0, 0	/* CFG_GPMC_A25_OUT */},
+	{0x1f0, 623, 0	/* CFG_GPMC_A26_OEN */},
+	{0x1f4, 0, 0	/* CFG_GPMC_A26_OUT */},
+	{0x1fc, 54, 0	/* CFG_GPMC_A27_OEN */},
+	{0x200, 0, 0	/* CFG_GPMC_A27_OUT */},
+	{0x364, 0, 0	/* CFG_GPMC_CS1_OEN */},
+	{0x368, 0, 0	/* CFG_GPMC_CS1_OUT */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_ddr_1_8v_dra72_conf[] = {
+	{0x18c, 0, 0,	/* CFG_GPMC_A19_IN */},
+	{0x1a4, 121, 0,	/* CFG_GPMC_A20_IN */},
+	{0x1b0, 0, 0,	/* CFG_GPMC_A21_IN */},
+	{0x1bc, 20, 0,	/* CFG_GPMC_A22_IN */},
+	{0x1c8, 108, 0,	/* CFG_GPMC_A23_IN */},
+	{0x1d4, 31, 0,	/* CFG_GPMC_A24_IN */},
+	{0x1e0, 0, 0,	/* CFG_GPMC_A25_IN */},
+	{0x1ec, 24, 0,	/* CFG_GPMC_A26_IN */},
+	{0x1f8, 0, 0,	/* CFG_GPMC_A27_IN */},
+	{0x360, 0, 0,	/* CFG_GPMC_CS1_IN */},
+	{0x194, 152, 0,	/* CFG_GPMC_A19_OUT */},
+	{0x1ac, 206, 0,	/* CFG_GPMC_A20_OUT */},
+	{0x1b8, 78, 0,	/* CFG_GPMC_A21_OUT */},
+	{0x1c4, 2, 0,	/* CFG_GPMC_A22_OUT */},
+	{0x1d0, 266, 0,	/* CFG_GPMC_A23_OUT */},
+	{0x1dc, 0, 0,	/* CFG_GPMC_A24_OUT */},
+	{0x1e8, 0, 0,	/* CFG_GPMC_A25_OUT */},
+	{0x1f4, 43, 0,	/* CFG_GPMC_A26_OUT */},
+	{0x200, 0, 0,	/* CFG_GPMC_A27_OUT */},
+	{0x368, 0, 0,	/* CFG_GPMC_CS1_OUT */},
+	{0x190, 0, 0,	/* CFG_GPMC_A19_OEN */},
+	{0x1a8, 0, 0,	/* CFG_GPMC_A20_OEN */},
+	{0x1b4, 0, 0,	/* CFG_GPMC_A21_OEN */},
+	{0x1c0, 0, 0,	/* CFG_GPMC_A22_OEN */},
+	{0x1d8, 0, 0,	/* CFG_GPMC_A24_OEN */},
+	{0x1e4, 0, 0,	/* CFG_GPMC_A25_OEN */},
+	{0x1f0, 0, 0,	/* CFG_GPMC_A26_OEN */},
+	{0x1fc, 0, 0,	/* CFG_GPMC_A27_OEN */},
+	{0x364, 0, 0,	/* CFG_GPMC_CS1_OEN */},
+};
+
+static struct iodelay_cfg_entry mmc2_iodelay_hs200_1_8v_dra72_conf[] = {
+	{0x194, 150 , 95	/* CFG_GPMC_A19_OUT */},
+	{0x1AC, 250 , 0		/* CFG_GPMC_A20_OUT */},
+	{0x1B8, 125 , 0		/* CFG_GPMC_A21_OUT */},
+	{0x1C4, 100 , 0		/* CFG_GPMC_A22_OUT */},
+	{0x1D0, 870 , 415	/* CFG_GPMC_A23_OUT */},
+	{0x1DC, 30  , 0		/* CFG_GPMC_A24_OUT */},
+	{0x1E8, 200 , 0		/* CFG_GPMC_A25_OUT */},
+	{0x1F4, 200 , 0		/* CFG_GPMC_A26_OUT */},
+	{0x200, 0   , 0		/* CFG_GPMC_A27_OUT */},
+	{0x368, 240 , 0		/* CFG_GPMC_CS1_OUT */},
+	{0x190, 695 , 0		/* CFG_GPMC_A19_OEN */},
+	{0x1A8, 924 , 0		/* CFG_GPMC_A20_OEN */},
+	{0x1B4, 719 , 0		/* CFG_GPMC_A21_OEN */},
+	{0x1C0, 824 , 0		/* CFG_GPMC_A22_OEN */},
+	{0x1D8, 877 , 0		/* CFG_GPMC_A24_OEN */},
+	{0x1E4, 446 , 0		/* CFG_GPMC_A25_OEN */},
+	{0x1F0, 847 , 0		/* CFG_GPMC_A26_OEN */},
+	{0x1FC, 586 , 0		/* CFG_GPMC_A27_OEN */},
+	{0x364, 1039 , 0	/* CFG_GPMC_CS1_OEN */},
+};
+
+#define dimof(t) (sizeof(t) / sizeof(t[0]))
+static struct omap_hsmmc_pinctrl_state hsmmc1_default = {
+	.padconf = hsmmc1_default_padconf,
+	.npads = dimof(hsmmc1_default_padconf),
+	.iodelay = NULL,
+	.niodelays = 0,
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_default_hs = {
+	.padconf = mmc2_pins_default_hs,
+	.npads = dimof(mmc2_pins_default_hs),
+	.iodelay = NULL,
+	.niodelays = 0,
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_ddr_1v8_rev11 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_ddr_1_8v_rev11_conf,
+	.niodelays = dimof(mmc2_iodelay_ddr_1_8v_rev11_conf),
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_ddr_1v8_rev20 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_ddr_1_8v_rev20_conf,
+	.niodelays = dimof(mmc2_iodelay_ddr_1_8v_rev20_conf),
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_hs200_1v8_rev11 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_hs200_1_8v_rev11_conf,
+	.niodelays = dimof(mmc2_iodelay_hs200_1_8v_rev11_conf),
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_hs200_1v8_rev20 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_hs200_1_8v_rev20_conf,
+	.niodelays = dimof(mmc2_iodelay_hs200_1_8v_rev20_conf),
+};
+
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_ddr_1v8_dra72 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_ddr_1_8v_dra72_conf,
+	.niodelays = dimof(mmc2_iodelay_ddr_1_8v_dra72_conf),
+};
+
+static struct omap_hsmmc_pinctrl_state hsmmc2_hs200_1v8_dra72 = {
+	.padconf = mmc2_pins_ddr_hs200_1_8v,
+	.npads = dimof(mmc2_pins_ddr_hs200_1_8v),
+	.iodelay = mmc2_iodelay_hs200_1_8v_dra72_conf,
+	.niodelays = dimof(mmc2_iodelay_hs200_1_8v_dra72_conf),
+};
+#endif
+
 #endif /* _MUX_DATA_DRA7XX_H_ */
diff -u -N U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts
--- U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts	2019-09-12 15:54:51.000000726 -0500
+++ U-Boot_SDcard/arch/arm/dts/dra72-evm-revc.dts	1969-12-31 19:29:23.000000301 -0600
@@ -1,80 +1,326 @@
-/*
- * Copyright (C) 2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include "dra72-evm-common.dtsi"
-#include <dt-bindings/net/ti-dp83867.h>
-
-/ {
-	model = "TI DRA722 Rev C EVM";
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x80000000>; /* 2GB */
-	};
-};
-
-&i2c1 {
-	tps65917: tps65917@58 {
-		reg = <0x58>;
-
-		interrupts = <GIC_SPI 2 IRQ_TYPE_NONE>;  /* IRQ_SYS_1N */
-	};
-};
-
-#include "dra72-evm-tps65917.dtsi"
-
-&ldo2_reg {
-	/* LDO2_OUT --> VDDA_1V8_PHY2 */
-	regulator-always-on;
-	regulator-boot-on;
-};
-
-&hdmi {
-	vdda-supply = <&ldo2_reg>;
-};
-
-&pcf_gpio_21 {
-	interrupt-parent = <&gpio3>;
-	interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
-};
-
-&mac {
-	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_LOW>,
-		     <&pcf_hdmi 9 GPIO_ACTIVE_LOW>,	/* P11 */
-		     <&pcf_hdmi 10 GPIO_ACTIVE_LOW>;	/* P12 */
-	dual_emac;
-};
-
-&cpsw_emac0 {
-	phy-handle = <&dp83867_0>;
-	phy-mode = "rgmii-id";
-	dual_emac_res_vlan = <1>;
-};
-
-&cpsw_emac1 {
-	phy-handle = <&dp83867_1>;
-	phy-mode = "rgmii-id";
-	dual_emac_res_vlan = <2>;
-};
-
-&davinci_mdio {
-	dp83867_0: ethernet-phy@2 {
-		reg = <2>;
-		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
-		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
-		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
-		ti,min-output-imepdance;
-	};
-
-	dp83867_1: ethernet-phy@3 {
-		reg = <3>;
-		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
-		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
-		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
-		ti,min-output-imepdance;
-	};
-};
+/*
+ * Copyright (C) 2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "dra72-evm-common.dtsi"
+#include <dt-bindings/net/ti-dp83867.h>
+
+/ {
+	model = "TI DRA722 Rev C EVM";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>; /* 2GB */
+	};
+};
+
+&i2c1 {
+	tps65917: tps65917@58 {
+		reg = <0x58>;
+
+		interrupts = <GIC_SPI 2 IRQ_TYPE_NONE>;  /* IRQ_SYS_1N */
+	};
+};
+
+#include "dra72-evm-tps65917.dtsi"
+
+&dra7_pmx_core {
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: mmc1_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: mmc2_pins_ddr_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs200_1_8v: mmc2_pins_hs200_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_conf: mmc1_iodelay_ddr50_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CLK_IN */
+			0x624 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_IN */
+			0x630 A_DELAY_PS(495) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x63C A_DELAY_PS(116) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x648 A_DELAY_PS(117) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x654 A_DELAY_PS(32) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x620 A_DELAY_PS(1224) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(44) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(64) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(79) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65C A_DELAY_PS(87) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(520) G_DELAY_PS(320)	/* CFG_MMC1_CLK_OUT */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(40) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(83) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(98) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65c A_DELAY_PS(106) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(51) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(363) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64c A_DELAY_PS(199) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(273) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc2_iodelay_ddr_1_8v_conf: mmc2_iodelay_ddr_1_8v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(121) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(108) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(31) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(24) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x194 A_DELAY_PS(152) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(206) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(78) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(2) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(266) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(43) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+
+	mmc2_iodelay_hs200_1_8v_conf: mmc2_iodelay_hs200_1_8v_conf {
+		pinctrl-pin-array = <
+			0x194 A_DELAY_PS(135) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(189) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(0) G_DELAY_PS(70)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(730) G_DELAY_PS(360)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(70) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(231) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(39) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(91) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(176) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(101) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(360) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+};
+
+&ldo2_reg {
+	/* LDO2_OUT --> VDDA_1V8_PHY2 */
+	regulator-always-on;
+	regulator-boot-on;
+};
+
+&hdmi {
+	vdda-supply = <&ldo2_reg>;
+};
+
+&pcf_gpio_21 {
+	interrupt-parent = <&gpio3>;
+	interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
+};
+
+&mac {
+	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_LOW>,
+		     <&pcf_hdmi 9 GPIO_ACTIVE_LOW>,	/* P11 */
+		     <&pcf_hdmi 10 GPIO_ACTIVE_LOW>;	/* P12 */
+	dual_emac;
+};
+
+&cpsw_emac0 {
+	phy-handle = <&dp83867_0>;
+	phy-mode = "rgmii-id";
+	dual_emac_res_vlan = <1>;
+};
+
+&cpsw_emac1 {
+	phy-handle = <&dp83867_1>;
+	phy-mode = "rgmii-id";
+	dual_emac_res_vlan = <2>;
+};
+
+&davinci_mdio {
+	dp83867_0: ethernet-phy@2 {
+		reg = <2>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		ti,min-output-impedance;
+	};
+
+	dp83867_1: ethernet-phy@3 {
+		reg = <3>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		ti,min-output-impedance;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+	vmmc_aux-supply = <&ldo1_reg>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v", "hs200_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_conf>;
+	pinctrl-3 = <&mmc2_pins_hs200_1_8v &mmc2_iodelay_hs200_1_8v_conf>;
+};
diff -u -N /dev/null U-Boot_SDcard/common/fw_update.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/common/fw_update.h	1969-12-31 19:31:37.000000902 -0600
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2000-2010
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * (C) Copyright 2008 Atmel Corporation
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <environment.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <search.h>
+#include <errno.h>
+#include <dm/device-internal.h>
+
+#ifndef CONFIG_ENV_SPI_BUS
+# define CONFIG_ENV_SPI_BUS	0
+#endif
+#ifndef CONFIG_ENV_SPI_CS
+# define CONFIG_ENV_SPI_CS	0
+#endif
+#ifndef CONFIG_ENV_SPI_MAX_HZ
+# define CONFIG_ENV_SPI_MAX_HZ	1000000
+#endif
+#ifndef CONFIG_ENV_SPI_MODE
+# define CONFIG_ENV_SPI_MODE	CONFIG_SF_DEFAULT_MODE
+#endif
+
+#if 0
+#define BRANSON_ACTIVE_BOOTMODE        	0x00000000
+#define BRANSON_PASSIVE_BOOTMODE       	0x00000001
+
+#define BRANSON_NORMAL_BOOT      	0x00000000
+#define BRANSON_FWUPGRADE		0x00000001
+
+#define BRANSON_ACTIVE_BOOTPART     	0x00A00000
+#define BRANSON_PASSIVE_BOOTPART    	0x00A00000
+
+#define FIRMWARE_PARTITION_INFO		0x00100000	/* assigned size  64KB , block no 1023 */
+#define VXWORKS_KERNEL_MAX_SIZE 	0x00500000 	/* Allocated size for vxworks bin is 10 MB,
+								 from block 160 to 319*/
+#define FW_LOAD_RAM_ADDR 		0x80100000	/* firmware loading address in RAM */
+
+#endif
+
+#if 1 
+#define BRANSON_ACTIVE_BOOTMODE        	0x00000000
+#define BRANSON_PASSIVE_BOOTMODE       	0x00000001
+
+#define BRANSON_NORMAL_BOOT      	0x00000000
+#define BRANSON_FWUPGRADE		0x00000001
+
+#define BRANSON_ACTIVE_BOOTPART     	0x1E0000
+#define BRANSON_PASSIVE_BOOTPART    	0x2000000
+#define PARTITION_BOUNDARY		0x10000		/* 40 KB boundary between Active & Passive partition */
+
+#define FIRMWARE_PARTITION_INFO		0x1C0000	/* assigned size  64KB , block no 1023 */
+
+							/* Max allocated size for vxworks bin is ~31 MB */
+#define VXWORKS_KERNEL_MAX_SIZE 	(BRANSON_PASSIVE_BOOTPART - BRANSON_ACTIVE_BOOTPART) - PARTITION_BOUNDARY 
+					
+#define FW_LOAD_RAM_ADDR 		0x84100000	/* firmware loading address in RAM */
+
+#define CONFIG_ENV_SECT_SIZE             (0x40000)
+
+#endif
+
+void load_firmware(void);
+
+
+typedef struct fwInfo {
+	int bootMode;
+	int fwUpgrade;
+	int activePart;
+	int passivePart;
+
+} FW_INFO;
+
+
+
diff -u -N U-Boot_SDcard/drivers/mmc/mmc.c U-Boot_SDcard/drivers/mmc/mmc.c
--- U-Boot_SDcard/drivers/mmc/mmc.c	2019-09-12 15:54:54.000000590 -0500
+++ U-Boot_SDcard/drivers/mmc/mmc.c	1969-12-31 19:29:21.000000192 -0600
@@ -22,6 +22,8 @@
 #include <div64.h>
 #include "mmc_private.h"
 
+#define MAX_ERROR_RATE	20
+
 static const unsigned int sd_au_size[] = {
 	0,		SZ_16K / 512,		SZ_32K / 512,
 	SZ_64K / 512,	SZ_128K / 512,		SZ_256K / 512,
@@ -29,6 +31,13 @@
 	SZ_4M / 512,	SZ_8M / 512,		(SZ_8M + SZ_4M) / 512,
 	SZ_16M / 512,	(SZ_16M + SZ_8M) / 512,	SZ_32M / 512,	SZ_64M / 512,
 };
+static int mmc_reinit(struct mmc *mmc);
+static int mmc_set_timing(struct mmc *mmc, uint timing);
+static int mmc_set_bus_width(struct mmc *mmc, uint width);
+static int mmc_select_bus_width(struct mmc *mmc);
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
+static int mmc_set_vdd(struct mmc *mmc, bool enable);
+static void mmc_power_cycle(struct mmc *mmc);
 
 #if CONFIG_IS_ENABLED(MMC_TINY)
 static struct mmc mmc_static;
@@ -160,6 +169,12 @@
 
 	return ret;
 }
+
+
+int mmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	return mmc->cfg->ops->execute_tuning(mmc, opcode);
+}
 #endif
 
 int mmc_send_status(struct mmc *mmc, int timeout)
@@ -209,6 +224,8 @@
 int mmc_set_blocklen(struct mmc *mmc, int len)
 {
 	struct mmc_cmd cmd;
+	int retries = 5;
+	int err;
 
 	if (mmc->ddr_mode)
 		return 0;
@@ -217,7 +234,81 @@
 	cmd.resp_type = MMC_RSP_R1;
 	cmd.cmdarg = len;
 
-	return mmc_send_cmd(mmc, &cmd, NULL);
+	do {
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (!err)
+			break;
+	} while (retries--);
+
+	return err;
+}
+
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
+int mmc_send_tuning(struct mmc *mmc, u32 opcode, int *cmd_error)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	const u8 *tuning_block_pattern;
+	int size, err;
+
+	if (mmc->bus_width == MMC_BUS_WIDTH_8) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+	} else if (mmc->bus_width == MMC_BUS_WIDTH_4) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+	} else {
+		return -EINVAL;
+	}
+
+	ALLOC_CACHE_ALIGN_BUFFER(u8, data_buf, size);
+
+	cmd.cmdidx = opcode;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = (void *)data_buf;
+	data.blocks = 1;
+	data.blocksize = size;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err)
+		return err;
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		return -EIO;
+
+	return 0;
 }
 
 static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
@@ -261,6 +352,43 @@
 	return blkcnt;
 }
 
+bool mmc_check_error_rate(struct mmc *mmc, struct mmc_statistics *s)
+{
+	int percent = s->transfers ? ((s->errors * 100) / s->transfers) : 0;
+
+	if ((percent > MAX_ERROR_RATE) && (s->transfers > 10)) {
+		debug("error rate too high: %d%% (%d/%d)\n", percent,
+		      s->errors, s->transfers);
+		return true;
+	}
+	return false;
+}
+
+bool mmc_disable_current_mode(struct mmc *mmc)
+{
+	__maybe_unused const char *mode;
+	bool disabled = true;
+
+	switch (mmc->timing) {
+	case MMC_TIMING_MMC_HS200:
+		mode = "HS200";
+		mmc->host_ok_caps &= ~MMC_MODE_HS200;
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		mode = "DDR52";
+		mmc->host_ok_caps &= ~MMC_MODE_DDR_52MHz;
+		break;
+	default:
+		disabled = false;
+	}
+	if (disabled) {
+		debug("%s mode is disabled. Reinitializing the MMC...\n", mode);
+		mmc->has_init = 0;
+		mmc_reinit(mmc);
+	}
+	return disabled;
+}
+
 #ifdef CONFIG_BLK
 ulong mmc_bread(struct udevice *dev, lbaint_t start, lbaint_t blkcnt, void *dst)
 #else
@@ -274,6 +402,7 @@
 	int dev_num = block_dev->devnum;
 	int err;
 	lbaint_t cur, blocks_todo = blkcnt;
+	uint start_time;
 
 	if (blkcnt == 0)
 		return 0;
@@ -303,10 +432,26 @@
 		return 0;
 	}
 
+	start_time =  get_timer(0);
 	do {
+		mmc->rd_stats.transfers++;
 		cur = (blocks_todo > mmc->cfg->b_max) ?
 			mmc->cfg->b_max : blocks_todo;
 		if (mmc_read_blocks(mmc, dst, start, cur) != cur) {
+			mmc->rd_stats.errors++;
+			/*
+			 * An error occured. Maybe we should try a slower but
+			 * safer mode.
+			 */
+			if (mmc_check_error_rate(mmc, &mmc->rd_stats))
+				if (mmc_disable_current_mode(mmc))
+					return (blkcnt - blocks_todo) +
+#ifdef CONFIG_BLK
+						mmc_bread(dev, start,
+#else
+						mmc_bread(block_dev, start,
+#endif
+							  blocks_todo, dst);
 			debug("%s: Failed to read blocks\n", __func__);
 			return 0;
 		}
@@ -315,6 +460,8 @@
 		dst += cur * mmc->read_bl_len;
 	} while (blocks_todo > 0);
 
+	mmc->rd_stats.total_time += get_timer(start_time);
+	mmc->rd_stats.total_sz += blkcnt;
 	return blkcnt;
 }
 
@@ -339,7 +486,76 @@
 	return 0;
 }
 
-static int sd_send_op_cond(struct mmc *mmc)
+static int mmc_host_uhs(struct mmc *mmc)
+{
+	return mmc->host_ok_caps &
+	(MMC_MODE_UHS_SDR12 | MMC_MODE_UHS_SDR25 |
+	MMC_MODE_UHS_SDR50 | MMC_MODE_UHS_SDR104 |
+	MMC_MODE_UHS_DDR50);
+}
+
+static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
+{
+	struct mmc_cmd cmd = {0};
+	int err = 0;
+
+	/*
+	 * Send CMD11 only if the request is to switch the card to
+	 * 1.8V signalling.
+	 */
+	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+		return mmc_set_signal_voltage(mmc, signal_voltage);
+
+	cmd.cmdidx = SD_CMD_SWITCH_UHS18V;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_R1;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto fail;
+
+	if (!mmc_host_is_spi(host) && (cmd.response[0] & MMC_STATUS_ERROR))
+		goto fail;
+
+	/*
+	 * The card should drive cmd and dat[0:3] low immediately
+	 * after the response of cmd11, but wait 1 ms to be sure
+	 */
+	udelay(1000);
+	if (mmc->cfg->ops->card_busy && !mmc->cfg->ops->card_busy(mmc))
+		goto fail;
+
+	/*
+	 * During a signal voltage level switch, the clock must be gated
+	 * for 5 ms according to the SD spec
+	 */
+	mmc_set_clock(mmc, mmc->clock, true);
+
+	err = mmc_set_signal_voltage(mmc, signal_voltage);
+	if (err)
+		goto fail;
+
+	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
+	udelay(10000);
+	mmc_set_clock(mmc, mmc->clock, false);
+
+	/* Wait for at least 1 ms according to spec */
+	udelay(1000);
+
+	/*
+	 * Failure to switch is indicated by the card holding
+	 * dat[0:3] low
+	 */
+	if (mmc->cfg->ops->card_busy && mmc->cfg->ops->card_busy(mmc))
+		goto fail;
+
+	return 0;
+
+fail:
+	return -EIO;
+}
+
+static int sd_send_op_cond(struct mmc *mmc, int uhs_en)
 {
 	int timeout = 1000;
 	int err;
@@ -371,6 +587,9 @@
 		if (mmc->version == SD_VERSION_2)
 			cmd.cmdarg |= OCR_HCS;
 
+		if (mmc_host_uhs(mmc) && uhs_en)
+			cmd.cmdarg |= OCR_S18R;
+
 		err = mmc_send_cmd(mmc, &cmd, NULL);
 
 		if (err)
@@ -401,6 +620,13 @@
 
 	mmc->ocr = cmd.response[0];
 
+	if (!(mmc_host_is_spi(mmc)) && (cmd.response[0] & 0x41000000)
+	    == 0x41000000) {
+		err = mmc_switch_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
+		if (err)
+			return err;
+	}
+
 	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
 	mmc->rca = 0;
 
@@ -546,6 +772,38 @@
 
 }
 
+static void mmc_select_card_type(struct mmc *mmc, char card_type)
+{
+	u32 caps = mmc->host_ok_caps;
+	uint hs_max_dtr = mmc->tran_speed;
+
+	if (caps & MMC_MODE_HS &&
+	    card_type & EXT_CSD_CARD_TYPE_26) {
+		hs_max_dtr = MMC_HIGH_26_MAX_DTR;
+		mmc->card_caps |= MMC_MODE_HS;
+	}
+
+	if (caps & MMC_MODE_HS &&
+	    card_type & EXT_CSD_CARD_TYPE_52) {
+		hs_max_dtr = MMC_HIGH_52_MAX_DTR;
+		mmc->card_caps |= MMC_MODE_HS_52MHz;
+	}
+
+	if (caps & MMC_MODE_DDR_52MHz &&
+	    card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) {
+		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
+		mmc->card_caps |= MMC_MODE_DDR_52MHz;
+	}
+
+	if (caps & MMC_MODE_HS200 &&
+	    card_type & EXT_CSD_CARD_TYPE_HS200_1_8V) {
+		hs_max_dtr = MMC_HS200_MAX_DTR;
+		mmc->card_caps |= MMC_MODE_HS200;
+	}
+
+	mmc->tran_speed = hs_max_dtr;
+}
+
 static int mmc_change_freq(struct mmc *mmc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
@@ -568,30 +826,37 @@
 	if (err)
 		return err;
 
-	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
+	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0x3f;
+
+	mmc_select_card_type(mmc, cardtype);
 
-	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+	if (mmc->card_caps & MMC_MODE_HS200) {
+		err = mmc_select_bus_width(mmc);
+		if (err)
+			return err;
 
-	if (err)
-		return err;
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200);
+		if (err)
+			return err;
 
-	/* Now check to see that it worked */
-	err = mmc_send_ext_csd(mmc, ext_csd);
+		mmc_set_timing(mmc, MMC_TIMING_MMC_HS200);
+	} else if (mmc->card_caps & MMC_MODE_HS) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+				 1);
+		if (err)
+			return err;
 
-	if (err)
-		return err;
+		/* Now check to see that it worked */
+		err = mmc_send_ext_csd(mmc, ext_csd);
+		if (err)
+			return err;
 
-	/* No high-speed support */
-	if (!ext_csd[EXT_CSD_HS_TIMING])
-		return 0;
+		/* No high-speed support */
+		if (!ext_csd[EXT_CSD_HS_TIMING])
+			return 0;
 
-	/* High Speed is set, there are two types: 52MHz and 26MHz */
-	if (cardtype & EXT_CSD_CARD_TYPE_52) {
-		if (cardtype & EXT_CSD_CARD_TYPE_DDR_1_8V)
-			mmc->card_caps |= MMC_MODE_DDR_52MHz;
-		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
-	} else {
-		mmc->card_caps |= MMC_MODE_HS;
+		mmc_set_timing(mmc, MMC_TIMING_MMC_HS);
 	}
 
 	return 0;
@@ -877,7 +1142,207 @@
 	return mmc_send_cmd(mmc, &cmd, &data);
 }
 
+static int mmc_app_set_bus_width(struct mmc *mmc, int width)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+	cmd.resp_type = MMC_RSP_R1;
+	switch (width) {
+	case MMC_BUS_WIDTH_1:
+		cmd.cmdarg = SD_BUS_WIDTH_1;
+		break;
+	case MMC_BUS_WIDTH_4:
+		cmd.cmdarg = SD_BUS_WIDTH_4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	mmc_set_bus_width(mmc, width);
+
+	return 0;
+}
+
+static void sd_update_bus_speed_mode(struct mmc *mmc)
+{
+	u32 caps = mmc->host_ok_caps;
+	/*
+	 * If the host doesn't support any of the UHS-I modes, fallback on
+	 * default speed.
+	 */
+	if (!mmc_host_uhs(mmc)) {
+		mmc->sd_bus_speed = 0;
+		return;
+	}
+
+	if ((caps & MMC_MODE_UHS_SDR104) &&
+	    (mmc->sd3_bus_mode & SD_MODE_UHS_SDR104))
+		mmc->sd_bus_speed = UHS_SDR104_BUS_SPEED;
+	else if ((caps & MMC_MODE_UHS_DDR50) &&
+		 (mmc->sd3_bus_mode & SD_MODE_UHS_DDR50))
+		mmc->sd_bus_speed = UHS_DDR50_BUS_SPEED;
+	else if ((caps & (MMC_MODE_UHS_SDR104 |
+		 MMC_MODE_UHS_SDR50)) && (mmc->sd3_bus_mode &
+		 SD_MODE_UHS_SDR50))
+		mmc->sd_bus_speed = UHS_SDR50_BUS_SPEED;
+	else if ((caps & (MMC_MODE_UHS_SDR104 |
+		 MMC_MODE_UHS_SDR50 | MMC_MODE_UHS_SDR25)) &&
+		 (mmc->sd3_bus_mode & SD_MODE_UHS_SDR25))
+		mmc->sd_bus_speed = UHS_SDR25_BUS_SPEED;
+	else if ((caps & (MMC_MODE_UHS_SDR104 |
+		 MMC_MODE_UHS_SDR50 | MMC_MODE_UHS_SDR25 |
+		 MMC_MODE_UHS_SDR12)) && (mmc->sd3_bus_mode &
+		 SD_MODE_UHS_SDR12))
+		mmc->sd_bus_speed = UHS_SDR12_BUS_SPEED;
+}
+
+static int sd_set_bus_speed_mode(struct mmc *mmc)
+{
+	int err;
+	unsigned int timing = 0;
+	uint hs_max_dtr = mmc->tran_speed;
+	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
+
+	switch (mmc->sd_bus_speed) {
+	case UHS_SDR104_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR104;
+		hs_max_dtr = UHS_SDR104_MAX_DTR;
+		break;
+	case UHS_DDR50_BUS_SPEED:
+		timing = MMC_TIMING_UHS_DDR50;
+		hs_max_dtr = UHS_DDR50_MAX_DTR;
+		break;
+	case UHS_SDR50_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR50;
+		hs_max_dtr = UHS_SDR50_MAX_DTR;
+		break;
+	case UHS_SDR25_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR25;
+		hs_max_dtr = UHS_SDR25_MAX_DTR;
+		break;
+	case UHS_SDR12_BUS_SPEED:
+		timing = MMC_TIMING_UHS_SDR12;
+		hs_max_dtr = UHS_SDR12_MAX_DTR;
+		break;
+	default:
+		return 0;
+	}
+
+	mmc->tran_speed = hs_max_dtr;
+
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, mmc->sd_bus_speed,
+			(u8 *)switch_status);
+	if (err)
+		return err;
+
+	if (((__be32_to_cpu(switch_status[4]) & 0x0f000000) >> 24) ==
+	    mmc->sd_bus_speed) {
+		mmc_set_timing(mmc, timing);
+		mmc_set_clock(mmc, hs_max_dtr, false);
+	}
+
+	return 0;
+}
+
+/*
+ * UHS-I specific initialization procedure
+ */
+static int mmc_sd_init_uhs_card(struct mmc *mmc)
+{
+	int err = 0;
 
+	if (mmc->version != SD_VERSION_3)
+		return 0;
+
+	if (mmc->card_caps & MMC_MODE_4BIT) {
+		err = mmc_app_set_bus_width(mmc, MMC_BUS_WIDTH_4);
+		if (err)
+			return err;
+		mmc_set_bus_width(mmc, MMC_BUS_WIDTH_4);
+	}
+
+	/*
+	 * Select the bus speed mode depending on host
+	 * and card capability.
+	 */
+	sd_update_bus_speed_mode(mmc);
+
+	/* Set bus speed mode of the card */
+	err = sd_set_bus_speed_mode(mmc);
+	if (err)
+		return err;
+
+	/*
+	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
+	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
+	 */
+	if (!mmc_host_is_spi(mmc) &&
+	    (mmc->timing == MMC_TIMING_UHS_SDR50 ||
+	     mmc->timing == MMC_TIMING_UHS_DDR50 ||
+	     mmc->timing == MMC_TIMING_UHS_SDR104)) {
+		err = mmc_execute_tuning(mmc, MMC_SEND_TUNING_BLOCK);
+
+		/*
+		 * As SD Specifications Part1 Physical Layer Specification
+		 * Version 3.01 says, CMD19 tuning is available for unlocked
+		 * cards in transfer state of 1.8V signaling mode. The small
+		 * difference between v3.00 and 3.01 spec means that CMD19
+		 * tuning is also available for DDR50 mode.
+		 */
+		if (err && mmc->timing == MMC_TIMING_UHS_DDR50) {
+			printf("ddr50 tuning failed\n");
+			err = 0;
+		}
+	}
+
+	return err;
+}
+
+static int mmc_sd_switch_hs(struct mmc *mmc)
+{
+	int err;
+	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
+
+	/*
+	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
+	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
+	 * This can avoid furthur problem when the card runs in different
+	 * mode between the host.
+	 */
+	if (!((mmc->host_ok_caps & MMC_MODE_HS_52MHz) &&
+	      (mmc->host_ok_caps & MMC_MODE_HS)))
+		return -EINVAL;
+
+	if (!(mmc->card_caps & MMC_MODE_HS))
+		return -EINVAL;
+
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
+	if (err)
+		return err;
+
+	if (!((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000))
+		return -EINVAL;
+
+	mmc_set_timing(mmc, MMC_TIMING_SD_HS);
+	mmc->tran_speed = HIGH_SPEED_MAX_DTR;
+
+	return 0;
+}
+
 static int sd_change_freq(struct mmc *mmc)
 {
 	int err;
@@ -963,28 +1428,30 @@
 			break;
 	}
 
+	mmc->sd3_bus_mode = __be32_to_cpu(switch_status[3]) >> 16 & 0x1f;
+
 	/* If high-speed isn't supported, we return */
-	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
-		return 0;
+	if (__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED)
+		mmc->card_caps |= MMC_MODE_HS;
 
-	/*
-	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
-	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
-	 * This can avoid furthur problem when the card runs in different
-	 * mode between the host.
-	 */
-	if (!((mmc->cfg->host_caps & MMC_MODE_HS_52MHz) &&
-		(mmc->cfg->host_caps & MMC_MODE_HS)))
-		return 0;
+	/* Restrict card's capabilities by what the host can do */
+	mmc->card_caps &= mmc->host_ok_caps;
 
-	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
+	if (mmc->ocr & OCR_S18R) {
+		mmc_sd_init_uhs_card(mmc);
+	} else {
+		err = mmc_sd_switch_hs(mmc);
+		if (err)
+			mmc->tran_speed = 25000000;
 
-	if (err)
-		return err;
+		mmc_set_clock(mmc, mmc->tran_speed, false);
+		if (mmc->card_caps & MMC_MODE_4BIT) {
+			err = mmc_app_set_bus_width(mmc, MMC_BUS_WIDTH_4);
+			if (err)
+				return err;
+		}
+	}
 
-	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
-		mmc->card_caps |= MMC_MODE_HS;
-
 	return 0;
 }
 
@@ -1076,14 +1543,28 @@
 };
 
 #ifndef CONFIG_DM_MMC_OPS
-static void mmc_set_ios(struct mmc *mmc)
+static int mmc_set_vdd(struct mmc *mmc, bool enable)
+{
+	int ret = 0;
+
+	if (mmc->cfg->ops->set_vdd)
+		ret = mmc->cfg->ops->set_vdd(mmc, enable);
+
+	return ret;
+}
+
+static int mmc_set_ios(struct mmc *mmc)
 {
+	int ret = 0;
+
 	if (mmc->cfg->ops->set_ios)
-		mmc->cfg->ops->set_ios(mmc);
+		ret = mmc->cfg->ops->set_ios(mmc);
+
+	return ret;
 }
 #endif
 
-void mmc_set_clock(struct mmc *mmc, uint clock)
+int mmc_set_clock(struct mmc *mmc, uint clock, u8 disable)
 {
 	if (clock > mmc->cfg->f_max)
 		clock = mmc->cfg->f_max;
@@ -1092,15 +1573,134 @@
 		clock = mmc->cfg->f_min;
 
 	mmc->clock = clock;
+	mmc->clk_disable = disable;
+
+	return mmc_set_ios(mmc);
+}
 
-	mmc_set_ios(mmc);
+static int mmc_set_timing(struct mmc *mmc, uint timing)
+{
+	mmc->timing = timing;
+	return mmc_set_ios(mmc);
 }
 
-static void mmc_set_bus_width(struct mmc *mmc, uint width)
+static int mmc_set_bus_width(struct mmc *mmc, uint width)
 {
 	mmc->bus_width = width;
 
-	mmc_set_ios(mmc);
+	return mmc_set_ios(mmc);
+}
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	mmc->signal_voltage = signal_voltage;
+	return mmc_set_ios(mmc);
+}
+
+static int mmc_select_hs_ddr(struct mmc *mmc)
+{
+	u32 ext_csd_bits;
+	int err = 0;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
+
+	if (!(mmc->card_caps & MMC_MODE_DDR_52MHz))
+		return 0;
+
+	if (mmc->bus_width == MMC_BUS_WIDTH_1)
+		return 0;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		return err;
+
+	ext_csd_bits = (mmc->bus_width == MMC_BUS_WIDTH_8) ?
+		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_BUS_WIDTH,
+			 ext_csd_bits);
+	if (err)
+		return err;
+
+	mmc_set_timing(mmc, MMC_TIMING_MMC_DDR52);
+	mmc->ddr_mode = true;
+
+	err = mmc_send_ext_csd(mmc, test_csd);
+	if (err)
+		return err;
+
+	/* Only compare read only fields */
+	if (!(ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
+		== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
+	    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
+		== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
+	    ext_csd[EXT_CSD_REV]
+		== test_csd[EXT_CSD_REV] &&
+	    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+		== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
+	    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
+		   &test_csd[EXT_CSD_SEC_CNT], 4) == 0))
+		err = -EBADMSG;
+
+	return err;
+}
+
+static int mmc_select_bus_width(struct mmc *mmc)
+{
+	static unsigned ext_csd_bits[] = {
+		EXT_CSD_BUS_WIDTH_8,
+		EXT_CSD_BUS_WIDTH_4,
+	};
+	static unsigned bus_widths[] = {
+		MMC_BUS_WIDTH_8,
+		MMC_BUS_WIDTH_4,
+	};
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
+	unsigned idx = 0, bus_width = 0;
+	int err = 0;
+
+	if (!(mmc->host_ok_caps & (MMC_MODE_8BIT | MMC_MODE_4BIT)))
+		return 0;
+
+	idx = (mmc->host_ok_caps & MMC_MODE_8BIT) ? 0 : 1;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		return err;
+
+	for (; idx < ARRAY_SIZE(bus_widths); idx++) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_BUS_WIDTH,
+				 ext_csd_bits[idx]);
+		if (err)
+			continue;
+
+		bus_width = bus_widths[idx];
+		mmc_set_bus_width(mmc, bus_width);
+
+		err = mmc_send_ext_csd(mmc, test_csd);
+		if (err)
+			return err;
+
+		/* Only compare read only fields */
+		if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
+			== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
+		    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
+			== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
+		    ext_csd[EXT_CSD_REV]
+			== test_csd[EXT_CSD_REV] &&
+		    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+			== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
+		    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
+			   &test_csd[EXT_CSD_SEC_CNT], 4) == 0)
+			break;
+		else
+			err = -EBADMSG;
+	}
+
+	return err;
 }
 
 static int mmc_startup(struct mmc *mmc)
@@ -1110,8 +1710,7 @@
 	u64 cmult, csize, capacity;
 	struct mmc_cmd cmd;
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
-	int timeout = 1000;
+	int timeout = 1000, retries = 3;
 	bool has_parts = false;
 	bool part_completed;
 	struct blk_desc *bdesc;
@@ -1134,7 +1733,11 @@
 	cmd.resp_type = MMC_RSP_R2;
 	cmd.cmdarg = 0;
 
-	err = mmc_send_cmd(mmc, &cmd, NULL);
+	do {
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (!err)
+			break;
+	} while (retries--);
 
 	if (err)
 		return err;
@@ -1430,129 +2033,36 @@
 	mmc->card_caps &= mmc->cfg->host_caps;
 
 	if (IS_SD(mmc)) {
-		if (mmc->card_caps & MMC_MODE_4BIT) {
-			cmd.cmdidx = MMC_CMD_APP_CMD;
-			cmd.resp_type = MMC_RSP_R1;
-			cmd.cmdarg = mmc->rca << 16;
-
-			err = mmc_send_cmd(mmc, &cmd, NULL);
-			if (err)
-				return err;
-
-			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
-			cmd.resp_type = MMC_RSP_R1;
-			cmd.cmdarg = 2;
-			err = mmc_send_cmd(mmc, &cmd, NULL);
-			if (err)
-				return err;
-
-			mmc_set_bus_width(mmc, 4);
-		}
-
 		err = sd_read_ssr(mmc);
 		if (err)
 			return err;
-
-		if (mmc->card_caps & MMC_MODE_HS)
-			mmc->tran_speed = 50000000;
-		else
-			mmc->tran_speed = 25000000;
 	} else if (mmc->version >= MMC_VERSION_4) {
-		/* Only version 4 of MMC supports wider bus widths */
-		int idx;
-
-		/* An array of possible bus widths in order of preference */
-		static unsigned ext_csd_bits[] = {
-			EXT_CSD_DDR_BUS_WIDTH_8,
-			EXT_CSD_DDR_BUS_WIDTH_4,
-			EXT_CSD_BUS_WIDTH_8,
-			EXT_CSD_BUS_WIDTH_4,
-			EXT_CSD_BUS_WIDTH_1,
-		};
-
-		/* An array to map CSD bus widths to host cap bits */
-		static unsigned ext_to_hostcaps[] = {
-			[EXT_CSD_DDR_BUS_WIDTH_4] =
-				MMC_MODE_DDR_52MHz | MMC_MODE_4BIT,
-			[EXT_CSD_DDR_BUS_WIDTH_8] =
-				MMC_MODE_DDR_52MHz | MMC_MODE_8BIT,
-			[EXT_CSD_BUS_WIDTH_4] = MMC_MODE_4BIT,
-			[EXT_CSD_BUS_WIDTH_8] = MMC_MODE_8BIT,
-		};
-
-		/* An array to map chosen bus width to an integer */
-		static unsigned widths[] = {
-			8, 4, 8, 4, 1,
-		};
-
-		for (idx=0; idx < ARRAY_SIZE(ext_csd_bits); idx++) {
-			unsigned int extw = ext_csd_bits[idx];
-			unsigned int caps = ext_to_hostcaps[extw];
-
-			/*
-			 * If the bus width is still not changed,
-			 * don't try to set the default again.
-			 * Otherwise, recover from switch attempts
-			 * by switching to 1-bit bus width.
-			 */
-			if (extw == EXT_CSD_BUS_WIDTH_1 &&
-					mmc->bus_width == 1) {
-				err = 0;
-				break;
+		mmc_set_clock(mmc, mmc->tran_speed, false);
+		if (mmc->timing == MMC_TIMING_MMC_HS200) {
+			err = mmc_execute_tuning(mmc,
+						MMC_SEND_TUNING_BLOCK_HS200);
+			if (err) {
+				printf("Tuning failed, dropping HS200 mode.\n");
+				mmc->host_ok_caps &= ~MMC_MODE_HS200;
+				return -EAGAIN;
 			}
-
-			/*
-			 * Check to make sure the card and controller support
-			 * these capabilities
-			 */
-			if ((mmc->card_caps & caps) != caps)
-				continue;
-
-			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_BUS_WIDTH, extw);
-
+		} else if (mmc->timing == MMC_TIMING_MMC_HS) {
+			err = mmc_select_bus_width(mmc);
 			if (err)
-				continue;
+				return err;
 
-			mmc->ddr_mode = (caps & MMC_MODE_DDR_52MHz) ? 1 : 0;
-			mmc_set_bus_width(mmc, widths[idx]);
-
-			err = mmc_send_ext_csd(mmc, test_csd);
-
-			if (err)
-				continue;
-
-			/* Only compare read only fields */
-			if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
-				== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
-			    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
-				== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
-			    ext_csd[EXT_CSD_REV]
-				== test_csd[EXT_CSD_REV] &&
-			    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
-				== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
-			    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
-				   &test_csd[EXT_CSD_SEC_CNT], 4) == 0)
-				break;
-			else
-				err = -EBADMSG;
+			err = mmc_select_hs_ddr(mmc);
+			if (err) {
+				printf("dropping DDR52 mode.\n");
+				mmc->host_ok_caps &= ~MMC_MODE_DDR_52MHz;
+				return -EAGAIN;
+			}
 		}
-
-		if (err)
-			return err;
-
-		if (mmc->card_caps & MMC_MODE_HS) {
-			if (mmc->card_caps & MMC_MODE_HS_52MHz)
-				mmc->tran_speed = 52000000;
-			else
-				mmc->tran_speed = 26000000;
-		}
 	}
 
-	mmc_set_clock(mmc, mmc->tran_speed);
-
 	/* Fix the block length for DDR mode */
 	if (mmc->ddr_mode) {
+		mmc_set_timing(mmc, MMC_TIMING_MMC_DDR52);
 		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
 		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
 	}
@@ -1642,10 +2152,51 @@
 	return 0;
 }
 
+static void mmc_set_initial_state(struct mmc *mmc)
+{
+	int err;
+
+	/* First try to set 3.3V. If it fails set to 1.8V */
+	err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_330);
+	if (err != 0)
+		err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
+	if (err != 0)
+		printf("failed to set signal voltage\n");
+
+	mmc_set_bus_width(mmc, 1);
+	mmc_set_clock(mmc, 1, false);
+	mmc_set_timing(mmc, MMC_TIMING_LEGACY);
+}
+
+static void mmc_power_up(struct mmc *mmc)
+{
+	mmc_set_initial_state(mmc);
+	mmc_set_vdd(mmc, true);
+	udelay(10000);
+}
+
+static void mmc_power_off(struct mmc *mmc)
+{
+	mmc_set_vdd(mmc, false);
+	mmc_set_clock(mmc, 1, true);
+}
+
+static void mmc_power_cycle(struct mmc *mmc)
+{
+	mmc_power_off(mmc);
+	/*
+	 * SD spec recommends at least 1ms of delay. Let's wait for 2ms
+	 * to be on the safer side.
+	 */
+	udelay(2000);
+	mmc_power_up(mmc);
+}
+
 int mmc_start_init(struct mmc *mmc)
 {
 	bool no_card;
 	int err;
+	int uhs_en = true;
 
 	/* we pretend there's no card when init is NULL */
 	no_card = mmc_getcd(mmc) == 0;
@@ -1679,9 +2230,10 @@
 		return err;
 #endif
 	mmc->ddr_mode = 0;
-	mmc_set_bus_width(mmc, 1);
-	mmc_set_clock(mmc, 1);
 
+retry:
+	mmc_power_cycle(mmc);
+
 	/* Reset the Card */
 	err = mmc_go_idle(mmc);
 
@@ -1695,7 +2247,11 @@
 	err = mmc_send_if_cond(mmc);
 
 	/* Now try to get the SD card's operating condition */
-	err = sd_send_op_cond(mmc);
+	err = sd_send_op_cond(mmc, uhs_en);
+	if (err == -EIO) {
+		uhs_en = false;
+		goto retry;
+	}
 
 	/* If the command timed out, we check for an MMC card */
 	if (err == -ETIMEDOUT) {
@@ -1732,29 +2288,43 @@
 	return err;
 }
 
-int mmc_init(struct mmc *mmc)
+static int mmc_reinit(struct mmc *mmc)
 {
 	int err = 0;
+	int retries = 0;
 	__maybe_unused unsigned start;
 #ifdef CONFIG_DM_MMC
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(mmc->dev);
 
 	upriv->mmc = mmc;
 #endif
-	if (mmc->has_init)
-		return 0;
 
+	memset(&mmc->rd_stats, 0, sizeof(struct mmc_statistics));
+	memset(&mmc->wr_stats, 0, sizeof(struct mmc_statistics));
 	start = get_timer(0);
 
-	if (!mmc->init_in_progress)
-		err = mmc_start_init(mmc);
+	do {
+		retries++;
+		if (!mmc->init_in_progress)
+			err = mmc_start_init(mmc);
+
+		if (!err)
+			err = mmc_complete_init(mmc);
+	} while (err == -EAGAIN);
 
-	if (!err)
-		err = mmc_complete_init(mmc);
-	debug("%s: %d, time %lu\n", __func__, err, get_timer(start));
+	debug("%s: %d, time %lu (retries %d)\n", __func__, err,
+	      get_timer(start), retries - 1);
 	return err;
 }
 
+int mmc_init(struct mmc *mmc)
+{
+	if (mmc->has_init)
+		return 0;
+	mmc->host_ok_caps = mmc->cfg->host_caps;
+	return mmc_reinit(mmc);
+}
+
 int mmc_set_dsr(struct mmc *mmc, u16 val)
 {
 	mmc->dsr = val;
@@ -1778,12 +2348,7 @@
 	mmc->preinit = preinit;
 }
 
-#if defined(CONFIG_DM_MMC) && defined(CONFIG_SPL_BUILD)
-static int mmc_probe(bd_t *bis)
-{
-	return 0;
-}
-#elif defined(CONFIG_DM_MMC)
+#if defined(CONFIG_DM_MMC)
 static int mmc_probe(bd_t *bis)
 {
 	int ret, i;
diff -u -N U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h
--- U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h	2019-09-12 15:54:39.000000707 -0500
+++ U-Boot_SDcard/include/dt-bindings/pinctrl/dra.h	1969-12-31 19:29:28.000000244 -0600
@@ -73,5 +73,9 @@
  */
 #define DRA7XX_CORE_IOPAD(pa, val)	(((pa) & 0xffff) - 0x3400) (val)
 
+/* DRA7 IODELAY configuration parameters */
+#define A_DELAY_PS(val)		((val) & 0xffff)
+#define G_DELAY_PS(val)		((val) & 0xffff)
+
 #endif
 
diff -u -N U-Boot_SDcard/drivers/usb/gadget/rndis.h U-Boot_SDcard/drivers/usb/gadget/rndis.h
--- U-Boot_SDcard/drivers/usb/gadget/rndis.h	2019-09-12 15:54:32.000000662 -0500
+++ U-Boot_SDcard/drivers/usb/gadget/rndis.h	1969-12-31 19:29:28.000000022 -0600
@@ -222,23 +222,34 @@
 
 	const u8		*host_mac;
 	u16			*filter;
-	struct eth_device	*dev;
 	struct net_device_stats *stats;
 	int			mtu;
 
 	u32			vendorID;
 	const char		*vendorDescr;
-	int			(*ack)(struct eth_device *);
+#ifndef CONFIG_DM_ETH
+	struct eth_device	*dev;
+	int (*ack)(struct eth_device *);
+#else
+	struct udevice		*dev;
+	int (*ack)(struct udevice *);
+#endif
 	struct list_head	resp_queue;
 } rndis_params;
 
 /* RNDIS Message parser and other useless functions */
 int  rndis_msg_parser(u8 configNr, u8 *buf);
 enum rndis_state rndis_get_state(int configNr);
+void rndis_deregister(int configNr);
+#ifndef CONFIG_DM_ETH
 int  rndis_register(int (*rndis_control_ack)(struct eth_device *));
-void rndis_deregister(int configNr);
 int  rndis_set_param_dev(u8 configNr, struct eth_device *dev, int mtu,
-			struct net_device_stats *stats, u16 *cdc_filter);
+			 struct net_device_stats *stats, u16 *cdc_filter);
+#else
+int  rndis_register(int (*rndis_control_ack)(struct udevice *));
+int  rndis_set_param_dev(u8 configNr, struct udevice *dev, int mtu,
+			 struct net_device_stats *stats, u16 *cdc_filter);
+#endif
 int  rndis_set_param_vendor(u8 configNr, u32 vendorID,
 			    const char *vendorDescr);
 int  rndis_set_param_medium(u8 configNr, u32 medium, u32 speed);
diff -u -N /dev/null U-Boot_SDcard/drivers/rapidio/keystone_rio.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/rapidio/keystone_rio.h	1969-12-31 19:31:37.000000922 -0600
@@ -0,0 +1,620 @@
+/*
+ * (C) Copyright 2017
+ * Texas Instruments Incorporated, <www.ti.com>
+ * Authors: Aurelien Jacquiot <a-jacquiot@ti.com>
+ *	    WingMan Kwok <w-kwok2@ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef KEYSTONE_RIO_H
+#define KEYSTONE_RIO_H
+
+#include <asm/setup.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+
+#define KEYSTONE_RIO_MAP_FLAG_SEGMENT     BIT(0)
+#define KEYSTONE_RIO_MAP_FLAG_SRC_PROMISC BIT(1)
+#define KEYSTONE_RIO_MAP_FLAG_TT_16       BIT(13)
+#define KEYSTONE_RIO_MAP_FLAG_DST_PROMISC BIT(15)
+#define KEYSTONE_RIO_DESC_FLAG_TT_16      BIT(9)
+
+#define KEYSTONE_RIO_BOOT_COMPLETE        BIT(24)
+#define KEYSTONE_RIO_PER_EN               BIT(2)
+#define KEYSTONE_RIO_PER_FREE             BIT(0)
+#define KEYSTONE_RIO_PEF_FLOW_CONTROL     BIT(7)
+
+/*
+ * Packet types
+ */
+#define KEYSTONE_RIO_PACKET_TYPE_NREAD    0x24
+#define KEYSTONE_RIO_PACKET_TYPE_NWRITE   0x54
+#define KEYSTONE_RIO_PACKET_TYPE_NWRITE_R 0x55
+#define KEYSTONE_RIO_PACKET_TYPE_SWRITE   0x60
+#define KEYSTONE_RIO_PACKET_TYPE_DBELL    0xa0
+#define KEYSTONE_RIO_PACKET_TYPE_MAINT_R  0x80
+#define KEYSTONE_RIO_PACKET_TYPE_MAINT_W  0x81
+#define KEYSTONE_RIO_PACKET_TYPE_MAINT_RR 0x82
+#define KEYSTONE_RIO_PACKET_TYPE_MAINT_WR 0x83
+#define KEYSTONE_RIO_PACKET_TYPE_MAINT_PW 0x84
+
+/*
+ * LSU defines
+ */
+#define KEYSTONE_RIO_LSU_PRIO           0
+
+#define KEYSTONE_RIO_LSU_BUSY_MASK      BIT(31)
+#define KEYSTONE_RIO_LSU_FULL_MASK      BIT(30)
+
+#define KEYSTONE_RIO_LSU_CC_MASK        0x0f
+#define KEYSTONE_RIO_LSU_CC_TIMEOUT     0x01
+#define KEYSTONE_RIO_LSU_CC_XOFF        0x02
+#define KEYSTONE_RIO_LSU_CC_ERROR       0x03
+#define KEYSTONE_RIO_LSU_CC_INVALID     0x04
+#define KEYSTONE_RIO_LSU_CC_DMA         0x05
+#define KEYSTONE_RIO_LSU_CC_RETRY       0x06
+#define KEYSTONE_RIO_LSU_CC_CANCELED    0x07
+
+/* Mask for receiving both error and good completion LSU interrupts */
+#define KEYSTONE_RIO_ICSR_LSU0(src_id)  ((0x10001) << (src_id))
+
+/* Keystone2 supported baud rates */
+#define KEYSTONE_RIO_BAUD_1_250         0
+#define KEYSTONE_RIO_BAUD_2_500         1
+#define KEYSTONE_RIO_BAUD_3_125         2
+#define KEYSTONE_RIO_BAUD_5_000         3
+
+#define KEYSTONE_RIO_FULL_RATE          0
+#define KEYSTONE_RIO_HALF_RATE          1
+#define KEYSTONE_RIO_QUARTER_RATE       2
+
+/* Max ports configuration per path modes */
+#define KEYSTONE_RIO_MAX_PORTS_PATH_MODE_0      0xf /* 4 ports:    4-1x    */
+#define KEYSTONE_RIO_MAX_PORTS_PATH_MODE_1      0xd /* 3 ports: 2-1x, 1-2x */
+#define KEYSTONE_RIO_MAX_PORTS_PATH_MODE_2      0x7 /* 3 ports: 1-2x, 2-1x */
+#define KEYSTONE_RIO_MAX_PORTS_PATH_MODE_3      0x5 /* 2 ports: 1-2x, 1-2x */
+#define KEYSTONE_RIO_MAX_PORTS_PATH_MODE_4      0x1 /* 1 ports:       1-4x */
+
+#define SERDES_LANE(lane_num)                  (0x01 << lane_num)
+#define IS_SERDES_LANE_USED(lanes, lane_num)   (lanes & SERDES_LANE(lane_num))
+
+/*
+ * Various RIO defines
+ */
+#define KEYSTONE_RIO_TIMEOUT_CNT               1000
+
+/*
+ * RIO error, reset and special event interrupt defines
+ */
+#define KEYSTONE_RIO_PORT_ERROR_OUT_PKT_DROP    BIT(26)
+#define KEYSTONE_RIO_PORT_ERROR_OUT_FAILED      BIT(25)
+#define KEYSTONE_RIO_PORT_ERROR_OUT_DEGRADED    BIT(24)
+#define KEYSTONE_RIO_PORT_ERROR_OUT_RETRY       BIT(20)
+#define KEYSTONE_RIO_PORT_ERROR_OUT_ERROR       BIT(17)
+#define KEYSTONE_RIO_PORT_ERROR_IN_ERROR        BIT(9)
+#define KEYSTONE_RIO_PORT_ERROR_PW_PENDING      BIT(4)
+#define KEYSTONE_RIO_PORT_ERROR_PORT_ERR        BIT(2)
+
+#define KEYSTONE_RIO_PORT_ERROR_MASK   \
+	(KEYSTONE_RIO_PORT_ERROR_OUT_PKT_DROP   |\
+	KEYSTONE_RIO_PORT_ERROR_OUT_FAILED      |\
+	KEYSTONE_RIO_PORT_ERROR_OUT_DEGRADED    |\
+	KEYSTONE_RIO_PORT_ERROR_OUT_RETRY       |\
+	KEYSTONE_RIO_PORT_ERROR_OUT_ERROR       |\
+	KEYSTONE_RIO_PORT_ERROR_IN_ERROR        |\
+	KEYSTONE_RIO_PORT_ERROR_PW_PENDING      |\
+	KEYSTONE_RIO_PORT_ERROR_PORT_ERR)
+
+#define KEYSTONE_RIO_SP_HDR_NEXT_BLK_PTR        0x1000
+#define KEYSTONE_RIO_SP_HDR_EP_REC_ID           0x0002
+#define KEYSTONE_RIO_ERR_HDR_NEXT_BLK_PTR       0x3000
+#define KEYSTONE_RIO_ERR_EXT_FEAT_ID            0x0007
+
+/*
+ * RapidIO global definitions
+ */
+#define KEYSTONE_RIO_MAX_PORT          4
+#define KEYSTONE_RIO_BLK_NUM           9
+#define KEYSTONE_RIO_MAINT_BUF_SIZE    64
+
+/*
+ * Dev Id and dev revision
+ */
+#define KEYSTONE_RIO_DEV_ID_VAL \
+	((((__raw_readl(krio_priv->jtagid_reg)) << 4)  & 0xffff0000) | 0x30)
+
+#define KEYSTONE_RIO_DEV_INFO_VAL \
+	(((__raw_readl(krio_priv->jtagid_reg)) >> 28) & 0xf)
+
+#define KEYSTONE_RIO_ID_TI             (0x00000030)
+#define KEYSTONE_RIO_EXT_FEAT_PTR      (0x00000100)
+
+/*
+ * RIO error, reset and special event interrupt defines
+ */
+#define KEYSTONE_RIO_ERR_RST_EVNT_MASK  0x00010f07
+
+/* Refer to bits in KEYSTONE_RIO_ERR_RST_EVNT_MASK */
+#define KEYSTONE_RIO_RESET_INT          16  /* reset interrupt on any port */
+#define KEYSTONE_RIO_PORT3_ERROR_INT    11  /* port 3 error */
+#define KEYSTONE_RIO_PORT2_ERROR_INT    10  /* port 2 error */
+#define KEYSTONE_RIO_PORT1_ERROR_INT    9   /* port 1 error */
+#define KEYSTONE_RIO_PORT0_ERROR_INT    8   /* port 0 error */
+#define KEYSTONE_RIO_EVT_CAP_ERROR_INT  2   /* error management event capture */
+#define KEYSTONE_RIO_PORT_WRITEIN_INT   1   /* port-write-in request received */
+#define KEYSTONE_RIO_MCAST_EVT_INT      0   /* multicast event control symbol */
+
+/*
+ * Interrupts and DMA event mapping
+ */
+#define KEYSTONE_GEN_RIO_INT            0   /* RIO int for generic events */
+#define KEYSTONE_LSU_RIO_INT            1   /* RIO int for LSU events */
+
+/* Mask for error and good completion LSU interrupts */
+#define KEYSTONE_RIO_ICSR_LSU0_ERROR_MASK     0xffff0000
+#define KEYSTONE_RIO_ICSR_LSU0_COMPLETE_MASK  0x0000ffff
+#define KEYSTONE_RIO_ICSR_LSU1_COMPLETE_MASK  0x000000ff
+
+/*
+ * Various RIO defines
+ */
+#define KEYSTONE_RIO_DBELL_NUMBER         4
+#define KEYSTONE_RIO_DBELL_VALUE_MAX      (KEYSTONE_RIO_DBELL_NUMBER * 16)
+#define KEYSTONE_RIO_DBELL_MASK           (KEYSTONE_RIO_DBELL_VALUE_MAX - 1)
+#define KEYSTONE_RIO_DBELL_INFO_ANY       0xffff
+
+/*
+ * SerDes configurations
+ */
+struct keystone_serdes_config {
+	u32 cfg_cntl;            /* setting control register config */
+	u16 serdes_cfg_pll;
+	u16 prescalar_srv_clk;
+	u32 rx_chan_config[KEYSTONE_RIO_MAX_PORT];
+	u32 tx_chan_config[KEYSTONE_RIO_MAX_PORT];
+};
+
+/*
+ * Per board RIO devices controller configuration
+ */
+struct keystone_rio_pdata {
+	u32	rio_regs_base;
+	u32	rio_regs_size;
+
+	u32	boot_cfg_regs_base;
+	u32	boot_cfg_regs_size;
+
+	u32	serdes_cfg_regs_base;
+	u32	serdes_cfg_regs_size;
+
+	u16	ports; /* bitfield of port(s) to probe on this controller */
+	u16	id;    /* host id */
+	u16	size;  /* RapidIO common transport system size.
+			* 0 - Small size. 256 devices.
+			* 1 - Large size, 65536 devices.
+			*/
+	u16	keystone2_serdes;
+	u32	serdes_baudrate;
+	u32	path_mode;
+
+	int	riohdid;
+	int	rio_irq;
+	int	lsu_irq;
+
+	struct keystone_serdes_config serdes_config;
+};
+
+struct keystone_rio_data;
+
+/*
+ * RapidIO Registers
+ */
+
+struct keystone_srio_serdes_regs {
+	u32	pll;
+
+	struct {
+		u32	rx;
+		u32	tx;
+	} channel[4];
+};
+
+/* RIO Registers  0000 - 2fff */
+struct keystone_rio_regs {
+/* Required Peripheral Registers */
+	u32	pid;			/* 0000 */
+	u32	pcr;			/* 0004 */
+	u32	__rsvd0[3];		/* 0008 - 0010 */
+
+/* Peripheral Setting Control Registers */
+	u32	per_set_cntl;		/* 0014 */
+	u32	per_set_cntl1;		/* 0018 */
+
+	u32	__rsvd1[2];		/* 001c - 0020 */
+
+	u32	gbl_en;			/* 0024 */
+	u32	gbl_en_stat;		/* 0028 */
+
+	struct {
+		u32 enable;		/* 002c */
+		u32 status;		/* 0030 */
+	} blk[10];			/* 002c - 0078 */
+
+	/* ID Registers */
+	u32	__rsvd2[17];		/* 007c - 00bc */
+	u32	multiid_reg[8];		/* 00c0 - 00dc */
+
+/* Hardware Packet Forwarding Registers */
+	struct {
+		u32	pf_16b;
+		u32	pf_8b;
+	} pkt_fwd_cntl[8];		/* 00e0 - 011c */
+
+	u32	__rsvd3[24];		/* 0120 - 017c */
+
+/* Interrupt Registers */
+	struct {
+		u32	status;
+		u32	__rsvd0;
+		u32	clear;
+		u32	__rsvd1;
+	} doorbell_int[4];		/* 0180 - 01bc */
+
+	struct {
+		u32	status;
+		u32	__rsvd0;
+		u32	clear;
+		u32	__rsvd1;
+	} lsu_int[2];			/* 01c0 - 01dc */
+
+	u32	err_rst_evnt_int_stat;	/* 01e0 */
+	u32	__rsvd4;
+	u32	err_rst_evnt_int_clear;	/* 01e8 */
+	u32	__rsvd5;
+
+	u32	__rsvd6[4];		/* 01f0 - 01fc */
+
+	struct {
+		u32 route;		/* 0200 */
+		u32 route2;		/* 0204 */
+		u32 __rsvd;		/* 0208 */
+	} doorbell_int_route[4];	/* 0200 - 022c */
+
+	u32	lsu0_int_route[4];		/* 0230 - 023c */
+	u32	lsu1_int_route1;		/* 0240 */
+
+	u32	__rsvd7[3];		/* 0244 - 024c */
+
+	u32	err_rst_evnt_int_route[3];	/* 0250 - 0258 */
+
+	u32	__rsvd8[2];		/* 025c - 0260 */
+
+	u32	interrupt_ctl;		/* 0264 */
+
+	u32	__rsvd9[26];		/* 0268, 026c, 0270 - 02cc */
+
+	u32	intdst_rate_cntl[16];	/* 02d0 - 030c */
+	u32	intdst_rate_disable;	/* 0310 */
+
+	u32	__rsvd10[59];		/* 0314 - 03fc */
+
+/* RXU Registers */
+	struct {
+		u32	ltr_mbox_src;
+		u32	dest_prom_seg;
+		u32	flow_qid;
+	} rxu_map[64];			/* 0400 - 06fc */
+
+	struct {
+		u32	cos_src;
+		u32	dest_prom;
+		u32	stream;
+	} rxu_type9_map[64];		/* 0700 - 09fc */
+
+	u32	__rsvd11[192];		/* 0a00 - 0cfc */
+
+/* LSU/MAU Registers */
+	struct {
+		u32 addr_msb;		/* 0d00 */
+		u32 addr_lsb_cfg_ofs;	/* 0d04 */
+		u32 dsp_addr;		/* 0d08 */
+		u32 dbell_val_byte_cnt;	/* 0d0c */
+		u32 destid;		/* 0d10 */
+		u32 dbell_info_fttype;	/* 0d14 */
+		u32 busy_full;		/* 0d18 */
+	} lsu_reg[8];			/* 0d00 - 0ddc */
+
+	u32	lsu_setup_reg[2];	/* 0de0 - 0de4 */
+	u32	lsu_stat_reg[6];	/* 0de8 - 0dfc */
+	u32	lsu_flow_masks[4];	/* 0e00 - 0e0c */
+
+	u32	__rsvd12[16];		/* 0e10 - 0e4c */
+
+/* Flow Control Registers */
+	u32	flow_cntl[16];		/* 0e50 - 0e8c */
+	u32	__rsvd13[8];		/* 0e90 - 0eac */
+
+/* TXU Registers 0eb0 - 0efc */
+	u32	tx_cppi_flow_masks[8];	/* 0eb0 - 0ecc */
+	u32	tx_queue_sch_info[4];	/* 0ed0 - 0edc */
+	u32	garbage_coll_qid[3];	/* 0ee0 - 0ee8 */
+
+	u32	__rsvd14[69];		/* 0eec, 0ef0 - 0ffc */
+
+};
+
+/* CDMAHP Registers 1000 - 2ffc */
+struct keystone_rio_pktdma_regs {
+	u32	__rsvd[2048];		/* 1000 - 2ffc */
+};
+
+/* CSR/CAR Registers  b000+ */
+struct keystone_rio_car_csr_regs {
+	u32	dev_id;			/* b000 */
+	u32	dev_info;		/* b004 */
+	u32	assembly_id;		/* b008 */
+	u32	assembly_info;		/* b00c */
+	u32	pe_feature;		/* b010 */
+
+	u32	sw_port;		/* b014 */
+
+	u32	src_op;			/* b018 */
+	u32	dest_op;		/* b01c */
+
+	u32	__rsvd1[7];		/* b020 - b038 */
+
+	u32	data_stm_info;		/* b03c */
+
+	u32	__rsvd2[2];		/* b040 - b044 */
+
+	u32	data_stm_logical_ctl;	/* b048 */
+	u32	pe_logical_ctl;		/* b04c */
+
+	u32	__rsvd3[2];		/* b050 - b054 */
+
+	u32	local_cfg_hbar;		/* b058 */
+	u32	local_cfg_bar;		/* b05c */
+
+	u32	base_dev_id;		/* b060 */
+	u32	__rsvd4;
+	u32	host_base_id_lock;	/* b068 */
+	u32	component_tag;		/* b06c */
+					/* b070 - b0fc */
+};
+
+struct keystone_rio_serial_port_regs {
+	u32	sp_maint_blk_hdr;	/* b100 */
+	u32	__rsvd6[7];		/* b104 - b11c */
+
+	u32	sp_link_timeout_ctl;	/* b120 */
+	u32	sp_rsp_timeout_ctl;	/* b124 */
+	u32	__rsvd7[5];		/* b128 - b138 */
+	u32	sp_gen_ctl;		/* b13c */
+
+	struct {
+		u32	link_maint_req;	/* b140 */
+		u32	link_maint_resp;/* b144 */
+		u32	ackid_stat;	/* b148 */
+		u32	__rsvd[2];	/* b14c - b150 */
+		u32	ctl2;		/* b154 */
+		u32	err_stat;	/* b158 */
+		u32	ctl;		/* b15c */
+	} sp[4];			/* b140 - b1bc */
+
+					/* b1c0 - bffc */
+};
+
+struct keystone_rio_err_mgmt_regs {
+	u32	err_report_blk_hdr;	/* c000 */
+	u32	__rsvd9;
+	u32	err_det;		/* c008 */
+	u32	err_en;			/* c00c */
+	u32	h_addr_capt;		/* c010 */
+	u32	addr_capt;		/* c014 */
+	u32	id_capt;		/* c018 */
+	u32	ctrl_capt;		/* c01c */
+	u32	__rsvd10[2];		/* c020 - c024 */
+	u32	port_write_tgt_id;	/* c028 */
+	u32	__rsvd11[5];		/* c02c - c03c */
+
+	struct {
+		u32	det;		/* c040 */
+		u32	rate_en;	/* c044 */
+		u32	attr_capt_dbg0;	/* c048 */
+		u32	capt_0_dbg1;	/* c04c */
+		u32	capt_1_dbg2;	/* c050 */
+		u32	capt_2_dbg3;	/* c054 */
+		u32	capt_3_dbg4;	/* c058 */
+		u32	__rsvd0[3];	/* c05c - c064 */
+		u32	rate;		/* c068 */
+		u32	thresh;		/* c06c */
+		u32	__rsvd1[4];	/* c070 - c07c */
+	} sp_err[4];			/* c040 - c13c */
+
+	u32	__rsvd12[1972];		/* c140 - e00c */
+
+	struct {
+		u32	stat0;		/* e010 */
+		u32	stat1;		/* e014 */
+		u32	__rsvd[6];	/* e018 - e02c */
+	} lane_stat[4];			/* e010 - e08c */
+
+					/* e090 - 1affc */
+};
+
+struct keystone_rio_phy_layer_regs {
+	u32	phy_blk_hdr;		/* 1b000 */
+	u32	__rsvd14[31];		/* 1b004 - 1b07c */
+	struct {
+		u32	imp_spec_ctl;	/* 1b080 */
+		u32	pwdn_ctl;	/* 1b084 */
+		u32	__rsvd0[2];
+
+		u32	status;		/* 1b090 */
+		u32	int_enable;	/* 1b094 */
+		u32	port_wr_enable;	/* 1b098 */
+		u32	event_gen;	/* 1b09c */
+
+		u32	all_int_en;	/* 1b0a0 */
+		u32	all_port_wr_en;	/* 1b0a4 */
+		u32	__rsvd1[2];
+
+		u32	path_ctl;	/* 1b0b0 */
+		u32	discovery_timer;/* 1b0b4 */
+		u32	silence_timer;	/* 1b0b8 */
+		u32	vmin_exp;	/* 1b0bc */
+
+		u32	pol_ctl;	/* 1b0c0 */
+		u32	__rsvd2;
+		u32	denial_ctl;	/* 1b0c8 */
+		u32	__rsvd3;
+
+		u32	rcvd_mecs;	/* 1b0d0 */
+		u32	__rsvd4;
+		u32	mecs_fwd;	/* 1b0d8 */
+		u32	__rsvd5;
+
+		u32	long_cs_tx1;	/* 1b0e0 */
+		u32	long_cs_tx2;	/* 1b0e4 */
+		u32	__rsvd[6];	/* 1b0e8, 1b0ec, 1b0f0 - 1b0fc */
+	} phy_sp[4];			/* 1b080 - 1b27c */
+
+					/* 1b280 - 1b2fc */
+};
+
+struct keystone_rio_transport_layer_regs {
+	u32	transport_blk_hdr;	/* 1b300 */
+	u32	__rsvd16[31];		/* 1b304 - 1b37c */
+
+	struct {
+		u32	control;	/*1b380 */
+		u32	__rsvd0[3];
+
+		u32	status;		/* 1b390 */
+		u32	int_enable;	/* 1b394 */
+		u32	port_wr_enable;	/* 1b398 */
+		u32	event_gen;	/* 1b39c */
+
+		struct {
+			u32	ctl;		/* 1b3a0 */
+			u32	pattern_match;	/* 1b3a4 */
+			u32	__rsvd[2];	/* 1b3a8 - 1b3ac */
+		} base_route[4];		/* 1b3a0 - 1b3dc */
+
+		u32	__rsvd1[8];		/* 1b3e0 - 1b3fc */
+
+	} transport_sp[4];			/* 1b380 - 1b57c */
+
+						/* 1b580 - 1b5fc */
+};
+
+struct keystone_rio_pkt_buf_regs {
+	u32	pkt_buf_blk_hdr;	/* 1b600 */
+	u32	__rsvd18[31];		/* 1b604 - 1b67c */
+
+	struct {
+		u32	control;	/* 1b680 */
+		u32	__rsvd0[3];
+
+		u32	status;		/* 1b690 */
+		u32	int_enable;	/* 1b694 */
+		u32	port_wr_enable;	/* 1b698 */
+		u32	event_gen;	/* 1b69c */
+
+		u32	ingress_rsc;	/* 1b6a0 */
+		u32	egress_rsc;	/* 1b6a4 */
+		u32	__rsvd1[2];
+
+		u32	ingress_watermark[4];	/* 1b6b0 - 1b6bc */
+		u32	__rsvd2[16];	/* 1b6c0 - 1b6fc */
+
+	} pkt_buf_sp[4];		/* 1b680 - 1b87c */
+
+					/* 1b880 - 1b8fc */
+};
+
+struct keystone_rio_evt_mgmt_regs {
+	u32	evt_mgmt_blk_hdr;	/* 1b900 */
+	u32	__rsvd20[3];
+
+	u32	evt_mgmt_int_stat;	/* 1b910 */
+	u32	evt_mgmt_int_enable;	/* 1b914 */
+	u32	evt_mgmt_int_port_stat;	/* 1b918 */
+	u32	__rsvd21;
+
+	u32	evt_mgmt_port_wr_stat;	/* 1b920 */
+	u32	evt_mgmt_port_wr_enable;/* 1b924 */
+	u32	evt_mgmt_port_wr_port_stat;	/* 1b928 */
+	u32	__rsvd22;
+
+	u32	evt_mgmt_dev_int_en;	/* 1b930 */
+	u32	evt_mgmt_dev_port_wr_en;/* 1b934 */
+	u32	__rsvd23;
+	u32	evt_mgmt_mecs_stat;	/* 1b93c */
+
+	u32	evt_mgmt_mecs_int_en;	/* 1b940 */
+	u32	evt_mgmt_mecs_cap_en;	/* 1b944 */
+	u32	evt_mgmt_mecs_trig_en;	/* 1b948 */
+	u32	evt_mgmt_mecs_req;	/* 1b94c */
+
+	u32	evt_mgmt_mecs_port_stat;/* 1b950 */
+	u32	__rsvd24[2];
+	u32	evt_mgmt_mecs_event_gen;/* 1b95c */
+
+	u32	evt_mgmt_rst_port_stat;	/* 1b960 */
+	u32	__rsvd25;
+	u32	evt_mgmt_rst_int_en;	/* 1b968 */
+	u32	__rsvd26;
+
+	u32	evt_mgmt_rst_port_wr_en;/* 1b970 */
+					/* 1b974 - 1b9fc */
+};
+
+struct keystone_rio_port_write_regs {
+	u32	port_wr_blk_hdr;	/* 1ba00 */
+	u32	port_wr_ctl;		/* 1ba04 */
+	u32	port_wr_route;		/* 1ba08 */
+	u32	__rsvd28;
+
+	u32	port_wr_rx_stat;	/* 1ba10 */
+	u32	port_wr_rx_event_gen;	/* 1ba14 */
+	u32	__rsvd29[2];
+
+	u32	port_wr_rx_capt[4];	/* 1ba20 - 1ba2c */
+					/* 1ba30 - 1bcfc */
+};
+
+struct keystone_rio_link_layer_regs {
+	u32	link_blk_hdr;		/* 1bd00 */
+	u32	__rsvd31[8];		/* 1bd04 - 1bd20 */
+	u32	whiteboard;		/* 1bd24 */
+	u32	port_number;		/* 1bd28 */
+
+	u32	__rsvd32;		/* 1bd2c */
+
+	u32	prescalar_srv_clk;	/* 1bd30 */
+	u32	reg_rst_ctl;		/* 1bd34 */
+	u32	__rsvd33[4];		/* 1bd38, 1bd3c, 1bd40, 1bd44 */
+	u32	local_err_det;		/* 1bd48 */
+	u32	local_err_en;		/* 1bd4c */
+
+	u32	local_h_addr_capt;	/* 1bd50 */
+	u32	local_addr_capt;	/* 1bd54 */
+	u32	local_id_capt;		/* 1bd58 */
+	u32	local_ctrl_capt;	/* 1bd5c */
+
+					/* 1bd60 - 1bdfc */
+};
+
+struct keystone_rio_fabric_regs {
+	u32	fabric_hdr;		/* 1be00 */
+	u32	__rsvd35[3];		/* 1be04 - 1be0c */
+
+	u32	fabric_csr;		/* 1be10 */
+	u32	__rsvd36[11];		/* 1be14 - 1be3c */
+
+	u32	sp_fabric_status[4];	/* 1be40 - 1be4c */
+};
+
+#endif /* KEYSTONE_RIO_H */
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c
--- U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c	2019-09-12 15:54:44.000000561 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap4/hw_data.c	1969-12-31 19:29:28.000000753 -0600
@@ -132,6 +132,7 @@
 };
 
 /* ABE M & N values with sys_clk as source */
+#ifdef CONFIG_SYS_OMAP_ABE_SYSCK
 static const struct dpll_params
 		abe_dpll_params_sysclk_196608khz[NUM_SYS_CLKS] = {
 	{49, 5, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 12 MHz   */
@@ -142,11 +143,12 @@
 	{29, 7, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
 	{64, 24, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1}	/* 38.4 MHz */
 };
-
+#else
 /* ABE M & N values with 32K clock as source */
 static const struct dpll_params abe_dpll_params_32k_196608khz = {
 	750, 0, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1
 };
+#endif
 
 static const struct dpll_params usb_dpll_params_1920mhz[NUM_SYS_CLKS] = {
 	{80, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},		/* 12 MHz   */
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c	2019-09-12 15:54:24.000000203 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/sys_info.c	1969-12-31 19:29:28.000000735 -0600
@@ -68,12 +68,34 @@
 	return readl(&cstat->statusreg) & SYSBOOT_MASK;
 }
 
+u32 get_sys_clk_index(void)
+{
+	struct ctrl_stat *ctrl = (struct ctrl_stat *)CTRL_BASE;
+	u32 ind = readl(&ctrl->statusreg);
+
+#ifdef CONFIG_AM43XX
+	u32 src;
+	src = (ind & CTRL_CRYSTAL_FREQ_SRC_MASK) >> CTRL_CRYSTAL_FREQ_SRC_SHIFT;
+	if (src == CTRL_CRYSTAL_FREQ_SRC_EFUSE) /* Value read from EFUSE */
+		return ((ind & CTRL_CRYSTAL_FREQ_SELECTION_MASK) >>
+			CTRL_CRYSTAL_FREQ_SELECTION_SHIFT);
+	else /* Value read from SYS BOOT pins */
+#endif
+		return ((ind & CTRL_SYSBOOT_15_14_MASK) >>
+			CTRL_SYSBOOT_15_14_SHIFT);
+}
+
+
 #ifdef CONFIG_DISPLAY_CPUINFO
 static char *cpu_revs[] = {
 		"1.0",
 		"2.0",
 		"2.1"};
 
+static char *cpu_revs_am43xx[] = {
+		"1.0",
+		"1.1",
+		"1.2"};
 
 static char *dev_types[] = {
 		"TST",
@@ -87,6 +109,7 @@
 int print_cpuinfo(void)
 {
 	char *cpu_s, *sec_s, *rev_s;
+	char **cpu_rev_arr = cpu_revs;
 
 	switch (get_cpu_type()) {
 	case AM335X:
@@ -97,6 +120,7 @@
 		break;
 	case AM437X:
 		cpu_s = "AM437X";
+		cpu_rev_arr = cpu_revs_am43xx;
 		break;
 	default:
 		cpu_s = "Unknown CPU type";
@@ -104,7 +128,7 @@
 	}
 
 	if (get_cpu_rev() < ARRAY_SIZE(cpu_revs))
-		rev_s = cpu_revs[get_cpu_rev()];
+		rev_s = cpu_rev_arr[get_cpu_rev()];
 	else
 		rev_s = "?";
 
@@ -126,13 +150,21 @@
 
 	sil_rev = readl(&cdev->deviceid) >> 28;
 
-	if (sil_rev == 1)
-		/* PG 2.0, efuse may not be set. */
-		return MPUPLL_M_800;
-	else if (sil_rev >= 2) {
+	if (sil_rev == 0) {
+		/* No efuse in PG 1.0. Use max speed */
+		return MPUPLL_M_720;
+	} else if (sil_rev >= 1) {
 		/* Check what the efuse says our max speed is. */
-		int efuse_arm_mpu_max_freq;
+		int efuse_arm_mpu_max_freq, package_type;
 		efuse_arm_mpu_max_freq = readl(&cdev->efuse_sma);
+		package_type = (efuse_arm_mpu_max_freq & PACKAGE_TYPE_MASK) >>
+				PACKAGE_TYPE_SHIFT;
+
+		/* PG 2.0, efuse may not be set. */
+		if (package_type == PACKAGE_TYPE_UNDEFINED || package_type ==
+		    PACKAGE_TYPE_RESERVED)
+			return MPUPLL_M_800;
+
 		switch ((efuse_arm_mpu_max_freq & DEVICE_ID_MASK)) {
 		case AM335X_ZCZ_1000:
 			return MPUPLL_M_1000;
@@ -149,14 +181,14 @@
 		}
 	}
 
-	/* PG 1.0 or otherwise unknown, use the PG1.0 max */
+	/* unknown, use the PG1.0 max */
 	return MPUPLL_M_720;
 }
 
 int am335x_get_tps65910_mpu_vdd(int sil_rev, int frequency)
 {
-	/* For PG2.1 and later, we have one set of values. */
-	if (sil_rev >= 2) {
+	/* For PG2.0 and later, we have one set of values. */
+	if (sil_rev >= 1) {
 		switch (frequency) {
 		case MPUPLL_M_1000:
 			return TPS65910_OP_REG_SEL_1_3_2_5;
@@ -165,12 +197,13 @@
 		case MPUPLL_M_720:
 			return TPS65910_OP_REG_SEL_1_2_0;
 		case MPUPLL_M_600:
+		case MPUPLL_M_500:
 		case MPUPLL_M_300:
-			return TPS65910_OP_REG_SEL_1_1_3;
+			return TPS65910_OP_REG_SEL_1_1_0;
 		}
 	}
 
-	/* Default to PG1.0/PG2.0 values. */
-	return TPS65910_OP_REG_SEL_1_1_3;
+	/* Default to PG1.0 values. */
+	return TPS65910_OP_REG_SEL_1_2_6;
 }
 #endif
diff -u -N /dev/null U-Boot_SDcard/drivers/rapidio/rio-uclass.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/rapidio/rio-uclass.c	1969-12-31 19:31:37.000000923 -0600
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2017 Texas Instruments, Inc
+ * Authors: Aurelien Jacquiot <a-jacquiot@ti.com>
+ *	    WingMan Kwok <w-kwok2@ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <linux/list.h>
+#include <rio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+UCLASS_DRIVER(rapidio) = {
+	.name		= "rapidio",
+	.id		= UCLASS_RIO,
+};
+
+int rio_config_read(struct udevice *dev, int portid, u16 destid,
+		    u8 hopcount, u32 offset, int len, u32 *val)
+{
+	const struct rio_ops *ops = device_get_ops(dev);
+
+	if (!ops->config_read)
+		return -ENOSYS;
+
+	return ops->config_read(dev, portid, destid, hopcount,
+				offset, len, val);
+}
+
+int rio_config_write(struct udevice *dev, int portid, u16 destid,
+		     u8 hopcount, u32 offset, int len, u32 val)
+{
+	const struct rio_ops *ops = device_get_ops(dev);
+
+	if (!ops->config_write)
+		return -ENOSYS;
+
+	return ops->config_write(dev, portid, destid, hopcount,
+				 offset, len, val);
+}
+
+int rio_local_config_read(struct udevice *dev, u32 offset, int len, u32 *data)
+{
+	const struct rio_ops *ops = device_get_ops(dev);
+
+	if (!ops->local_config_read)
+		return -ENOSYS;
+
+	return ops->local_config_read(dev, offset, len, data);
+}
+
+int rio_local_config_write(struct udevice *dev, u32 offset, int len, u32 data)
+{
+	const struct rio_ops *ops = device_get_ops(dev);
+
+	if (!ops->local_config_write)
+		return -ENOSYS;
+
+	return ops->local_config_write(dev, offset, len, data);
+}
+
+int rio_doorbell_rx(struct udevice *dev, u16 info)
+{
+	const struct rio_ops *ops = device_get_ops(dev);
+
+	if (!ops->doorbell_rx)
+		return -ENOSYS;
+
+	return ops->doorbell_rx(dev, info);
+}
+
+int rio_remove(struct udevice *dev)
+{
+	return device_remove(dev);
+}
diff -u -N U-Boot_SDcard/include/mmc.h U-Boot_SDcard/include/mmc.h
--- U-Boot_SDcard/include/mmc.h	2019-09-12 15:54:44.000000141 -0500
+++ U-Boot_SDcard/include/mmc.h	1969-12-31 19:29:19.000000259 -0600
@@ -58,6 +58,23 @@
 #define MMC_MODE_8BIT		(1 << 3)
 #define MMC_MODE_SPI		(1 << 4)
 #define MMC_MODE_DDR_52MHz	(1 << 5)
+#define MMC_MODE_HS200		(1 << 6)
+#define MMC_MODE_UHS_SDR12	(1 << 7)
+#define MMC_MODE_UHS_SDR25	(1 << 8)
+#define MMC_MODE_UHS_SDR50	(1 << 9)
+#define MMC_MODE_UHS_SDR104	(1 << 10)
+#define MMC_MODE_UHS_DDR50	(1 << 11)
+
+#define MMC_HIGH_26_MAX_DTR	26000000
+#define MMC_HIGH_52_MAX_DTR	52000000
+#define MMC_HIGH_DDR_MAX_DTR	52000000
+#define MMC_HS200_MAX_DTR	200000000
+#define HIGH_SPEED_MAX_DTR	50000000
+#define UHS_SDR104_MAX_DTR	208000000
+#define UHS_SDR50_MAX_DTR	100000000
+#define UHS_DDR50_MAX_DTR	50000000
+#define UHS_SDR25_MAX_DTR	UHS_DDR50_MAX_DTR
+#define UHS_SDR12_MAX_DTR	25000000
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -82,6 +99,8 @@
 #define MMC_CMD_SET_BLOCKLEN		16
 #define MMC_CMD_READ_SINGLE_BLOCK	17
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_SEND_TUNING_BLOCK		19
+#define MMC_SEND_TUNING_BLOCK_HS200	21
 #define MMC_CMD_SET_BLOCK_COUNT         23
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
@@ -113,8 +132,22 @@
 #define SD_HIGHSPEED_BUSY	0x00020000
 #define SD_HIGHSPEED_SUPPORTED	0x00020000
 
+#define UHS_SDR12_BUS_SPEED	0
+#define HIGH_SPEED_BUS_SPEED	1
+#define UHS_SDR25_BUS_SPEED	1
+#define UHS_SDR50_BUS_SPEED	2
+#define UHS_SDR104_BUS_SPEED	3
+#define UHS_DDR50_BUS_SPEED	4
+
+#define SD_MODE_UHS_SDR12	(1 << UHS_SDR12_BUS_SPEED)
+#define SD_MODE_UHS_SDR25	(1 << UHS_SDR25_BUS_SPEED)
+#define SD_MODE_UHS_SDR50	(1 << UHS_SDR50_BUS_SPEED)
+#define SD_MODE_UHS_SDR104	(1 << UHS_SDR104_BUS_SPEED)
+#define SD_MODE_UHS_DDR50	(1 << UHS_DDR50_BUS_SPEED)
+
 #define OCR_BUSY		0x80000000
 #define OCR_HCS			0x40000000
+#define OCR_S18R		0x1000000
 #define OCR_VOLTAGE_MASK	0x007FFF80
 #define OCR_ACCESS_MODE		0x60000000
 
@@ -205,6 +238,11 @@
 #define EXT_CSD_CARD_TYPE_DDR_1_2V	(1 << 3)
 #define EXT_CSD_CARD_TYPE_DDR_52	(EXT_CSD_CARD_TYPE_DDR_1_8V \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
+#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
+						/* SDR mode @1.2V I/O */
+#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS200_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@ -212,6 +250,8 @@
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
+#define EXT_CSD_TIMING_HS200	2	/* HS200 */
+
 #define EXT_CSD_BOOT_ACK_ENABLE			(1 << 6)
 #define EXT_CSD_BOOT_PARTITION_ENABLE		(1 << 3)
 #define EXT_CSD_PARTITION_ACCESS_ENABLE		(1 << 0)
@@ -261,6 +301,31 @@
 #define ENHNCD_SUPPORT		(0x2)
 #define PART_ENH_ATTRIB		(0x1f)
 
+#define MMC_TIMING_LEGACY	0
+#define MMC_TIMING_MMC_HS	1
+#define MMC_TIMING_SD_HS	2
+#define MMC_TIMING_MMC_DDR52	3
+#define MMC_TIMING_MMC_HS200	4
+#define MMC_TIMING_UHS_SDR12	5
+#define MMC_TIMING_UHS_SDR25	6
+#define MMC_TIMING_UHS_SDR50	7
+#define MMC_TIMING_UHS_SDR104	8
+#define MMC_TIMING_UHS_DDR50	9
+
+#define MMC_BUS_WIDTH_1		1
+#define MMC_BUS_WIDTH_4		4
+#define MMC_BUS_WIDTH_8		8
+
+#define MMC_SIGNAL_VOLTAGE_330	1
+#define MMC_SIGNAL_VOLTAGE_180	2
+#define MMC_SIGNAL_VOLTAGE_120	3
+
+/*
+ * SD bus widths
+ */
+#define SD_BUS_WIDTH_1		0
+#define SD_BUS_WIDTH_4		2
+
 /* Maximum block size for MMC */
 #define MMC_MAX_BLOCK_LEN	512
 
@@ -318,6 +383,13 @@
 	uint blocksize;
 };
 
+struct mmc_statistics {
+	uint transfers;
+	uint errors;
+	uint total_sz;
+	uint total_time;
+};
+
 /* forward decl. */
 struct mmc;
 
@@ -343,6 +415,15 @@
 	int (*set_ios)(struct udevice *dev);
 
 	/**
+	 * set_vdd() - Enable or Disable the Vdd line
+	 *
+	 * @dev:	Device to update
+	 * @enable:	true or false to enable or disable Vdd respectively
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*set_vdd)(struct udevice *dev, bool enable);
+
+	/**
 	 * get_cd() - See whether a card is present
 	 *
 	 * @dev:	Device to check
@@ -357,6 +438,15 @@
 	 * @return 0 if write-enabled, 1 if write-protected, -ve on error
 	 */
 	int (*get_wp)(struct udevice *dev);
+
+	/**
+	 * execute_tuning() - Start the tuning process
+	 *
+	 * @dev:	Device to start the tuning
+	 * @opcode:	Command opcode to send
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*execute_tuning)(struct mmc *mmc, uint opcode);
 };
 
 #define mmc_get_ops(dev)        ((struct dm_mmc_ops *)(dev)->driver->ops)
@@ -364,22 +454,29 @@
 int dm_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
 		    struct mmc_data *data);
 int dm_mmc_set_ios(struct udevice *dev);
+int dm_mmc_set_vdd(struct udevice *dev, bool enable);
 int dm_mmc_get_cd(struct udevice *dev);
 int dm_mmc_get_wp(struct udevice *dev);
+int dm_mmc_execute_tuning(struct udevice *dev, uint opcode);
 
 /* Transition functions for compatibility */
 int mmc_set_ios(struct mmc *mmc);
+int mmc_set_vdd(struct mmc *mmc, bool enable);
 int mmc_getcd(struct mmc *mmc);
 int mmc_getwp(struct mmc *mmc);
+int mmc_execute_tuning(struct udevice *dev, uint opcode);
 
 #else
 struct mmc_ops {
 	int (*send_cmd)(struct mmc *mmc,
 			struct mmc_cmd *cmd, struct mmc_data *data);
-	void (*set_ios)(struct mmc *mmc);
+	int (*set_ios)(struct mmc *mmc);
 	int (*init)(struct mmc *mmc);
+	int (*set_vdd)(struct mmc *mmc, bool enable);
 	int (*getcd)(struct mmc *mmc);
 	int (*getwp)(struct mmc *mmc);
+	int (*execute_tuning)(struct mmc *mmc, uint opcode);
+	int (*card_busy)(struct mmc *mmc);
 };
 #endif
 
@@ -417,8 +514,11 @@
 	void *priv;
 	uint has_init;
 	int high_capacity;
+	u8 clk_disable;
 	uint bus_width;
 	uint clock;
+	uint timing;
+	uint signal_voltage;
 	uint card_caps;
 	uint ocr;
 	uint dsr;
@@ -449,11 +549,16 @@
 #endif
 	char op_cond_pending;	/* 1 if we are waiting on an op_cond command */
 	char init_in_progress;	/* 1 if we have done mmc_start_init() */
+	uint host_ok_caps;	/* host caps that are not yet proven wrong */
 	char preinit;		/* start init as early as possible */
 	int ddr_mode;
 #ifdef CONFIG_DM_MMC
 	struct udevice *dev;	/* Device for this MMC controller */
 #endif
+	unsigned int sd_bus_speed;
+	unsigned int sd3_bus_mode;
+	struct mmc_statistics rd_stats;
+	struct mmc_statistics wr_stats;
 };
 
 struct mmc_hwpart_conf {
@@ -503,8 +608,10 @@
 int mmc_unbind(struct udevice *dev);
 int mmc_initialize(bd_t *bis);
 int mmc_init(struct mmc *mmc);
+int mmc_send_tuning(struct mmc *mmc, u32 opcode, int *cmd_error);
+int mmc_of_parse(const void *fdt, int node, struct mmc_config *cfg);
 int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size);
-void mmc_set_clock(struct mmc *mmc, uint clock);
+int mmc_set_clock(struct mmc *mmc, uint clock, u8 disable);
 struct mmc *find_mmc_device(int dev_num);
 int mmc_set_dev(int dev_num);
 void print_mmc_devices(char separator);
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c	2019-09-12 15:54:21.000000167 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am43xx.c	1969-12-31 19:29:28.000000729 -0600
@@ -124,6 +124,27 @@
 	writel(0x4, &cmdpll->clkselmacclk);
 }
 
+void rtc_only_enable_basic_clocks(void)
+{
+	u32 *const clk_domains[] = {
+		&cmper->emifclkstctrl,
+		0
+	};
+
+	u32 *const clk_modules_explicit_en[] = {
+		&cmper->gpio5clkctrl,
+		&cmper->emiffwclkctrl,
+		&cmper->emifclkctrl,
+		&cmper->otfaemifclkctrl,
+		0
+	};
+
+	do_enable_clocks(clk_domains, clk_modules_explicit_en, 1);
+
+	/* Select the Master osc clk as Timer2 clock source */
+	writel(0x1, &cmdpll->clktimer2clk);
+}
+
 #ifdef CONFIG_TI_EDMA3
 void enable_edma3_clocks(void)
 {
diff -u -N U-Boot_SDcard/drivers/mmc/mmc-uclass.c U-Boot_SDcard/drivers/mmc/mmc-uclass.c
--- U-Boot_SDcard/drivers/mmc/mmc-uclass.c	2019-09-12 15:54:20.000000529 -0500
+++ U-Boot_SDcard/drivers/mmc/mmc-uclass.c	1969-12-31 19:29:21.000000191 -0600
@@ -50,6 +50,22 @@
 	return dm_mmc_set_ios(mmc->dev);
 }
 
+int dm_mmc_set_vdd(struct udevice *dev, bool enable)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct dm_mmc_ops *ops = mmc_get_ops(dev);
+	int ret;
+
+	if (!ops->set_vdd)
+		return -ENOSYS;
+	return ops->set_vdd(dev, enable);
+}
+
+int mmc_set_vdd(struct mmc *mmc, bool enable)
+{
+	return dm_mmc_set_vdd(mmc->dev, enable);
+}
+
 int dm_mmc_get_wp(struct udevice *dev)
 {
 	struct dm_mmc_ops *ops = mmc_get_ops(dev);
@@ -77,8 +93,72 @@
 {
 	return dm_mmc_get_cd(mmc->dev);
 }
+
+int dm_mmc_execute_tuning(struct udevice *dev, uint opcode)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct dm_mmc_ops *ops = mmc_get_ops(dev);
+	int ret;
+
+	if (!ops->execute_tuning)
+		return -ENOSYS;
+	return ops->execute_tuning(dev, opcode);
+}
+
+int mmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	return dm_mmc_execute_tuning(mmc->dev, opcode);
+}
+
 #endif
 
+int mmc_of_parse(const void *fdt, int node, struct mmc_config *cfg)
+{
+	int val;
+
+	val = fdtdec_get_int(fdt, node, "bus-width", -1);
+	if (val < 0) {
+		printf("bus-width property missing; assuming 1 bit\n");
+		val = 1;
+	}
+
+	switch (val) {
+	case 0x8:
+		cfg->host_caps |= MMC_MODE_8BIT;
+	case 0x4:
+		cfg->host_caps |= MMC_MODE_4BIT;
+		break;
+	case 0x1:
+		break;
+	default:
+		printf("error: invalid bus-width property\n");
+		return -ENOENT;
+	}
+
+	cfg->f_max = fdtdec_get_int(fdt, node, "max-frequency", 52000000);
+
+	if (fdtdec_get_bool(fdt, node, "cap-sd-highspeed"))
+		cfg->host_caps |= MMC_MODE_HS;
+	if (fdtdec_get_bool(fdt, node, "cap-mmc-highspeed"))
+		cfg->host_caps |= MMC_MODE_HS;
+	if (fdtdec_get_bool(fdt, node, "mmc-ddr-1_8v"))
+		cfg->host_caps |= MMC_MODE_DDR_52MHz;
+	if (fdtdec_get_bool(fdt, node, "mmc-hs200-1_8v"))
+		cfg->host_caps |= MMC_MODE_HS200;
+	if (fdtdec_get_bool(fdt, node, "sd-uhs-sdr104"))
+		cfg->host_caps |= MMC_MODE_UHS_SDR104;
+	if (fdtdec_get_bool(fdt, node, "sd-uhs-sdr50"))
+		cfg->host_caps |= MMC_MODE_UHS_SDR50;
+	if (fdtdec_get_bool(fdt, node, "sd-uhs-ddr50"))
+		cfg->host_caps |= MMC_MODE_UHS_DDR50;
+	if (fdtdec_get_bool(fdt, node, "sd-uhs-sdr25"))
+		cfg->host_caps |= MMC_MODE_UHS_SDR25;
+	if (fdtdec_get_bool(fdt, node, "sd-uhs-sdr12"))
+		cfg->host_caps |= MMC_MODE_UHS_SDR12;
+
+	return 0;
+}
+
 struct mmc *mmc_get_mmc_dev(struct udevice *dev)
 {
 	struct mmc_uclass_priv *upriv;
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c
--- U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c	2019-09-12 15:54:29.000000237 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap5/hw_data.c	1969-12-31 19:29:28.000000764 -0600
@@ -28,17 +28,6 @@
 struct omap_sys_ctrl_regs const **ctrl =
 	(struct omap_sys_ctrl_regs const **)OMAP_SRAM_SCRATCH_SYS_CTRL;
 
-/* OPP HIGH FREQUENCY for ES2.0 */
-static const struct dpll_params mpu_dpll_params_1_5ghz[NUM_SYS_CLKS] = {
-	{125, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 12 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
-	{625, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 16.8 MHz */
-	{625, 7, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 19.2 MHz */
-	{750, 12, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 26 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
-	{625, 15, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}	/* 38.4 MHz */
-};
-
 /* OPP NOM FREQUENCY for ES1.0 */
 static const struct dpll_params mpu_dpll_params_800mhz[NUM_SYS_CLKS] = {
 	{200, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 12 MHz   */
@@ -50,28 +39,6 @@
 	{375, 17, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}	/* 38.4 MHz */
 };
 
-/* OPP LOW FREQUENCY for ES1.0 */
-static const struct dpll_params mpu_dpll_params_400mhz[NUM_SYS_CLKS] = {
-	{200, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 12 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
-	{1000, 20, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 16.8 MHz */
-	{375, 8, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 19.2 MHz */
-	{400, 12, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 26 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
-	{375, 17, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1}	/* 38.4 MHz */
-};
-
-/* OPP LOW FREQUENCY for ES2.0 */
-static const struct dpll_params mpu_dpll_params_499mhz[NUM_SYS_CLKS] = {
-	{499, 11, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 12 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
-	{297, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 16.8 MHz */
-	{493, 18, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 19.2 MHz */
-	{499, 25, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 26 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
-	{493, 37, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}	/* 38.4 MHz */
-};
-
 /* OPP NOM FREQUENCY for OMAP5 ES2.0, and DRA7 ES1.0 */
 static const struct dpll_params mpu_dpll_params_1ghz[NUM_SYS_CLKS] = {
 	{250, 2, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1},		/* 12 MHz   */
@@ -116,28 +83,6 @@
 	{277, 9, 2, 1, -1, 4, 62, 5, -1, 5, 4, 6},		/* 38.4 MHz */
 };
 
-static const struct dpll_params
-			core_dpll_params_2128mhz_ddr266[NUM_SYS_CLKS] = {
-	{266, 2, 4, 8, 8, 8, 62, 10, -1, 10, 14, -1},		/* 12 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
-	{443, 6, 4, 8, 8, 8, 62, 10, -1, 10, 14, -1},		/* 16.8 MHz */
-	{277, 4, 4, 8, 8, 8, 62, 10, -1, 10, 14, -1},		/* 19.2 MHz */
-	{368, 8, 4, 8, 8, 8, 62, 10, -1, 10, 14, -1},		/* 26 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
-	{277, 9, 4, 8, 8, 8, 62, 10, -1, 10, 14, -1}		/* 38.4 MHz */
-};
-
-static const struct dpll_params
-			core_dpll_params_2128mhz_ddr266_es2[NUM_SYS_CLKS] = {
-	{266, 2, 4, 8, 8, 8, 62, 5, 12, 10, 14, 12},		/* 12 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
-	{443, 6, 4, 8, 8, 8, 62, 5, 12, 10, 14, 12},		/* 16.8 MHz */
-	{277, 4, 4, 8, 8, 8, 62, 5, 12, 10, 14, 12},		/* 19.2 MHz */
-	{368, 8, 4, 8, 8, 8, 62, 5, 12, 10, 14, 12},		/* 26 MHz   */
-	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
-	{277, 9, 4, 8, 8, 8, 62, 5, 12, 10, 14, 12}		/* 38.4 MHz */
-};
-
 static const struct dpll_params per_dpll_params_768mhz[NUM_SYS_CLKS] = {
 	{32, 0, 4, 3, 6, 4, -1, 2, -1, -1, -1, -1},		/* 12 MHz   */
 	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 13 MHz   */
@@ -189,6 +134,7 @@
 };
 
 /* ABE M & N values with sys_clk as source */
+#ifdef CONFIG_SYS_OMAP_ABE_SYSCK
 static const struct dpll_params
 		abe_dpll_params_sysclk_196608khz[NUM_SYS_CLKS] = {
 	{49, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},		/* 12 MHz   */
@@ -199,11 +145,14 @@
 	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* 27 MHz   */
 	{64, 24, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1}		/* 38.4 MHz */
 };
+#endif
 
 /* ABE M & N values with 32K clock as source */
+#ifndef CONFIG_SYS_OMAP_ABE_SYSCK
 static const struct dpll_params abe_dpll_params_32k_196608khz = {
 	750, 0, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1
 };
+#endif
 
 /* ABE M & N values with sysclk2(22.5792 MHz) as input */
 static const struct dpll_params
@@ -437,17 +386,17 @@
 	setbits_le32((*prcm)->cm_l4per_gpio4_clkctrl,
 			GPIO4_CLKCTRL_OPTFCLKEN_MASK);
 
-	/* Enable 96 MHz clock for MMC1 & MMC2 */
+	/* Enable 192 MHz clock for MMC1 & MMC2 */
 	setbits_le32((*prcm)->cm_l3init_hsmmc1_clkctrl,
 			HSMMC_CLKCTRL_CLKSEL_MASK);
 	setbits_le32((*prcm)->cm_l3init_hsmmc2_clkctrl,
 			HSMMC_CLKCTRL_CLKSEL_MASK);
 
 	/* Set the correct clock dividers for mmc */
-	setbits_le32((*prcm)->cm_l3init_hsmmc1_clkctrl,
-			HSMMC_CLKCTRL_CLKSEL_DIV_MASK);
-	setbits_le32((*prcm)->cm_l3init_hsmmc2_clkctrl,
-			HSMMC_CLKCTRL_CLKSEL_DIV_MASK);
+	clrbits_le32((*prcm)->cm_l3init_hsmmc1_clkctrl,
+		     HSMMC_CLKCTRL_CLKSEL_DIV_MASK);
+	clrbits_le32((*prcm)->cm_l3init_hsmmc2_clkctrl,
+		     HSMMC_CLKCTRL_CLKSEL_DIV_MASK);
 
 	/* Select 32KHz clock as the source of GPTIMER1 */
 	setbits_le32((*prcm)->cm_wkup_gptimer1_clkctrl,
diff -u -N U-Boot_SDcard/drivers/mmc/uniphier-sd.c U-Boot_SDcard/drivers/mmc/uniphier-sd.c
--- U-Boot_SDcard/drivers/mmc/uniphier-sd.c	2019-09-12 15:54:34.000000695 -0500
+++ U-Boot_SDcard/drivers/mmc/uniphier-sd.c	1969-12-31 19:29:21.000000220 -0600
@@ -590,6 +590,8 @@
 	writel(tmp, priv->regbase + UNIPHIER_SD_CLKCTL);
 
 	udelay(1000);
+
+	return 0;
 }
 
 static int uniphier_sd_set_ios(struct udevice *dev)
diff -u -N /dev/null U-Boot_SDcard/drivers/memory/ti-gpmc.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/memory/ti-gpmc.c	1969-12-31 19:31:37.000000918 -0600
@@ -0,0 +1,77 @@
+/*
+ * TI GMPC driver
+ *
+ * (C) Copyright 2015
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/ti-common/ti-gpmc.h>
+#include <linux/mtd/omap_gpmc.h>
+
+const struct gpmc *gpmc_cfg;
+
+/*****************************************************
+ * omap_gpmc_init(): init gpmc bus
+ * Init GPMC for x16, MuxMode (SDRAM in x32).
+ * This code can only be executed from SRAM or SDRAM.
+ *****************************************************/
+/* FIXME: for now we only support one CS */
+void ti_gpmc_init(struct ti_gpmc_config *cfg)
+{
+	/* putting a blanket check on GPMC based on ZeBu for now */
+	gpmc_cfg = (struct gpmc *)TI_GPMC_BASE;
+#if defined(CONFIG_NOR)
+	u32 base = CONFIG_SYS_FLASH_BASE;
+	u32 size =	(CONFIG_SYS_FLASH_SIZE  > 0x08000000) ? GPMC_SIZE_256M :
+	/* > 64MB */	((CONFIG_SYS_FLASH_SIZE > 0x04000000) ? GPMC_SIZE_128M :
+	/* > 32MB */	((CONFIG_SYS_FLASH_SIZE > 0x02000000) ? GPMC_SIZE_64M  :
+	/* > 16MB */	((CONFIG_SYS_FLASH_SIZE > 0x01000000) ? GPMC_SIZE_32M  :
+	/* min 16MB */	GPMC_SIZE_16M)));
+#elif defined(CONFIG_NAND) || defined(CONFIG_CMD_NAND)
+/* configure GPMC for NAND */
+	u32 base = CONFIG_SYS_NAND_BASE;
+	u32 size = GPMC_SIZE_16M;
+#elif defined(CONFIG_CMD_ONENAND)
+	u32 size = GPMC_SIZE_128M;
+	u32 base = CONFIG_SYS_ONENAND_BASE;
+#else
+	u32 size = 0;
+	u32 base = 0;
+#endif
+	/* global settings */
+	writel(0x00000008, &gpmc_cfg->sysconfig);
+	writel(0x00000000, &gpmc_cfg->irqstatus);
+	writel(0x00000000, &gpmc_cfg->irqenable);
+	/* disable timeout, set a safe reset value */
+	writel(0x00001ff0, &gpmc_cfg->timeout_control);
+#ifdef CONFIG_NOR
+	writel(0x00000200, &gpmc_cfg->config);
+#else
+	writel(0x00000012, &gpmc_cfg->config);
+#endif
+	/*
+	 * Disable the GPMC0 config set by ROM code
+	 */
+	writel(0, &gpmc_cfg->cs[0].config7);
+	sdelay(1000);
+	/* enable chip-select specific configurations */
+	if (base != 0) {
+		writel(0, &gpmc_cfg->cs[0].config7);
+		sdelay(1000);
+		/* Delay for settling */
+		writel(cfg->config1, &gpmc_cfg->cs[0].config1);
+		writel(cfg->config2, &gpmc_cfg->cs[0].config2);
+		writel(cfg->config3, &gpmc_cfg->cs[0].config3);
+		writel(cfg->config4, &gpmc_cfg->cs[0].config4);
+		writel(cfg->config5, &gpmc_cfg->cs[0].config5);
+		writel(cfg->config6, &gpmc_cfg->cs[0].config6);
+		/* Enable the config */
+		writel((((size & 0xF) << 8) | ((base >> 24) & 0x3F) |
+				(1 << 6)), &gpmc_cfg->cs[0].config7);
+		sdelay(2000);
+	}
+}
diff -u -N U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h
--- U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h	2019-09-12 15:54:32.000000988 -0500
+++ U-Boot_SDcard/arch/arm/mach-davinci/include/mach/hardware.h	1969-12-31 19:29:30.000000878 -0600
@@ -475,12 +475,15 @@
 /* Boot config */
 struct davinci_syscfg_regs {
 	dv_reg	revid;
-	dv_reg	rsvd[13];
+	dv_reg	rsvd[7];
+	dv_reg	bootcfg;
+	dv_reg	chiprevidr;
+	dv_reg	rsvd2[4];
 	dv_reg	kick0;
 	dv_reg	kick1;
 	dv_reg	rsvd1[52];
 	dv_reg	mstpri[3];
-	dv_reg  rsvd2;
+	dv_reg  rsvd3;
 	dv_reg	pinmux[20];
 	dv_reg	suspsrc;
 	dv_reg	chipsig;
@@ -495,6 +498,15 @@
 #define davinci_syscfg_regs \
 	((struct davinci_syscfg_regs *)DAVINCI_BOOTCFG_BASE)
 
+enum {
+	DAVINCI_NAND8_BOOT	= 0b001110,
+	DAVINCI_NAND16_BOOT	= 0b010000,
+	DAVINCI_SD_OR_MMC_BOOT	= 0b011100,
+	DAVINCI_MMC_ONLY_BOOT	= 0b111100,
+	DAVINCI_SPI0_FLASH_BOOT	= 0b001010,
+	DAVINCI_SPI1_FLASH_BOOT	= 0b001100,
+};
+
 #define pinmux(x)	(&davinci_syscfg_regs->pinmux[x])
 
 /* Emulation suspend bits */
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c
--- U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c	2019-09-12 15:54:51.000000042 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board_k2e.c	1969-12-31 19:29:27.000000204 -0600
@@ -14,12 +14,30 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-unsigned int external_clk[ext_clk_count] = {
-	[sys_clk]	= 100000000,
-	[alt_core_clk]	= 100000000,
-	[pa_clk]	= 100000000,
-	[ddr3a_clk]	= 100000000,
-};
+unsigned int get_external_clk(u32 clk)
+{
+	unsigned int clk_freq;
+
+	switch (clk) {
+	case sys_clk:
+		clk_freq = 100000000;
+		break;
+	case alt_core_clk:
+		clk_freq = 100000000;
+		break;
+	case pa_clk:
+		clk_freq = 100000000;
+		break;
+	case ddr3a_clk:
+		clk_freq = 100000000;
+		break;
+	default:
+		clk_freq = 0;
+		break;
+	}
+
+	return clk_freq;
+}
 
 static struct pll_init_data core_pll_config[NUM_SPDS] = {
 	[SPD800]	= CORE_PLL_800,
@@ -148,6 +166,16 @@
 }
 #endif
 
+#if defined(CONFIG_FIT_EMBED)
+int board_fit_config_name_match(const char *name)
+{
+	if (!strcmp(name, "keystone-k2e-evm"))
+		return 0;
+
+	return -1;
+}
+#endif
+
 #if defined(CONFIG_BOARD_EARLY_INIT_F)
 int board_early_init_f(void)
 {
diff -u -N U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c
--- U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c	2019-09-12 15:54:23.000000628 -0500
+++ U-Boot_SDcard/board/logicpd/omap3som/omap3logic.c	1969-12-31 19:29:26.000000489 -0600
@@ -49,7 +49,8 @@
 static const struct ns16550_platdata omap3logic_serial = {
 	.base = OMAP34XX_UART1,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(omap3logic_uart) = {
@@ -244,7 +245,7 @@
 }
 #endif
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c
--- U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c	2019-09-12 15:54:43.000000140 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap5/dra7xx_iodelay.c	1969-12-31 19:29:28.000000761 -0600
@@ -272,3 +272,33 @@
 	__recalibrate_iodelay_end(ret);
 
 }
+
+void late_recalibrate_iodelay(struct pad_conf_entry const *pad, int npads,
+			   struct iodelay_cfg_entry const *iodelay,
+			   int niodelays)
+{
+	int ret = 0;
+
+	/* unlock IODELAY CONFIG registers */
+	writel(CFG_IODELAY_UNLOCK_KEY, (*ctrl)->iodelay_config_base +
+	       CFG_REG_8_OFFSET);
+
+	ret = calibrate_iodelay((*ctrl)->iodelay_config_base);
+	if (ret)
+		goto err;
+
+	ret = update_delay_mechanism((*ctrl)->iodelay_config_base);
+
+	/* Configure Mux settings */
+	do_set_mux32((*ctrl)->control_padconf_core_base, pad, npads);
+
+	/* Configure Manual IO timing modes */
+	ret = do_set_iodelay((*ctrl)->iodelay_config_base, iodelay, niodelays);
+	if (ret)
+		goto err;
+
+err:
+	/* lock IODELAY CONFIG registers */
+	writel(CFG_IODELAY_LOCK_KEY, (*ctrl)->iodelay_config_base +
+	       CFG_REG_8_OFFSET);
+}
diff -u -N U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c
--- U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c	2019-09-12 15:54:49.000000612 -0500
+++ U-Boot_SDcard/drivers/mtd/spi/spi_flash_ids.c	1969-12-31 19:29:27.000000752 -0600
@@ -84,6 +84,7 @@
 	{"mx25l12855e",	   INFO(0xc22618, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"mx66u51235f",    INFO(0xc2253a, 0x0, 64 * 1024,  1024, RD_FULL | WR_QPP) },
 	{"mx66l1g45g",     INFO(0xc2201b, 0x0, 64 * 1024,  2048, RD_FULL | WR_QPP) },
+/*	{"mx66l2g45g",     INFO(0xc2201c, 0x0, 64 * 1024,  4096, RD_FULL | WR_QPP) },  */
 #endif
 #ifdef CONFIG_SPI_FLASH_SPANSION	/* SPANSION */
 	{"s25fl008a",	   INFO(0x010213, 0x0, 64 * 1024,    16, 0) },
diff -u -N U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c
--- U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c	2019-09-12 15:54:15.000000483 -0500
+++ U-Boot_SDcard/fs/yaffs2/yaffs_uboot_glue.c	1969-12-31 19:29:21.000000904 -0600
@@ -166,11 +166,15 @@
 	char *mp = NULL;
 	struct nand_chip *chip;
 
+	mtd = get_nand_dev_by_index(flash_dev);
+	if (!mtd) {
+		error("\nno NAND devices available\n");
+		return;
+	}
+
 	dev = calloc(1, sizeof(*dev));
 	mp = strdup(_mp);
 
-	mtd = nand_info[flash_dev];
-
 	if (!dev || !mp) {
 		/* Alloc error */
 		printf("Failed to allocate memory\n");
diff -u -N U-Boot_SDcard/include/configs/omapl138_lcdk.h U-Boot_SDcard/include/configs/omapl138_lcdk.h
--- U-Boot_SDcard/include/configs/omapl138_lcdk.h	2019-09-12 15:54:54.000000794 -0500
+++ U-Boot_SDcard/include/configs/omapl138_lcdk.h	1969-12-31 19:29:22.000000372 -0600
@@ -111,7 +111,7 @@
 	(7 << DV_DDR_SDTMR2_RASMAX_SHIFT)	| \
 	(2 << DV_DDR_SDTMR2_XP_SHIFT)		| \
 	(0 << DV_DDR_SDTMR2_ODT_SHIFT)		| \
-	(10 << DV_DDR_SDTMR2_XSNR_SHIFT)	| \
+	(20 << DV_DDR_SDTMR2_XSNR_SHIFT)	| \
 	(199 << DV_DDR_SDTMR2_XSRD_SHIFT)	| \
 	(1 << DV_DDR_SDTMR2_RTP_SHIFT)		| \
 	(2 << DV_DDR_SDTMR2_CKE_SHIFT))
@@ -266,30 +266,27 @@
 #define CONFIG_CMDLINE_TAG
 #define CONFIG_REVISION_TAG
 #define CONFIG_SETUP_MEMORY_TAGS
-#define CONFIG_BOOTARGS		"console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw rootwait ip=off"
 #define CONFIG_BOOTCOMMAND \
-	"if mmc rescan; then " \
-		"run mmcboot; " \
-	"else " \
-		"run spiboot; " \
-	"fi"
+		"run envboot; " \
+		"run mmcboot; "
+
+#define DEFAULT_LINUX_BOOT_ENV \
+	"loadaddr=0xc0700000\0" \
+	"fdtaddr=0xc0600000\0" \
+	"scriptaddr=0xc0600000\0"
+
+#include <environment/ti/mmc.h>
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"fdtaddr=0xc0600000\0" \
+	DEFAULT_LINUX_BOOT_ENV \
+	DEFAULT_MMC_TI_ARGS \
+	"bootpart=0:2\0" \
+	"bootdir=/boot\0" \
+	"bootfile=zImage\0" \
 	"fdtfile=da850-lcdk.dtb\0" \
-	"fdtboot=bootz 0xc0700000 - ${fdtaddr};\0" \
-	"mmcboot=" \
-		"if fatload mmc 0 0xc0600000 boot.scr; then " \
-			"source 0xc0600000; " \
-		"else " \
-			"fatload mmc 0 0xc0700000 " \
-				__stringify(CONFIG_BOOTFILE) "; " \
-			"fatload mmc 0 ${fdtaddr} ${fdtfile}; " \
-			"run fdtboot; " \
-		"fi;\0" \
-	"spiboot=" \
-		"sf probe 0; " \
-		"sf read 0xc0700000 0x80000 0x220000; " \
-		"bootz 0xc0700000;\0"
+	"boot_fdt=yes\0" \
+	"boot_fit=0\0" \
+	"console=ttyS2,115200n8\0"
 
 /*
  * U-Boot commands
@@ -315,7 +312,8 @@
 #define CONFIG_CMD_UBIFS
 #endif
 
-#ifdef CONFIG_USE_SPIFLASH
+#ifdef CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
 #endif
 
 #if !defined(CONFIG_USE_NAND) && \
@@ -333,6 +331,8 @@
 
 #ifdef CONFIG_MMC
 #define CONFIG_DOS_PARTITION
+#define CONFIG_PARTITION_UUIDS
+#define CONFIG_CMD_PART
 #undef CONFIG_ENV_IS_IN_MMC
 #endif
 
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/clock.c U-Boot_SDcard/arch/arm/mach-keystone/clock.c
--- U-Boot_SDcard/arch/arm/mach-keystone/clock.c	2019-09-12 15:54:12.000000932 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/clock.c	1969-12-31 19:29:23.000000844 -0600
@@ -284,7 +284,7 @@
 	u32 tmp, reg;
 
 	if (pll == MAIN_PLL) {
-		ret = external_clk[sys_clk];
+		ret = get_external_clk(sys_clk);
 		if (pllctl_reg_read(pll, ctl) & PLLCTL_PLLEN_MASK) {
 			/* PLL mode */
 			tmp = __raw_readl(KS2_MAINPLLCTL0);
@@ -302,23 +302,23 @@
 	} else {
 		switch (pll) {
 		case PASS_PLL:
-			ret = external_clk[pa_clk];
+			ret = get_external_clk(pa_clk);
 			reg = KS2_PASSPLLCTL0;
 			break;
 		case TETRIS_PLL:
-			ret = external_clk[tetris_clk];
+			ret = get_external_clk(tetris_clk);
 			reg = KS2_ARMPLLCTL0;
 			break;
 		case DDR3A_PLL:
-			ret = external_clk[ddr3a_clk];
+			ret = get_external_clk(ddr3a_clk);
 			reg = KS2_DDR3APLLCTL0;
 			break;
 		case DDR3B_PLL:
-			ret = external_clk[ddr3b_clk];
+			ret = get_external_clk(ddr3b_clk);
 			reg = KS2_DDR3BPLLCTL0;
 			break;
 		case UART_PLL:
-			ret = external_clk[uart_clk];
+			ret = get_external_clk(uart_clk);
 			reg = KS2_UARTPLLCTL0;
 			break;
 		default:
diff -u -N U-Boot_SDcard/drivers/dfu/dfu.c U-Boot_SDcard/drivers/dfu/dfu.c
--- U-Boot_SDcard/drivers/dfu/dfu.c	2019-09-12 15:54:55.000000931 -0500
+++ U-Boot_SDcard/drivers/dfu/dfu.c	1969-12-31 19:29:20.000000961 -0600
@@ -35,7 +35,11 @@
  */
 __weak bool dfu_usb_get_reset(void)
 {
+#ifdef CONFIG_SPL_DFU_NO_RESET
+	return false;
+#else
 	return true;
+#endif
 }
 
 static int dfu_find_alt_num(const char *s)
diff -u -N U-Boot_SDcard/include/configs/am335x_shc.h U-Boot_SDcard/include/configs/am335x_shc.h
--- U-Boot_SDcard/include/configs/am335x_shc.h	2019-09-12 15:54:44.000000736 -0500
+++ U-Boot_SDcard/include/configs/am335x_shc.h	1969-12-31 19:29:22.000000035 -0600
@@ -279,7 +279,7 @@
 
 /* SPL */
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #ifndef CONFIG_SPL_USBETH_SUPPORT
 #define CONFIG_FASTBOOT_FLASH_MMC_DEV   1
diff -u -N U-Boot_SDcard/include/spl.h U-Boot_SDcard/include/spl.h
--- U-Boot_SDcard/include/spl.h	2019-09-12 15:54:52.000000393 -0500
+++ U-Boot_SDcard/include/spl.h	1969-12-31 19:29:19.000000360 -0600
@@ -85,7 +85,7 @@
  * This parses the legacy image header information at @header and sets up
  * @spl_image according to what is found. If no image header is found, then
  * a raw image or bootz is assumed. If CONFIG_SPL_PANIC_ON_RAW_IMAGE is
- * enabled, then this causes a panic. If CONFIG_SPL_ABORT_ON_RAW_IMAGE is
+ * enabled, then this causes a panic. If CONFIG_SPL_RAW_IMAGE_SUPPORT is not
  * enabled then U-Boot gives up. Otherwise U-Boot sets up the image using
  * spl_set_header_raw_uboot(), or possibly the bootz header.
  *
@@ -213,11 +213,29 @@
 			  struct blk_desc *block_dev, int partition);
 
 /**
+ * spl_early_init() - Set up device tree and driver model in SPL if enabled
+ *
+ * Call this function in board_init_f() if you want to use device tree and
+ * driver model early, before board_init_r() is called.
+ *
+ * If this is not called, then driver model will be inactive in SPL's
+ * board_init_f(), and no device tree will be available.
+ */
+int spl_early_init(void);
+
+/**
  * spl_init() - Set up device tree and driver model in SPL if enabled
  *
- * Call this function in board_init_f() if you want to use device tree and
- * driver model early, before board_init_r() is called. This function will
- * be called from board_init_r() if not called earlier.
+ * You can optionally call spl_early_init(), then optionally call spl_init().
+ * This function will be called from board_init_r() if not called earlier.
+ *
+ * Both spl_early_init() and spl_init() perform a similar function except that
+ * the latter will not set up the malloc() area if
+ * CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN is enabled, since it is assumed to
+ * already be done by a calll to spl_relocate_stack_gd() before board_init_r()
+ * is reached.
+ *
+ * This function will be called from board_init_r() if not called earlier.
  *
  * If this is not called, then driver model will be inactive in SPL's
  * board_init_f(), and no device tree will be available.
diff -u -N U-Boot_SDcard/drivers/mtd/nand/Makefile U-Boot_SDcard/drivers/mtd/nand/Makefile
--- U-Boot_SDcard/drivers/mtd/nand/Makefile	2019-09-12 15:54:27.000000709 -0500
+++ U-Boot_SDcard/drivers/mtd/nand/Makefile	1969-12-31 19:29:27.000000686 -0600
@@ -1,80 +1,82 @@
-#
-# (C) Copyright 2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-ifdef CONFIG_SPL_BUILD
-
-ifdef CONFIG_SPL_NAND_DRIVERS
-NORMAL_DRIVERS=y
-endif
-
-obj-$(CONFIG_SPL_NAND_AM33XX_BCH) += am335x_spl_bch.o
-obj-$(CONFIG_SPL_NAND_DENALI) += denali_spl.o
-obj-$(CONFIG_SPL_NAND_SIMPLE) += nand_spl_simple.o
-obj-$(CONFIG_SPL_NAND_LOAD) += nand_spl_load.o
-obj-$(CONFIG_SPL_NAND_ECC) += nand_ecc.o
-obj-$(CONFIG_SPL_NAND_BASE) += nand_base.o
-obj-$(CONFIG_SPL_NAND_INIT) += nand.o
-ifeq ($(CONFIG_SPL_ENV_SUPPORT),y)
-obj-$(CONFIG_ENV_IS_IN_NAND) += nand_util.o
-endif
-
-else # not spl
-
-NORMAL_DRIVERS=y
-
-obj-y += nand.o
-obj-y += nand_bbt.o
-obj-y += nand_ids.o
-obj-y += nand_util.o
-obj-y += nand_ecc.o
-obj-y += nand_base.o
-obj-y += nand_timings.o
-
-endif # not spl
-
-ifdef NORMAL_DRIVERS
-
-obj-$(CONFIG_NAND_ECC_BCH) += nand_bch.o
-
-obj-$(CONFIG_NAND_ATMEL) += atmel_nand.o
-obj-$(CONFIG_NAND_ARASAN) += arasan_nfc.o
-obj-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
-obj-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
-obj-$(CONFIG_NAND_DENALI) += denali.o
-obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
-obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_nand.o
-obj-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
-obj-$(CONFIG_NAND_FSMC) += fsmc_nand.o
-obj-$(CONFIG_NAND_KB9202) += kb9202_nand.o
-obj-$(CONFIG_NAND_KIRKWOOD) += kirkwood_nand.o
-obj-$(CONFIG_NAND_KMETER1) += kmeter1_nand.o
-obj-$(CONFIG_NAND_LPC32XX_MLC) += lpc32xx_nand_mlc.o
-obj-$(CONFIG_NAND_LPC32XX_SLC) += lpc32xx_nand_slc.o
-obj-$(CONFIG_NAND_MPC5121_NFC) += mpc5121_nfc.o
-obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
-obj-$(CONFIG_NAND_MXC) += mxc_nand.o
-obj-$(CONFIG_NAND_MXS) += mxs_nand.o
-obj-$(CONFIG_NAND_NDFC) += ndfc.o
-obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o
-obj-$(CONFIG_NAND_S3C2410) += s3c2410_nand.o
-obj-$(CONFIG_NAND_SPEAR) += spr_nand.o
-obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o
-obj-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
-obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
-obj-$(CONFIG_NAND_PLAT) += nand_plat.o
-obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
-obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
-
-else  # minimal SPL drivers
-
-obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
-obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_spl.o
-obj-$(CONFIG_NAND_MXC) += mxc_nand_spl.o
-obj-$(CONFIG_NAND_MXS) += mxs_nand_spl.o mxs_nand.o
-obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_spl.o
-
-endif # drivers
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+
+ifdef CONFIG_SPL_NAND_DRIVERS
+NORMAL_DRIVERS=y
+endif
+
+obj-$(CONFIG_SPL_NAND_AM33XX_BCH) += am335x_spl_bch.o
+obj-$(CONFIG_SPL_NAND_DENALI) += denali_spl.o
+obj-$(CONFIG_SPL_NAND_SIMPLE) += nand_spl_simple.o
+obj-$(CONFIG_SPL_NAND_LOAD) += nand_spl_load.o
+obj-$(CONFIG_SPL_NAND_ECC) += nand_ecc.o
+obj-$(CONFIG_SPL_NAND_BASE) += nand_base.o
+obj-$(CONFIG_SPL_NAND_INIT) += nand.o
+ifeq ($(CONFIG_SPL_ENV_SUPPORT),y)
+obj-$(CONFIG_ENV_IS_IN_NAND) += nand_util.o
+endif
+
+else # not spl
+
+NORMAL_DRIVERS=y
+
+obj-y += nand.o
+obj-y += nand_bbt.o
+obj-y += nand_ids.o
+obj-y += nand_util.o
+obj-y += nand_ecc.o
+obj-y += nand_base.o
+obj-y += nand_timings.o
+
+endif # not spl
+
+ifdef NORMAL_DRIVERS
+
+obj-$(CONFIG_DM_NAND) += nand-uclass.o
+
+obj-$(CONFIG_NAND_ECC_BCH) += nand_bch.o
+
+obj-$(CONFIG_NAND_ATMEL) += atmel_nand.o
+obj-$(CONFIG_NAND_ARASAN) += arasan_nfc.o
+obj-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
+obj-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
+obj-$(CONFIG_NAND_DENALI) += denali.o
+obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
+obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_nand.o
+obj-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
+obj-$(CONFIG_NAND_FSMC) += fsmc_nand.o
+obj-$(CONFIG_NAND_KB9202) += kb9202_nand.o
+obj-$(CONFIG_NAND_KIRKWOOD) += kirkwood_nand.o
+obj-$(CONFIG_NAND_KMETER1) += kmeter1_nand.o
+obj-$(CONFIG_NAND_LPC32XX_MLC) += lpc32xx_nand_mlc.o
+obj-$(CONFIG_NAND_LPC32XX_SLC) += lpc32xx_nand_slc.o
+obj-$(CONFIG_NAND_MPC5121_NFC) += mpc5121_nfc.o
+obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
+obj-$(CONFIG_NAND_MXC) += mxc_nand.o
+obj-$(CONFIG_NAND_MXS) += mxs_nand.o
+obj-$(CONFIG_NAND_NDFC) += ndfc.o
+obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o
+obj-$(CONFIG_NAND_S3C2410) += s3c2410_nand.o
+obj-$(CONFIG_NAND_SPEAR) += spr_nand.o
+obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o
+obj-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
+obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
+obj-$(CONFIG_NAND_PLAT) += nand_plat.o
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
+obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
+
+else  # minimal SPL drivers
+
+obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
+obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_spl.o
+obj-$(CONFIG_NAND_MXC) += mxc_nand_spl.o
+obj-$(CONFIG_NAND_MXS) += mxs_nand_spl.o mxs_nand.o
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_spl.o
+
+endif # drivers
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h	2019-09-12 15:54:31.000000397 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-omap5/clock.h	1969-12-31 19:29:30.000000537 -0600
@@ -135,7 +135,7 @@
 
 /* CM_L3INIT_HSMMCn_CLKCTRL */
 #define HSMMC_CLKCTRL_CLKSEL_MASK		(1 << 24)
-#define HSMMC_CLKCTRL_CLKSEL_DIV_MASK		(1 << 25)
+#define HSMMC_CLKCTRL_CLKSEL_DIV_MASK		(3 << 25)
 
 /* CM_L3INIT_SATA_CLKCTRL */
 #define SATA_CLKCTRL_OPTFCLKEN_MASK		(1 << 8)
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c
--- U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c	2019-09-12 15:54:49.000000711 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/ddr3.c	1969-12-31 19:29:23.000000850 -0600
@@ -52,8 +52,7 @@
 	__raw_writel(phy_cfg->dtpr2, base + KS2_DDRPHY_DTPR2_OFFSET);
 	__raw_writel(phy_cfg->mr0,   base + KS2_DDRPHY_MR0_OFFSET);
 	__raw_writel(phy_cfg->mr1,   base + KS2_DDRPHY_MR1_OFFSET);
-	if (!cpu_is_k2g())
-		__raw_writel(phy_cfg->mr2,   base + KS2_DDRPHY_MR2_OFFSET);
+	__raw_writel(phy_cfg->mr2,   base + KS2_DDRPHY_MR2_OFFSET);
 	__raw_writel(phy_cfg->dtcr,  base + KS2_DDRPHY_DTCR_OFFSET);
 	__raw_writel(phy_cfg->pgcr2, base + KS2_DDRPHY_PGCR2_OFFSET);
 
@@ -66,11 +65,33 @@
 		;
 
 	if (cpu_is_k2g()) {
-		setbits_le32(base + KS2_DDRPHY_DATX8_4_OFFSET, 0x1);
-		clrbits_le32(base + KS2_DDRPHY_DATX8_5_OFFSET, 0x1);
-		clrbits_le32(base + KS2_DDRPHY_DATX8_6_OFFSET, 0x1);
-		clrbits_le32(base + KS2_DDRPHY_DATX8_7_OFFSET, 0x1);
-		clrbits_le32(base + KS2_DDRPHY_DATX8_8_OFFSET, 0x1);
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_2_OFFSET,
+				phy_cfg->datx8_2_mask,
+				phy_cfg->datx8_2_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_3_OFFSET,
+				phy_cfg->datx8_3_mask,
+				phy_cfg->datx8_3_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_4_OFFSET,
+				phy_cfg->datx8_4_mask,
+				phy_cfg->datx8_4_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_5_OFFSET,
+				phy_cfg->datx8_5_mask,
+				phy_cfg->datx8_5_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_6_OFFSET,
+				phy_cfg->datx8_6_mask,
+				phy_cfg->datx8_6_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_7_OFFSET,
+				phy_cfg->datx8_7_mask,
+				phy_cfg->datx8_7_val);
+
+		clrsetbits_le32(base + KS2_DDRPHY_DATX8_8_OFFSET,
+				phy_cfg->datx8_8_mask,
+				phy_cfg->datx8_8_val);
 	}
 
 	__raw_writel(phy_cfg->pir_v2, base + KS2_DDRPHY_PIR_OFFSET);
diff -u -N U-Boot_SDcard/board/BuR/common/common.c U-Boot_SDcard/board/BuR/common/common.c
--- U-Boot_SDcard/board/BuR/common/common.c	2019-09-12 15:54:53.000000129 -0500
+++ U-Boot_SDcard/board/BuR/common/common.c	1969-12-31 19:29:24.000000534 -0600
@@ -684,7 +684,7 @@
 	return rv;
 }
 #endif /* defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD) */
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(1, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/board/ti/panda/panda.c U-Boot_SDcard/board/ti/panda/panda.c
--- U-Boot_SDcard/board/ti/panda/panda.c	2019-09-12 15:54:29.000000616 -0500
+++ U-Boot_SDcard/board/ti/panda/panda.c	1969-12-31 19:29:27.000000224 -0600
@@ -287,17 +287,19 @@
 			   sizeof(struct pad_conf_entry));
 }
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 void board_mmc_power_init(void)
 {
 	twl6030_power_mmc_init(0);
 }
 #endif
+#endif
 
 #ifdef CONFIG_USB_EHCI
 
diff -u -N U-Boot_SDcard/arch/arm/mach-davinci/spl.c U-Boot_SDcard/arch/arm/mach-davinci/spl.c
--- U-Boot_SDcard/arch/arm/mach-davinci/spl.c	2019-09-12 15:54:49.000000357 -0500
+++ U-Boot_SDcard/arch/arm/mach-davinci/spl.c	1969-12-31 19:29:23.000000813 -0600
@@ -52,14 +52,27 @@
 
 u32 spl_boot_device(void)
 {
-#ifdef CONFIG_SPL_NAND_SIMPLE
-	return BOOT_DEVICE_NAND;
-#elif defined(CONFIG_SPL_SPI_LOAD)
-	return BOOT_DEVICE_SPI;
-#elif defined(CONFIG_SPL_MMC_LOAD)
-	return BOOT_DEVICE_MMC1;
-#else
-	puts("Unknown boot device\n");
-	hang();
+	switch (davinci_syscfg_regs->bootcfg) {
+#ifdef CONFIG_SPL_NAND_SUPPORT
+	case DAVINCI_NAND8_BOOT:
+	case DAVINCI_NAND16_BOOT:
+		return BOOT_DEVICE_NAND;
+#endif
+
+#ifdef CONFIG_SPL_MMC_SUPPORT
+	case DAVINCI_SD_OR_MMC_BOOT:
+	case DAVINCI_MMC_ONLY_BOOT:
+		return BOOT_DEVICE_MMC1;
+#endif
+
+#ifdef CONFIG_SPL_SPI_FLASH_SUPPORT
+	case DAVINCI_SPI0_FLASH_BOOT:
+	case DAVINCI_SPI1_FLASH_BOOT:
+		return BOOT_DEVICE_SPI;
 #endif
+
+	default:
+		puts("Unknown boot device\n");
+		hang();
+	}
 }
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h	2019-09-12 15:54:19.000000315 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/sys_proto.h	1969-12-31 19:29:30.000000345 -0600
@@ -46,3 +46,4 @@
 void enable_usb_clocks(int index);
 void disable_usb_clocks(int index);
 void do_board_detect(void);
+u32 get_sys_clk_index(void);
diff -u -N U-Boot_SDcard/scripts/checkpatch.pl U-Boot_SDcard/scripts/checkpatch.pl
--- U-Boot_SDcard/scripts/checkpatch.pl	2019-09-12 15:54:56.000000635 -0500
+++ U-Boot_SDcard/scripts/checkpatch.pl	1969-12-31 19:29:19.000000550 -0600
@@ -7,9 +7,12 @@
 
 use strict;
 use POSIX;
+use File::Basename;
+use Cwd 'abs_path';
 
 my $P = $0;
 $P =~ s@.*/@@g;
+my $D = dirname(abs_path($P));
 
 my $V = '0.32';
 
@@ -42,6 +45,9 @@
 my $max_line_length = 80;
 my $ignore_perl_version = 0;
 my $minimum_perl_version = 5.10.0;
+my $spelling_file = "$D/spelling.txt";
+my $codespell = 0;
+my $codespellfile = "/usr/share/codespell/dictionary.txt";
 
 sub help {
 	my ($exitcode) = @_;
@@ -82,6 +88,9 @@
                              file.  It's your fault if there's no backup or git
   --ignore-perl-version      override checking of perl version.  expect
                              runtime errors.
+  --codespell                Use the codespell dictionary for spelling/typos
+                             (default:/usr/local/share/codespell/dictionary.txt)
+  --codespellfile            Use this codespell dictionary
   -h, --help, --version      display this help and exit
 
 When FILE is - read standard input.
@@ -139,6 +148,8 @@
 	'ignore-perl-version!' => \$ignore_perl_version,
 	'debug=s'	=> \%debug,
 	'test-only=s'	=> \$tst_only,
+	'codespell!'    => \$codespell,
+	'codespellfile=s' => \$codespellfile,
 	'h|help'	=> \$help,
 	'version'	=> \$help
 ) or help(1);
@@ -387,6 +398,56 @@
 )};
 # memory.h: ARM has a custom one
 
+# Load common spelling mistakes and build regular expression list.
+my $misspellings;
+my %spelling_fix;
+
+if (open(my $spelling, '<', $spelling_file)) {
+	while (<$spelling>) {
+		my $line = $_;
+
+		$line =~ s/\s*\n?$//g;
+		$line =~ s/^\s*//g;
+
+		next if ($line =~ m/^\s*#/);
+		next if ($line =~ m/^\s*$/);
+
+		my ($suspect, $fix) = split(/\|\|/, $line);
+
+		$spelling_fix{$suspect} = $fix;
+	}
+	close($spelling);
+} else {
+	warn "No typos will be found - file '$spelling_file': $!\n";
+}
+
+if ($codespell) {
+	if (open(my $spelling, '<', $codespellfile)) {
+		while (<$spelling>) {
+			my $line = $_;
+
+			$line =~ s/\s*\n?$//g;
+			$line =~ s/^\s*//g;
+
+			next if ($line =~ m/^\s*#/);
+			next if ($line =~ m/^\s*$/);
+			next if ($line =~ m/, disabled/i);
+
+			$line =~ s/,.*$//;
+
+			my ($suspect, $fix) = split(/->/, $line);
+
+			$spelling_fix{$suspect} = $fix;
+		}
+		close($spelling);
+	} else {
+		warn "No codespell typos will be found - file '$codespellfile': $!\n";
+	}
+}
+
+$misspellings = join("|", sort keys %spelling_fix) if keys %spelling_fix;
+
+
 sub build_types {
 	my $mods = "(?x:  \n" . join("|\n  ", @modifierList) . "\n)";
 	my $all = "(?x:  \n" . join("|\n  ", @typeList) . "\n)";
@@ -528,6 +589,8 @@
 my @lines = ();
 my @fixed = ();
 my $vname;
+my $fixlinenr = -1;
+
 for my $filename (@ARGV) {
 	my $FILE;
 	if ($file) {
@@ -1950,6 +2013,24 @@
 			    "8-bit UTF-8 used in possible commit log\n" . $herecurr);
 		}
 
+# Check for various typo / spelling mistakes
+		if (defined($misspellings) &&
+		    ($in_commit_log || $line =~ /^(?:\+|Subject:)/i)) {
+			while ($rawline =~ /(?:^|[^a-z@])($misspellings)(?:\b|$|[^a-z@])/gi) {
+				my $typo = $1;
+				my $typo_fix = $spelling_fix{lc($typo)};
+				$typo_fix = ucfirst($typo_fix) if ($typo =~ /^[A-Z]/);
+				$typo_fix = uc($typo_fix) if ($typo =~ /^[A-Z]+$/);
+				my $msg_type = \&WARN;
+				$msg_type = \&CHK if ($file);
+				if (&{$msg_type}("TYPO_SPELLING",
+						 "'$typo' may be misspelled - perhaps '$typo_fix'?\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;
+				}
+			}
+		}
+
 # ignore non-hunk lines and lines being removed
 		next if (!$hunk_line || $line =~ /^-/);
 
diff -u -N U-Boot_SDcard/drivers/mtd/nand/nand.c U-Boot_SDcard/drivers/mtd/nand/nand.c
--- U-Boot_SDcard/drivers/mtd/nand/nand.c	2019-09-12 15:54:16.000000999 -0500
+++ U-Boot_SDcard/drivers/mtd/nand/nand.c	1969-12-31 19:29:27.000000712 -0600
@@ -19,10 +19,9 @@
 
 int nand_curr_device = -1;
 
-
 struct mtd_info *nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
 
-#ifndef CONFIG_SYS_NAND_SELF_INIT
+#if !defined(CONFIG_SYS_NAND_SELF_INIT) && !defined(CONFIG_DM_NAND)
 static struct nand_chip nand_chip[CONFIG_SYS_MAX_NAND_DEVICE];
 static ulong base_address[CONFIG_SYS_MAX_NAND_DEVICE] = CONFIG_SYS_NAND_BASE_LIST;
 #endif
@@ -31,12 +30,23 @@
 
 static unsigned long total_nand_size; /* in kiB */
 
+#ifndef CONFIG_DM_NAND
+struct mtd_info *get_nand_dev_by_index(int dev)
+{
+	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[dev] ||
+	    !nand_info[dev]->name)
+		return NULL;
+
+	return nand_info[dev];
+}
+#endif
+
 int nand_mtd_to_devnum(struct mtd_info *mtd)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(nand_info); i++) {
-		if (mtd && nand_info[i] == mtd)
+	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
+		if (mtd && get_nand_dev_by_index(i) == mtd)
 			return i;
 	}
 
@@ -49,8 +59,9 @@
 	if (devnum >= CONFIG_SYS_MAX_NAND_DEVICE)
 		return -EINVAL;
 
+#if !defined(CONFIG_SYS_NAND_SELF_INIT) && !defined(CONFIG_DM_NAND)
 	nand_info[devnum] = mtd;
-
+#endif
 	sprintf(dev_name[devnum], "nand%d", devnum);
 	mtd->name = dev_name[devnum];
 
@@ -73,18 +84,28 @@
 #ifndef CONFIG_SYS_NAND_SELF_INIT
 static void nand_init_chip(int i)
 {
+#ifndef CONFIG_DM_NAND
 	struct nand_chip *nand = &nand_chip[i];
 	struct mtd_info *mtd = nand_to_mtd(nand);
 	ulong base_addr = base_address[i];
+#else
+	struct mtd_info *mtd;
+#endif
 	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;
 
 	if (maxchips < 1)
 		maxchips = 1;
 
+#ifdef CONFIG_DM_NAND
+	mtd = get_nand_dev_by_index(i);
+	if (!mtd)
+		return;
+#else
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
 
 	if (board_nand_init(nand))
 		return;
+#endif
 
 	if (nand_scan(mtd, maxchips))
 		return;
@@ -101,8 +122,9 @@
 	int i;
 
 	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
-		if (nand_info[i] != NULL) {
-			nand_info_list[nand_devices_found] = nand_info[i];
+		struct mtd_info *mtd = get_nand_dev_by_index(i);
+		if (mtd != NULL) {
+			nand_info_list[nand_devices_found] = mtd;
 			nand_devices_found++;
 		}
 	}
@@ -148,7 +170,7 @@
 	/*
 	 * Select the chip in the board/cpu specific driver
 	 */
-	board_nand_select_device(mtd_to_nand(nand_info[nand_curr_device]),
+	board_nand_select_device(mtd_to_nand(get_nand_dev_by_index(nand_curr_device)),
 				 nand_curr_device);
 #endif
 
diff -u -N U-Boot_SDcard/common/spl/spl_fat.c U-Boot_SDcard/common/spl/spl_fat.c
--- U-Boot_SDcard/common/spl/spl_fat.c	2019-09-12 15:54:46.000000589 -0500
+++ U-Boot_SDcard/common/spl/spl_fat.c	1969-12-31 19:29:20.000000769 -0600
@@ -19,7 +19,6 @@
 
 static int fat_registered;
 
-#ifdef CONFIG_SPL_FAT_SUPPORT
 static int spl_register_fat_device(struct blk_desc *block_dev, int partition)
 {
 	int err = 0;
@@ -160,4 +159,3 @@
 	return -ENOSYS;
 }
 #endif
-#endif
diff -u -N U-Boot_SDcard/board/ti/am43xx/board.c U-Boot_SDcard/board/ti/am43xx/board.c
--- U-Boot_SDcard/board/ti/am43xx/board.c	2019-09-12 15:54:21.000000087 -0500
+++ U-Boot_SDcard/board/ti/am43xx/board.c	1969-12-31 19:29:27.000000169 -0600
@@ -49,8 +49,6 @@
 
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 
-#define NUM_OPPS	6
-
 const struct dpll_params dpll_mpu[NUM_CRYSTAL_FREQ][NUM_OPPS] = {
 	{	/* 19.2 MHz */
 		{125, 3, 2, -1, -1, -1, -1},	/* OPP 50 */
@@ -317,25 +315,6 @@
 	return;
 }
 
-/*
- * get_sys_clk_index : returns the index of the sys_clk read from
- *			ctrl status register. This value is either
- *			read from efuse or sysboot pins.
- */
-static u32 get_sys_clk_index(void)
-{
-	struct ctrl_stat *ctrl = (struct ctrl_stat *)CTRL_BASE;
-	u32 ind = readl(&ctrl->statusreg), src;
-
-	src = (ind & CTRL_CRYSTAL_FREQ_SRC_MASK) >> CTRL_CRYSTAL_FREQ_SRC_SHIFT;
-	if (src == CTRL_CRYSTAL_FREQ_SRC_EFUSE) /* Value read from EFUSE */
-		return ((ind & CTRL_CRYSTAL_FREQ_SELECTION_MASK) >>
-			CTRL_CRYSTAL_FREQ_SELECTION_SHIFT);
-	else /* Value read from SYS BOOT pins */
-		return ((ind & CTRL_SYSBOOT_15_14_MASK) >>
-			CTRL_SYSBOOT_15_14_SHIFT);
-}
-
 const struct dpll_params *get_dpll_ddr_params(void)
 {
 	int ind = get_sys_clk_index();
@@ -441,6 +420,13 @@
 		printf("%s failure\n", __func__);
 		return;
 	}
+
+	/* Set DCDC3 (DDR) voltage */
+	if (tps65218_voltage_update(TPS65218_DCDC3,
+	    TPS65218_DCDC3_VOLT_SEL_1350MV)) {
+		printf("%s failure\n", __func__);
+		return;
+	}
 }
 
 void scale_vcores_idk(u32 m)
@@ -532,6 +518,62 @@
 	writel(temp, AM33XX_GPIO5_BASE + OMAP_GPIO_OE);
 }
 
+enum {
+	RTC_BOARD_EPOS = 1,
+	RTC_BOARD_EVM14,
+	RTC_BOARD_EVM12,
+	RTC_BOARD_GPEVM,
+	RTC_BOARD_SK,
+};
+
+/*
+ * In the rtc_only boot path we have the board type info in the rtc scratch pad
+ * register hence we bypass the costly i2c reads to eeprom and directly program
+ * the board name string
+ */
+void rtc_only_update_board_type(u32 btype)
+{
+	const char *name = "";
+	const char *rev = "1.0";
+
+	switch (btype) {
+	case RTC_BOARD_EPOS:
+		name = "AM43EPOS";
+		break;
+	case RTC_BOARD_EVM14:
+		name = "AM43__GP";
+		rev = "1.4";
+		break;
+	case RTC_BOARD_EVM12:
+		name = "AM43__GP";
+		rev = "1.2";
+		break;
+	case RTC_BOARD_GPEVM:
+		name = "AM43__GP";
+		break;
+	case RTC_BOARD_SK:
+		name = "AM43__SK";
+		break;
+	}
+	ti_i2c_eeprom_am_set(name, rev);
+}
+
+u32 rtc_only_get_board_type(void)
+{
+	if (board_is_eposevm())
+		return RTC_BOARD_EPOS;
+	else if (board_is_evm_14_or_later())
+		return RTC_BOARD_EVM14;
+	else if (board_is_evm_12_or_later())
+		return RTC_BOARD_EVM12;
+	else if (board_is_gpevm())
+		return RTC_BOARD_GPEVM;
+	else if (board_is_sk())
+		return RTC_BOARD_SK;
+
+	return 0;
+}
+
 void sdram_init(void)
 {
 	/*
@@ -747,8 +789,9 @@
 }
 #endif /* defined(CONFIG_USB_DWC3) || defined(CONFIG_USB_XHCI_OMAP) */
 
-#ifdef CONFIG_DRIVER_TI_CPSW
-
+#ifndef CONFIG_DM_ETH
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
 static void cpsw_control(int enabled)
 {
 	/* Additional controls can be added here */
@@ -786,7 +829,25 @@
 	.host_port_num		= 0,
 	.version		= CPSW_CTRL_VERSION_2,
 };
+#endif
+
 
+/*
+ * This function will:
+ * Read the eFuse for MAC addresses, and set ethaddr/eth1addr/usbnet_devaddr
+ * in the environment
+ * Perform fixups to the PHY present on certain boards.  We only need this
+ * function in:
+ * - SPL with either CPSW or USB ethernet support
+ * - Full U-Boot, with either CPSW or USB ethernet
+ * Build in only these cases to avoid warnings about unused variables
+ * when we build an SPL that has neither option but full U-Boot will.
+ */
+#if ((defined(CONFIG_SPL_ETH_SUPPORT) || \
+	defined(CONFIG_SPL_USBETH_SUPPORT)) && \
+	defined(CONFIG_SPL_BUILD)) || \
+	((defined(CONFIG_DRIVER_TI_CPSW) || \
+	  defined(CONFIG_USB_ETHER)) && !defined(CONFIG_SPL_BUILD))
 int board_eth_init(bd_t *bis)
 {
 	int rv;
@@ -803,12 +864,15 @@
 	mac_addr[4] = mac_lo & 0xFF;
 	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
 
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
 	if (!getenv("ethaddr")) {
 		puts("<ethaddr> not set. Validating first E-fuse MAC\n");
 		if (is_valid_ethaddr(mac_addr))
 			eth_setenv_enetaddr("ethaddr", mac_addr);
 	}
 
+#ifndef CONFIG_SPL_BUILD
 	mac_lo = readl(&cdev->macid1l);
 	mac_hi = readl(&cdev->macid1h);
 	mac_addr[0] = mac_hi & 0xFF;
@@ -822,7 +886,7 @@
 		if (is_valid_ethaddr(mac_addr))
 			eth_setenv_enetaddr("eth1addr", mac_addr);
 	}
-
+#endif
 	if (board_is_eposevm()) {
 		writel(RMII_MODE_ENABLE | RMII_CHIPCKL_ENABLE, &cdev->miisel);
 		cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RMII;
@@ -843,13 +907,35 @@
 	}
 
 	rv = cpsw_register(&cpsw_data);
+	if (rv < 0) {
+		printf("Error %d registering CPSW switch\n", rv);
+		return rv;
+	}
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	if (is_valid_ethaddr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
 	if (rv < 0)
-		printf("Error %d registering CPSW switch\n", rv);
+		printf("Error %d registering USB_ETHER\n", rv);
+#endif
 
 	return rv;
 }
 #endif
+#endif
 
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	ft_cpu_setup(blob, bd);
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_SPL_LOAD_FIT
 int board_fit_config_name_match(const char *name)
 {
@@ -871,4 +957,11 @@
 {
 	secure_boot_verify_image(p_image, p_size);
 }
+
+void board_tee_image_process(ulong tee_image, size_t tee_size)
+{
+	secure_tee_install((u32)tee_image);
+}
+
+U_BOOT_FIT_LOADABLE_HANDLER(IH_TYPE_TEE, board_tee_image_process);
 #endif
diff -u -N U-Boot_SDcard/include/configs/k2g_evm.h U-Boot_SDcard/include/configs/k2g_evm.h
--- U-Boot_SDcard/include/configs/k2g_evm.h	2019-09-12 15:54:55.000000890 -0500
+++ U-Boot_SDcard/include/configs/k2g_evm.h	1969-12-31 19:29:22.000000247 -0600
@@ -10,14 +10,20 @@
 #ifndef __CONFIG_K2G_EVM_H
 #define __CONFIG_K2G_EVM_H
 
+#include <environment/ti/mmc.h>
+
 /* Platform type */
 #define CONFIG_SOC_K2G
 
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
 /* U-Boot general configuration */
 #define CONFIG_EXTRA_ENV_KS2_BOARD_SETTINGS				\
 	DEFAULT_MMC_TI_ARGS						\
 	DEFAULT_PMMC_BOOT_ENV						\
 	DEFAULT_FW_INITRAMFS_BOOT_ENV					\
+	DEFAULT_FIT_TI_ARGS						\
 	"boot=mmc\0"							\
 	"console=ttyS0,115200n8\0"					\
 	"bootpart=0:2\0"						\
@@ -25,7 +31,14 @@
 	"rd_spec=-\0"							\
 	"args_ubi=setenv bootargs ${bootargs} rootfstype=ubifs "	\
 	"root=ubi0:rootfs rootflags=sync rw ubi.mtd=ubifs,2048\0"	\
-	"name_fdt=keystone-k2g-evm.dtb\0"				\
+	"findfdt="\
+		"if test $board_name = 66AK2GGP; then " \
+			 "setenv name_fdt keystone-k2g-evm.dtb; " \
+		"else if test $board_name = 66AK2GIC; then " \
+			 "setenv name_fdt keystone-k2g-ice.dtb; " \
+		"else if test $name_fdt = undefined; then " \
+			"echo WARNING: Could not determine device tree to use;"\
+		"fi;fi;fi; setenv fdtfile ${name_fdt}\0" \
 	"name_mon=skern-k2g.bin\0"					\
 	"name_ubi=k2g-evm-ubifs.ubi\0"					\
 	"name_uboot=u-boot-spi-k2g-evm.gph\0"				\
@@ -39,20 +52,32 @@
 	"get_mon_mmc=load mmc ${bootpart} ${addr_mon} ${bootdir}/${name_mon}\0"\
 	"name_fs=arago-base-tisdk-image-k2g-evm.cpio\0"
 
+#ifndef CONFIG_TI_SECURE_DEVICE
+#define CONFIG_BOOTCOMMAND						\
+	"run findfdt; "							\
+	"run envboot; "							\
+	"run init_${boot}; "						\
+	"run get_mon_${boot} run_mon; "					\
+	"run set_name_pmmc get_pmmc_${boot} run_pmmc; "			\
+	"run get_kern_${boot}; "					\
+	"run init_fw_rd_${boot}; "					\
+	"run get_fdt_${boot}; "						\
+	"run run_kern"
+#else
 #define CONFIG_BOOTCOMMAND						\
+	"run findfdt; "							\
 	"run envboot; "							\
-	"run set_name_pmmc init_${boot} init_fw_rd_${boot} "		\
-	"get_pmmc_${boot} run_pmmc get_mon_${boot} run_mon "		\
-	"get_fdt_${boot} get_kern_${boot} run_kern"
+	"run run_mon_hs; "						\
+	"run init_${boot}; "						\
+	"run get_fit_${boot}; "						\
+	"bootm ${fit_loadaddr}#${name_fdt}"
+#endif
 
 #include <configs/ti_armv7_keystone2.h>
 
 /* SPL SPI Loader Configuration */
 #define CONFIG_SPL_TEXT_BASE		0x0c080000
 
-/* NAND Configuration */
-#define CONFIG_SYS_NAND_PAGE_2K
-
 /* Network */
 #define CONFIG_KSNET_NETCP_V1_5
 #define CONFIG_KSNET_CPSW_NUM_PORTS	2
@@ -80,4 +105,53 @@
 #define CONFIG_BOUNCE_BUFFER
 #endif
 
+/* NAND */
+#define CONFIG_SYS_MAX_NAND_DEVICE      1
+#define CONFIG_MTD_DEVICE               /* Required for mtdparts */
+#define CONFIG_CMD_MTDPARTS
+
+/* NAND: device related configs - Micron MT29F2G16ABAFAWP */
+#define CONFIG_SYS_NAND_PAGE_SIZE       2048
+#define CONFIG_SYS_NAND_OOBSIZE         224
+#define CONFIG_SYS_NAND_BLOCK_SIZE      (128*1024)
+#define CONFIG_SYS_NAND_PAGE_COUNT      (CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+/* NAND: driver related configs */
+#define TI_GPMC_BASE			KS2_GPMC_BASE
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_BASE		0x30000000
+#define CONFIG_SYS_NAND_BUSWIDTH_16BIT
+#define CONFIG_NAND_OMAP_ELM
+#define ELM_BASE			0x021c8000
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_NAND_OMAP_ECCSCHEME      OMAP_ECC_BCH16_CODE_HW
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS   NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS  { 2, 3, 4, 5, 6, 7, 8, 9, \
+				  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, \
+				  20, 21, 22, 23, 24, 25, 26, 27, 28, 29, \
+				  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \
+				  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, \
+				  50, 51, 52, 53, 54, 55, 56, 57, 58, 59, \
+				  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, \
+				  70, 71, 72, 73, 74, 75, 76, 77, 78, 79, \
+				  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, \
+				  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, \
+				  100, 101, 102, 103, 104, 105, 106, 107, 108, \
+				  109, 110, 111, 112, 113, 114, 115, 116, 117, \
+				  118, 119, 120, 121, 122, 123, 124, 125, 126, \
+				  127, 128, 129, 130, 131, 132, 133, 134, 135, \
+				  136, 137, 138, 139, 140, 141, 142, 143, 144, \
+				  145, 146, 147, 148, 149, 150, 151, 152, 153, \
+				  154, 155, 156, 157, 158, 159, 160, 161, 162, \
+				  163, 164, 165, 166, 167, 168, 169, 170, 171, \
+				  172, 173, 174, 175, 176, 177, 178, 179, 180, \
+				  181, 182, 183, 184, 185, 186, 187, 188, 189, \
+				  190, 191, 192, 193, 194, 195, 196, 197, 198, \
+				  199, 200, 201, 202, 203, 204, 205, 206, 207, \
+				  208, 209, \
+				}
+#define CONFIG_SYS_NAND_ECCSIZE         512
+#define CONFIG_SYS_NAND_ECCBYTES        26
+#define CONFIG_PHY_TI
 #endif /* __CONFIG_K2G_EVM_H */
diff -u -N U-Boot_SDcard/include/common.h U-Boot_SDcard/include/common.h
--- U-Boot_SDcard/include/common.h	2019-09-12 15:54:42.000000957 -0500
+++ U-Boot_SDcard/include/common.h	1969-12-31 19:29:19.000000088 -0600
@@ -456,6 +456,10 @@
 #endif
 #endif
 
+#if defined(CONFIG_DTB_RESELECT)
+int	embedded_dtb_select(void);
+#endif
+
 int	misc_init_f   (void);
 int	misc_init_r   (void);
 
diff -u -N U-Boot_SDcard/drivers/dfu/dfu_nand.c U-Boot_SDcard/drivers/dfu/dfu_nand.c
--- U-Boot_SDcard/drivers/dfu/dfu_nand.c	2019-09-12 15:54:23.000000085 -0500
+++ U-Boot_SDcard/drivers/dfu/dfu_nand.c	1969-12-31 19:29:20.000000963 -0600
@@ -37,15 +37,15 @@
 	lim = dfu->data.nand.start + dfu->data.nand.size - start;
 	count = *len;
 
+	mtd = get_nand_dev_by_index(nand_curr_device);
+
 	if (nand_curr_device < 0 ||
 	    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-	    !nand_info[nand_curr_device]) {
+	    !mtd) {
 		printf("%s: invalid nand device\n", __func__);
 		return -1;
 	}
 
-	mtd = nand_info[nand_curr_device];
-
 	if (op == DFU_OP_READ) {
 		ret = nand_read_skip_bad(mtd, start, &count, &actual,
 					 lim, buf);
@@ -143,18 +143,16 @@
 
 	/* in case of ubi partition, erase rest of the partition */
 	if (dfu->data.nand.ubi) {
-		struct mtd_info *mtd;
+		struct mtd_info *mtd = get_nand_dev_by_index(nand_curr_device);
 		nand_erase_options_t opts;
 
 		if (nand_curr_device < 0 ||
 		    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-		    !nand_info[nand_curr_device]) {
+		    !mtd) {
 			printf("%s: invalid nand device\n", __func__);
 			return -1;
 		}
 
-		mtd = nand_info[nand_curr_device];
-
 		memset(&opts, 0, sizeof(opts));
 		off = dfu->offset;
 		if ((off & (mtd->erasesize - 1)) != 0) {
diff -u -N U-Boot_SDcard/include/configs/k2l_evm.h U-Boot_SDcard/include/configs/k2l_evm.h
--- U-Boot_SDcard/include/configs/k2l_evm.h	2019-09-12 15:54:46.000000081 -0500
+++ U-Boot_SDcard/include/configs/k2l_evm.h	1969-12-31 19:29:22.000000249 -0600
@@ -25,14 +25,22 @@
 	"name_uboot=u-boot-spi-k2l-evm.gph\0"				\
 	"name_fs=arago-console-image-k2l-evm.cpio.gz\0"
 
+/* NAND Configuration */
+#define CONFIG_SYS_NAND_PAGE_4K
+#define CONFIG_NAND_DAVINCI
+#define CONFIG_KEYSTONE_RBL_NAND
+#define CONFIG_KEYSTONE_NAND_MAX_RBL_SIZE	CONFIG_ENV_OFFSET
+#define CONFIG_SYS_NAND_MASK_CLE		0x4000
+#define CONFIG_SYS_NAND_MASK_ALE		0x2000
+#define CONFIG_SYS_NAND_CS			2
+#define CONFIG_SYS_NAND_4BIT_HW_ECC_OOBFIRST
+#define CONFIG_SYS_NAND_LARGEPAGE
+
 #include <configs/ti_armv7_keystone2.h>
 
 /* SPL SPI Loader Configuration */
 #define CONFIG_SPL_TEXT_BASE		0x0c100000
 
-/* NAND Configuration */
-#define CONFIG_SYS_NAND_PAGE_4K
-
 /* Network */
 #define CONFIG_KSNET_NETCP_V1_5
 #define CONFIG_KSNET_CPSW_NUM_PORTS	5
diff -u -N U-Boot_SDcard/drivers/dfu/dfu_mmc.c U-Boot_SDcard/drivers/dfu/dfu_mmc.c
--- U-Boot_SDcard/drivers/dfu/dfu_mmc.c	2019-09-12 15:54:36.000000321 -0500
+++ U-Boot_SDcard/drivers/dfu/dfu_mmc.c	1969-12-31 19:29:20.000000962 -0600
@@ -15,6 +15,7 @@
 #include <ext4fs.h>
 #include <fat.h>
 #include <mmc.h>
+#include <cli.h>
 
 static unsigned char *dfu_file_buf;
 static long dfu_file_buf_len;
diff -u -N U-Boot_SDcard/drivers/memory/Makefile U-Boot_SDcard/drivers/memory/Makefile
--- U-Boot_SDcard/drivers/memory/Makefile	2019-09-12 15:54:50.000000798 -0500
+++ U-Boot_SDcard/drivers/memory/Makefile	1969-12-31 19:29:21.000000135 -0600
@@ -1,3 +1,4 @@
-# SPDX-License-Identifier:	GPL-2.0+
-
-obj-$(CONFIG_TI_AEMIF) += ti-aemif.o
+# SPDX-License-Identifier:	GPL-2.0+
+
+obj-$(CONFIG_TI_AEMIF) += ti-aemif.o
+obj-$(CONFIG_TI_GPMC) += ti-gpmc.o
diff -u -N U-Boot_SDcard/fs/ext4/ext4fs.c U-Boot_SDcard/fs/ext4/ext4fs.c
--- U-Boot_SDcard/fs/ext4/ext4fs.c	2019-09-12 15:54:18.000000254 -0500
+++ U-Boot_SDcard/fs/ext4/ext4fs.c	1969-12-31 19:29:21.000000810 -0600
@@ -71,7 +71,7 @@
 	blockcnt = lldiv(((len + pos) + blocksize - 1), blocksize);
 
 	for (i = lldiv(pos, blocksize); i < blockcnt; i++) {
-		lbaint_t blknr;
+		long int blknr;
 		int blockoff = pos - (blocksize * i);
 		int blockend = blocksize;
 		int skipfirst = 0;
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c
--- U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c	2019-09-12 15:54:31.000000591 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board_k2hk.c	1969-12-31 19:29:27.000000206 -0600
@@ -23,6 +23,37 @@
 	[ddr3b_clk]	=	100000000,
 };
 
+unsigned int get_external_clk(u32 clk)
+{
+	unsigned int clk_freq;
+
+	switch (clk) {
+	case sys_clk:
+		clk_freq = 122880000;
+		break;
+	case alt_core_clk:
+		clk_freq = 125000000;
+		break;
+	case pa_clk:
+		clk_freq = 122880000;
+		break;
+	case tetris_clk:
+		clk_freq = 125000000;
+		break;
+	case ddr3a_clk:
+		clk_freq = 100000000;
+		break;
+	case ddr3b_clk:
+		clk_freq = 100000000;
+		break;
+	default:
+		clk_freq = 0;
+		break;
+	}
+
+	return clk_freq;
+}
+
 static struct pll_init_data core_pll_config[NUM_SPDS] = {
 	[SPD800]	= CORE_PLL_799,
 	[SPD1000]	= CORE_PLL_999,
@@ -119,6 +150,16 @@
 }
 #endif
 
+#if defined(CONFIG_FIT_EMBED)
+int board_fit_config_name_match(const char *name)
+{
+	if (!strcmp(name, "keystone-k2hk-evm"))
+		return 0;
+
+	return -1;
+}
+#endif
+
 #ifdef CONFIG_SPL_BUILD
 void spl_init_keystone_plls(void)
 {
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c
--- U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c	2019-09-12 15:54:23.000000961 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/cmd_mon.c	1969-12-31 19:29:23.000000847 -0600
@@ -19,6 +19,7 @@
 	u32 addr, dpsc_base = 0x1E80000, freq, load_addr, size;
 	int     rcode = 0;
 	struct image_header *header;
+	u32 ecrypt_bm_addr = 0;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -39,14 +40,17 @@
 	memcpy((void *)load_addr, (void *)(addr + sizeof(struct image_header)),
 	       size);
 
-	rcode = mon_install(load_addr, dpsc_base, freq);
+	if (argc >=  3)
+		ecrypt_bm_addr = simple_strtoul(argv[2], NULL, 16);
+
+	rcode = mon_install(load_addr, dpsc_base, freq, ecrypt_bm_addr);
 	printf("## installed monitor @ 0x%x, freq [%d], status %d\n",
 	       load_addr, freq, rcode);
 
 	return 0;
 }
 
-U_BOOT_CMD(mon_install, 2, 0, do_mon_install,
+U_BOOT_CMD(mon_install, 3, 0, do_mon_install,
 	   "Install boot kernel at 'addr'",
 	   ""
 );
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c	2019-09-12 15:54:16.000000940 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/board.c	1969-12-31 19:29:28.000000725 -0600
@@ -40,14 +40,20 @@
 
 #if !CONFIG_IS_ENABLED(OF_CONTROL)
 static const struct ns16550_platdata am33xx_serial[] = {
-	{ .base = CONFIG_SYS_NS16550_COM1, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
+	{ .base = CONFIG_SYS_NS16550_COM1, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
 # ifdef CONFIG_SYS_NS16550_COM2
-	{ .base = CONFIG_SYS_NS16550_COM2, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
+	{ .base = CONFIG_SYS_NS16550_COM2, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
 #  ifdef CONFIG_SYS_NS16550_COM3
-	{ .base = CONFIG_SYS_NS16550_COM3, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = CONFIG_SYS_NS16550_COM4, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = CONFIG_SYS_NS16550_COM5, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = CONFIG_SYS_NS16550_COM6, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
+	{ .base = CONFIG_SYS_NS16550_COM3, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = CONFIG_SYS_NS16550_COM4, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = CONFIG_SYS_NS16550_COM5, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = CONFIG_SYS_NS16550_COM6, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
 #  endif
 # endif
 };
@@ -105,7 +111,7 @@
 const struct gpio_bank *const omap_gpio_bank = gpio_bank_am33xx;
 #endif
 
-#if defined(CONFIG_OMAP_HSMMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_OMAP_HSMMC)
 int cpu_mmc_init(bd_t *bis)
 {
 	int ret;
@@ -118,6 +124,15 @@
 }
 #endif
 
+/*
+ * RTC only mode magic value, checked against during boot to see if we have
+ * a valid config
+ */
+#define RTC_MAGIC_VAL		0x8cd0
+
+/* Board type field bit shift for RTC only mode */
+#define RTC_BOARD_TYPE_SHIFT	16
+
 /* AM33XX has two MUSB controllers which can be host or gadget */
 #if (defined(CONFIG_USB_MUSB_GADGET) || defined(CONFIG_USB_MUSB_HOST)) && \
 	(defined(CONFIG_AM335X_USB0) || defined(CONFIG_AM335X_USB1)) && \
@@ -204,11 +219,64 @@
 	ret = uclass_first_device(UCLASS_MISC, &dev);
 	if (ret || !dev)
 		return ret;
+
+	ret = uclass_first_device(UCLASS_USB_DEV_GENERIC, &dev);
+	if (ret)
+		return ret;
+#if defined(CONFIG_DM_ETH) && defined(CONFIG_USB_ETHER)
+	ret = usb_ether_init();
+	if (ret) {
+		error("USB ether init failed\n");
+		return ret;
+	}
 #endif
+#endif
 	return 0;
 }
 
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
+
+#if defined(CONFIG_SPL_AM33XX_ENABLE_RTC32K_OSC) || \
+	(defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_RTC_ONLY_SUPPORT))
+static void rtc32k_unlock(struct davinci_rtc *rtc)
+{
+	/*
+	 * Unlock the RTC's registers.  For more details please see the
+	 * RTC_SS section of the TRM.  In order to unlock we need to
+	 * write these specific values (keys) in this order.
+	 */
+	writel(RTC_KICK0R_WE, &rtc->kick0r);
+	writel(RTC_KICK1R_WE, &rtc->kick1r);
+}
+#endif
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_RTC_ONLY_SUPPORT)
+/*
+ * Write contents of the RTC_SCRATCH1 register based on board type
+ * Two things are passed
+ * on. First 16 bits (0:15) are written with RTC_MAGIC value. Once the
+ * control gets to kernel, kernel reads the scratchpad register and gets to
+ * know that bootloader has rtc_only support.
+ *
+ * Second important thing is the board type  (16:31). This is needed in the
+ * rtc_only boot where in we want to avoid costly i2c reads to eeprom to
+ * identify the board type and we go ahead and copy the board strings to
+ * am43xx_board_name.
+ */
+void update_rtc_magic(void)
+{
+	struct davinci_rtc *rtc = (struct davinci_rtc *)RTC_BASE;
+	u32 magic = RTC_MAGIC_VAL;
+
+	magic |= (rtc_only_get_board_type() << RTC_BOARD_TYPE_SHIFT);
+
+	rtc32k_unlock(rtc);
+
+	/* write magic */
+	writel(magic, &rtc->scratch1);
+}
+#endif
+
 /*
  * In the case of non-SPL based booting we'll want to call these
  * functions a tiny bit later as it will require gd to be set and cleared
@@ -218,7 +286,9 @@
 {
 	prcm_init();
 	set_mux_conf_regs();
-
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_RTC_ONLY_SUPPORT)
+	update_rtc_magic();
+#endif
 	return 0;
 }
 
@@ -228,8 +298,6 @@
  */
 __weak void am33xx_spl_board_init(void)
 {
-	do_setup_dpll(&dpll_core_regs, &dpll_core_opp100);
-	do_setup_dpll(&dpll_mpu_regs, &dpll_mpu_opp100);
 }
 
 #if defined(CONFIG_SPL_AM33XX_ENABLE_RTC32K_OSC)
@@ -237,13 +305,7 @@
 {
 	struct davinci_rtc *rtc = (struct davinci_rtc *)RTC_BASE;
 
-	/*
-	 * Unlock the RTC's registers.  For more details please see the
-	 * RTC_SS section of the TRM.  In order to unlock we need to
-	 * write these specific values (keys) in this order.
-	 */
-	writel(RTC_KICK0R_WE, &rtc->kick0r);
-	writel(RTC_KICK1R_WE, &rtc->kick1r);
+	rtc32k_unlock(rtc);
 
 	/* Enable the RTC 32K OSC by setting bits 3 and 6. */
 	writel((1 << 3) | (1 << 6), &rtc->osc);
@@ -280,8 +342,68 @@
 		;
 }
 
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_RTC_ONLY_SUPPORT)
+/*
+ * Check if we are executing rtc-only mode, and resume from it if needed
+ */
+static void rtc_only(void)
+{
+	struct davinci_rtc *rtc = (struct davinci_rtc *)RTC_BASE;
+	struct prm_device_inst *prm_device =
+				(struct prm_device_inst *)PRM_DEVICE_INST;
+
+	u32 scratch1;
+	void (*resume_func)(void);
+
+	scratch1 = readl(&rtc->scratch1);
+
+	/*
+	 * Check RTC scratch against RTC_MAGIC_VAL, RTC_MAGIC_VAL is only
+	 * written to this register when we want to wake up from RTC only
+	 * mode. Contents of the RTC_SCRATCH1:
+	 * bits 0-15:  RTC_MAGIC_VAL
+	 * bits 16-31: board type (needed for sdram_init)
+	 */
+	if ((scratch1 & 0xffff) != RTC_MAGIC_VAL)
+		return;
+
+	rtc32k_unlock(rtc);
+
+	/* Clear RTC magic */
+	writel(0, &rtc->scratch1);
+
+	/*
+	 * Update board type based on value stored on RTC_SCRATCH1, this
+	 * is done so that we don't need to read the board type from eeprom
+	 * over i2c bus which is expensive
+	 */
+	rtc_only_update_board_type(scratch1 >> RTC_BOARD_TYPE_SHIFT);
+
+	/*
+	 * Enable EMIF_DEVOFF in PRCM_PRM_EMIF_CTRL to indicate to EMIF we
+	 * are resuming from self-refresh. This avoids an unnecessary re-init
+	 * of the DDR. The re-init takes time and we would need to wait for
+	 * it to complete before accessing DDR to avoid L3 NOC errors.
+	 */
+	writel(EMIF_CTRL_DEVOFF, &prm_device->emif_ctrl);
+
+	rtc_only_prcm_init();
+	sdram_init();
+
+	/* Disable EMIF_DEVOFF for normal operation and to exit self-refresh */
+	writel(0, &prm_device->emif_ctrl);
+
+	resume_func = (void *)readl(&rtc->scratch0);
+	if (resume_func)
+		resume_func();
+}
+#endif
+
 void s_init(void)
 {
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_RTC_ONLY_SUPPORT)
+	rtc_only();
+#endif
 }
 
 void early_system_init(void)
@@ -298,6 +420,14 @@
 	set_uart_mux_conf();
 	setup_early_clocks();
 	uart_soft_reset();
+#ifdef CONFIG_SPL_BUILD
+	/*
+	 * Save the boot parameters passed from romcode.
+	 * We cannot delay the saving further than this,
+	 * to prevent overwrites.
+	 */
+	save_omap_boot_params();
+#endif
 #ifdef CONFIG_TI_I2C_BOARD_DETECT
 	do_board_detect();
 #endif
@@ -313,6 +443,10 @@
 	early_system_init();
 	board_early_init_f();
 	sdram_init();
+	/* dram_init must store complete ramsize in gd->ram_size */
+	gd->ram_size = get_ram_size(
+			(void *)CONFIG_SYS_SDRAM_BASE,
+			CONFIG_MAX_RAM_BANK_SIZE);
 }
 #endif
 
diff -u -N U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h
--- U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h	2019-09-12 15:54:23.000000594 -0500
+++ U-Boot_SDcard/drivers/usb/gadget/gadget_chips.h	1969-12-31 19:29:28.000000015 -0600
@@ -231,5 +231,7 @@
 		return 0x21;
 	else if (gadget_is_fotg210(gadget))
 		return 0x22;
+	else if (gadget_is_dwc3(gadget))
+		return 0x23;
 	return -ENOENT;
 }
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/am57xx-evm-reva3.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/am57xx-evm-reva3.dts	1969-12-31 19:31:37.000000929 -0600
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am57xx-beagle-x15-revb1.dts"
+#include "am57xx-evm-common.dtsi"
+#include "am57xx-industrial-grade.dtsi"
+
+/ {
+	model = "TI AM572x EVM Rev A3";
+};
+
+&dra7_pmx_core {
+
+	/*
+	 * TODO: We should be able to move PinMux values defined here to
+	 * am57xx-beagle-x15-revb1.dts once that board is available and
+	 * its MMC/SD interface is verified. For now these stay here until
+	 * that exercise is complete.
+	 */
+
+	mmc1_pins_default: mmc1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_3_3v: pinmux_mmc2_ddr_3_3v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_conf: mmc1_iodelay_ddr50_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CLK_IN */
+			0x620 A_DELAY_PS(1271) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x624 A_DELAY_PS(229) G_DELAY_PS(0)	/* CFG_MMC1_CMD_IN */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x630 A_DELAY_PS(850) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x63C A_DELAY_PS(468) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x648 A_DELAY_PS(466) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x654 A_DELAY_PS(399) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(600) G_DELAY_PS(400)	/* CFG_MMC1_CLK_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(30) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x64c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc2_iodelay_ddr_3_3v_conf: mmc2_iodelay_ddr_3_3v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(270) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(170) G_DELAY_PS(0)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(758) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(81) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(286) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(123) G_DELAY_PS(0)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(346) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(55) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(422) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(642) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(128) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(395) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(623) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(54) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+	vmmc-supply = <&vdd_3v3>;
+	vmmc_aux-supply = <&ldo1_reg>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_3_3v &mmc2_iodelay_ddr_3_3v_conf>;
+	/delete-property/ mmc-hs200-1_8v;
+};
diff -u -N /dev/null U-Boot_SDcard/common/spl/spl_ram.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/common/spl/spl_ram.c	1969-12-31 19:31:37.000000917 -0600
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2016
+ * Xilinx, Inc.
+ *
+ * (C) Copyright 2016
+ * Toradex AG
+ *
+ * Michal Simek <michal.simek@xilinx.com>
+ * Stefan Agner <stefan.agner@toradex.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <spl.h>
+#include <libfdt.h>
+
+#ifndef CONFIG_SPL_LOAD_FIT_ADDRESS
+# define CONFIG_SPL_LOAD_FIT_ADDRESS	0
+#endif
+
+static ulong spl_ram_load_read(struct spl_load_info *load, ulong sector,
+			       ulong count, void *buf)
+{
+	debug("%s: sector %lx, count %lx, buf %lx\n",
+	      __func__, sector, count, (ulong)buf);
+	memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS + sector), count);
+	return count;
+}
+
+static int spl_ram_load_image(struct spl_image_info *spl_image,
+			      struct spl_boot_device *bootdev)
+{
+	struct image_header *header;
+
+	header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS;
+
+#if defined(CONFIG_SPL_DFU_SUPPORT)
+	if (bootdev->boot_device == BOOT_DEVICE_DFU)
+		spl_dfu_cmd(0, "dfu_alt_info_ram", "ram", "0");
+#endif
+
+	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+	    image_get_magic(header) == FDT_MAGIC) {
+		struct spl_load_info load;
+
+		debug("Found FIT\n");
+		load.bl_len = 1;
+		load.read = spl_ram_load_read;
+		spl_load_simple_fit(spl_image, &load, 0, header);
+	} else {
+		debug("Legacy image\n");
+		/*
+		 * Get the header.  It will point to an address defined by
+		 * handoff which will tell where the image located inside
+		 * the flash. For now, it will temporary fixed to address
+		 * pointed by U-Boot.
+		 */
+		header = (struct image_header *)
+			(CONFIG_SYS_TEXT_BASE -	sizeof(struct image_header));
+
+		spl_parse_image_header(spl_image, header);
+	}
+
+	return 0;
+}
+#if defined(CONFIG_SPL_RAM_DEVICE)
+SPL_LOAD_IMAGE_METHOD("RAM", 0, BOOT_DEVICE_RAM, spl_ram_load_image);
+#endif
+#if defined(CONFIG_SPL_DFU_SUPPORT)
+SPL_LOAD_IMAGE_METHOD("DFU", 0, BOOT_DEVICE_DFU, spl_ram_load_image);
+#endif
+
+
diff -u -N U-Boot_SDcard/common/board_f.c U-Boot_SDcard/common/board_f.c
--- U-Boot_SDcard/common/board_f.c	2019-09-12 15:54:16.000000312 -0500
+++ U-Boot_SDcard/common/board_f.c	1969-12-31 19:29:17.000000453 -0600
@@ -929,6 +929,9 @@
 #if defined(CONFIG_MPC5xxx)
 	prt_mpc5xxx_clks,
 #endif /* CONFIG_MPC5xxx */
+#if defined(CONFIG_DTB_RESELECT)
+	embedded_dtb_select,
+#endif
 #if defined(CONFIG_DISPLAY_BOARDINFO)
 	show_board_info,
 #endif
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h	2019-09-12 15:54:32.000000180 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock.h	1969-12-31 19:29:30.000000922 -0600
@@ -117,7 +117,6 @@
 	int pll_od;		/* PLL output divider */
 };
 
-extern unsigned int external_clk[ext_clk_count];
 extern const struct keystone_pll_regs keystone_pll_regs[];
 extern s16 divn_val[];
 extern int speeds[];
@@ -129,6 +128,7 @@
 int get_max_dev_speed(int *spds);
 int get_max_arm_speed(int *spds);
 void pll_pa_clk_sel(void);
+unsigned int get_external_clk(u32 clk);
 
 #endif
 #endif
diff -u -N U-Boot_SDcard/board/ti/common/board_detect.h U-Boot_SDcard/board/ti/common/board_detect.h
--- U-Boot_SDcard/board/ti/common/board_detect.h	2019-09-12 15:54:55.000000864 -0500
+++ U-Boot_SDcard/board/ti/common/board_detect.h	1969-12-31 19:29:27.000000186 -0600
@@ -98,7 +98,7 @@
 };
 
 #define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
-				OMAP_SRAM_SCRATCH_BOARD_EEPROM_START)
+				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
 
 /**
  * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
@@ -193,4 +193,42 @@
  */
 void set_board_info_env(char *name);
 
+/**
+ * board_ti_was_eeprom_read() - Check to see if the eeprom contents have been read
+ *
+ * This function is useful to determine if the eeprom has already been read and
+ * its contents have already been loaded into memory. It utiltzes the magic
+ * number that the header value is set to upon successful eeprom read.
+ */
+bool board_ti_was_eeprom_read(void);
+
+/**
+ * ti_i2c_eeprom_am_set() - Setup the eeprom data with predefined values
+ * @name:	Name of the board
+ * @rev:	Revision of the board
+ *
+ * In some cases such as in RTC-only mode, we are able to skip reading eeprom
+ * and wasting i2c based initialization time by using predefined flags for
+ * detecting what platform we are booting on. For those platforms, provide
+ * a handy function to pre-program information.
+ *
+ * NOTE: many eeprom information such as serial number, mac address etc is not
+ * available.
+ *
+ * Return: 0 if all went fine, else return error.
+ */
+int ti_i2c_eeprom_am_set(const char *name, const char *rev);
+
+/**
+ * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ *
+ * EEPROM should be already read before calling this function.
+ * The EEPROM contains 2 MAC addresses which define the MAC address
+ * range (i.e. first and last MAC address).
+ * This function sets the ethaddr environment variable for all
+ * the available MAC addresses starting from eth<index>addr.
+ */
+void board_ti_set_ethaddr(int index);
+
 #endif	/* __BOARD_DETECT_H */
diff -u -N U-Boot_SDcard/doc/driver-model/README.txt U-Boot_SDcard/doc/driver-model/README.txt
--- U-Boot_SDcard/doc/driver-model/README.txt	2019-09-12 15:54:22.000000160 -0500
+++ U-Boot_SDcard/doc/driver-model/README.txt	1969-12-31 19:29:20.000000833 -0600
@@ -825,6 +825,10 @@
 'u-boot,dm-pre-reloc' flag are initialised prior to relocation. This helps
 to reduce the driver model overhead.
 
+It is possible to limit this to specific relocation steps, by using
+the more specialized 'u-boot,dm-spl' and 'u-boot,dm-tpl' flags
+in the devicetree.
+
 Then post relocation we throw that away and re-init driver model again.
 For drivers which require some sort of continuity between pre- and
 post-relocation devices, we can provide access to the pre-relocation
diff -u -N U-Boot_SDcard/include/configs/am335x_igep0033.h U-Boot_SDcard/include/configs/am335x_igep0033.h
--- U-Boot_SDcard/include/configs/am335x_igep0033.h	2019-09-12 15:54:23.000000877 -0500
+++ U-Boot_SDcard/include/configs/am335x_igep0033.h	1969-12-31 19:29:22.000000034 -0600
@@ -123,7 +123,7 @@
 #undef CONFIG_USE_IRQ
 
 /* SPL */
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #define CONFIG_SYS_NAND_5_ADDR_CYCLE
 #define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
diff -u -N U-Boot_SDcard/include/power/tps65218.h U-Boot_SDcard/include/power/tps65218.h
--- U-Boot_SDcard/include/power/tps65218.h	2019-09-12 15:54:55.000000949 -0500
+++ U-Boot_SDcard/include/power/tps65218.h	1969-12-31 19:29:22.000000771 -0600
@@ -56,11 +56,14 @@
 
 #define TPS65218_MASK_ALL_BITS			0xFF
 
+#define TPS65218_DCDC_VSEL_MASK			0x3F
+
 #define TPS65218_DCDC_VOLT_SEL_0950MV		0x0a
 #define TPS65218_DCDC_VOLT_SEL_1100MV		0x19
 #define TPS65218_DCDC_VOLT_SEL_1200MV		0x23
 #define TPS65218_DCDC_VOLT_SEL_1260MV		0x29
 #define TPS65218_DCDC_VOLT_SEL_1330MV		0x30
+#define TPS65218_DCDC3_VOLT_SEL_1350MV		0x12
 
 #define TPS65218_CC_STAT	(BIT(0) | BIT(1))
 #define TPS65218_STATE		(BIT(2) | BIT(3))
diff -u -N U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c
--- U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c	2019-09-12 15:54:25.000000186 -0500
+++ U-Boot_SDcard/drivers/power/pmic/pmic_tps65218.c	1969-12-31 19:29:27.000000928 -0600
@@ -96,12 +96,13 @@
 int tps65218_voltage_update(uchar dc_cntrl_reg, uchar volt_sel)
 {
 	if ((dc_cntrl_reg != TPS65218_DCDC1) &&
-	    (dc_cntrl_reg != TPS65218_DCDC2))
+	    (dc_cntrl_reg != TPS65218_DCDC2) &&
+	    (dc_cntrl_reg != TPS65218_DCDC3))
 		return 1;
 
 	/* set voltage level */
 	if (tps65218_reg_write(TPS65218_PROT_LEVEL_2, dc_cntrl_reg, volt_sel,
-			       TPS65218_MASK_ALL_BITS))
+			       TPS65218_DCDC_VSEL_MASK))
 		return 1;
 
 	/* set GO bit to initiate voltage transition */
diff -u -N U-Boot_SDcard/drivers/usb/gadget/ether.c U-Boot_SDcard/drivers/usb/gadget/ether.c
--- U-Boot_SDcard/drivers/usb/gadget/ether.c	2019-09-12 15:54:47.000000012 -0500
+++ U-Boot_SDcard/drivers/usb/gadget/ether.c	1969-12-31 19:29:28.000000006 -0600
@@ -25,6 +25,7 @@
 #include "rndis.h"
 
 #include <dm.h>
+#include <dm/lists.h>
 #include <dm/uclass-internal.h>
 #include <dm/device-internal.h>
 
@@ -115,7 +116,11 @@
 
 	struct usb_request	*tx_req, *rx_req;
 
+#ifndef CONFIG_DM_ETH
 	struct eth_device	*net;
+#else
+	struct udevice		*net;
+#endif
 	struct net_device_stats	stats;
 	unsigned int		tx_qlen;
 
@@ -142,7 +147,11 @@
 /*-------------------------------------------------------------------------*/
 struct ether_priv {
 	struct eth_dev ethdev;
+#ifndef CONFIG_DM_ETH
 	struct eth_device netdev;
+#else
+	struct udevice *netdev;
+#endif
 	struct usb_gadget_driver eth_driver;
 };
 
@@ -498,6 +507,7 @@
  * can't really use its struct.  All we do here is say that we're using
  * the submode of "SAFE" which directly matches the CDC Subset.
  */
+#ifdef CONFIG_USB_ETH_SUBSET
 static const u8 mdlm_detail_desc[] = {
 	6,
 	USB_DT_CS_INTERFACE,
@@ -507,6 +517,7 @@
 	0,	/* network control capabilities (none) */
 	0,	/* network data capabilities ("raw" encapsulation) */
 };
+#endif
 
 #endif
 
@@ -1850,7 +1861,11 @@
 
 static char rndis_resp_buf[8] __attribute__((aligned(sizeof(__le32))));
 
+#ifndef CONFIG_DM_ETH
 static int rndis_control_ack(struct eth_device *net)
+#else
+static int rndis_control_ack(struct udevice *net)
+#endif
 {
 	struct ether_priv	*priv = (struct ether_priv *)net->priv;
 	struct eth_dev		*dev = &priv->ethdev;
@@ -1999,7 +2014,9 @@
 	struct usb_ep		*in_ep, *out_ep, *status_ep = NULL;
 	int			status = -ENOMEM;
 	int			gcnum;
-	u8			tmp[7];
+#ifdef CONFIG_DM_ETH
+	struct eth_pdata	*pdata = dev_get_platdata(l_priv->netdev);
+#endif
 
 	/* these flags are only ever cleared; compiler take note */
 #ifndef	CONFIG_USB_ETH_CDC
@@ -2187,7 +2204,11 @@
 
 
 	/* network device setup */
+#ifndef CONFIG_DM_ETH
 	dev->net = &l_priv->netdev;
+#else
+	dev->net = l_priv->netdev;
+#endif
 
 	dev->cdc = cdc;
 	dev->zlp = zlp;
@@ -2203,11 +2224,12 @@
 	 * host side code for the SAFE thing cares -- its original BLAN
 	 * thing didn't, Sharp never assigned those addresses on Zaurii.
 	 */
+#ifndef CONFIG_DM_ETH
 	get_ether_addr(dev_addr, dev->net->enetaddr);
+#else
+	get_ether_addr(dev_addr, pdata->enetaddr);
+#endif
 
-	memset(tmp, 0, sizeof(tmp));
-	memcpy(tmp, dev->net->enetaddr, sizeof(dev->net->enetaddr));
-
 	get_ether_addr(host_addr, dev->host_mac);
 
 	sprintf(ethaddr, "%02X%02X%02X%02X%02X%02X",
@@ -2267,10 +2289,11 @@
 		status_ep ? " STATUS " : "",
 		status_ep ? status_ep->name : ""
 		);
-	printf("MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-		dev->net->enetaddr[0], dev->net->enetaddr[1],
-		dev->net->enetaddr[2], dev->net->enetaddr[3],
-		dev->net->enetaddr[4], dev->net->enetaddr[5]);
+#ifndef CONFIG_DM_ETH
+	printf("MAC %pM\n", dev->net->enetaddr);
+#else
+	printf("MAC %pM\n", pdata->enetaddr);
+#endif
 
 	if (cdc || rndis)
 		printf("HOST MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -2519,13 +2542,12 @@
 	}
 
 	usb_gadget_unregister_driver(&priv->eth_driver);
-#ifdef CONFIG_DM_USB
-	device_remove(dev->usb_udev);
-#else
+#ifndef CONFIG_DM_USB
 	board_usb_cleanup(0, USB_INIT_DEVICE);
 #endif
 }
 
+#ifndef CONFIG_DM_ETH
 static int usb_eth_init(struct eth_device *netdev, bd_t *bd)
 {
 	struct ether_priv *priv = (struct ether_priv *)netdev->priv;
@@ -2592,3 +2614,114 @@
 	eth_register(netdev);
 	return 0;
 }
+#else
+static int usb_eth_start(struct udevice *dev)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+
+	return _usb_eth_init(priv);
+}
+
+static int usb_eth_send(struct udevice *dev, void *packet, int length)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+
+	return _usb_eth_send(priv, packet, length);
+}
+
+static int usb_eth_recv(struct udevice *dev, int flags, uchar **packetp)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+	struct eth_dev *ethdev = &priv->ethdev;
+	int ret;
+
+	ret = _usb_eth_recv(priv);
+	if (ret) {
+		error("error packet receive\n");
+		return ret;
+	}
+
+	if (packet_received) {
+		if (ethdev->rx_req) {
+			*packetp = (uchar *)net_rx_packets[0];
+			return ethdev->rx_req->length;
+		} else {
+			error("dev->rx_req invalid");
+			return -EFAULT;
+		}
+	}
+
+	return -EAGAIN;
+}
+
+static int usb_eth_free_pkt(struct udevice *dev, uchar *packet,
+				   int length)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+	struct eth_dev *ethdev = &priv->ethdev;
+
+	packet_received = 0;
+
+	return rx_submit(ethdev, ethdev->rx_req, 0);
+}
+
+static void usb_eth_stop(struct udevice *dev)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+
+	_usb_eth_halt(priv);
+}
+
+static int usb_eth_probe(struct udevice *dev)
+{
+	struct ether_priv *priv = dev_get_priv(dev);
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+	priv->netdev = dev;
+	l_priv = priv;
+
+	get_ether_addr(CONFIG_USBNET_DEVADDR, pdata->enetaddr);
+	eth_setenv_enetaddr("usbnet_devaddr", pdata->enetaddr);
+
+	return 0;
+}
+
+static const struct eth_ops usb_eth_ops = {
+	.start		= usb_eth_start,
+	.send		= usb_eth_send,
+	.recv		= usb_eth_recv,
+	.free_pkt	= usb_eth_free_pkt,
+	.stop		= usb_eth_stop,
+};
+
+int usb_ether_init(void)
+{
+	struct udevice *dev;
+	struct udevice *usb_dev;
+	int ret;
+
+	ret = uclass_first_device(UCLASS_USB_DEV_GENERIC, &usb_dev);
+	if (!usb_dev || ret) {
+		error("No USB device found\n");
+		return ret;
+	}
+
+	ret = device_bind_driver(usb_dev, "usb_ether", "usb_ether", &dev);
+	if (!dev || ret) {
+		error("usb - not able to bind usb_ether device\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(eth_usb) = {
+	.name	= "usb_ether",
+	.id	= UCLASS_ETH,
+	.probe	= usb_eth_probe,
+	.ops	= &usb_eth_ops,
+	.priv_auto_alloc_size = sizeof(struct ether_priv),
+	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
+#endif /* CONFIG_DM_ETH */
diff -u -N U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c
--- U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c	2019-09-12 15:54:42.000000452 -0500
+++ U-Boot_SDcard/drivers/mmc/ftsdc010_mci.c	1969-12-31 19:29:21.000000186 -0600
@@ -251,7 +251,7 @@
 	return ret;
 }
 
-static void ftsdc010_set_ios(struct mmc *mmc)
+static int ftsdc010_set_ios(struct mmc *mmc)
 {
 	struct ftsdc010_chip *chip = mmc->priv;
 	struct ftsdc010_mmc __iomem *regs = chip->regs;
@@ -270,6 +270,8 @@
 		setbits_le32(&regs->bwr, FTSDC010_BWR_MODE_1BIT);
 		break;
 	}
+
+	return 0;
 }
 
 static int ftsdc010_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/include/configs/ti_omap5_common.h U-Boot_SDcard/include/configs/ti_omap5_common.h
--- U-Boot_SDcard/include/configs/ti_omap5_common.h	2019-09-12 15:54:24.000000149 -0500
+++ U-Boot_SDcard/include/configs/ti_omap5_common.h	1969-12-31 19:29:22.000000532 -0600
@@ -45,7 +45,7 @@
  * Hardware drivers
  */
 #define CONFIG_SYS_NS16550_CLK		48000000
-#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_DM_SERIAL)
+#if !defined(CONFIG_DM_SERIAL)
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	(-4)
 #endif
@@ -61,6 +61,12 @@
 #define DFUARGS
 #endif
 
+/*#define AM5728_MMC_BOOT */
+
+#ifndef AM5728_QSPI_BOOT
+#ifdef AM5728_MMC_BOOT
+#include <environment/ti/mmc.h>
+
 #define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	DEFAULT_LINUX_BOOT_ENV \
@@ -91,19 +97,29 @@
 			"setenv fdtfile am57xx-beagle-x15.dtb; fi;" \
 		"if test $board_name = beagle_x15_revb1; then " \
 			"setenv fdtfile am57xx-beagle-x15-revb1.dtb; fi;" \
-		"if test $board_name = am572x_idk; then " \
+		"if test $board_name = am572x_idk && test $idk_lcd = no; then " \
 			"setenv fdtfile am572x-idk.dtb; fi;" \
+		"if test $board_name = am572x_idk && test $idk_lcd = osd101t2045; then " \
+			"setenv fdtfile am572x-idk-lcd-osd101t2045.dtb; fi;" \
+		"if test $board_name = am572x_idk && test $idk_lcd = osd101t2587; then " \
+			"setenv fdtfile am572x-idk-lcd-osd101t2587.dtb; fi;" \
 		"if test $board_name = am57xx_evm; then " \
-			"setenv fdtfile am57xx-beagle-x15.dtb; fi;" \
+			"setenv fdtfile am57xx-evm.dtb; fi;" \
 		"if test $board_name = am57xx_evm_reva3; then " \
-			"setenv fdtfile am57xx-beagle-x15.dtb; fi;" \
-		"if test $board_name = am571x_idk; then " \
+			"setenv fdtfile am57xx-evm-reva3.dtb; fi;" \
+		"if test $board_name = am571x_idk && test $idk_lcd = no; then " \
 			"setenv fdtfile am571x-idk.dtb; fi;" \
+		"if test $board_name = am571x_idk && test $idk_lcd = osd101t2045; then " \
+			"setenv fdtfile am571x-idk-lcd-osd101t2045.dtb; fi;" \
+		"if test $board_name = am571x_idk && test $idk_lcd = osd101t2587; then " \
+			"setenv fdtfile am571x-idk-lcd-osd101t2587.dtb; fi;" \
 		"if test $fdtfile = undefined; then " \
 			"echo WARNING: Could not determine device tree to use; fi; \0" \
 	DFUARGS \
 	NETARGS \
 
+/*abhi_debug*/
+#if 1 
 #define CONFIG_BOOTCOMMAND \
 	"if test ${dofastboot} -eq 1; then " \
 		"echo Boot fastboot requested, resetting dofastboot ...;" \
@@ -122,7 +138,9 @@
 	"setenv mmcroot /dev/mmcblk0p2 rw; " \
 	"run mmcboot;" \
 	""
-
+#endif
+#endif
+#endif
 /*
  * SPL related defines.  The Public RAM memory map the ROM defines the
  * area between 0x40300000 and 0x4031E000 as a download area for OMAP5.
@@ -163,14 +181,8 @@
 #define CONFIG_SPL_NAND_AM33XX_BCH	/* ELM support */
 #endif
 
-/*
- * Disable MMC DM for SPL build and can be re-enabled after adding
- * DM support in SPL
- */
 #ifdef CONFIG_SPL_BUILD
-#undef CONFIG_DM_MMC
 #undef CONFIG_TIMER
-#undef CONFIG_DM_ETH
 #endif
 
 #endif /* __CONFIG_TI_OMAP5_COMMON_H */
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h	2019-09-12 15:54:16.000000715 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-omap5/gpio.h	1969-12-31 19:29:30.000000541 -0600
@@ -34,4 +34,8 @@
 #define OMAP54XX_GPIO7_BASE		0x48051000
 #define OMAP54XX_GPIO8_BASE		0x48053000
 
+
+/* Get the GPIO index from the given bank number and bank gpio */
+#define GPIO_TO_PIN(bank, bank_gpio)	(32 * (bank - 1) + (bank_gpio))
+
 #endif /* _GPIO_OMAP5_H */
diff -u -N U-Boot_SDcard/include/ns16550.h U-Boot_SDcard/include/ns16550.h
--- U-Boot_SDcard/include/ns16550.h	2019-09-12 15:54:20.000000179 -0500
+++ U-Boot_SDcard/include/ns16550.h	1969-12-31 19:29:19.000000283 -0600
@@ -121,6 +121,11 @@
 /* Ingenic JZ47xx specific UART-enable bit. */
 #define UART_FCR_UME		0x10
 
+/* Clear & enable FIFOs */
+#define UART_FCR_DEFVAL (UART_FCR_FIFO_EN | \
+			UART_FCR_RXSR |	\
+			UART_FCR_TXSR)
+
 /*
  * These are the definitions for the Modem Control Register
  */
diff -u -N U-Boot_SDcard/arch/arm/dts/dra7-evm.dts U-Boot_SDcard/arch/arm/dts/dra7-evm.dts
--- U-Boot_SDcard/arch/arm/dts/dra7-evm.dts	2019-09-12 15:54:53.000000734 -0500
+++ U-Boot_SDcard/arch/arm/dts/dra7-evm.dts	1969-12-31 19:29:23.000000296 -0600
@@ -1,945 +1,1294 @@
-/*
- * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-/dts-v1/;
-
-#include "dra74x.dtsi"
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/clk/ti-dra7-atl.h>
-#include <dt-bindings/input/input.h>
-
-/ {
-	model = "TI DRA742";
-	compatible = "ti,dra7-evm", "ti,dra742", "ti,dra74", "ti,dra7";
-
-	chosen {
-		stdout-path = &uart1;
-		tick-timer = &timer2;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x60000000>; /* 1536 MB */
-	};
-
-	evm_3v3_sd: fixedregulator-sd {
-		compatible = "regulator-fixed";
-		regulator-name = "evm_3v3_sd";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		enable-active-high;
-		gpio = <&pcf_gpio_21 5 GPIO_ACTIVE_HIGH>;
-	};
-
-	evm_3v3_sw: fixedregulator-evm_3v3_sw {
-		compatible = "regulator-fixed";
-		regulator-name = "evm_3v3_sw";
-		vin-supply = <&sysen1>;
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-	};
-
-	aic_dvdd: fixedregulator-aic_dvdd {
-		/* TPS77018DBVT */
-		compatible = "regulator-fixed";
-		regulator-name = "aic_dvdd";
-		vin-supply = <&evm_3v3_sw>;
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
-	};
-
-	extcon_usb1: extcon_usb1 {
-		compatible = "linux,extcon-usb-gpio";
-		id-gpio = <&pcf_gpio_21 1 GPIO_ACTIVE_HIGH>;
-	};
-
-	extcon_usb2: extcon_usb2 {
-		compatible = "linux,extcon-usb-gpio";
-		id-gpio = <&pcf_gpio_21 2 GPIO_ACTIVE_HIGH>;
-	};
-
-	vtt_fixed: fixedregulator-vtt {
-		compatible = "regulator-fixed";
-		regulator-name = "vtt_fixed";
-		regulator-min-microvolt = <1350000>;
-		regulator-max-microvolt = <1350000>;
-		regulator-always-on;
-		regulator-boot-on;
-		enable-active-high;
-		vin-supply = <&sysen2>;
-		gpio = <&gpio7 11 GPIO_ACTIVE_HIGH>;
-	};
-
-	sound0: sound0 {
-		compatible = "simple-audio-card";
-		simple-audio-card,name = "DRA7xx-EVM";
-		simple-audio-card,widgets =
-			"Headphone", "Headphone Jack",
-			"Line", "Line Out",
-			"Microphone", "Mic Jack",
-			"Line", "Line In";
-		simple-audio-card,routing =
-			"Headphone Jack",	"HPLOUT",
-			"Headphone Jack",	"HPROUT",
-			"Line Out",		"LLOUT",
-			"Line Out",		"RLOUT",
-			"MIC3L",		"Mic Jack",
-			"MIC3R",		"Mic Jack",
-			"Mic Jack",		"Mic Bias",
-			"LINE1L",		"Line In",
-			"LINE1R",		"Line In";
-		simple-audio-card,format = "dsp_b";
-		simple-audio-card,bitclock-master = <&sound0_master>;
-		simple-audio-card,frame-master = <&sound0_master>;
-		simple-audio-card,bitclock-inversion;
-
-		sound0_master: simple-audio-card,cpu {
-			sound-dai = <&mcasp3>;
-			system-clock-frequency = <5644800>;
-		};
-
-		simple-audio-card,codec {
-			sound-dai = <&tlv320aic3106>;
-			clocks = <&atl_clkin2_ck>;
-		};
-	};
-
-	leds {
-		compatible = "gpio-leds";
-		led0 {
-			label = "dra7:usr1";
-			gpios = <&pcf_lcd 4 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-		};
-
-		led1 {
-			label = "dra7:usr2";
-			gpios = <&pcf_lcd 5 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-		};
-
-		led2 {
-			label = "dra7:usr3";
-			gpios = <&pcf_lcd 6 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-		};
-
-		led3 {
-			label = "dra7:usr4";
-			gpios = <&pcf_lcd 7 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-		};
-	};
-
-	gpio_keys {
-		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		autorepeat;
-
-		USER1 {
-			label = "btnUser1";
-			linux,code = <BTN_0>;
-			gpios = <&pcf_lcd 2 GPIO_ACTIVE_LOW>;
-		};
-
-		USER2 {
-			label = "btnUser2";
-			linux,code = <BTN_1>;
-			gpios = <&pcf_lcd 3 GPIO_ACTIVE_LOW>;
-		};
-	};
-};
-
-&dra7_pmx_core {
-	pinctrl-names = "default";
-	pinctrl-0 = <&vtt_pin>;
-
-	vtt_pin: pinmux_vtt_pin {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37b4, PIN_OUTPUT | MUX_MODE14) /* spi1_cs1.gpio7_11 */
-		>;
-	};
-
-	i2c1_pins: pinmux_i2c1_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3800, PIN_INPUT | MUX_MODE0) /* i2c1_sda */
-			DRA7XX_CORE_IOPAD(0x3804, PIN_INPUT | MUX_MODE0) /* i2c1_scl */
-		>;
-	};
-
-	i2c2_pins: pinmux_i2c2_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3808, PIN_INPUT | MUX_MODE0) /* i2c2_sda */
-			DRA7XX_CORE_IOPAD(0x380c, PIN_INPUT | MUX_MODE0) /* i2c2_scl */
-		>;
-	};
-
-	i2c3_pins: pinmux_i2c3_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3688, PIN_INPUT | MUX_MODE9) /* gpio6_14.i2c3_sda */
-			DRA7XX_CORE_IOPAD(0x368c, PIN_INPUT | MUX_MODE9) /* gpio6_15.i2c3_scl */
-		>;
-	};
-
-	mcspi1_pins: pinmux_mcspi1_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37a4, PIN_INPUT | MUX_MODE0) /* spi1_sclk */
-			DRA7XX_CORE_IOPAD(0x37a8, PIN_INPUT | MUX_MODE0) /* spi1_d1 */
-			DRA7XX_CORE_IOPAD(0x37ac, PIN_INPUT | MUX_MODE0) /* spi1_d0 */
-			DRA7XX_CORE_IOPAD(0x37b0, PIN_INPUT_SLEW | MUX_MODE0) /* spi1_cs0 */
-			DRA7XX_CORE_IOPAD(0x37b8, PIN_INPUT_SLEW | MUX_MODE6) /* spi1_cs2.hdmi1_hpd */
-			DRA7XX_CORE_IOPAD(0x37bc, PIN_INPUT_SLEW | MUX_MODE6) /* spi1_cs3.hdmi1_cec */
-		>;
-	};
-
-	mcspi2_pins: pinmux_mcspi2_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37c0, PIN_INPUT | MUX_MODE0) /* spi2_sclk */
-			DRA7XX_CORE_IOPAD(0x37c4, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_d1 */
-			DRA7XX_CORE_IOPAD(0x37c8, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_d1 */
-			DRA7XX_CORE_IOPAD(0x37cc, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_cs0 */
-		>;
-	};
-
-	uart1_pins: pinmux_uart1_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37e0, PIN_INPUT_SLEW | MUX_MODE0) /* uart1_rxd */
-			DRA7XX_CORE_IOPAD(0x37e4, PIN_INPUT_SLEW | MUX_MODE0) /* uart1_txd */
-			DRA7XX_CORE_IOPAD(0x37e8, PIN_INPUT | MUX_MODE3) /* uart1_ctsn */
-			DRA7XX_CORE_IOPAD(0x37ec, PIN_INPUT | MUX_MODE3) /* uart1_rtsn */
-		>;
-	};
-
-	uart2_pins: pinmux_uart2_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37f0, PIN_INPUT | MUX_MODE0) /* uart2_rxd */
-			DRA7XX_CORE_IOPAD(0x37f4, PIN_INPUT | MUX_MODE0) /* uart2_txd */
-			DRA7XX_CORE_IOPAD(0x37f8, PIN_INPUT | MUX_MODE0) /* uart2_ctsn */
-			DRA7XX_CORE_IOPAD(0x37fc, PIN_INPUT | MUX_MODE0) /* uart2_rtsn */
-		>;
-	};
-
-	uart3_pins: pinmux_uart3_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3648, PIN_INPUT_SLEW | MUX_MODE0) /* uart3_rxd */
-			DRA7XX_CORE_IOPAD(0x364c, PIN_INPUT_SLEW | MUX_MODE0) /* uart3_txd */
-		>;
-	};
-
-	usb1_pins: pinmux_usb1_pins {
-                pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3680, PIN_INPUT_SLEW | MUX_MODE0) /* usb1_drvvbus */
-                >;
-        };
-
-	usb2_pins: pinmux_usb2_pins {
-                pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3684, PIN_INPUT_SLEW | MUX_MODE0) /* usb2_drvvbus */
-                >;
-        };
-
-	nand_flash_x16: nand_flash_x16 {
-		/* On DRA7 EVM, GPMC_WPN and NAND_BOOTn comes from DIP switch
-		 * So NAND flash requires following switch settings:
-		 * SW5.1 (NAND_BOOTn) = ON (LOW)
-		 * SW5.9 (GPMC_WPN) = OFF (HIGH)
-		 */
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3400, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad0	*/
-			DRA7XX_CORE_IOPAD(0x3404, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad1	*/
-			DRA7XX_CORE_IOPAD(0x3408, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad2	*/
-			DRA7XX_CORE_IOPAD(0x340c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad3	*/
-			DRA7XX_CORE_IOPAD(0x3410, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad4	*/
-			DRA7XX_CORE_IOPAD(0x3414, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad5	*/
-			DRA7XX_CORE_IOPAD(0x3418, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad6	*/
-			DRA7XX_CORE_IOPAD(0x341c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad7	*/
-			DRA7XX_CORE_IOPAD(0x3420, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad8	*/
-			DRA7XX_CORE_IOPAD(0x3424, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad9	*/
-			DRA7XX_CORE_IOPAD(0x3428, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad10	*/
-			DRA7XX_CORE_IOPAD(0x342c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad11	*/
-			DRA7XX_CORE_IOPAD(0x3430, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad12	*/
-			DRA7XX_CORE_IOPAD(0x3434, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad13	*/
-			DRA7XX_CORE_IOPAD(0x3438, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad14	*/
-			DRA7XX_CORE_IOPAD(0x343c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad15	*/
-			DRA7XX_CORE_IOPAD(0x34d8, PIN_INPUT_PULLUP  | MUX_MODE0)	/* gpmc_wait0	*/
-			DRA7XX_CORE_IOPAD(0x34cc, PIN_OUTPUT | MUX_MODE0)	/* gpmc_wen	*/
-			DRA7XX_CORE_IOPAD(0x34b4, PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_csn0	*/
-			DRA7XX_CORE_IOPAD(0x34c4, PIN_OUTPUT | MUX_MODE0)	/* gpmc_advn_ale */
-			DRA7XX_CORE_IOPAD(0x34c8, PIN_OUTPUT | MUX_MODE0)	/* gpmc_oen_ren	 */
-			DRA7XX_CORE_IOPAD(0x34d0, PIN_OUTPUT | MUX_MODE0)	/* gpmc_be0n_cle */
-		>;
-	};
-
-	cpsw_default: cpsw_default {
-		pinctrl-single,pins = <
-			/* Slave 1 */
-			DRA7XX_CORE_IOPAD(0x3650, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txc.rgmii0_txc */
-			DRA7XX_CORE_IOPAD(0x3654, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txctl.rgmii0_txctl */
-			DRA7XX_CORE_IOPAD(0x3658, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_td3.rgmii0_txd3 */
-			DRA7XX_CORE_IOPAD(0x365c, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd2.rgmii0_txd2 */
-			DRA7XX_CORE_IOPAD(0x3660, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd1.rgmii0_txd1 */
-			DRA7XX_CORE_IOPAD(0x3664, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd0.rgmii0_txd0 */
-			DRA7XX_CORE_IOPAD(0x3668, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxc.rgmii0_rxc */
-			DRA7XX_CORE_IOPAD(0x366c, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxctl.rgmii0_rxctl */
-			DRA7XX_CORE_IOPAD(0x3670, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd3.rgmii0_rxd3 */
-			DRA7XX_CORE_IOPAD(0x3674, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd2.rgmii0_rxd2 */
-			DRA7XX_CORE_IOPAD(0x3678, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd1.rgmii0_rxd1 */
-			DRA7XX_CORE_IOPAD(0x367c, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd0.rgmii0_rxd0 */
-
-			/* Slave 2 */
-			DRA7XX_CORE_IOPAD(0x3598, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d12.rgmii1_txc */
-			DRA7XX_CORE_IOPAD(0x359c, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d13.rgmii1_tctl */
-			DRA7XX_CORE_IOPAD(0x35a0, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d14.rgmii1_td3 */
-			DRA7XX_CORE_IOPAD(0x35a4, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d15.rgmii1_td2 */
-			DRA7XX_CORE_IOPAD(0x35a8, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d16.rgmii1_td1 */
-			DRA7XX_CORE_IOPAD(0x35ac, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d17.rgmii1_td0 */
-			DRA7XX_CORE_IOPAD(0x35b0, PIN_INPUT | MUX_MODE3)	/* vin2a_d18.rgmii1_rclk */
-			DRA7XX_CORE_IOPAD(0x35b4, PIN_INPUT | MUX_MODE3)	/* vin2a_d19.rgmii1_rctl */
-			DRA7XX_CORE_IOPAD(0x35b8, PIN_INPUT | MUX_MODE3)	/* vin2a_d20.rgmii1_rd3 */
-			DRA7XX_CORE_IOPAD(0x35bc, PIN_INPUT | MUX_MODE3)	/* vin2a_d21.rgmii1_rd2 */
-			DRA7XX_CORE_IOPAD(0x35c0, PIN_INPUT | MUX_MODE3)	/* vin2a_d22.rgmii1_rd1 */
-			DRA7XX_CORE_IOPAD(0x35c4, PIN_INPUT | MUX_MODE3)	/* vin2a_d23.rgmii1_rd0 */
-		>;
-
-	};
-
-	cpsw_sleep: cpsw_sleep {
-		pinctrl-single,pins = <
-			/* Slave 1 */
-			DRA7XX_CORE_IOPAD(0x3650, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3654, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3658, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x365c, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3660, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3664, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3668, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x366c, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3670, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3674, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3678, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x367c, MUX_MODE15)
-
-			/* Slave 2 */
-			DRA7XX_CORE_IOPAD(0x3598, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x359c, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35a0, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35a4, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35a8, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35ac, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35b0, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35b4, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35b8, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35bc, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35c0, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x35c4, MUX_MODE15)
-		>;
-	};
-
-	davinci_mdio_default: davinci_mdio_default {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x363c, PIN_OUTPUT_PULLUP | MUX_MODE0)	/* mdio_d.mdio_d */
-			DRA7XX_CORE_IOPAD(0x3640, PIN_INPUT_PULLUP | MUX_MODE0)	/* mdio_clk.mdio_clk */
-		>;
-	};
-
-	davinci_mdio_sleep: davinci_mdio_sleep {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x363c, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3640, MUX_MODE15)
-		>;
-	};
-
-	dcan1_pins_default: dcan1_pins_default {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37d0, PIN_OUTPUT_PULLUP | MUX_MODE0) /* dcan1_tx */
-			DRA7XX_CORE_IOPAD(0x3818, PULL_UP | MUX_MODE1) /* wakeup0.dcan1_rx */
-		>;
-	};
-
-	dcan1_pins_sleep: dcan1_pins_sleep {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x37d0, MUX_MODE15 | PULL_UP)	/* dcan1_tx.off */
-			DRA7XX_CORE_IOPAD(0x3818, MUX_MODE15 | PULL_UP)	/* wakeup0.off */
-		>;
-	};
-
-	atl_pins: pinmux_atl_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3698, PIN_OUTPUT | MUX_MODE5)	/* xref_clk1.atl_clk1 */
-			DRA7XX_CORE_IOPAD(0x369c, PIN_OUTPUT | MUX_MODE5)	/* xref_clk2.atl_clk2 */
-		>;
-	};
-
-	mcasp3_pins: pinmux_mcasp3_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3724, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_aclkx */
-			DRA7XX_CORE_IOPAD(0x3728, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_fsx */
-			DRA7XX_CORE_IOPAD(0x372c, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_axr0 */
-			DRA7XX_CORE_IOPAD(0x3730, PIN_INPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_axr1 */
-		>;
-	};
-
-	mcasp3_sleep_pins: pinmux_mcasp3_sleep_pins {
-		pinctrl-single,pins = <
-			DRA7XX_CORE_IOPAD(0x3724, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3728, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x372c, MUX_MODE15)
-			DRA7XX_CORE_IOPAD(0x3730, MUX_MODE15)
-		>;
-	};
-};
-
-&i2c1 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c1_pins>;
-	clock-frequency = <400000>;
-
-	tps659038: tps659038@58 {
-		compatible = "ti,tps659038";
-		reg = <0x58>;
-
-		tps659038_pmic {
-			compatible = "ti,tps659038-pmic";
-
-			regulators {
-				smps123_reg: smps123 {
-					/* VDD_MPU */
-					regulator-name = "smps123";
-					regulator-min-microvolt = < 850000>;
-					regulator-max-microvolt = <1250000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				smps45_reg: smps45 {
-					/* VDD_DSPEVE */
-					regulator-name = "smps45";
-					regulator-min-microvolt = < 850000>;
-					regulator-max-microvolt = <1250000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				smps6_reg: smps6 {
-					/* VDD_GPU - over VDD_SMPS6 */
-					regulator-name = "smps6";
-					regulator-min-microvolt = <850000>;
-					regulator-max-microvolt = <1250000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				smps7_reg: smps7 {
-					/* CORE_VDD */
-					regulator-name = "smps7";
-					regulator-min-microvolt = <850000>;
-					regulator-max-microvolt = <1150000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				smps8_reg: smps8 {
-					/* VDD_IVAHD */
-					regulator-name = "smps8";
-					regulator-min-microvolt = < 850000>;
-					regulator-max-microvolt = <1250000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				smps9_reg: smps9 {
-					/* VDDS1V8 */
-					regulator-name = "smps9";
-					regulator-min-microvolt = <1800000>;
-					regulator-max-microvolt = <1800000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				ldo1_reg: ldo1 {
-					/* LDO1_OUT --> SDIO  */
-					regulator-name = "ldo1";
-					regulator-min-microvolt = <1800000>;
-					regulator-max-microvolt = <3300000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				ldo2_reg: ldo2 {
-					/* VDD_RTCIO */
-					/* LDO2 -> VDDSHV5, LDO2 also goes to CAN_PHY_3V3 */
-					regulator-name = "ldo2";
-					regulator-min-microvolt = <3300000>;
-					regulator-max-microvolt = <3300000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				ldo3_reg: ldo3 {
-					/* VDDA_1V8_PHY */
-					regulator-name = "ldo3";
-					regulator-min-microvolt = <1800000>;
-					regulator-max-microvolt = <1800000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				ldo9_reg: ldo9 {
-					/* VDD_RTC */
-					regulator-name = "ldo9";
-					regulator-min-microvolt = <1050000>;
-					regulator-max-microvolt = <1050000>;
-					regulator-always-on;
-					regulator-boot-on;
-					regulator-allow-bypass;
-				};
-
-				ldoln_reg: ldoln {
-					/* VDDA_1V8_PLL */
-					regulator-name = "ldoln";
-					regulator-min-microvolt = <1800000>;
-					regulator-max-microvolt = <1800000>;
-					regulator-always-on;
-					regulator-boot-on;
-				};
-
-				ldousb_reg: ldousb {
-					/* VDDA_3V_USB: VDDA_USBHS33 */
-					regulator-name = "ldousb";
-					regulator-min-microvolt = <3300000>;
-					regulator-max-microvolt = <3300000>;
-					regulator-boot-on;
-				};
-
-				/* REGEN1 is unused */
-
-				regen2: regen2 {
-					/* Needed for PMIC internal resources */
-					regulator-name = "regen2";
-					regulator-boot-on;
-					regulator-always-on;
-				};
-
-				/* REGEN3 is unused */
-
-				sysen1: sysen1 {
-					/* PMIC_REGEN_3V3 */
-					regulator-name = "sysen1";
-					regulator-boot-on;
-					regulator-always-on;
-				};
-
-				sysen2: sysen2 {
-					/* PMIC_REGEN_DDR */
-					regulator-name = "sysen2";
-					regulator-boot-on;
-					regulator-always-on;
-				};
-			};
-		};
-	};
-
-	pcf_lcd: gpio@20 {
-		compatible = "ti,pcf8575", "nxp,pcf8575";
-		reg = <0x20>;
-		gpio-controller;
-		#gpio-cells = <2>;
-		interrupt-parent = <&gpio6>;
-		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-	};
-
-	pcf_gpio_21: gpio@21 {
-		compatible = "ti,pcf8575", "nxp,pcf8575";
-		reg = <0x21>;
-		lines-initial-states = <0x1408>;
-		gpio-controller;
-		#gpio-cells = <2>;
-		interrupt-parent = <&gpio6>;
-		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-		u-boot,i2c-offset-len = <0>;
-	};
-
-	tlv320aic3106: tlv320aic3106@19 {
-		#sound-dai-cells = <0>;
-		compatible = "ti,tlv320aic3106";
-		reg = <0x19>;
-		adc-settle-ms = <40>;
-		ai3x-micbias-vg = <1>;		/* 2.0V */
-		status = "okay";
-
-		/* Regulators */
-		AVDD-supply = <&evm_3v3_sw>;
-		IOVDD-supply = <&evm_3v3_sw>;
-		DRVDD-supply = <&evm_3v3_sw>;
-		DVDD-supply = <&aic_dvdd>;
-	};
-};
-
-&i2c2 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c2_pins>;
-	clock-frequency = <400000>;
-
-	pcf_hdmi: gpio@26 {
-		compatible = "ti,pcf8575", "nxp,pcf8575";
-		reg = <0x26>;
-		gpio-controller;
-		#gpio-cells = <2>;
-		p1 {
-			/* vin6_sel_s0: high: VIN6, low: audio */
-			gpio-hog;
-			gpios = <1 GPIO_ACTIVE_HIGH>;
-			output-low;
-			line-name = "vin6_sel_s0";
-		};
-	};
-};
-
-&i2c3 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c3_pins>;
-	clock-frequency = <400000>;
-};
-
-&mcspi1 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&mcspi1_pins>;
-};
-
-&mcspi2 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&mcspi2_pins>;
-};
-
-&uart1 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart1_pins>;
-	interrupts-extended = <&crossbar_mpu GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
-			      <&dra7_pmx_core 0x3e0>;
-};
-
-&uart2 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2_pins>;
-};
-
-&uart3 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart3_pins>;
-};
-
-&mmc1 {
-	status = "okay";
-	vmmc-supply = <&evm_3v3_sd>;
-	vmmc_aux-supply = <&ldo1_reg>;
-	bus-width = <4>;
-	/*
-	 * SDCD signal is not being used here - using the fact that GPIO mode
-	 * is always hardwired.
-	 */
-	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>;
-};
-
-&mmc2 {
-	status = "okay";
-	vmmc-supply = <&evm_3v3_sw>;
-	bus-width = <8>;
-};
-
-&cpu0 {
-	cpu0-supply = <&smps123_reg>;
-};
-
-&qspi {
-	status = "okay";
-
-	spi-max-frequency = <76800000>;
-	m25p80@0 {
-		compatible = "s25fl256s1", "spi-flash";
-		spi-max-frequency = <76800000>;
-		reg = <0>;
-		spi-tx-bus-width = <1>;
-		spi-rx-bus-width = <4>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		/* MTD partition table.
-		 * The ROM checks the first four physical blocks
-		 * for a valid file to boot and the flash here is
-		 * 64KiB block size.
-		 */
-		partition@0 {
-			label = "QSPI.SPL";
-			reg = <0x00000000 0x000010000>;
-		};
-		partition@1 {
-			label = "QSPI.SPL.backup1";
-			reg = <0x00010000 0x00010000>;
-		};
-		partition@2 {
-			label = "QSPI.SPL.backup2";
-			reg = <0x00020000 0x00010000>;
-		};
-		partition@3 {
-			label = "QSPI.SPL.backup3";
-			reg = <0x00030000 0x00010000>;
-		};
-		partition@4 {
-			label = "QSPI.u-boot";
-			reg = <0x00040000 0x00100000>;
-		};
-		partition@5 {
-			label = "QSPI.u-boot-spl-os";
-			reg = <0x00140000 0x00080000>;
-		};
-		partition@6 {
-			label = "QSPI.u-boot-env";
-			reg = <0x001c0000 0x00010000>;
-		};
-		partition@7 {
-			label = "QSPI.u-boot-env.backup1";
-			reg = <0x001d0000 0x0010000>;
-		};
-		partition@8 {
-			label = "QSPI.kernel";
-			reg = <0x001e0000 0x0800000>;
-		};
-		partition@9 {
-			label = "QSPI.file-system";
-			reg = <0x009e0000 0x01620000>;
-		};
-	};
-};
-
-&omap_dwc3_1 {
-	extcon = <&extcon_usb1>;
-};
-
-&omap_dwc3_2 {
-	extcon = <&extcon_usb2>;
-};
-
-&usb1 {
-	dr_mode = "peripheral";
-	pinctrl-names = "default";
-	pinctrl-0 = <&usb1_pins>;
-};
-
-&usb2 {
-	dr_mode = "host";
-	pinctrl-names = "default";
-	pinctrl-0 = <&usb2_pins>;
-};
-
-&elm {
-	status = "okay";
-};
-
-&gpmc {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&nand_flash_x16>;
-	ranges = <0 0 0x08000000 0x01000000>;	/* minimum GPMC partition = 16MB */
-	nand@0,0 {
-		compatible = "ti,omap2-nand";
-		reg = <0 0 4>;		/* device IO registers */
-		interrupt-parent = <&gpmc>;
-		interrupts = <0 IRQ_TYPE_NONE>, /* fifoevent */
-			     <1 IRQ_TYPE_NONE>; /* termcount */
-		rb-gpios = <&gpmc 0 GPIO_ACTIVE_HIGH>; /* gpmc_wait0 pin */
-		ti,nand-ecc-opt = "bch8";
-		ti,elm-id = <&elm>;
-		nand-bus-width = <16>;
-		gpmc,device-width = <2>;
-		gpmc,sync-clk-ps = <0>;
-		gpmc,cs-on-ns = <0>;
-		gpmc,cs-rd-off-ns = <80>;
-		gpmc,cs-wr-off-ns = <80>;
-		gpmc,adv-on-ns = <0>;
-		gpmc,adv-rd-off-ns = <60>;
-		gpmc,adv-wr-off-ns = <60>;
-		gpmc,we-on-ns = <10>;
-		gpmc,we-off-ns = <50>;
-		gpmc,oe-on-ns = <4>;
-		gpmc,oe-off-ns = <40>;
-		gpmc,access-ns = <40>;
-		gpmc,wr-access-ns = <80>;
-		gpmc,rd-cycle-ns = <80>;
-		gpmc,wr-cycle-ns = <80>;
-		gpmc,bus-turnaround-ns = <0>;
-		gpmc,cycle2cycle-delay-ns = <0>;
-		gpmc,clk-activation-ns = <0>;
-		gpmc,wr-data-mux-bus-ns = <0>;
-		/* MTD partition table */
-		/* All SPL-* partitions are sized to minimal length
-		 * which can be independently programmable. For
-		 * NAND flash this is equal to size of erase-block */
-		#address-cells = <1>;
-		#size-cells = <1>;
-		partition@0 {
-			label = "NAND.SPL";
-			reg = <0x00000000 0x000020000>;
-		};
-		partition@1 {
-			label = "NAND.SPL.backup1";
-			reg = <0x00020000 0x00020000>;
-		};
-		partition@2 {
-			label = "NAND.SPL.backup2";
-			reg = <0x00040000 0x00020000>;
-		};
-		partition@3 {
-			label = "NAND.SPL.backup3";
-			reg = <0x00060000 0x00020000>;
-		};
-		partition@4 {
-			label = "NAND.u-boot-spl-os";
-			reg = <0x00080000 0x00040000>;
-		};
-		partition@5 {
-			label = "NAND.u-boot";
-			reg = <0x000c0000 0x00100000>;
-		};
-		partition@6 {
-			label = "NAND.u-boot-env";
-			reg = <0x001c0000 0x00020000>;
-		};
-		partition@7 {
-			label = "NAND.u-boot-env.backup1";
-			reg = <0x001e0000 0x00020000>;
-		};
-		partition@8 {
-			label = "NAND.kernel";
-			reg = <0x00200000 0x00800000>;
-		};
-		partition@9 {
-			label = "NAND.file-system";
-			reg = <0x00a00000 0x0f600000>;
-		};
-	};
-};
-
-&usb2_phy1 {
-	phy-supply = <&ldousb_reg>;
-};
-
-&usb2_phy2 {
-	phy-supply = <&ldousb_reg>;
-};
-
-&gpio7 {
-	ti,no-reset-on-init;
-	ti,no-idle-on-init;
-};
-
-&mac {
-	status = "okay";
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&cpsw_default>;
-	pinctrl-1 = <&cpsw_sleep>;
-	dual_emac;
-};
-
-&cpsw_emac0 {
-	phy_id = <&davinci_mdio>, <2>;
-	phy-mode = "rgmii";
-	dual_emac_res_vlan = <1>;
-};
-
-&cpsw_emac1 {
-	phy_id = <&davinci_mdio>, <3>;
-	phy-mode = "rgmii";
-	dual_emac_res_vlan = <2>;
-};
-
-&davinci_mdio {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&davinci_mdio_default>;
-	pinctrl-1 = <&davinci_mdio_sleep>;
-};
-
-&dcan1 {
-	status = "ok";
-	pinctrl-names = "default", "sleep", "active";
-	pinctrl-0 = <&dcan1_pins_sleep>;
-	pinctrl-1 = <&dcan1_pins_sleep>;
-	pinctrl-2 = <&dcan1_pins_default>;
-};
-
-&atl {
-	pinctrl-names = "default";
-	pinctrl-0 = <&atl_pins>;
-
-	assigned-clocks = <&abe_dpll_sys_clk_mux>,
-			  <&atl_gfclk_mux>,
-			  <&dpll_abe_ck>,
-			  <&dpll_abe_m2x2_ck>,
-			  <&atl_clkin2_ck>;
-	assigned-clock-parents = <&sys_clkin2>, <&dpll_abe_m2_ck>;
-	assigned-clock-rates = <0>, <0>, <180633600>, <361267200>, <5644800>;
-
-	status = "okay";
-
-	atl2 {
-		bws = <DRA7_ATL_WS_MCASP2_FSX>;
-		aws = <DRA7_ATL_WS_MCASP3_FSX>;
-	};
-};
-
-&mcasp3 {
-	#sound-dai-cells = <0>;
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&mcasp3_pins>;
-	pinctrl-1 = <&mcasp3_sleep_pins>;
-
-	assigned-clocks = <&mcasp3_ahclkx_mux>;
-	assigned-clock-parents = <&atl_clkin2_ck>;
-
-	status = "okay";
-
-	op-mode = <0>;          /* MCASP_IIS_MODE */
-	tdm-slots = <2>;
-	/* 4 serializer */
-	serial-dir = <  /* 0: INACTIVE, 1: TX, 2: RX */
-		1 2 0 0
-	>;
-	tx-num-evt = <32>;
-	rx-num-evt = <32>;
-};
-
-&mailbox5 {
-	status = "okay";
-	mbox_ipu1_ipc3x: mbox_ipu1_ipc3x {
-		status = "okay";
-	};
-	mbox_dsp1_ipc3x: mbox_dsp1_ipc3x {
-		status = "okay";
-	};
-};
-
-&mailbox6 {
-	status = "okay";
-	mbox_ipu2_ipc3x: mbox_ipu2_ipc3x {
-		status = "okay";
-	};
-	mbox_dsp2_ipc3x: mbox_dsp2_ipc3x {
-		status = "okay";
-	};
-};
+/*
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "dra74x.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clk/ti-dra7-atl.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "TI DRA742";
+	compatible = "ti,dra7-evm", "ti,dra742", "ti,dra74", "ti,dra7";
+
+	chosen {
+		stdout-path = &uart1;
+		tick-timer = &timer2;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x60000000>; /* 1536 MB */
+	};
+
+	evm_3v3_sd: fixedregulator-sd {
+		compatible = "regulator-fixed";
+		regulator-name = "evm_3v3_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&pcf_gpio_21 5 GPIO_ACTIVE_HIGH>;
+	};
+
+	evm_3v3_sw: fixedregulator-evm_3v3_sw {
+		compatible = "regulator-fixed";
+		regulator-name = "evm_3v3_sw";
+		vin-supply = <&sysen1>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	aic_dvdd: fixedregulator-aic_dvdd {
+		/* TPS77018DBVT */
+		compatible = "regulator-fixed";
+		regulator-name = "aic_dvdd";
+		vin-supply = <&evm_3v3_sw>;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	extcon_usb1: extcon_usb1 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&pcf_gpio_21 1 GPIO_ACTIVE_HIGH>;
+	};
+
+	extcon_usb2: extcon_usb2 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&pcf_gpio_21 2 GPIO_ACTIVE_HIGH>;
+	};
+
+	vtt_fixed: fixedregulator-vtt {
+		compatible = "regulator-fixed";
+		regulator-name = "vtt_fixed";
+		regulator-min-microvolt = <1350000>;
+		regulator-max-microvolt = <1350000>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		vin-supply = <&sysen2>;
+		gpio = <&gpio7 11 GPIO_ACTIVE_HIGH>;
+	};
+
+	sound0: sound0 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "DRA7xx-EVM";
+		simple-audio-card,widgets =
+			"Headphone", "Headphone Jack",
+			"Line", "Line Out",
+			"Microphone", "Mic Jack",
+			"Line", "Line In";
+		simple-audio-card,routing =
+			"Headphone Jack",	"HPLOUT",
+			"Headphone Jack",	"HPROUT",
+			"Line Out",		"LLOUT",
+			"Line Out",		"RLOUT",
+			"MIC3L",		"Mic Jack",
+			"MIC3R",		"Mic Jack",
+			"Mic Jack",		"Mic Bias",
+			"LINE1L",		"Line In",
+			"LINE1R",		"Line In";
+		simple-audio-card,format = "dsp_b";
+		simple-audio-card,bitclock-master = <&sound0_master>;
+		simple-audio-card,frame-master = <&sound0_master>;
+		simple-audio-card,bitclock-inversion;
+
+		sound0_master: simple-audio-card,cpu {
+			sound-dai = <&mcasp3>;
+			system-clock-frequency = <5644800>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tlv320aic3106>;
+			clocks = <&atl_clkin2_ck>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led0 {
+			label = "dra7:usr1";
+			gpios = <&pcf_lcd 4 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		led1 {
+			label = "dra7:usr2";
+			gpios = <&pcf_lcd 5 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		led2 {
+			label = "dra7:usr3";
+			gpios = <&pcf_lcd 6 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		led3 {
+			label = "dra7:usr4";
+			gpios = <&pcf_lcd 7 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+
+		USER1 {
+			label = "btnUser1";
+			linux,code = <BTN_0>;
+			gpios = <&pcf_lcd 2 GPIO_ACTIVE_LOW>;
+		};
+
+		USER2 {
+			label = "btnUser2";
+			linux,code = <BTN_1>;
+			gpios = <&pcf_lcd 3 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&dra7_pmx_core {
+	pinctrl-names = "default";
+	pinctrl-0 = <&vtt_pin>;
+
+	vtt_pin: pinmux_vtt_pin {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37b4, PIN_OUTPUT | MUX_MODE14) /* spi1_cs1.gpio7_11 */
+		>;
+	};
+
+	i2c1_pins: pinmux_i2c1_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3800, PIN_INPUT | MUX_MODE0) /* i2c1_sda */
+			DRA7XX_CORE_IOPAD(0x3804, PIN_INPUT | MUX_MODE0) /* i2c1_scl */
+		>;
+	};
+
+	i2c2_pins: pinmux_i2c2_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3808, PIN_INPUT | MUX_MODE0) /* i2c2_sda */
+			DRA7XX_CORE_IOPAD(0x380c, PIN_INPUT | MUX_MODE0) /* i2c2_scl */
+		>;
+	};
+
+	i2c3_pins: pinmux_i2c3_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3688, PIN_INPUT | MUX_MODE9) /* gpio6_14.i2c3_sda */
+			DRA7XX_CORE_IOPAD(0x368c, PIN_INPUT | MUX_MODE9) /* gpio6_15.i2c3_scl */
+		>;
+	};
+
+	mcspi1_pins: pinmux_mcspi1_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37a4, PIN_INPUT | MUX_MODE0) /* spi1_sclk */
+			DRA7XX_CORE_IOPAD(0x37a8, PIN_INPUT | MUX_MODE0) /* spi1_d1 */
+			DRA7XX_CORE_IOPAD(0x37ac, PIN_INPUT | MUX_MODE0) /* spi1_d0 */
+			DRA7XX_CORE_IOPAD(0x37b0, PIN_INPUT_SLEW | MUX_MODE0) /* spi1_cs0 */
+			DRA7XX_CORE_IOPAD(0x37b8, PIN_INPUT_SLEW | MUX_MODE6) /* spi1_cs2.hdmi1_hpd */
+			DRA7XX_CORE_IOPAD(0x37bc, PIN_INPUT_SLEW | MUX_MODE6) /* spi1_cs3.hdmi1_cec */
+		>;
+	};
+
+	mcspi2_pins: pinmux_mcspi2_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37c0, PIN_INPUT | MUX_MODE0) /* spi2_sclk */
+			DRA7XX_CORE_IOPAD(0x37c4, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_d1 */
+			DRA7XX_CORE_IOPAD(0x37c8, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_d1 */
+			DRA7XX_CORE_IOPAD(0x37cc, PIN_INPUT_SLEW | MUX_MODE0) /* spi2_cs0 */
+		>;
+	};
+
+	mmc1_pins_default: mmc1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x376c, PIN_INPUT | MUX_MODE14)	/* mmc1sdcd.gpio219 */
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE10 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: pinmux_mmc2_ddr_1_8v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs200_1_8v: mmc2_pins_hs200_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37e0, PIN_INPUT_SLEW | MUX_MODE0) /* uart1_rxd */
+			DRA7XX_CORE_IOPAD(0x37e4, PIN_INPUT_SLEW | MUX_MODE0) /* uart1_txd */
+			DRA7XX_CORE_IOPAD(0x37e8, PIN_INPUT | MUX_MODE3) /* uart1_ctsn */
+			DRA7XX_CORE_IOPAD(0x37ec, PIN_INPUT | MUX_MODE3) /* uart1_rtsn */
+		>;
+	};
+
+	uart2_pins: pinmux_uart2_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37f0, PIN_INPUT | MUX_MODE0) /* uart2_rxd */
+			DRA7XX_CORE_IOPAD(0x37f4, PIN_INPUT | MUX_MODE0) /* uart2_txd */
+			DRA7XX_CORE_IOPAD(0x37f8, PIN_INPUT | MUX_MODE0) /* uart2_ctsn */
+			DRA7XX_CORE_IOPAD(0x37fc, PIN_INPUT | MUX_MODE0) /* uart2_rtsn */
+		>;
+	};
+
+	uart3_pins: pinmux_uart3_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3648, PIN_INPUT_SLEW | MUX_MODE0) /* uart3_rxd */
+			DRA7XX_CORE_IOPAD(0x364c, PIN_INPUT_SLEW | MUX_MODE0) /* uart3_txd */
+		>;
+	};
+
+	usb1_pins: pinmux_usb1_pins {
+                pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3680, PIN_INPUT_SLEW | MUX_MODE0) /* usb1_drvvbus */
+                >;
+        };
+
+	usb2_pins: pinmux_usb2_pins {
+                pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3684, PIN_INPUT_SLEW | MUX_MODE0) /* usb2_drvvbus */
+                >;
+        };
+
+	nand_flash_x16: nand_flash_x16 {
+		/* On DRA7 EVM, GPMC_WPN and NAND_BOOTn comes from DIP switch
+		 * So NAND flash requires following switch settings:
+		 * SW5.1 (NAND_BOOTn) = ON (LOW)
+		 * SW5.9 (GPMC_WPN) = OFF (HIGH)
+		 */
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3400, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad0	*/
+			DRA7XX_CORE_IOPAD(0x3404, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad1	*/
+			DRA7XX_CORE_IOPAD(0x3408, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad2	*/
+			DRA7XX_CORE_IOPAD(0x340c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad3	*/
+			DRA7XX_CORE_IOPAD(0x3410, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad4	*/
+			DRA7XX_CORE_IOPAD(0x3414, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad5	*/
+			DRA7XX_CORE_IOPAD(0x3418, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad6	*/
+			DRA7XX_CORE_IOPAD(0x341c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad7	*/
+			DRA7XX_CORE_IOPAD(0x3420, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad8	*/
+			DRA7XX_CORE_IOPAD(0x3424, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad9	*/
+			DRA7XX_CORE_IOPAD(0x3428, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad10	*/
+			DRA7XX_CORE_IOPAD(0x342c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad11	*/
+			DRA7XX_CORE_IOPAD(0x3430, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad12	*/
+			DRA7XX_CORE_IOPAD(0x3434, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad13	*/
+			DRA7XX_CORE_IOPAD(0x3438, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad14	*/
+			DRA7XX_CORE_IOPAD(0x343c, PIN_INPUT  | MUX_MODE0)	/* gpmc_ad15	*/
+			DRA7XX_CORE_IOPAD(0x34d8, PIN_INPUT_PULLUP  | MUX_MODE0)	/* gpmc_wait0	*/
+			DRA7XX_CORE_IOPAD(0x34cc, PIN_OUTPUT | MUX_MODE0)	/* gpmc_wen	*/
+			DRA7XX_CORE_IOPAD(0x34b4, PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_csn0	*/
+			DRA7XX_CORE_IOPAD(0x34c4, PIN_OUTPUT | MUX_MODE0)	/* gpmc_advn_ale */
+			DRA7XX_CORE_IOPAD(0x34c8, PIN_OUTPUT | MUX_MODE0)	/* gpmc_oen_ren	 */
+			DRA7XX_CORE_IOPAD(0x34d0, PIN_OUTPUT | MUX_MODE0)	/* gpmc_be0n_cle */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* Slave 1 */
+			DRA7XX_CORE_IOPAD(0x3650, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txc.rgmii0_txc */
+			DRA7XX_CORE_IOPAD(0x3654, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txctl.rgmii0_txctl */
+			DRA7XX_CORE_IOPAD(0x3658, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_td3.rgmii0_txd3 */
+			DRA7XX_CORE_IOPAD(0x365c, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd2.rgmii0_txd2 */
+			DRA7XX_CORE_IOPAD(0x3660, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd1.rgmii0_txd1 */
+			DRA7XX_CORE_IOPAD(0x3664, PIN_OUTPUT | MUX_MODE0)	/* rgmii0_txd0.rgmii0_txd0 */
+			DRA7XX_CORE_IOPAD(0x3668, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxc.rgmii0_rxc */
+			DRA7XX_CORE_IOPAD(0x366c, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxctl.rgmii0_rxctl */
+			DRA7XX_CORE_IOPAD(0x3670, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd3.rgmii0_rxd3 */
+			DRA7XX_CORE_IOPAD(0x3674, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd2.rgmii0_rxd2 */
+			DRA7XX_CORE_IOPAD(0x3678, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd1.rgmii0_rxd1 */
+			DRA7XX_CORE_IOPAD(0x367c, PIN_INPUT | MUX_MODE0)	/* rgmii0_rxd0.rgmii0_rxd0 */
+
+			/* Slave 2 */
+			DRA7XX_CORE_IOPAD(0x3598, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d12.rgmii1_txc */
+			DRA7XX_CORE_IOPAD(0x359c, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d13.rgmii1_tctl */
+			DRA7XX_CORE_IOPAD(0x35a0, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d14.rgmii1_td3 */
+			DRA7XX_CORE_IOPAD(0x35a4, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d15.rgmii1_td2 */
+			DRA7XX_CORE_IOPAD(0x35a8, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d16.rgmii1_td1 */
+			DRA7XX_CORE_IOPAD(0x35ac, PIN_OUTPUT | MUX_MODE3)	/* vin2a_d17.rgmii1_td0 */
+			DRA7XX_CORE_IOPAD(0x35b0, PIN_INPUT | MUX_MODE3)	/* vin2a_d18.rgmii1_rclk */
+			DRA7XX_CORE_IOPAD(0x35b4, PIN_INPUT | MUX_MODE3)	/* vin2a_d19.rgmii1_rctl */
+			DRA7XX_CORE_IOPAD(0x35b8, PIN_INPUT | MUX_MODE3)	/* vin2a_d20.rgmii1_rd3 */
+			DRA7XX_CORE_IOPAD(0x35bc, PIN_INPUT | MUX_MODE3)	/* vin2a_d21.rgmii1_rd2 */
+			DRA7XX_CORE_IOPAD(0x35c0, PIN_INPUT | MUX_MODE3)	/* vin2a_d22.rgmii1_rd1 */
+			DRA7XX_CORE_IOPAD(0x35c4, PIN_INPUT | MUX_MODE3)	/* vin2a_d23.rgmii1_rd0 */
+		>;
+
+	};
+
+	cpsw_sleep: cpsw_sleep {
+		pinctrl-single,pins = <
+			/* Slave 1 */
+			DRA7XX_CORE_IOPAD(0x3650, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3654, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3658, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x365c, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3660, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3664, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3668, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x366c, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3670, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3674, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3678, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x367c, MUX_MODE15)
+
+			/* Slave 2 */
+			DRA7XX_CORE_IOPAD(0x3598, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x359c, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35a0, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35a4, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35a8, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35ac, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35b0, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35b4, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35b8, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35bc, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35c0, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x35c4, MUX_MODE15)
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x363c, PIN_OUTPUT_PULLUP | MUX_MODE0)	/* mdio_d.mdio_d */
+			DRA7XX_CORE_IOPAD(0x3640, PIN_INPUT_PULLUP | MUX_MODE0)	/* mdio_clk.mdio_clk */
+		>;
+	};
+
+	davinci_mdio_sleep: davinci_mdio_sleep {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x363c, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3640, MUX_MODE15)
+		>;
+	};
+
+	dcan1_pins_default: dcan1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37d0, PIN_OUTPUT_PULLUP | MUX_MODE0) /* dcan1_tx */
+			DRA7XX_CORE_IOPAD(0x3818, PULL_UP | MUX_MODE1) /* wakeup0.dcan1_rx */
+		>;
+	};
+
+	dcan1_pins_sleep: dcan1_pins_sleep {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37d0, MUX_MODE15 | PULL_UP)	/* dcan1_tx.off */
+			DRA7XX_CORE_IOPAD(0x3818, MUX_MODE15 | PULL_UP)	/* wakeup0.off */
+		>;
+	};
+
+	atl_pins: pinmux_atl_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3698, PIN_OUTPUT | MUX_MODE5)	/* xref_clk1.atl_clk1 */
+			DRA7XX_CORE_IOPAD(0x369c, PIN_OUTPUT | MUX_MODE5)	/* xref_clk2.atl_clk2 */
+		>;
+	};
+
+	mcasp3_pins: pinmux_mcasp3_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3724, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_aclkx */
+			DRA7XX_CORE_IOPAD(0x3728, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_fsx */
+			DRA7XX_CORE_IOPAD(0x372c, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_axr0 */
+			DRA7XX_CORE_IOPAD(0x3730, PIN_INPUT_PULLDOWN | MUX_MODE0)	/* mcasp3_axr1 */
+		>;
+	};
+
+	mcasp3_sleep_pins: pinmux_mcasp3_sleep_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3724, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3728, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x372c, MUX_MODE15)
+			DRA7XX_CORE_IOPAD(0x3730, MUX_MODE15)
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_rev11_conf: mmc1_iodelay_ddr50_rev11_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(572) G_DELAY_PS(540)	/* CFG_MMC1_CLK_IN */
+			0x624 A_DELAY_PS(0) G_DELAY_PS(600)	/* CFG_MMC1_CMD_IN */
+			0x630 A_DELAY_PS(403) G_DELAY_PS(120)	/* CFG_MMC1_DAT0_IN */
+			0x63c A_DELAY_PS(23) G_DELAY_PS(60)	/* CFG_MMC1_DAT1_IN */
+			0x648 A_DELAY_PS(25) G_DELAY_PS(60)	/* CFG_MMC1_DAT2_IN */
+			0x654 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x620 A_DELAY_PS(1525) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62c A_DELAY_PS(55) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x64c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc1_iodelay_ddr50_rev20_conf: mmc1_iodelay_ddr50_rev20_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CLK_IN */
+			0x620 A_DELAY_PS(1271) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x624 A_DELAY_PS(229) G_DELAY_PS(0)	/* CFG_MMC1_CMD_IN */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x630 A_DELAY_PS(850) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x63C A_DELAY_PS(468) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x648 A_DELAY_PS(466) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x654 A_DELAY_PS(399) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_rev11_conf: mmc1_iodelay_sdr104_rev11_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(1063) G_DELAY_PS(17)	/* CFG_MMC1_CLK_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62c A_DELAY_PS(23) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(2) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x64c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_rev20_conf: mmc1_iodelay_sdr104_rev20_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(600) G_DELAY_PS(400)	/* CFG_MMC1_CLK_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x638 A_DELAY_PS(30) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x64c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x650 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+			0x65c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+		>;
+	};
+
+	mmc2_iodelay_hs200_1_8v_rev11_conf: mmc2_iodelay_hs200_1_8v_rev11_conf {
+		pinctrl-pin-array = <
+			0x190 A_DELAY_PS(621) G_DELAY_PS(600)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(300) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(739) G_DELAY_PS(600)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(240) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(812) G_DELAY_PS(600)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(240) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(954) G_DELAY_PS(600)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(60)  G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(1340) G_DELAY_PS(420)	/* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(935) G_DELAY_PS(600)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(525) G_DELAY_PS(600)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(120) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(767) G_DELAY_PS(600)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(225) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(565) G_DELAY_PS(600)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(60) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(969) G_DELAY_PS(600)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(180) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+	      >;
+	};
+
+	mmc2_iodelay_hs200_1_8v_rev20_conf: mmc2_iodelay_hs200_1_8v_rev20_conf {
+		pinctrl-pin-array = <
+			0x190 A_DELAY_PS(274) G_DELAY_PS(0)       /* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(162) G_DELAY_PS(0)       /* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(401) G_DELAY_PS(0)       /* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(73) G_DELAY_PS(0)        /* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(465) G_DELAY_PS(0)       /* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(115) G_DELAY_PS(0)       /* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(633) G_DELAY_PS(0)       /* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(47) G_DELAY_PS(0)        /* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(935) G_DELAY_PS(280)     /* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(621) G_DELAY_PS(0)       /* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)         /* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(183) G_DELAY_PS(0)       /* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)         /* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(467) G_DELAY_PS(0)       /* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(0) G_DELAY_PS(0)         /* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(262) G_DELAY_PS(0)       /* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(46) G_DELAY_PS(0)        /* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(684) G_DELAY_PS(0)       /* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(76) G_DELAY_PS(0)        /* CFG_GPMC_CS1_OUT */
+	      >;
+	};
+
+	mmc2_iodelay_ddr_1_8v_rev11_conf: mmc2_iodelay_ddr_1_8v_rev11_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(274) G_DELAY_PS(240)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(60)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(0) G_DELAY_PS(60)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(514) G_DELAY_PS(360)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(187) G_DELAY_PS(120)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(60)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(121) G_DELAY_PS(60)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(174) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(168) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(136) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(879) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(34) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(120) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(11) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+
+	mmc2_iodelay_ddr_1_8v_rev20_conf: mmc2_iodelay_ddr_1_8v_rev20_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(270) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(170) G_DELAY_PS(0)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(758) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(81) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(286) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(123) G_DELAY_PS(0)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(346) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(55) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(422) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b4 A_DELAY_PS(642) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(128) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(395) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f0 A_DELAY_PS(623) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1fc A_DELAY_PS(54) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+	clock-frequency = <400000>;
+
+	tps659038: tps659038@58 {
+		compatible = "ti,tps659038";
+		reg = <0x58>;
+
+		tps659038_pmic {
+			compatible = "ti,tps659038-pmic";
+
+			regulators {
+				smps123_reg: smps123 {
+					/* VDD_MPU */
+					regulator-name = "smps123";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps45_reg: smps45 {
+					/* VDD_DSPEVE */
+					regulator-name = "smps45";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps6_reg: smps6 {
+					/* VDD_GPU - over VDD_SMPS6 */
+					regulator-name = "smps6";
+					regulator-min-microvolt = <850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps7_reg: smps7 {
+					/* CORE_VDD */
+					regulator-name = "smps7";
+					regulator-min-microvolt = <850000>;
+					regulator-max-microvolt = <1150000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps8_reg: smps8 {
+					/* VDD_IVAHD */
+					regulator-name = "smps8";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps9_reg: smps9 {
+					/* VDDS1V8 */
+					regulator-name = "smps9";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo1_reg: ldo1 {
+					/* LDO1_OUT --> SDIO  */
+					regulator-name = "ldo1";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo2_reg: ldo2 {
+					/* VDD_RTCIO */
+					/* LDO2 -> VDDSHV5, LDO2 also goes to CAN_PHY_3V3 */
+					regulator-name = "ldo2";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo3_reg: ldo3 {
+					/* VDDA_1V8_PHY */
+					regulator-name = "ldo3";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo9_reg: ldo9 {
+					/* VDD_RTC */
+					regulator-name = "ldo9";
+					regulator-min-microvolt = <1050000>;
+					regulator-max-microvolt = <1050000>;
+					regulator-always-on;
+					regulator-boot-on;
+					regulator-allow-bypass;
+				};
+
+				ldoln_reg: ldoln {
+					/* VDDA_1V8_PLL */
+					regulator-name = "ldoln";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldousb_reg: ldousb {
+					/* VDDA_3V_USB: VDDA_USBHS33 */
+					regulator-name = "ldousb";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-boot-on;
+				};
+
+				/* REGEN1 is unused */
+
+				regen2: regen2 {
+					/* Needed for PMIC internal resources */
+					regulator-name = "regen2";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+
+				/* REGEN3 is unused */
+
+				sysen1: sysen1 {
+					/* PMIC_REGEN_3V3 */
+					regulator-name = "sysen1";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+
+				sysen2: sysen2 {
+					/* PMIC_REGEN_DDR */
+					regulator-name = "sysen2";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+			};
+		};
+	};
+
+	pcf_lcd: gpio@20 {
+		compatible = "ti,pcf8575", "nxp,pcf8575";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-parent = <&gpio6>;
+		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+	};
+
+	pcf_gpio_21: gpio@21 {
+		compatible = "ti,pcf8575", "nxp,pcf8575";
+		reg = <0x21>;
+		lines-initial-states = <0x1408>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-parent = <&gpio6>;
+		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		u-boot,i2c-offset-len = <0>;
+	};
+
+	tlv320aic3106: tlv320aic3106@19 {
+		#sound-dai-cells = <0>;
+		compatible = "ti,tlv320aic3106";
+		reg = <0x19>;
+		adc-settle-ms = <40>;
+		ai3x-micbias-vg = <1>;		/* 2.0V */
+		status = "okay";
+
+		/* Regulators */
+		AVDD-supply = <&evm_3v3_sw>;
+		IOVDD-supply = <&evm_3v3_sw>;
+		DRVDD-supply = <&evm_3v3_sw>;
+		DVDD-supply = <&aic_dvdd>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+	clock-frequency = <400000>;
+
+	pcf_hdmi: gpio@26 {
+		compatible = "ti,pcf8575", "nxp,pcf8575";
+		reg = <0x26>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		p1 {
+			/* vin6_sel_s0: high: VIN6, low: audio */
+			gpio-hog;
+			gpios = <1 GPIO_ACTIVE_HIGH>;
+			output-low;
+			line-name = "vin6_sel_s0";
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3_pins>;
+	clock-frequency = <400000>;
+};
+
+&mcspi1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mcspi1_pins>;
+};
+
+&mcspi2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mcspi2_pins>;
+};
+
+&uart1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+	interrupts-extended = <&crossbar_mpu GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+			      <&dra7_pmx_core 0x3e0>;
+};
+
+&uart2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_pins>;
+};
+
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3_pins>;
+};
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&evm_3v3_sd>;
+	vmmc_aux-supply = <&ldo1_reg>;
+	bus-width = <4>;
+	/*
+	 * SDCD signal is not being used here - using the fact that GPIO mode
+	 * is always hardwired.
+	 */
+	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50-rev11", "sdr104-rev11", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_rev11_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_rev11_conf>;
+	pinctrl-7 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_rev20_conf>;
+	pinctrl-8 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_rev20_conf>;
+};
+
+&mmc2 {
+	status = "okay";
+	vmmc-supply = <&evm_3v3_sw>;
+	bus-width = <8>;
+	pinctrl-names = "default", "hs", "ddr_1_8v-rev11", "ddr_1_8v", "hs200_1_8v-rev11", "hs200_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_rev11_conf>;
+	pinctrl-3 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_rev20_conf>;
+	pinctrl-4 = <&mmc2_pins_hs200_1_8v &mmc2_iodelay_hs200_1_8v_rev11_conf>;
+	pinctrl-5 = <&mmc2_pins_hs200_1_8v &mmc2_iodelay_hs200_1_8v_rev20_conf>;
+};
+
+&cpu0 {
+	cpu0-supply = <&smps123_reg>;
+};
+
+&qspi {
+	status = "okay";
+
+	spi-max-frequency = <76800000>;
+	m25p80@0 {
+		compatible = "s25fl256s1", "spi-flash";
+		spi-max-frequency = <76800000>;
+		reg = <0>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		/* MTD partition table.
+		 * The ROM checks the first four physical blocks
+		 * for a valid file to boot and the flash here is
+		 * 64KiB block size.
+		 */
+		partition@0 {
+			label = "QSPI.SPL";
+			reg = <0x00000000 0x000010000>;
+		};
+		partition@1 {
+			label = "QSPI.SPL.backup1";
+			reg = <0x00010000 0x00010000>;
+		};
+		partition@2 {
+			label = "QSPI.SPL.backup2";
+			reg = <0x00020000 0x00010000>;
+		};
+		partition@3 {
+			label = "QSPI.SPL.backup3";
+			reg = <0x00030000 0x00010000>;
+		};
+		partition@4 {
+			label = "QSPI.u-boot";
+			reg = <0x00040000 0x00100000>;
+		};
+		partition@5 {
+			label = "QSPI.u-boot-spl-os";
+			reg = <0x00140000 0x00080000>;
+		};
+		partition@6 {
+			label = "QSPI.u-boot-env";
+			reg = <0x001c0000 0x00010000>;
+		};
+		partition@7 {
+			label = "QSPI.u-boot-env.backup1";
+			reg = <0x001d0000 0x0010000>;
+		};
+		partition@8 {
+			label = "QSPI.kernel";
+			reg = <0x001e0000 0x0800000>;
+		};
+		partition@9 {
+			label = "QSPI.file-system";
+			reg = <0x009e0000 0x01620000>;
+		};
+	};
+};
+
+&omap_dwc3_1 {
+	extcon = <&extcon_usb1>;
+};
+
+&omap_dwc3_2 {
+	extcon = <&extcon_usb2>;
+};
+
+&usb1 {
+	dr_mode = "peripheral";
+	pinctrl-names = "default";
+	pinctrl-0 = <&usb1_pins>;
+};
+
+&usb2 {
+	dr_mode = "host";
+	pinctrl-names = "default";
+	pinctrl-0 = <&usb2_pins>;
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&nand_flash_x16>;
+	ranges = <0 0 0x08000000 0x01000000>;	/* minimum GPMC partition = 16MB */
+	nand@0,0 {
+		compatible = "ti,omap2-nand";
+		reg = <0 0 4>;		/* device IO registers */
+		interrupt-parent = <&gpmc>;
+		interrupts = <0 IRQ_TYPE_NONE>, /* fifoevent */
+			     <1 IRQ_TYPE_NONE>; /* termcount */
+		rb-gpios = <&gpmc 0 GPIO_ACTIVE_HIGH>; /* gpmc_wait0 pin */
+		ti,nand-ecc-opt = "bch8";
+		ti,elm-id = <&elm>;
+		nand-bus-width = <16>;
+		gpmc,device-width = <2>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <80>;
+		gpmc,cs-wr-off-ns = <80>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <60>;
+		gpmc,adv-wr-off-ns = <60>;
+		gpmc,we-on-ns = <10>;
+		gpmc,we-off-ns = <50>;
+		gpmc,oe-on-ns = <4>;
+		gpmc,oe-off-ns = <40>;
+		gpmc,access-ns = <40>;
+		gpmc,wr-access-ns = <80>;
+		gpmc,rd-cycle-ns = <80>;
+		gpmc,wr-cycle-ns = <80>;
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		/* MTD partition table */
+		/* All SPL-* partitions are sized to minimal length
+		 * which can be independently programmable. For
+		 * NAND flash this is equal to size of erase-block */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		partition@0 {
+			label = "NAND.SPL";
+			reg = <0x00000000 0x000020000>;
+		};
+		partition@1 {
+			label = "NAND.SPL.backup1";
+			reg = <0x00020000 0x00020000>;
+		};
+		partition@2 {
+			label = "NAND.SPL.backup2";
+			reg = <0x00040000 0x00020000>;
+		};
+		partition@3 {
+			label = "NAND.SPL.backup3";
+			reg = <0x00060000 0x00020000>;
+		};
+		partition@4 {
+			label = "NAND.u-boot-spl-os";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@5 {
+			label = "NAND.u-boot";
+			reg = <0x000c0000 0x00100000>;
+		};
+		partition@6 {
+			label = "NAND.u-boot-env";
+			reg = <0x001c0000 0x00020000>;
+		};
+		partition@7 {
+			label = "NAND.u-boot-env.backup1";
+			reg = <0x001e0000 0x00020000>;
+		};
+		partition@8 {
+			label = "NAND.kernel";
+			reg = <0x00200000 0x00800000>;
+		};
+		partition@9 {
+			label = "NAND.file-system";
+			reg = <0x00a00000 0x0f600000>;
+		};
+	};
+};
+
+&usb2_phy1 {
+	phy-supply = <&ldousb_reg>;
+};
+
+&usb2_phy2 {
+	phy-supply = <&ldousb_reg>;
+};
+
+&gpio7 {
+	ti,no-reset-on-init;
+	ti,no-idle-on-init;
+};
+
+&mac {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_default>;
+	pinctrl-1 = <&cpsw_sleep>;
+	dual_emac;
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <2>;
+	phy-mode = "rgmii";
+	dual_emac_res_vlan = <1>;
+};
+
+&cpsw_emac1 {
+	phy_id = <&davinci_mdio>, <3>;
+	phy-mode = "rgmii";
+	dual_emac_res_vlan = <2>;
+};
+
+&davinci_mdio {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&davinci_mdio_default>;
+	pinctrl-1 = <&davinci_mdio_sleep>;
+};
+
+&dcan1 {
+	status = "ok";
+	pinctrl-names = "default", "sleep", "active";
+	pinctrl-0 = <&dcan1_pins_sleep>;
+	pinctrl-1 = <&dcan1_pins_sleep>;
+	pinctrl-2 = <&dcan1_pins_default>;
+};
+
+&atl {
+	pinctrl-names = "default";
+	pinctrl-0 = <&atl_pins>;
+
+	assigned-clocks = <&abe_dpll_sys_clk_mux>,
+			  <&atl_gfclk_mux>,
+			  <&dpll_abe_ck>,
+			  <&dpll_abe_m2x2_ck>,
+			  <&atl_clkin2_ck>;
+	assigned-clock-parents = <&sys_clkin2>, <&dpll_abe_m2_ck>;
+	assigned-clock-rates = <0>, <0>, <180633600>, <361267200>, <5644800>;
+
+	status = "okay";
+
+	atl2 {
+		bws = <DRA7_ATL_WS_MCASP2_FSX>;
+		aws = <DRA7_ATL_WS_MCASP3_FSX>;
+	};
+};
+
+&mcasp3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mcasp3_pins>;
+	pinctrl-1 = <&mcasp3_sleep_pins>;
+
+	assigned-clocks = <&mcasp3_ahclkx_mux>;
+	assigned-clock-parents = <&atl_clkin2_ck>;
+
+	status = "okay";
+
+	op-mode = <0>;          /* MCASP_IIS_MODE */
+	tdm-slots = <2>;
+	/* 4 serializer */
+	serial-dir = <  /* 0: INACTIVE, 1: TX, 2: RX */
+		1 2 0 0
+	>;
+	tx-num-evt = <32>;
+	rx-num-evt = <32>;
+};
+
+&mailbox5 {
+	status = "okay";
+	mbox_ipu1_ipc3x: mbox_ipu1_ipc3x {
+		status = "okay";
+	};
+	mbox_dsp1_ipc3x: mbox_dsp1_ipc3x {
+		status = "okay";
+	};
+};
+
+&mailbox6 {
+	status = "okay";
+	mbox_ipu2_ipc3x: mbox_ipu2_ipc3x {
+		status = "okay";
+	};
+	mbox_dsp2_ipc3x: mbox_dsp2_ipc3x {
+		status = "okay";
+	};
+};
diff -u -N U-Boot_SDcard/include/configs/siemens-am33x-common.h U-Boot_SDcard/include/configs/siemens-am33x-common.h
--- U-Boot_SDcard/include/configs/siemens-am33x-common.h	2019-09-12 15:54:41.000000806 -0500
+++ U-Boot_SDcard/include/configs/siemens-am33x-common.h	1969-12-31 19:29:22.000000458 -0600
@@ -134,7 +134,7 @@
 #define CONFIG_SPL_SPI_LOAD
 #define CONFIG_SYS_SPI_U_BOOT_OFFS	0x20000
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #define CONFIG_SPL_BOARD_INIT
 #define CONFIG_SPL_NAND_AM33XX_BCH
diff -u -N U-Boot_SDcard/include/configs/cm_t335.h U-Boot_SDcard/include/configs/cm_t335.h
--- U-Boot_SDcard/include/configs/cm_t335.h	2019-09-12 15:54:24.000000229 -0500
+++ U-Boot_SDcard/include/configs/cm_t335.h	1969-12-31 19:29:22.000000133 -0600
@@ -102,7 +102,7 @@
 #define CONFIG_SYS_I2C_EEPROM_BUS	0
 
 /* SPL */
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 /* Network. */
 #define CONFIG_PHY_GIGE
diff -u -N U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c
--- U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c	2019-09-12 15:54:15.000000899 -0500
+++ U-Boot_SDcard/board/compulab/cm_t3517/cm_t3517.c	1969-12-31 19:29:25.000000106 -0600
@@ -115,7 +115,7 @@
 	return 0;
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 #define SB_T35_CD_GPIO 144
 #define SB_T35_WP_GPIO 59
 
diff -u -N /dev/null U-Boot_SDcard/drivers/rapidio/Makefile
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/rapidio/Makefile	1969-12-31 19:31:37.000000920 -0600
@@ -0,0 +1,9 @@
+#
+# (C) Copyright 2017
+# Texas Instruments Incorporated, <www.ti.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_DM_RIO) += rio-uclass.o
+obj-$(CONFIG_KEYSTONE_RIO) += keystone_rio.o
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h	2019-09-12 15:54:52.000000689 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/hardware-k2g.h	1969-12-31 19:29:30.000000926 -0600
@@ -70,9 +70,12 @@
 
 #define K2G_GPIO0_BASE			0X02603000
 #define K2G_GPIO1_BASE			0X0260a000
+#define K2G_GPIO0_BANK0_BASE		K2G_GPIO0_BASE + 0x10
 #define K2G_GPIO1_BANK2_BASE		K2G_GPIO1_BASE + 0x38
 #define K2G_GPIO_DIR_OFFSET		0x0
+#define K2G_GPIO_OUTDATA_OFFSET		0x4
 #define K2G_GPIO_SETDATA_OFFSET		0x8
+#define K2G_GPIO_CLRDATA_OFFSET		0xC
 
 /* BOOTCFG RESETMUX8 */
 #define KS2_RSTMUX8			(KS2_DEVICE_STATE_CTRL_BASE + 0x328)
@@ -86,4 +89,25 @@
 #define RSTMUX_OMODE8_INT		0x3
 #define RSTMUX_OMODE8_INT_AND_DEV_RESET	0x4
 
+/* DEVSTAT register definition */
+#define KS2_DEVSTAT_REFCLK_SHIFT	 7
+#define KS2_DEVSTAT_REFCLK_MASK		(0x7 << 7)
+
+/* GPMC */
+#define KS2_GPMC_BASE			0x21818000
+
+/* SYSCLK indexes */
+#define SYSCLK_19MHz	0
+#define SYSCLK_24MHz	1
+#define SYSCLK_25MHz	2
+#define SYSCLK_26MHz	3
+#define MAX_SYSCLK	4
+
+#ifndef __ASSEMBLY__
+static inline u8 get_sysclk_index(void)
+{
+	u32 dev_stat = __raw_readl(KS2_DEVSTAT);
+	return (dev_stat & KS2_DEVSTAT_REFCLK_MASK) >> KS2_DEVSTAT_REFCLK_SHIFT;
+}
+#endif
 #endif /* __ASM_ARCH_HARDWARE_K2G_H */
diff -u -N U-Boot_SDcard/drivers/net/keystone_net.c U-Boot_SDcard/drivers/net/keystone_net.c
--- U-Boot_SDcard/drivers/net/keystone_net.c	2019-09-12 15:54:13.000000165 -0500
+++ U-Boot_SDcard/drivers/net/keystone_net.c	1969-12-31 19:29:21.000000305 -0600
@@ -104,6 +104,7 @@
 	struct mii_dev			*mdio_bus;
 	int				phy_addr;
 	phy_interface_t			phy_if;
+	int				phy_of_handle;
 	int				sgmii_link_type;
 	void				*mdio_base;
 	struct rx_buff_desc		net_rx_buffs;
@@ -955,6 +956,10 @@
 	if (priv->has_mdio) {
 		priv->phydev = phy_connect(priv->mdio_bus, priv->phy_addr,
 					   dev, priv->phy_if);
+#ifdef CONFIG_DM_ETH
+	if (priv->phy_of_handle)
+		priv->phydev->dev->of_offset = priv->phy_of_handle;
+#endif
 		phy_config(priv->phydev);
 	}
 
@@ -1048,6 +1053,7 @@
 	int phy;
 	int dma_count;
 	u32 dma_channel[8];
+	const char *phy_mode;
 
 	priv->slave_port = fdtdec_get_int(fdt, slave, "slave-port", -1);
 	priv->net_rx_buffs.rx_flow = priv->slave_port * 8;
@@ -1069,7 +1075,9 @@
 	priv->link_type = fdtdec_get_int(fdt, slave, "link-interface", -1);
 
 	phy = fdtdec_lookup_phandle(fdt, slave, "phy-handle");
+
 	if (phy >= 0) {
+		priv->phy_of_handle = phy;
 		priv->phy_addr = fdtdec_get_int(fdt, phy, "reg", -1);
 
 		mdio = fdt_parent_offset(fdt, phy);
@@ -1086,7 +1094,19 @@
 		priv->sgmii_link_type = SGMII_LINK_MAC_PHY;
 		priv->has_mdio = true;
 	} else if (priv->link_type == LINK_TYPE_RGMII_LINK_MAC_PHY) {
-		priv->phy_if = PHY_INTERFACE_MODE_RGMII;
+		phy_mode = fdt_getprop(fdt, slave, "phy-mode", NULL);
+		if (phy_mode) {
+			priv->phy_if = phy_get_interface_by_name(phy_mode);
+			if ((priv->phy_if != PHY_INTERFACE_MODE_RGMII) &&
+			    (priv->phy_if != PHY_INTERFACE_MODE_RGMII_ID) &&
+			    (priv->phy_if != PHY_INTERFACE_MODE_RGMII_RXID) &&
+			    (priv->phy_if != PHY_INTERFACE_MODE_RGMII_TXID)) {
+				error("invalid phy-mode\n");
+				return -EINVAL;
+			}
+		} else {
+			priv->phy_if = PHY_INTERFACE_MODE_RGMII;
+		}
 		pdata->phy_interface = priv->phy_if;
 		priv->has_mdio = true;
 	}
diff -u -N U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c
--- U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c	2019-09-12 15:54:32.000000363 -0500
+++ U-Boot_SDcard/board/compulab/cm_t35/cm_t35.c	1969-12-31 19:29:25.000000102 -0600
@@ -372,7 +372,7 @@
 		cm_t3730_set_muxconf();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 #define SB_T35_WP_GPIO 59
 
 int board_mmc_getcd(struct mmc *mmc)
diff -u -N U-Boot_SDcard/arch/arm/include/asm/cache.h U-Boot_SDcard/arch/arm/include/asm/cache.h
--- U-Boot_SDcard/arch/arm/include/asm/cache.h	2019-09-12 15:54:57.000000440 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/cache.h	1969-12-31 19:29:28.000000629 -0600
@@ -39,6 +39,7 @@
 void arm_init_domains(void);
 void cpu_cache_initialization(void);
 void dram_bank_mmu_setup(int bank);
+void sram_bank_mmu_setup(phys_addr_t start, phys_addr_t size);
 
 #endif
 
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c	2019-09-12 15:54:22.000000103 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock.c	1969-12-31 19:29:28.000000727 -0600
@@ -244,3 +244,13 @@
 	scale_vcores();
 	setup_dplls();
 }
+
+void rtc_only_prcm_init(void)
+{
+	const struct dpll_params *params;
+
+	rtc_only_enable_basic_clocks();
+
+	params = get_dpll_ddr_params();
+	do_setup_dpll(&dpll_ddr_regs, params);
+}
diff -u -N U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts
--- U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts	2019-09-12 15:54:40.000000271 -0500
+++ U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15.dts	1969-12-31 19:29:23.000000228 -0600
@@ -1,24 +1,120 @@
-/*
- * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include "am57xx-beagle-x15-common.dtsi"
-
-/ {
-	/* NOTE: This describes the "original" pre-production A2 revision */
-	model = "TI AM5728 BeagleBoard-X15";
-};
-
-&tpd12s015 {
-	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
-		<&gpio6 28 GPIO_ACTIVE_HIGH>,	/* gpio6_28, LS OE */
-		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
-};
-
-&mmc1 {
-	vmmc-supply = <&ldo1_reg>;
-};
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am57xx-beagle-x15-common.dtsi"
+
+/ {
+	/* NOTE: This describes the "original" pre-production A2 revision */
+	model = "TI AM5728 BeagleBoard-X15";
+};
+
+&tpd12s015 {
+	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
+		<&gpio6 28 GPIO_ACTIVE_HIGH>,	/* gpio6_28, LS OE */
+		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
+};
+
+&dra7_pmx_core {
+	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_3_3v: pinmux_mmc2_ddr_3_3v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc2_iodelay_ddr_3_3v_conf: mmc2_iodelay_ddr_3_3v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A19_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(174) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a4 A_DELAY_PS(265) G_DELAY_PS(360)	/* CFG_GPMC_A20_IN */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(168) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A21_IN */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(136) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1bc A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A22_IN */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1c8 A_DELAY_PS(287) G_DELAY_PS(420)	/* CFG_GPMC_A23_IN */
+			0x1d0 A_DELAY_PS(879) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d4 A_DELAY_PS(144) G_DELAY_PS(240)	/* CFG_GPMC_A24_IN */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(34) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A26_IN */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(120) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1f8 A_DELAY_PS(120) G_DELAY_PS(180)	/* CFG_GPMC_A27_IN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(11) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+
+	vmmc-supply = <&ldo1_reg>;
+	/delete-property/ sd-uhs-sdr104;
+	/delete-property/ sd-uhs-sdr50;
+	/delete-property/ sd-uhs-ddr50;
+	/delete-property/ sd-uhs-sdr25;
+	/delete-property/ sd-uhs-sdr12;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_3_3v &mmc2_iodelay_ddr_3_3v_conf>;
+	/delete-property/ mmc-hs200-1_8v;
+};
diff -u -N U-Boot_SDcard/include/linux/mtd/nand.h U-Boot_SDcard/include/linux/mtd/nand.h
--- U-Boot_SDcard/include/linux/mtd/nand.h	2019-09-12 15:54:58.000000765 -0500
+++ U-Boot_SDcard/include/linux/mtd/nand.h	1969-12-31 19:29:28.000000277 -0600
@@ -684,6 +684,16 @@
  *			correctable).
  * @write_page:		[REPLACEABLE] High-level page write function
  */
+#ifdef CONFIG_DM_NAND
+/**
+ * DM compatible nand drivers must have struct nand_chip as
+ * the first part of their private data:
+ * U_BOOT_DRIVER(...) = {
+ *     ...
+ *             .priv_auto_alloc_size = sizeof(struct nand_chip),
+ * };
+ */
+#endif
 
 struct nand_chip {
 	struct mtd_info mtd;
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk
--- U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk	2019-09-12 15:54:52.000000332 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/config_secure.mk	1969-12-31 19:29:23.000000895 -0600
@@ -1,111 +1,126 @@
-#
-# Copyright (C) 2016, Texas Instruments, Incorporated - http://www.ti.com/
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-quiet_cmd_mkomapsecimg = SECURE  $@
-ifneq ($(TI_SECURE_DEV_PKG),)
-ifneq ($(wildcard $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh),)
-ifneq ($(CONFIG_SPL_BUILD),)
-cmd_mkomapsecimg = $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh \
-	$(patsubst u-boot-spl_HS_%,%,$(@F)) $< $@ $(CONFIG_ISW_ENTRY_ADDR) \
-	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
-else
-cmd_mkomapsecimg = $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh \
-	$(patsubst u-boot_HS_%,%,$(@F)) $< $@ $(CONFIG_ISW_ENTRY_ADDR) \
-	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
-endif
-else
-cmd_mkomapsecimg = echo "WARNING:" \
-	"$(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh not found." \
-	"$@ was NOT secured!"; cp $< $@
-endif
-else
-cmd_mkomapsecimg = echo "WARNING: TI_SECURE_DEV_PKG environment" \
-	"variable must be defined for TI secure devices. \
-	$@ was NOT secured!"; cp $< $@
-endif
-
-ifdef CONFIG_SPL_LOAD_FIT
-quiet_cmd_omapsecureimg = SECURE  $@
-ifneq ($(TI_SECURE_DEV_PKG),)
-ifneq ($(wildcard $(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh),)
-cmd_omapsecureimg = $(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh \
-	$< $@ \
-	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
-else
-cmd_omapsecureimg = echo "WARNING:" \
-	"$(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh not found." \
-	"$@ was NOT secured!"; cp $< $@
-endif
-else
-cmd_omapsecureimg = echo "WARNING: TI_SECURE_DEV_PKG environment" \
-	"variable must be defined for TI secure devices." \
-	"$@ was NOT secured!"; cp $< $@
-endif
-endif
-
-
-# Standard X-LOADER target (QPSI, NOR flash)
-u-boot-spl_HS_X-LOADER: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# For MLO targets (SD card boot) the final file name that is copied to the SD
-# card FAT partition must be MLO, so we make a copy of the output file to a new
-# file with that name
-u-boot-spl_HS_MLO: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-	@if [ -f $@ ]; then \
-		cp -f $@ MLO; \
-	fi
-
-# Standard 2ND target (certain peripheral boot modes)
-u-boot-spl_HS_2ND: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# Standard ULO target (certain peripheral boot modes)
-u-boot-spl_HS_ULO: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# Standard ISSW target (certain devices, various boot modes)
-u-boot-spl_HS_ISSW: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# For SPI flash on AM335x and AM43xx, these require special byte swap handling
-# so we use the SPI_X-LOADER target instead of X-LOADER and let the
-# create-boot-image.sh script handle that
-u-boot-spl_HS_SPI_X-LOADER: $(obj)/u-boot-spl.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# For supporting single stage XiP QSPI on AM43xx, the image is a full u-boot
-# file, not an SPL. In this case the mkomapsecimg command looks for a
-# u-boot-HS_* prefix
-u-boot_HS_XIP_X-LOADER: $(obj)/u-boot.bin FORCE
-	$(call if_changed,mkomapsecimg)
-
-# For supporting the SPL loading and interpreting of FIT images whose
-# components are pre-processed before being integrated into the FIT image in
-# order to secure them in some way
-ifdef CONFIG_SPL_LOAD_FIT
-
-MKIMAGEFLAGS_u-boot_HS.img = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
-	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
-	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board" -E \
-	$(patsubst %,-b arch/$(ARCH)/dts/%.dtb_HS,$(subst ",,$(CONFIG_OF_LIST)))
-
-OF_LIST_TARGETS = $(patsubst %,arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST)))
-$(OF_LIST_TARGETS): dtbs
-
-%.dtb_HS: %.dtb FORCE
-	$(call if_changed,omapsecureimg)
-
-u-boot-nodtb_HS.bin: u-boot-nodtb.bin FORCE
-	$(call if_changed,omapsecureimg)
-
-u-boot_HS.img: u-boot-nodtb_HS.bin u-boot.img $(patsubst %.dtb,%.dtb_HS,$(OF_LIST_TARGETS)) FORCE
-	$(call if_changed,mkimage)
-	$(Q)if [ -f $@ ]; then \
-		cp -f $@ u-boot.img; \
-	fi
-
-endif
+#
+# Copyright (C) 2016, Texas Instruments, Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+quiet_cmd_mkomapsecimg = SECURE  $@
+ifneq ($(TI_SECURE_DEV_PKG),)
+ifneq ($(wildcard $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh),)
+ifneq ($(CONFIG_SPL_BUILD),)
+cmd_mkomapsecimg = $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh \
+	$(patsubst u-boot-spl_HS_%,%,$(@F)) $< $@ $(CONFIG_ISW_ENTRY_ADDR) \
+	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
+else
+cmd_mkomapsecimg = $(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh \
+	$(patsubst u-boot_HS_%,%,$(@F)) $< $@ $(CONFIG_ISW_ENTRY_ADDR) \
+	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
+endif
+else
+cmd_mkomapsecimg = echo "WARNING:" \
+	"$(TI_SECURE_DEV_PKG)/scripts/create-boot-image.sh not found." \
+	"$@ was NOT secured!"; cp $< $@
+endif
+else
+cmd_mkomapsecimg = echo "WARNING: TI_SECURE_DEV_PKG environment" \
+	"variable must be defined for TI secure devices. \
+	$@ was NOT secured!"; cp $< $@
+endif
+
+ifdef CONFIG_SPL_LOAD_FIT
+quiet_cmd_omapsecureimg = SECURE  $@
+ifneq ($(TI_SECURE_DEV_PKG),)
+ifneq ($(wildcard $(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh),)
+cmd_omapsecureimg = $(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh \
+	$< $@ \
+	$(if $(KBUILD_VERBOSE:1=), >/dev/null)
+else
+cmd_omapsecureimg = echo "WARNING:" \
+	"$(TI_SECURE_DEV_PKG)/scripts/secure-binary-image.sh not found." \
+	"$@ was NOT secured!"; cp $< $@
+endif
+else
+cmd_omapsecureimg = echo "WARNING: TI_SECURE_DEV_PKG environment" \
+	"variable must be defined for TI secure devices." \
+	"$@ was NOT secured!"; cp $< $@
+endif
+endif
+
+
+# Standard X-LOADER target (QPSI, NOR flash)
+u-boot-spl_HS_X-LOADER: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+
+# For MLO targets (SD card boot) the final file name that is copied to the SD
+# card FAT partition must be MLO, so we make a copy of the output file to a new
+# file with that name
+u-boot-spl_HS_MLO: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+	@if [ -f $@ ]; then \
+		cp -f $@ MLO; \
+	fi
+
+# Standard 2ND target (certain peripheral boot modes)
+u-boot-spl_HS_2ND: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+
+# Standard ULO target (certain peripheral boot modes)
+u-boot-spl_HS_ULO: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+
+# Standard ISSW target (certain devices, various boot modes), when copied to
+# an SD card FAT partition this file must be called "MLO", we make a copy with
+# this name to make this clear
+u-boot-spl_HS_ISSW: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+	@if [ -f $@ ]; then \
+		cp -f $@ MLO; \
+	fi
+
+# For SPI flash on AM335x and AM43xx, these require special byte swap handling
+# so we use the SPI_X-LOADER target instead of X-LOADER and let the
+# create-boot-image.sh script handle that
+u-boot-spl_HS_SPI_X-LOADER: $(obj)/u-boot-spl.bin FORCE
+	$(call if_changed,mkomapsecimg)
+
+# For supporting single stage boot on keystone, the image is a full u-boot
+# file, not an SPL. This will work for all boot devices, other than SPI
+# flash. On Keystone devices when booting from an SD card FAT partition this
+# file must be called "MLO"
+u-boot_HS_MLO: $(obj)/u-boot.bin
+	$(call if_changed,mkomapsecimg)
+	@if [ -f $@ ]; then \
+		cp -f $@ MLO; \
+	fi
+
+# For supporting single stage XiP QSPI on AM43xx, the image is a full u-boot
+# file, not an SPL. In this case the mkomapsecimg command looks for a
+# u-boot-HS_* prefix
+u-boot_HS_XIP_X-LOADER: $(obj)/u-boot.bin FORCE
+	$(call if_changed,mkomapsecimg)
+
+# For supporting the SPL loading and interpreting of FIT images whose
+# components are pre-processed before being integrated into the FIT image in
+# order to secure them in some way
+ifdef CONFIG_SPL_LOAD_FIT
+
+MKIMAGEFLAGS_u-boot_HS.img = -f auto -A $(ARCH) -T firmware -C none -O u-boot \
+	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_UBOOT_START) \
+	-n "U-Boot $(UBOOTRELEASE) for $(BOARD) board" -E \
+	$(patsubst %,-b arch/$(ARCH)/dts/%.dtb_HS,$(subst ",,$(CONFIG_OF_LIST)))
+
+OF_LIST_TARGETS = $(patsubst %,arch/$(ARCH)/dts/%.dtb,$(subst ",,$(CONFIG_OF_LIST)))
+$(OF_LIST_TARGETS): dtbs
+
+%.dtb_HS: %.dtb FORCE
+	$(call if_changed,omapsecureimg)
+
+u-boot-nodtb_HS.bin: u-boot-nodtb.bin FORCE
+	$(call if_changed,omapsecureimg)
+
+u-boot_HS.img: u-boot-nodtb_HS.bin u-boot.img $(patsubst %.dtb,%.dtb_HS,$(OF_LIST_TARGETS)) FORCE
+	$(call if_changed,mkimage)
+	$(Q)if [ -f $@ ]; then \
+		cp -f $@ u-boot.img; \
+	fi
+
+endif
diff -u -N U-Boot_SDcard/drivers/mmc/fsl_esdhc.c U-Boot_SDcard/drivers/mmc/fsl_esdhc.c
--- U-Boot_SDcard/drivers/mmc/fsl_esdhc.c	2019-09-12 15:54:21.000000721 -0500
+++ U-Boot_SDcard/drivers/mmc/fsl_esdhc.c	1969-12-31 19:29:21.000000184 -0600
@@ -592,7 +592,7 @@
 }
 #endif
 
-static void esdhc_set_ios(struct mmc *mmc)
+static int esdhc_set_ios(struct mmc *mmc)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
 	struct fsl_esdhc *regs = priv->esdhc_regs;
@@ -614,6 +614,7 @@
 	else if (mmc->bus_width == 8)
 		esdhc_setbits32(&regs->proctl, PROCTL_DTW_8);
 
+	return 0;
 }
 
 static int esdhc_init(struct mmc *mmc)
@@ -655,7 +656,7 @@
 #endif
 
 	/* Set the initial clock speed */
-	mmc_set_clock(mmc, 400000);
+	mmc_set_clock(mmc, 400000, false);
 
 	/* Disable the BRR and BWR bits in IRQSTAT */
 	esdhc_clrbits32(&regs->irqstaten, IRQSTATEN_BRR | IRQSTATEN_BWR);
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/config.mk U-Boot_SDcard/arch/arm/mach-keystone/config.mk
--- U-Boot_SDcard/arch/arm/mach-keystone/config.mk	2019-09-12 15:55:03.000000153 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/config.mk	1969-12-31 19:29:23.000000850 -0600
@@ -1,28 +1,34 @@
-# Copyright 2015 Texas Instruments Incorporated, <www.ti.com>
-#
-# Lokesh Vutla <lokeshvutla@ti.com>
-#
-# SPDX-License-Identifier:     GPL-2.0+
-#
-
-ifndef CONFIG_SPL_BUILD
-ALL-y += MLO
-endif
-
-MKIMAGEFLAGS_u-boot-spl.gph = -A $(ARCH) -T gpimage -C none \
-	-a $(CONFIG_SPL_TEXT_BASE) -e $(CONFIG_SPL_TEXT_BASE) -n SPL
-spl/u-boot-spl.gph: spl/u-boot-spl.bin FORCE
-	$(call if_changed,mkimage)
-
-OBJCOPYFLAGS_u-boot-spi.gph = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
-			  --gap-fill=0
-u-boot-spi.gph: spl/u-boot-spl.gph u-boot-dtb.img FORCE
-	$(call if_changed,pad_cat)
-
-ifndef CONFIG_SPL_BUILD
-MKIMAGEFLAGS_MLO = -A $(ARCH) -T gpimage -C none \
-	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE) -n U-Boot
-MLO: u-boot-dtb.bin FORCE
-	$(call if_changed,mkimage)
-	@dd if=/dev/zero bs=8 count=1 2>/dev/null >> $@
-endif
+# Copyright 2015 Texas Instruments Incorporated, <www.ti.com>
+#
+# Lokesh Vutla <lokeshvutla@ti.com>
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+include  $(srctree)/arch/arm/mach-omap2/config_secure.mk
+
+ifndef CONFIG_SPL_BUILD
+ifeq ($(CONFIG_TI_SECURE_DEVICE),y)
+ALL-y += u-boot_HS_MLO
+else
+ALL-y += MLO
+endif
+endif
+
+MKIMAGEFLAGS_u-boot-spl.gph = -A $(ARCH) -T gpimage -C none \
+	-a $(CONFIG_SPL_TEXT_BASE) -e $(CONFIG_SPL_TEXT_BASE) -n SPL
+spl/u-boot-spl.gph: spl/u-boot-spl.bin FORCE
+	$(call if_changed,mkimage)
+
+OBJCOPYFLAGS_u-boot-spi.gph = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
+			  --gap-fill=0
+u-boot-spi.gph: spl/u-boot-spl.gph u-boot.img FORCE
+	$(call if_changed,pad_cat)
+
+ifndef CONFIG_SPL_BUILD
+MKIMAGEFLAGS_MLO = -A $(ARCH) -T gpimage -C none \
+	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE) -n U-Boot
+MLO: u-boot.bin FORCE
+	$(call if_changed,mkimage)
+	@dd if=/dev/zero bs=8 count=1 2>/dev/null >> $@
+endif
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/config.mk U-Boot_SDcard/arch/arm/mach-omap2/config.mk
--- U-Boot_SDcard/arch/arm/mach-omap2/config.mk	2019-09-12 15:54:14.000000722 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/config.mk	1969-12-31 19:29:23.000000894 -0600
@@ -1,53 +1,67 @@
-#
-# Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
-#
-# SPDX-License-Identifier:      GPL-2.0+
-
-include  $(srctree)/arch/arm/mach-omap2/config_secure.mk
-
-ifdef CONFIG_SPL_BUILD
-ifeq ($(CONFIG_AM33XX)$(CONFIG_TI_SECURE_DEVICE),yy)
-#
-# For booting from SPI use
-# u-boot-spl_HS_SPI_X-LOADER to program flash
-#
-# On AM43XX:
-#
-# For booting spl from all other media use
-# u-boot-spl_HS_ISSW
-#
-# On AM33XX:
-#
-# For booting spl from NAND flash use
-# u-boot-spl_HS_X-LOADER
-#
-# For booting spl from SD/MMC/eMMC media use
-# u-boot-spl_HS_MLO
-#
-# For booting spl over UART, USB, or Ethernet use
-# u-boot-spl_HS_2ND
-#
-# Refer to README.ti-secure for more info
-#
-ALL-y += u-boot-spl_HS_ISSW
-ALL-y += u-boot-spl_HS_SPI_X-LOADER
-ALL-y += u-boot-spl_HS_X-LOADER
-ALL-y += u-boot-spl_HS_MLO
-ALL-y += u-boot-spl_HS_2ND
-else
-ifeq ($(CONFIG_OMAP54XX)$(CONFIG_TI_SECURE_DEVICE),yy)
-ALL-y += u-boot-spl_HS_MLO u-boot-spl_HS_X-LOADER
-else
-ALL-y += MLO
-ifeq ($(CONFIG_AM33XX),y)
-ALL-y += MLO.byteswap
-endif
-endif
-endif
-else
-ifeq ($(CONFIG_TI_SECURE_DEVICE),y)
-ALL-$(CONFIG_QSPI_BOOT) += u-boot_HS_XIP_X-LOADER
-ALL-$(CONFIG_SPL_LOAD_FIT) += u-boot_HS.img
-endif
-ALL-y += u-boot.img
-endif
+#
+# Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:      GPL-2.0+
+
+include  $(srctree)/arch/arm/mach-omap2/config_secure.mk
+
+ifdef CONFIG_SPL_BUILD
+ifeq ($(CONFIG_TI_SECURE_DEVICE),y) # Refer to README.ti-secure for more info
+# On DRA7xx/AM57xx:
+#
+# For booting spl from SD/MMC/eMMC use
+# u-boot-spl_HS_MLO
+#
+# For booting spl over UART or USB use
+# u-boot-spl_HS_ULO
+#
+# For booting spl from QSPI or NOR use
+# u-boot-spl_HS_X-LOADER
+ifeq ($(CONFIG_OMAP54XX),y)
+ALL-y += u-boot-spl_HS_MLO
+ALL-y += u-boot-spl_HS_ULO
+ALL-y += u-boot-spl_HS_X-LOADER
+endif
+# On AM43XX:
+#
+# For booting spl from SPI flash use
+# u-boot-spl_HS_SPI_X-LOADER
+#
+# For booting spl from all other media use
+# u-boot-spl_HS_ISSW
+ifeq ($(CONFIG_AM43XX),y)
+ALL-y += u-boot-spl_HS_SPI_X-LOADER
+ALL-y += u-boot-spl_HS_ISSW
+endif
+# On AM33XX:
+#
+# For booting spl from SPI flash use
+# u-boot-spl_HS_SPI_X-LOADER
+#
+# For booting spl from NAND flash or raw SD/MMC/eMMC use
+# u-boot-spl_HS_X-LOADER
+#
+# For booting spl from a filesystem on SD/MMC/eMMC use
+# u-boot-spl_HS_MLO
+#
+# For booting spl over UART, USB, or Ethernet use
+# u-boot-spl_HS_2ND
+ifeq ($(CONFIG_AM33XX),y)
+ALL-y += u-boot-spl_HS_SPI_X-LOADER
+ALL-y += u-boot-spl_HS_X-LOADER
+ALL-y += u-boot-spl_HS_MLO
+ALL-y += u-boot-spl_HS_2ND
+endif
+else
+ALL-y += MLO
+ifeq ($(CONFIG_AM33XX),y)
+ALL-y += MLO.byteswap
+endif
+endif
+else
+ifeq ($(CONFIG_TI_SECURE_DEVICE),y)
+ALL-$(CONFIG_QSPI_BOOT) += u-boot_HS_XIP_X-LOADER
+ALL-$(CONFIG_SPL_LOAD_FIT) += u-boot_HS.img
+endif
+ALL-y += u-boot.img
+endif
diff -u -N U-Boot_SDcard/cmd/jffs2.c U-Boot_SDcard/cmd/jffs2.c
--- U-Boot_SDcard/cmd/jffs2.c	2019-09-12 15:54:34.000000674 -0500
+++ U-Boot_SDcard/cmd/jffs2.c	1969-12-31 19:29:17.000000382 -0600
@@ -166,8 +166,9 @@
 #endif
 	} else if (type == MTD_DEV_TYPE_NAND) {
 #if defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)
-		if (num < CONFIG_SYS_MAX_NAND_DEVICE) {
-			*size = nand_info[num]->size;
+		struct mtd_info *mtd = get_nand_dev_by_index(num);
+		if (mtd) {
+			*size = mtd->size;
 			return 0;
 		}
 
@@ -244,7 +245,7 @@
 #if defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)
 	struct mtd_info *mtd;
 
-	mtd = nand_info[id->num];
+	mtd = get_nand_dev_by_index(id->num);
 
 	return mtd->erasesize;
 #else
diff -u -N /dev/null U-Boot_SDcard/drivers/rapidio/keystone_rio.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/rapidio/keystone_rio.c	1969-12-31 19:31:37.000000921 -0600
@@ -0,0 +1,1483 @@
+/*
+ * Texas Instruments Keystone RapidIO driver
+ * Authors: Aurelien Jacquiot <a-jacquiot@ti.com>
+ *	    WingMan Kwok <w-kwok2@ti.com>
+ *
+ * This is the Rapidio driver for Keystone devices. This is
+ * required to support RapidIO functionality on K2HK devices.
+ *
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the
+ * distribution.
+ *
+ * Neither the name of Texas Instruments Incorporated nor the names of
+ * its contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/arch/psc_defs.h>
+#include <linux/compat.h>
+#include <rio.h>
+
+#include "keystone_rio.h"
+
+#define DRIVER_VER		"v2.0"
+
+#ifdef CONFIG_SOC_K2HK
+#define KEYSTONE_RIO_IS_K2	1
+#else
+#define KEYSTONE_RIO_IS_K2	0
+#endif
+
+#define K2_SERDES(p)        ((p)->board_rio_cfg.keystone2_serdes)
+
+static unsigned int rio_dbg;
+
+#define debug_rio(fmt, args...)	if (rio_dbg) printf(fmt, ##args)
+
+/*
+ * Main KeyStone RapidIO driver data
+ */
+struct keystone_rio_data {
+	struct udevice		*dev;
+	int			riohdid;
+	u32			rio_pe_feat;
+
+	u32			ports_registering;
+	u32			port_chk_cnt;
+
+	u8			lsu_start;
+	u8			lsu_end;
+	u8			lsu_free;
+	u8			lsu_maint;
+
+	u32			*jtagid_reg;
+	u32			*serdes_sts_reg;
+	struct keystone_srio_serdes_regs	*serdes_regs;
+	struct keystone_rio_regs		*regs;
+
+	struct keystone_rio_car_csr_regs	*car_csr_regs;
+	struct keystone_rio_serial_port_regs	*serial_port_regs;
+	struct keystone_rio_err_mgmt_regs	*err_mgmt_regs;
+	struct keystone_rio_phy_layer_regs	*phy_regs;
+	struct keystone_rio_transport_layer_regs *transport_regs;
+	struct keystone_rio_pkt_buf_regs	*pkt_buf_regs;
+	struct keystone_rio_evt_mgmt_regs	*evt_mgmt_regs;
+	struct keystone_rio_port_write_regs	*port_write_regs;
+	struct keystone_rio_link_layer_regs	*link_regs;
+	struct keystone_rio_fabric_regs		*fabric_regs;
+	u32					car_csr_regs_base;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define krio_write_reg(r, v)		writel(reg_val, reg)
+#define krio_read_reg(r)		readl(reg)
+
+#define krio_read(k, r)			readl(&k->regs->r)
+#define krio_write(k, r, v)		writel((v), &k->regs->r)
+
+#define krio_car_csr_read(k, r)		readl(&k->car_csr_regs->r)
+#define krio_car_csr_write(k, r, v)	writel((v), &k->car_csr_regs->r)
+
+#define krio_car_csr_read_ofs(k, ofs)		\
+		readl((void *)k->car_csr_regs_base + ofs)
+#define krio_car_csr_write_ofs(k, ofs, v)	\
+		writel((v), (void *)(k->car_csr_regs_base + ofs))
+
+#define krio_sp_read(k, r)		readl(&k->serial_port_regs->r)
+#define krio_sp_write(k, r, v)		writel((v), &k->serial_port_regs->r)
+
+#define krio_err_read(k, r)		readl(&k->err_mgmt_regs->r)
+#define krio_err_write(k, r, v)		writel((v), &k->err_mgmt_regs->r)
+
+#define krio_phy_read(k, r)		readl(&k->phy_regs->r)
+#define krio_phy_write(k, r, v)		writel((v), &k->phy_regs->r)
+
+#define krio_tp_read(k, r)		readl(&k->transport_regs->r)
+#define krio_tp_write(k, r, v)		writel((v), &k->transport_regs->r)
+
+#define krio_pb_read(k, r)		readl(&k->pkt_buf_regs->r)
+#define krio_pb_write(k, r, v)		writel((v), &k->pkt_buf_regs->r)
+
+#define krio_ev_read(k, r)		readl(&k->evt_mgmt_regs->r)
+#define krio_ev_write(k, r, v)		writel((v), &k->evt_mgmt_regs->r)
+
+#define krio_pw_read(k, r)		readl(&k->port_write_regs->r)
+#define krio_pw_write(k, r, v)		writel((v), &k->port_write_regs->r)
+
+#define krio_lnk_read(k, r)		readl(&k->link_regs->r)
+#define krio_lnk_write(k, r, v)		writel((v), &k->link_regs->r)
+
+#define krio_fab_read(k, r)		readl(&k->fabric_regs->r)
+#define krio_fab_write(k, r, v)		writel((v), &k->fabric_regs->r)
+
+#define krio_sd_read(k, r)		readl(&k->serdes_regs->r)
+#define krio_sd_write(k, r, v)		writel((v), &k->serdes_regs->r)
+
+/*--------------------- Maintenance Request Management  ---------------------*/
+
+static u32 keystone_rio_dio_get_lsu_cc(u32 lsu_id, u8 ltid, u8 *lcb,
+				       struct keystone_rio_data *krio_priv)
+{
+	u32 idx;
+	u32 shift;
+	u32 value;
+	u32 cc;
+	/* lSU shadow register status mapping */
+	u32 lsu_index[8] = { 0, 9, 15, 20, 24, 33, 39, 44 };
+
+	/* Compute LSU stat index from LSU id and LTID */
+	idx   = (lsu_index[lsu_id] + ltid) >> 3;
+	shift = ((lsu_index[lsu_id] + ltid) & 0x7) << 2;
+
+	/* Get completion code and context */
+	value  = krio_read(krio_priv, lsu_stat_reg[idx]);
+	cc     = (value >> (shift + 1)) & 0x7;
+	*lcb   = (value >> shift) & 0x1;
+
+	return cc;
+}
+
+/**
+ * maint_request - Perform a maintenance request
+ * @port_id: output port ID of transaction
+ * @dest_id: destination ID of target device
+ * @hopcount: hopcount for this request
+ * @offset: offset in the RapidIO configuration space
+ * @buff: dma address of the data on the host
+ * @buff_len: length of the data
+ * @size: 1 for 16bit, 0 for 8bit ID size
+ * @type: packet type
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+static inline int keystone_rio_maint_request(
+	int port_id,
+	u32 dest_id,
+	u8  hopcount,
+	u32 offset,
+	dma_addr_t buff,
+	int buff_len,
+	u16 size,
+	u16 type,
+	struct keystone_rio_data *krio_priv)
+{
+	unsigned int count;
+	unsigned int status = 0;
+	unsigned int res    = 0;
+	u8           context;
+	u8           ltid;
+
+	/* Check is there is space in the LSU shadow reg and that it is free */
+	count = 0;
+	while (1) {
+		status = krio_read(krio_priv, lsu_reg[0].busy_full);
+		if (((status & KEYSTONE_RIO_LSU_FULL_MASK) == 0x0) &&
+		    ((status & KEYSTONE_RIO_LSU_BUSY_MASK) == 0x0))
+			break;
+		count++;
+
+		if (count >= KEYSTONE_RIO_TIMEOUT_CNT) {
+			debug_rio("RIO: no LSU available, status = 0x%x\n",
+				  status);
+			res = -1;
+			goto out;
+		}
+		udelay(1);
+	}
+
+	/* Get LCB and LTID, LSU reg 6 is already read */
+	context = (status >> 4) & 0x1;
+	ltid    = status & 0xf;
+
+	/* LSU Reg 0 - MSB of RapidIO address */
+	krio_write(krio_priv, lsu_reg[0].addr_msb, 0);
+
+	/* LSU Reg 1 - LSB of destination */
+	krio_write(krio_priv, lsu_reg[0].addr_lsb_cfg_ofs, offset);
+
+	/* LSU Reg 2 - source address */
+	krio_write(krio_priv, lsu_reg[0].dsp_addr, buff);
+
+	/* LSU Reg 3 - byte count */
+	krio_write(krio_priv, lsu_reg[0].dbell_val_byte_cnt, buff_len);
+
+	/* LSU Reg 4 - */
+	krio_write(krio_priv, lsu_reg[0].destid,
+		   ((port_id << 8)
+		    | (KEYSTONE_RIO_LSU_PRIO << 4)
+		    | (size ? BIT(10) : 0)
+		    | ((u32)dest_id << 16)));
+
+	/* LSU Reg 5 */
+	krio_write(krio_priv, lsu_reg[0].dbell_info_fttype,
+		   ((hopcount & 0xff) << 8) | (type & 0xff));
+
+	/* Retrieve our completion code */
+	count = 0;
+	res   = 0;
+	while (1) {
+		u8 lcb;
+
+		status = keystone_rio_dio_get_lsu_cc(0, ltid, &lcb, krio_priv);
+		if (lcb == context)
+			break;
+		count++;
+		if (count >= KEYSTONE_RIO_TIMEOUT_CNT) {
+			debug_rio(
+				"RIO: timeout %d, ltid = %d, context = %d, lcb = %d, cc = %d\n",
+				count, ltid, context, lcb, status);
+			res = -2;
+			break;
+		}
+		udelay(1);
+	}
+out:
+	if (res)
+		return res;
+
+	if (status)
+		debug_rio("RIO: transfer error = 0x%x\n", status);
+
+	switch (status) {
+	case KEYSTONE_RIO_LSU_CC_TIMEOUT:
+	case KEYSTONE_RIO_LSU_CC_XOFF:
+	case KEYSTONE_RIO_LSU_CC_ERROR:
+	case KEYSTONE_RIO_LSU_CC_INVALID:
+	case KEYSTONE_RIO_LSU_CC_DMA:
+		return -3;
+	case KEYSTONE_RIO_LSU_CC_RETRY:
+		return -4;
+	case KEYSTONE_RIO_LSU_CC_CANCELED:
+		return -5;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/*------------------------- RapidIO hw controller setup ---------------------*/
+
+struct keystone_lane_config {
+	int start; /* lane start number of the port */
+	int end;   /* lane end number of the port */
+};
+
+/*
+ * Table with the various lanes per port configuration modes:
+ * path mode 0: 4 ports in 1x
+ * path mode 1: 3 ports in 2x/1x
+ * path mode 2: 3 ports in 1x/2x
+ * path mode 3: 2 ports in 2x
+ * path mode 4: 1 ports in 4x
+ */
+static struct keystone_lane_config keystone_lane_configs[5][4] = {
+	{ {0, 1}, {1, 2},   {2, 3},   {3, 4}   },
+	{ {0, 2}, {-1, -1}, {2, 3},   {3, 4}   },
+	{ {0, 1}, {1, 2},   {2, 4},   {-1, -1} },
+	{ {0, 2}, {-1, -1}, {2, 4},   {-1, -1} },
+	{ {0, 4}, {-1, -1}, {-1, -1}, {-1, -1} },
+};
+
+/* Retrieve the corresponding lanes bitmask from ports bitmask and path_mode */
+static int keystone_rio_get_lane_config(u32 ports, u32 path_mode)
+{
+	u32 lanes = 0;
+
+	while (ports) {
+		u32 lane;
+		u32 port = ffs(ports) - 1;
+
+		ports &= ~BIT(port);
+
+		if (keystone_lane_configs[path_mode][port].start == -1)
+			return -1;
+
+		for (lane = keystone_lane_configs[path_mode][port].start;
+		     lane < keystone_lane_configs[path_mode][port].end;
+		     lane++) {
+			lanes |= BIT(lane);
+		}
+	}
+	return (int)lanes;
+}
+
+/* Serdes Config Begin */
+#define reg_fmkr(msb, lsb, val)					\
+	(((val) & ((BIT((msb) - (lsb) + 1)) - 1)) << (lsb))
+
+#define reg_finsr(addr, msb, lsb, val)					\
+	writel(((readl(addr)						\
+		 & ~(((BIT((msb) - (lsb) + 1)) - 1) << (lsb)))		\
+		 | reg_fmkr(msb, lsb, val)), (addr))
+
+static void k2_rio_serdes_init_3g(u32 lanes,
+				  struct keystone_rio_data *krio_priv)
+{
+	void __iomem *reg = (void __iomem *)krio_priv->serdes_regs;
+
+	reg_finsr((reg + 0x0000), 31, 24, 0x00);
+	reg_finsr((reg + 0x0014),  7,  0, 0x82);
+	reg_finsr((reg + 0x0014), 15,  8, 0x82);
+	reg_finsr((reg + 0x0060),  7,  0, 0x48);
+	reg_finsr((reg + 0x0060), 15,  8, 0x2c);
+	reg_finsr((reg + 0x0060), 23, 16, 0x13);
+	reg_finsr((reg + 0x0064), 15,  8, 0xc7);
+	reg_finsr((reg + 0x0064), 23, 16, 0xc3);
+	reg_finsr((reg + 0x0078), 15,  8, 0xc0);
+
+	reg_finsr((reg + 0x0204),  7,  0, 0x80);
+	reg_finsr((reg + 0x0204), 31, 24, 0x78);
+	reg_finsr((reg + 0x0208),  7,  0, 0x24);
+	reg_finsr((reg + 0x0208), 23, 16, 0x01);
+	reg_finsr((reg + 0x020c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0210), 31, 24, 0x1b);
+	reg_finsr((reg + 0x0214),  7,  0, 0x7c);
+	reg_finsr((reg + 0x0214), 15,  8, 0x6e);
+	reg_finsr((reg + 0x0218),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0218), 23, 16, 0x80);
+	reg_finsr((reg + 0x0218), 31, 24, 0x7a);
+	reg_finsr((reg + 0x022c), 15,  8, 0x08);
+	reg_finsr((reg + 0x022c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0280),  7,  0, 0x70);
+	reg_finsr((reg + 0x0280), 23, 16, 0x70);
+	reg_finsr((reg + 0x0284),  7,  0, 0x85);
+	reg_finsr((reg + 0x0284), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0284), 31, 24, 0x1d);
+	reg_finsr((reg + 0x028c), 15,  8, 0x3b);
+
+	reg_finsr((reg + 0x0404),  7,  0, 0x80);
+	reg_finsr((reg + 0x0404), 31, 24, 0x78);
+	reg_finsr((reg + 0x0408),  7,  0, 0x24);
+	reg_finsr((reg + 0x0408), 23, 16, 0x01);
+	reg_finsr((reg + 0x040c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0410), 31, 24, 0x1b);
+	reg_finsr((reg + 0x0414),  7,  0, 0x7c);
+	reg_finsr((reg + 0x0414), 15,  8, 0x6e);
+	reg_finsr((reg + 0x0418),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0418), 23, 16, 0x80);
+	reg_finsr((reg + 0x0418), 31, 24, 0x7a);
+	reg_finsr((reg + 0x042c), 15,  8, 0x08);
+	reg_finsr((reg + 0x042c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0480),  7,  0, 0x70);
+	reg_finsr((reg + 0x0480), 23, 16, 0x70);
+	reg_finsr((reg + 0x0484),  7,  0, 0x85);
+	reg_finsr((reg + 0x0484), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0484), 31, 24, 0x1d);
+	reg_finsr((reg + 0x048c), 15,  8, 0x3b);
+
+	reg_finsr((reg + 0x0604),  7,  0, 0x80);
+	reg_finsr((reg + 0x0604), 31, 24, 0x78);
+	reg_finsr((reg + 0x0608),  7,  0, 0x24);
+	reg_finsr((reg + 0x0608), 23, 16, 0x01);
+	reg_finsr((reg + 0x060c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0610), 31, 24, 0x1b);
+	reg_finsr((reg + 0x0614),  7,  0, 0x7c);
+	reg_finsr((reg + 0x0614), 15,  8, 0x6e);
+	reg_finsr((reg + 0x0618),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0618), 23, 16, 0x80);
+	reg_finsr((reg + 0x0618), 31, 24, 0x7a);
+	reg_finsr((reg + 0x062c), 15,  8, 0x08);
+	reg_finsr((reg + 0x062c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0680),  7,  0, 0x70);
+	reg_finsr((reg + 0x0680), 23, 16, 0x70);
+	reg_finsr((reg + 0x0684),  7,  0, 0x85);
+	reg_finsr((reg + 0x0684), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0684), 31, 24, 0x1d);
+	reg_finsr((reg + 0x068c), 15,  8, 0x3b);
+
+	reg_finsr((reg + 0x0804),  7,  0, 0x80);
+	reg_finsr((reg + 0x0804), 31, 24, 0x78);
+	reg_finsr((reg + 0x0808),  7,  0, 0x24);
+	reg_finsr((reg + 0x0808), 23, 16, 0x01);
+	reg_finsr((reg + 0x080c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0810), 31, 24, 0x1b);
+	reg_finsr((reg + 0x0814),  7,  0, 0x7c);
+	reg_finsr((reg + 0x0814), 15,  8, 0x6e);
+	reg_finsr((reg + 0x0818),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0818), 23, 16, 0x80);
+	reg_finsr((reg + 0x0818), 31, 24, 0x7a);
+	reg_finsr((reg + 0x082c), 15,  8, 0x08);
+	reg_finsr((reg + 0x082c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0880),  7,  0, 0x70);
+	reg_finsr((reg + 0x0880), 23, 16, 0x70);
+	reg_finsr((reg + 0x0884),  7,  0, 0x85);
+	reg_finsr((reg + 0x0884), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0884), 31, 24, 0x1d);
+	reg_finsr((reg + 0x088c), 15,  8, 0x3b);
+
+	reg_finsr((reg + 0x0a00), 15,  8, 0x08);
+	reg_finsr((reg + 0x0a08), 23, 16, 0x72);
+	reg_finsr((reg + 0x0a08), 31, 24, 0x37);
+	reg_finsr((reg + 0x0a30), 15,  8, 0x77);
+	reg_finsr((reg + 0x0a30), 23, 16, 0x77);
+	reg_finsr((reg + 0x0a84), 15,  8, 0x07);
+	reg_finsr((reg + 0x0a94), 31, 24, 0x10);
+	reg_finsr((reg + 0x0aa0), 31, 24, 0x81);
+	reg_finsr((reg + 0x0abc), 31, 24, 0xff);
+	reg_finsr((reg + 0x0ac0),  7,  0, 0x8b);
+	reg_finsr((reg + 0x0a48), 15,  8, 0x8c);
+	reg_finsr((reg + 0x0a48), 23, 16, 0xfd);
+	reg_finsr((reg + 0x0a54),  7,  0, 0x72);
+	reg_finsr((reg + 0x0a54), 15,  8, 0xec);
+	reg_finsr((reg + 0x0a54), 23, 16, 0x2f);
+	reg_finsr((reg + 0x0a58), 15,  8, 0x21);
+	reg_finsr((reg + 0x0a58), 23, 16, 0xf9);
+	reg_finsr((reg + 0x0a58), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a5c),  7,  0, 0x60);
+	reg_finsr((reg + 0x0a5c), 15,  8, 0x00);
+	reg_finsr((reg + 0x0a5c), 23, 16, 0x04);
+	reg_finsr((reg + 0x0a5c), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a60),  7,  0, 0x00);
+	reg_finsr((reg + 0x0a60), 15,  8, 0x80);
+	reg_finsr((reg + 0x0a60), 23, 16, 0x00);
+	reg_finsr((reg + 0x0a60), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a64),  7,  0, 0x20);
+	reg_finsr((reg + 0x0a64), 15,  8, 0x12);
+	reg_finsr((reg + 0x0a64), 23, 16, 0x58);
+	reg_finsr((reg + 0x0a64), 31, 24, 0x0c);
+	reg_finsr((reg + 0x0a68),  7,  0, 0x02);
+	reg_finsr((reg + 0x0a68), 15,  8, 0x06);
+	reg_finsr((reg + 0x0a68), 23, 16, 0x3b);
+	reg_finsr((reg + 0x0a68), 31, 24, 0xe1);
+	reg_finsr((reg + 0x0a6c),  7,  0, 0xc1);
+	reg_finsr((reg + 0x0a6c), 15,  8, 0x4c);
+	reg_finsr((reg + 0x0a6c), 23, 16, 0x07);
+	reg_finsr((reg + 0x0a6c), 31, 24, 0xb8);
+	reg_finsr((reg + 0x0a70),  7,  0, 0x89);
+	reg_finsr((reg + 0x0a70), 15,  8, 0xe9);
+	reg_finsr((reg + 0x0a70), 23, 16, 0x02);
+	reg_finsr((reg + 0x0a70), 31, 24, 0x3f);
+	reg_finsr((reg + 0x0a74),  7,  0, 0x01);
+	reg_finsr((reg + 0x0b20), 23, 16, 0x37);
+	reg_finsr((reg + 0x0b1c), 31, 24, 0x37);
+	reg_finsr((reg + 0x0b20),  7,  0, 0x5d);
+	reg_finsr((reg + 0x0000),  7,  0, 0x03);
+	reg_finsr((reg + 0x0a00),  7,  0, 0x5f);
+}
+
+static void k2_rio_serdes_init_5g(u32 lanes,
+				  struct keystone_rio_data *krio_priv)
+{
+	void __iomem *reg = (void __iomem *)krio_priv->serdes_regs;
+
+	reg_finsr((reg + 0x0000), 31, 24, 0x00);
+	reg_finsr((reg + 0x0014),  7,  0, 0x82);
+	reg_finsr((reg + 0x0014), 15,  8, 0x82);
+	reg_finsr((reg + 0x0060),  7,  0, 0x38);
+	reg_finsr((reg + 0x0060), 15,  8, 0x24);
+	reg_finsr((reg + 0x0060), 23, 16, 0x14);
+	reg_finsr((reg + 0x0064), 15,  8, 0xc7);
+	reg_finsr((reg + 0x0064), 23, 16, 0xc3);
+	reg_finsr((reg + 0x0078), 15,  8, 0xc0);
+
+	reg_finsr((reg + 0x0204),  7,  0, 0x80);
+	reg_finsr((reg + 0x0204), 31, 24, 0x78);
+	reg_finsr((reg + 0x0208),  7,  0, 0x26);
+	reg_finsr((reg + 0x0208), 23, 16, 0x01);
+	reg_finsr((reg + 0x020c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0214),  7,  0, 0x38);
+	reg_finsr((reg + 0x0214), 15,  8, 0x6f);
+	reg_finsr((reg + 0x0218),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0218), 23, 16, 0x80);
+	reg_finsr((reg + 0x0218), 31, 24, 0x7a);
+	reg_finsr((reg + 0x022c), 15,  8, 0x08);
+	reg_finsr((reg + 0x022c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0280),  7,  0, 0x86);
+	reg_finsr((reg + 0x0280), 23, 16, 0x86);
+	reg_finsr((reg + 0x0284),  7,  0, 0x85);
+	reg_finsr((reg + 0x0284), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0284), 31, 24, 0x1d);
+	reg_finsr((reg + 0x028c), 15,  8, 0x2c);
+
+	reg_finsr((reg + 0x0404),  7,  0, 0x80);
+	reg_finsr((reg + 0x0404), 31, 24, 0x78);
+	reg_finsr((reg + 0x0408),  7,  0, 0x26);
+	reg_finsr((reg + 0x0408), 23, 16, 0x01);
+	reg_finsr((reg + 0x040c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0414),  7,  0, 0x38);
+	reg_finsr((reg + 0x0414), 15,  8, 0x6f);
+	reg_finsr((reg + 0x0418),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0418), 23, 16, 0x80);
+	reg_finsr((reg + 0x0418), 31, 24, 0x7a);
+	reg_finsr((reg + 0x042c), 15,  8, 0x08);
+	reg_finsr((reg + 0x042c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0480),  7,  0, 0x86);
+	reg_finsr((reg + 0x0480), 23, 16, 0x86);
+	reg_finsr((reg + 0x0484),  7,  0, 0x85);
+	reg_finsr((reg + 0x0484), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0484), 31, 24, 0x1d);
+	reg_finsr((reg + 0x048c), 15,  8, 0x2c);
+
+	reg_finsr((reg + 0x0604),  7,  0, 0x80);
+	reg_finsr((reg + 0x0604), 31, 24, 0x78);
+	reg_finsr((reg + 0x0608),  7,  0, 0x26);
+	reg_finsr((reg + 0x0608), 23, 16, 0x01);
+	reg_finsr((reg + 0x060c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0614),  7,  0, 0x38);
+	reg_finsr((reg + 0x0614), 15,  8, 0x6f);
+	reg_finsr((reg + 0x0618),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0618), 23, 16, 0x80);
+	reg_finsr((reg + 0x0618), 31, 24, 0x7a);
+	reg_finsr((reg + 0x062c), 15,  8, 0x08);
+	reg_finsr((reg + 0x062c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0680),  7,  0, 0x86);
+	reg_finsr((reg + 0x0680), 23, 16, 0x86);
+	reg_finsr((reg + 0x0684),  7,  0, 0x85);
+	reg_finsr((reg + 0x0684), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0684), 31, 24, 0x1d);
+	reg_finsr((reg + 0x068c), 15,  8, 0x2c);
+
+	reg_finsr((reg + 0x0804),  7,  0, 0x80);
+	reg_finsr((reg + 0x0804), 31, 24, 0x78);
+	reg_finsr((reg + 0x0808),  7,  0, 0x26);
+	reg_finsr((reg + 0x0808), 23, 16, 0x01);
+	reg_finsr((reg + 0x080c), 31, 24, 0x02);
+	reg_finsr((reg + 0x0814),  7,  0, 0x38);
+	reg_finsr((reg + 0x0814), 15,  8, 0x6f);
+	reg_finsr((reg + 0x0818),  7,  0, 0xe4);
+	reg_finsr((reg + 0x0818), 23, 16, 0x80);
+	reg_finsr((reg + 0x0818), 31, 24, 0x7a);
+	reg_finsr((reg + 0x082c), 15,  8, 0x08);
+	reg_finsr((reg + 0x082c), 23, 16, 0x30);
+	reg_finsr((reg + 0x0880),  7,  0, 0x86);
+	reg_finsr((reg + 0x0880), 23, 16, 0x86);
+	reg_finsr((reg + 0x0884),  7,  0, 0x85);
+	reg_finsr((reg + 0x0884), 23, 16, 0x0f);
+	reg_finsr((reg + 0x0884), 31, 24, 0x1d);
+	reg_finsr((reg + 0x088c), 15,  8, 0x2c);
+
+	reg_finsr((reg + 0x0a00), 15,  8, 0x80);
+	reg_finsr((reg + 0x0a08), 23, 16, 0xd2);
+	reg_finsr((reg + 0x0a08), 31, 24, 0x38);
+	reg_finsr((reg + 0x0a30), 15,  8, 0x8d);
+	reg_finsr((reg + 0x0a30), 23, 16, 0x8d);
+	reg_finsr((reg + 0x0a84), 15,  8, 0x07);
+	reg_finsr((reg + 0x0a94), 31, 24, 0x10);
+	reg_finsr((reg + 0x0aa0), 31, 24, 0x81);
+	reg_finsr((reg + 0x0abc), 31, 24, 0xff);
+	reg_finsr((reg + 0x0ac0),  7,  0, 0x8b);
+	reg_finsr((reg + 0x0a48), 15,  8, 0x8c);
+	reg_finsr((reg + 0x0a48), 23, 16, 0xfd);
+	reg_finsr((reg + 0x0a54),  7,  0, 0x72);
+	reg_finsr((reg + 0x0a54), 15,  8, 0xec);
+	reg_finsr((reg + 0x0a54), 23, 16, 0x2f);
+	reg_finsr((reg + 0x0a58), 15,  8, 0x21);
+	reg_finsr((reg + 0x0a58), 23, 16, 0xf9);
+	reg_finsr((reg + 0x0a58), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a5c),  7,  0, 0x60);
+	reg_finsr((reg + 0x0a5c), 15,  8, 0x00);
+	reg_finsr((reg + 0x0a5c), 23, 16, 0x04);
+	reg_finsr((reg + 0x0a5c), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a60),  7,  0, 0x00);
+	reg_finsr((reg + 0x0a60), 15,  8, 0x80);
+	reg_finsr((reg + 0x0a60), 23, 16, 0x00);
+	reg_finsr((reg + 0x0a60), 31, 24, 0x00);
+	reg_finsr((reg + 0x0a64),  7,  0, 0x20);
+	reg_finsr((reg + 0x0a64), 15,  8, 0x12);
+	reg_finsr((reg + 0x0a64), 23, 16, 0x58);
+	reg_finsr((reg + 0x0a64), 31, 24, 0x0c);
+	reg_finsr((reg + 0x0a68),  7,  0, 0x02);
+	reg_finsr((reg + 0x0a68), 15,  8, 0x06);
+	reg_finsr((reg + 0x0a68), 23, 16, 0x3b);
+	reg_finsr((reg + 0x0a68), 31, 24, 0xe1);
+	reg_finsr((reg + 0x0a6c),  7,  0, 0xc1);
+	reg_finsr((reg + 0x0a6c), 15,  8, 0x4c);
+	reg_finsr((reg + 0x0a6c), 23, 16, 0x07);
+	reg_finsr((reg + 0x0a6c), 31, 24, 0xb8);
+	reg_finsr((reg + 0x0a70),  7,  0, 0x89);
+	reg_finsr((reg + 0x0a70), 15,  8, 0xe9);
+	reg_finsr((reg + 0x0a70), 23, 16, 0x02);
+	reg_finsr((reg + 0x0a70), 31, 24, 0x3f);
+	reg_finsr((reg + 0x0a74),  7,  0, 0x01);
+	reg_finsr((reg + 0x0b20), 23, 16, 0x37);
+	reg_finsr((reg + 0x0b1c), 31, 24, 0x37);
+	reg_finsr((reg + 0x0b20),  7,  0, 0x5d);
+	reg_finsr((reg + 0x0000),  7,  0, 0x03);
+	reg_finsr((reg + 0x0a00),  7,  0, 0x5f);
+}
+
+static void k2_rio_serdes_lane_enable(u32 lane, u32 rate,
+				      struct keystone_rio_data *krio_priv)
+{
+	void *regs = (void *)krio_priv->serdes_regs;
+	u32 val;
+
+	val = readl(regs + 0x200 * (lane + 1) + 0x28);
+	val &= ~BIT(29);
+	writel(val, regs + 0x200 * (lane + 1) + 0x28);
+
+	switch (rate) {
+	case KEYSTONE_RIO_FULL_RATE:
+		writel(0xF0C0F0F0, regs + 0x1fe0 + 4 * lane);
+		break;
+	case KEYSTONE_RIO_HALF_RATE:
+		writel(0xF4C0F4F0, regs + 0x1fe0 + 4 * lane);
+		break;
+	case KEYSTONE_RIO_QUARTER_RATE:
+		writel(0xF8C0F8F0, regs + 0x1fe0 + 4 * lane);
+		break;
+	default:
+		return;
+	}
+}
+
+static int k2_rio_serdes_config(u32 lanes, u32 baud,
+				struct keystone_rio_data *krio_priv)
+{
+	void *regs = (void *)krio_priv->serdes_regs;
+	u32 rate;
+	u32 val;
+
+	writel(0x00000000, regs + 0x1ff4);
+
+	switch (baud) {
+	case KEYSTONE_RIO_BAUD_1_250:
+		rate = KEYSTONE_RIO_QUARTER_RATE;
+		k2_rio_serdes_init_5g(lanes, krio_priv);
+		break;
+	case KEYSTONE_RIO_BAUD_2_500:
+		rate = KEYSTONE_RIO_HALF_RATE;
+		k2_rio_serdes_init_5g(lanes, krio_priv);
+		break;
+	case KEYSTONE_RIO_BAUD_5_000:
+		rate = KEYSTONE_RIO_FULL_RATE;
+		k2_rio_serdes_init_5g(lanes, krio_priv);
+		break;
+	case KEYSTONE_RIO_BAUD_3_125:
+		rate = KEYSTONE_RIO_HALF_RATE;
+		k2_rio_serdes_init_3g(lanes, krio_priv);
+		break;
+	default:
+		printf("RIO: unsupported baud rate %d\n", baud);
+		return -1;
+	}
+
+	while (lanes) {
+		u32 lane = ffs(lanes) - 1;
+
+		lanes &= ~BIT(lane);
+
+		if (lane >= KEYSTONE_RIO_MAX_PORT)
+			return -1;
+
+		k2_rio_serdes_lane_enable(lane, rate, krio_priv);
+	}
+
+	writel(0xe0000000, regs + 0x1ff4);
+
+	do {
+		val = readl(regs + 0xbf8);
+	} while (!(val & BIT(16)));
+
+	return 0;
+}
+
+static int k2_rio_serdes_wait_lock(struct keystone_rio_data *krio_priv,
+				   u32 lanes)
+{
+	u32 loop;
+	u32 val;
+	u32 val_mask;
+	void *regs = (void *)krio_priv->serdes_regs;
+
+	val_mask = lanes | (lanes << 8);
+
+	for (loop = 0; loop < 100000; loop++) {
+		val = readl(regs + 0x1ff4);
+		if ((val & val_mask) == val_mask)
+			break;
+		udelay(10);
+	}
+
+	if (loop == 100000)
+		return -1;
+
+	return 0;
+}
+
+/* Serdes Config End */
+
+/**
+ * keystone_rio_hw_init - Configure a RapidIO controller
+ * @mode: serdes configuration
+ * @hostid: device id of the host
+ */
+static void keystone_rio_hw_init(u32 mode, u32 baud,
+				 struct keystone_rio_data *krio_priv)
+{
+	struct keystone_rio_pdata *pdata = dev_get_platdata(krio_priv->dev);
+	struct keystone_serdes_config *serdes_config = &pdata->serdes_config;
+	u32 val;
+	u32 block;
+
+	/* Set sRIO out of reset */
+	krio_write(krio_priv, pcr, 0x00000011);
+
+	/* Clear BOOT_COMPLETE bit (allowing write) */
+	krio_write(krio_priv, per_set_cntl, 0x00000000);
+
+	/* Enable blocks */
+	krio_write(krio_priv, gbl_en, 1);
+	for (block = 0; block <= KEYSTONE_RIO_BLK_NUM; block++)
+		krio_write(krio_priv, blk[block].enable, 1);
+
+	/* Set control register 1 configuration */
+	krio_write(krio_priv, per_set_cntl1, 0x00000000);
+
+	/* Set Control register */
+	krio_write(krio_priv, per_set_cntl, serdes_config->cfg_cntl);
+
+	if (pdata->keystone2_serdes) {
+		u32 path_mode = pdata->path_mode;
+		u32 ports     = pdata->ports;
+		int res;
+
+		res = keystone_rio_get_lane_config(ports, path_mode);
+		if (res > 0) {
+			u32 lanes = (u32)res;
+
+			res = k2_rio_serdes_config(lanes, baud, krio_priv);
+		}
+	} else {
+		u32 port;
+
+		krio_sd_write(krio_priv, pll, serdes_config->serdes_cfg_pll);
+
+		for (port = 0; port < KEYSTONE_RIO_MAX_PORT; port++) {
+			krio_sd_write(krio_priv, channel[port].rx,
+				      serdes_config->rx_chan_config[port]);
+
+			krio_sd_write(krio_priv, channel[port].tx,
+				      serdes_config->tx_chan_config[port]);
+		}
+
+		do {
+			val = readl(krio_priv->serdes_sts_reg);
+		} while ((val & 0x1) != 0x1);
+	}
+
+	/* Set prescalar for ip_clk */
+	krio_lnk_write(krio_priv, prescalar_srv_clk,
+		       serdes_config->prescalar_srv_clk);
+
+	/* Peripheral-specific configuration and capabilities */
+	krio_car_csr_write(krio_priv, dev_id, KEYSTONE_RIO_DEV_ID_VAL);
+	krio_car_csr_write(krio_priv, dev_info, KEYSTONE_RIO_DEV_INFO_VAL);
+	krio_car_csr_write(krio_priv, assembly_id, KEYSTONE_RIO_ID_TI);
+	krio_car_csr_write(krio_priv, assembly_info, KEYSTONE_RIO_EXT_FEAT_PTR);
+
+	/* Set host device id */
+	krio_car_csr_write(krio_priv, base_dev_id,
+			   (krio_priv->riohdid & 0xffff)
+			   | ((krio_priv->riohdid & 0xff) << 16));
+
+	krio_priv->rio_pe_feat = RIO_PEF_PROCESSOR
+		| RIO_PEF_CTLS
+		| KEYSTONE_RIO_PEF_FLOW_CONTROL
+		| RIO_PEF_EXT_FEATURES
+		| RIO_PEF_ADDR_34
+		| RIO_PEF_STD_RT
+		| RIO_PEF_INB_DOORBELL
+		| RIO_PEF_INB_MBOX;
+
+	krio_car_csr_write(krio_priv, pe_feature, krio_priv->rio_pe_feat);
+
+	krio_car_csr_write(krio_priv, sw_port, KEYSTONE_RIO_MAX_PORT << 8);
+
+	krio_car_csr_write(krio_priv, src_op,
+			   (RIO_SRC_OPS_READ
+			    | RIO_SRC_OPS_WRITE
+			    | RIO_SRC_OPS_STREAM_WRITE
+			    | RIO_SRC_OPS_WRITE_RESPONSE
+			    | RIO_SRC_OPS_DATA_MSG
+			    | RIO_SRC_OPS_DOORBELL
+			    | RIO_SRC_OPS_ATOMIC_TST_SWP
+			    | RIO_SRC_OPS_ATOMIC_INC
+			    | RIO_SRC_OPS_ATOMIC_DEC
+			    | RIO_SRC_OPS_ATOMIC_SET
+			    | RIO_SRC_OPS_ATOMIC_CLR
+			    | RIO_SRC_OPS_PORT_WRITE));
+
+	krio_car_csr_write(krio_priv, dest_op,
+			   (RIO_DST_OPS_READ
+			    | RIO_DST_OPS_WRITE
+			    | RIO_DST_OPS_STREAM_WRITE
+			    | RIO_DST_OPS_WRITE_RESPONSE
+			    | RIO_DST_OPS_DATA_MSG
+			    | RIO_DST_OPS_DOORBELL
+			    | RIO_DST_OPS_PORT_WRITE));
+
+	krio_car_csr_write(krio_priv, pe_logical_ctl, RIO_PELL_ADDR_34);
+
+	val = (((KEYSTONE_RIO_SP_HDR_NEXT_BLK_PTR & 0xffff) << 16) |
+	       KEYSTONE_RIO_SP_HDR_EP_REC_ID);
+	krio_sp_write(krio_priv, sp_maint_blk_hdr, val);
+
+	/* clear high bits of local config space base addr */
+	krio_car_csr_write(krio_priv, local_cfg_hbar, 0x00000000);
+
+	/* set local config space base addr */
+	krio_car_csr_write(krio_priv, local_cfg_bar, 0x00520000);
+
+	/* Enable HOST & MASTER_ENABLE bits */
+	krio_sp_write(krio_priv, sp_gen_ctl, 0xe0000000);
+
+	/* set link timeout value */
+	krio_sp_write(krio_priv, sp_link_timeout_ctl, 0x000FFF00);
+
+	/* set response timeout value */
+	krio_sp_write(krio_priv, sp_rsp_timeout_ctl, 0x000FFF00);
+
+	/* allows SELF_RESET and PWDN_PORT resets to clear sticky reg bits */
+	krio_lnk_write(krio_priv, reg_rst_ctl, 0x00000001);
+
+	/* Set error detection mode */
+	/* clear all errors */
+	krio_err_write(krio_priv, err_det, 0x00000000);
+
+	/* enable all error detection */
+	krio_err_write(krio_priv, err_en, 0x00000000);
+
+	/* set err det block header */
+	val = (((KEYSTONE_RIO_ERR_HDR_NEXT_BLK_PTR & 0xffff) << 16) |
+	       KEYSTONE_RIO_ERR_EXT_FEAT_ID);
+	krio_err_write(krio_priv, err_report_blk_hdr, val);
+
+	/* clear msb of err catptured addr reg */
+	krio_err_write(krio_priv, h_addr_capt, 0x00000000);
+
+	/* clear lsb of err catptured addr reg */
+	krio_err_write(krio_priv, addr_capt, 0x00000000);
+
+	/* clear err catptured source and dest devID reg */
+	krio_err_write(krio_priv, id_capt, 0x00000000);
+
+	/* clear err catptured packet info */
+	krio_err_write(krio_priv, ctrl_capt, 0x00000000);
+
+	/* Force all writes to finish */
+	val = krio_err_read(krio_priv, ctrl_capt);
+}
+
+/**
+ * keystone_rio_start - Start RapidIO controller
+ */
+static void keystone_rio_start(struct keystone_rio_data *krio_priv)
+{
+	u32 val;
+
+	/* set PEREN bit to enable logical layer data flow */
+	val = (KEYSTONE_RIO_PER_EN | KEYSTONE_RIO_PER_FREE);
+	krio_write(krio_priv, pcr, val);
+
+	/* set BOOT_COMPLETE bit */
+	val = krio_read(krio_priv, per_set_cntl);
+	krio_write(krio_priv, per_set_cntl, val | KEYSTONE_RIO_BOOT_COMPLETE);
+}
+
+/**
+ * keystone_rio_port_status - Return if the port is OK or not
+ * @port: index of the port
+ *
+ * Return %0 if the port is ready or %-EIO on failure.
+ */
+static int keystone_rio_port_status(int port,
+				    struct keystone_rio_data *krio_priv)
+{
+	unsigned int count, value;
+	int solid_ok = 0;
+
+	if (port >= KEYSTONE_RIO_MAX_PORT)
+		return -1;
+
+	/* Check port status */
+	for (count = 0; count < 300; count++) {
+		value = krio_sp_read(krio_priv, sp[port].err_stat);
+
+		if (value & RIO_PORT_N_ERR_STS_PORT_OK) {
+			solid_ok++;
+			if (solid_ok == 100)
+				break;
+		} else {
+			if (solid_ok) {
+				debug_rio(
+					"RIO: unstable port %d (solid_ok = %d)\n",
+					port, solid_ok);
+				return -2;
+			}
+			solid_ok = 0;
+		}
+		udelay(20);
+	}
+
+	return 0;
+}
+
+/**
+ * keystone_rio_port_disable - Disable a RapidIO port
+ * @port: index of the port to configure
+ */
+static void keystone_rio_port_disable(u32 port,
+				      struct keystone_rio_data *krio_priv)
+{
+	/* Disable port */
+	krio_sp_write(krio_priv, sp[port].ctl, 0x800000);
+}
+
+/**
+ * keystone_rio_port_init - Configure a RapidIO port
+ * @port: index of the port to configure
+ * @mode: serdes configuration
+ */
+static int keystone_rio_port_init(u32 port, u32 path_mode,
+				  struct keystone_rio_data *krio_priv)
+{
+	if (port >= KEYSTONE_RIO_MAX_PORT)
+		return -1;
+
+	/* Disable packet forwarding */
+	krio_write(krio_priv, pkt_fwd_cntl[port].pf_16b, 0xffffffff);
+	krio_write(krio_priv, pkt_fwd_cntl[port].pf_8b, 0x0003ffff);
+
+	/* Silence and discovery timers */
+	if ((port == 0) || (port == 2)) {
+		krio_phy_write(krio_priv, phy_sp[port].silence_timer,
+			       0x20000000);
+		krio_phy_write(krio_priv, phy_sp[port].discovery_timer,
+			       0x20000000);
+	}
+
+	/* Enable port in input and output */
+	krio_sp_write(krio_priv, sp[port].ctl, 0x600000);
+
+	/* Program channel allocation to ports (1x, 2x or 4x) */
+	krio_phy_write(krio_priv, phy_sp[port].path_ctl, path_mode);
+
+	return 0;
+}
+
+/**
+ * keystone_rio_port_activate - Start using a RapidIO port
+ * @port: index of the port to configure
+ */
+static int keystone_rio_port_activate(u32 port,
+				      struct keystone_rio_data *krio_priv)
+{
+	/* Cleanup port error status */
+	krio_sp_write(krio_priv, sp[port].err_stat,
+		      KEYSTONE_RIO_PORT_ERROR_MASK);
+
+	krio_err_write(krio_priv, sp_err[port].det, 0);
+
+	/* Enable promiscuous */
+	krio_tp_write(krio_priv, transport_sp[port].control, 0x00309000);
+
+	return 0;
+}
+
+/*------------------------ Main driver functions -----------------------*/
+
+/**
+ * keystone_rio_config_read - Generate a RIO read maintenance transaction
+ * @portid: Output port ID of transaction
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Location to be read into
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int keystone_rio_config_read(struct udevice *dev, int portid, u16 destid,
+			     u8 hopcount, u32 offset, int len, u32 *val)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+	struct keystone_rio_pdata *pdata = dev_get_platdata(dev);
+	dma_addr_t dma;
+	u32 *tbuf;
+	int res;
+
+	tbuf = malloc(len);
+	if (!tbuf)
+		return -1;
+
+	memset(tbuf, 0, len);
+
+	dma = dma_map_single(tbuf, len, DMA_FROM_DEVICE);
+
+	res = keystone_rio_maint_request(portid, destid, hopcount, offset, dma,
+					 len, pdata->size,
+					 KEYSTONE_RIO_PACKET_TYPE_MAINT_R,
+					 krio_priv);
+
+	dma_unmap_single((void *)tbuf, len, dma);
+
+	/* Taking care of byteswap */
+	switch (len) {
+	case 1:
+		*val = *((u8 *)tbuf);
+		break;
+	case 2:
+		*val = ntohs(*((u16 *)tbuf));
+		break;
+	default:
+		*val = ntohl(*((u32 *)tbuf));
+		break;
+	}
+
+	free(tbuf);
+
+	debug_rio("RIO: %s portid %d destid %d hopcount %d offset 0x%x len %d val 0x%x res %d\n",
+		  __func__, portid, destid, hopcount, offset, len, *val,
+		res);
+
+	return res;
+}
+
+/**
+ * keystone_rio_config_write - Generate a RIO write maintenance transaction
+ * @portid: Output port ID of transaction
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Value to be written
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int keystone_rio_config_write(struct udevice *dev, int portid, u16 destid,
+			      u8 hopcount, u32 offset, int len, u32 val)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+	struct keystone_rio_pdata *pdata = dev_get_platdata(dev);
+	u32 *tbuf;
+	int res;
+	dma_addr_t dma;
+
+	tbuf = malloc(len);
+	if (!tbuf)
+		return -1;
+
+	memset(tbuf, 0, len);
+
+	/* Taking care of byteswap */
+	switch (len) {
+	case 1:
+		*tbuf = ((u8)val);
+		break;
+	case 2:
+		*tbuf = htons((u16)val);
+		break;
+	default:
+		*tbuf = htonl((u32)val);
+		break;
+	}
+
+	dma = dma_map_single(tbuf, len, DMA_TO_DEVICE);
+
+	res = keystone_rio_maint_request(portid, destid, hopcount, offset, dma,
+					 len, pdata->size,
+					 KEYSTONE_RIO_PACKET_TYPE_MAINT_W,
+					 krio_priv);
+
+	dma_unmap_single((void *)tbuf, len, dma);
+
+	debug_rio("RIO: %s portid %d destid %d hopcount %d offset 0x%x len %d val 0x%x res %d\n",
+		  __func__, portid, destid, hopcount, offset, len, val, res);
+
+	free(tbuf);
+
+	return res;
+}
+
+/**
+ * keystone_rio_local_config_read - RIO local config space read
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be read into
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int keystone_rio_local_config_read(struct udevice *dev, u32 offset,
+				   int len, u32 *data)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+
+	*data = krio_car_csr_read_ofs(krio_priv, offset);
+
+	debug_rio("RIO: %s offset 0x%x data 0x%x\n",
+		  __func__, offset, *data);
+
+	return 0;
+}
+
+/**
+ * keystone_rio_local_config_write - RIO local config space write
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be written
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int keystone_rio_local_config_write(struct udevice *dev, u32 offset,
+				    int len, u32 data)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+
+	debug_rio("RIO: %s offset 0x%x data 0x%x\n",
+		  __func__, offset, data);
+
+	krio_car_csr_write_ofs(krio_priv, offset, data);
+	return 0;
+}
+
+/**
+ * keystone_rio_doorbell_rx - Blocking wait to receive doorbell info
+ * @info: doorbell info to wait on
+ *
+ * Returns %0 on success or %-1 on failure.
+ */
+int keystone_rio_doorbell_rx(struct udevice *dev, u16 info)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+	u32 pending_dbell;
+	u16 db_bit_mask, start_db, end_db;
+	unsigned int i, received = 0;
+
+	if (info == KEYSTONE_RIO_DBELL_INFO_ANY) {
+		start_db = 0;
+		end_db = KEYSTONE_RIO_DBELL_NUMBER - 1;
+		db_bit_mask = 0xf;
+		printf("%s: waiting for dbell any ...\n", __func__);
+	} else {
+		start_db = (info >> 4) & 0x3;
+		end_db = start_db;
+		db_bit_mask = BIT(info & 0xf);
+		if (start_db >= KEYSTONE_RIO_DBELL_NUMBER) {
+			printf("Error: doorbell out of range. Invalid info: 0x%04x\n",
+			       info);
+			return -1;
+		}
+		printf("%s: waiting for dbell %u bit %u ...\n",
+		       __func__, start_db, info & 0xf);
+	}
+
+	while (1) {
+		for (i = start_db; i < end_db + 1; i++) {
+			pending_dbell = krio_read(krio_priv,
+						  doorbell_int[i].status);
+			if (pending_dbell) {
+				if (pending_dbell & db_bit_mask) {
+					received = 1;
+					printf("received dbell[%d] status: 0x%08x\n",
+					       i, pending_dbell);
+				}
+
+				/* Acknowledge the interrupts for
+				 * these doorbells
+				 */
+				krio_write(krio_priv, doorbell_int[i].clear,
+					   pending_dbell);
+			}
+		}
+
+		if (received)
+			return 0;
+
+		mdelay(10);
+	}
+}
+
+/*
+ * Platform configuration setup
+ */
+static int keystone_rio_setup_controller(struct keystone_rio_data *krio_priv)
+{
+	struct keystone_rio_pdata *pdata = dev_get_platdata(krio_priv->dev);
+	u32 ports;
+	u32 p;
+	u32 mode;
+	u32 baud;
+	u32 path_mode;
+	u32 size = 0;
+	int res = 0;
+	char str[8];
+
+	size      = pdata->size;
+	ports     = pdata->ports;
+	baud      = pdata->serdes_baudrate;
+	path_mode = pdata->path_mode;
+
+	debug_rio(
+		"RIO: size = %d, ports = 0x%x, baud = %d, path_mode = %d\n",
+		size, ports, baud, path_mode);
+
+	if (baud > KEYSTONE_RIO_BAUD_5_000) {
+		baud = KEYSTONE_RIO_BAUD_5_000;
+		printf("RIO: invalid baud rate, forcing it to 5Gbps\n");
+	}
+
+	switch (baud) {
+	case KEYSTONE_RIO_BAUD_1_250:
+		snprintf(str, sizeof(str), "1.25");
+		break;
+	case KEYSTONE_RIO_BAUD_2_500:
+		snprintf(str, sizeof(str), "2.50");
+		break;
+	case KEYSTONE_RIO_BAUD_3_125:
+		snprintf(str, sizeof(str), "3.125");
+		break;
+	case KEYSTONE_RIO_BAUD_5_000:
+		snprintf(str, sizeof(str), "5.00");
+		break;
+	default:
+		return -1;
+	}
+
+	debug_rio("RIO: initializing %s Gbps interface with port config %d\n",
+		  str, path_mode);
+
+	/* Hardware set up of the controller */
+	keystone_rio_hw_init(mode, baud, krio_priv);
+
+	/* Disable all ports */
+	for (p = 0; p < KEYSTONE_RIO_MAX_PORT; p++)
+		keystone_rio_port_disable(p, krio_priv);
+
+	/* Start the controller */
+	keystone_rio_start(krio_priv);
+
+	/* Try to lock K2 SerDes*/
+	if (pdata->keystone2_serdes) {
+		int lanes = keystone_rio_get_lane_config(ports, path_mode);
+
+		if (lanes > 0) {
+			res = k2_rio_serdes_wait_lock(krio_priv, (u32)lanes);
+			if (res < 0)
+				debug_rio("SerDes for lane mask 0x%x on %s Gbps not locked\n",
+					  lanes, str);
+		}
+	}
+
+	/* Use and check ports status (but only the requested ones) */
+	krio_priv->ports_registering = ports;
+	while (ports) {
+		int status;
+		u32 port = ffs(ports) - 1;
+
+		if (port > 32)
+			return 0;
+
+		ports &= ~BIT(port);
+
+		res = keystone_rio_port_init(port, path_mode, krio_priv);
+		if (res < 0) {
+			printf("RIO: initialization of port %d failed\n", p);
+			return res;
+		}
+
+		/* Start the port */
+		keystone_rio_port_activate(port, krio_priv);
+
+		/* Check the port status */
+		status = keystone_rio_port_status(port, krio_priv);
+		if (status == 0) {
+			krio_priv->ports_registering &= ~BIT(port);
+			debug_rio("RIO: port RIO%d ready\n", port);
+		} else {
+			printf("RIO: port %d not ready (status %d)\n",
+			       port, status);
+		}
+	}
+
+	if (krio_priv->ports_registering != 0)
+		return -1;
+
+	return res;
+}
+
+static int keystone_rio_probe(struct udevice *dev)
+{
+	struct keystone_rio_data *krio_priv = dev_get_priv(dev);
+	struct keystone_rio_pdata *pdata = dev_get_platdata(dev);
+	void *regs;
+
+	krio_priv->dev = dev;
+
+	regs = (void *)pdata->boot_cfg_regs_base;
+	krio_priv->jtagid_reg     = regs + 0x0018;
+	krio_priv->serdes_sts_reg = regs + 0x0154;
+
+	regs = (void *)pdata->serdes_cfg_regs_base;
+	krio_priv->serdes_regs = regs;
+
+	regs = (void *)pdata->rio_regs_base;
+	krio_priv->regs			= regs;
+	krio_priv->car_csr_regs		= regs + 0x0b000;
+	krio_priv->serial_port_regs	= regs + 0x0b100;
+	krio_priv->err_mgmt_regs	= regs + 0x0c000;
+	krio_priv->phy_regs		= regs + 0x1b000;
+	krio_priv->transport_regs	= regs + 0x1b300;
+	krio_priv->pkt_buf_regs		= regs + 0x1b600;
+	krio_priv->evt_mgmt_regs	= regs + 0x1b900;
+	krio_priv->port_write_regs	= regs + 0x1ba00;
+	krio_priv->link_regs		= regs + 0x1bd00;
+	krio_priv->fabric_regs		= regs + 0x1be00;
+	krio_priv->car_csr_regs_base	= (u32)regs + 0xb000;
+
+	krio_priv->riohdid = pdata->riohdid;
+	krio_priv->lsu_start = 0;
+	krio_priv->lsu_end   = 0;
+
+	/* Enable srio clock */
+	psc_enable_module(KS2_LPSC_SRIO);
+
+	debug_rio("KeyStone RapidIO driver %s, hdid=%d\n",
+		  DRIVER_VER, krio_priv->riohdid);
+
+	/* Setup the sRIO controller */
+	return keystone_rio_setup_controller(krio_priv);
+}
+
+/**
+ * keystone_rio_remove - Shutdown RapidIO subsystem
+ */
+static int keystone_rio_remove(struct udevice *dev)
+{
+	/* Power off */
+	psc_disable_module(KS2_LPSC_SRIO);
+	return 0;
+}
+
+static const struct rio_ops keystone_rio_ops = {
+	.config_read		= keystone_rio_config_read,
+	.config_write		= keystone_rio_config_write,
+	.local_config_read	= keystone_rio_local_config_read,
+	.local_config_write	= keystone_rio_local_config_write,
+	.doorbell_rx		= keystone_rio_doorbell_rx,
+};
+
+static int keystone_rio_ofdata_to_platdata(struct udevice *dev)
+{
+	struct keystone_rio_pdata *pdata = dev_get_platdata(dev);
+	const void *fdt = gd->fdt_blob;
+	fdt_addr_t addr;
+	int i, node = dev->of_offset;
+
+	addr = dev_get_addr_name(dev, "rio");
+	if (addr == FDT_ADDR_T_NONE) {
+		debug_rio("Can't get the RIO register base address\n");
+		return -ENXIO;
+	}
+	pdata->rio_regs_base = (u32)addr;
+
+	addr = dev_get_addr_name(dev, "boot_config");
+	if (addr == FDT_ADDR_T_NONE) {
+		debug_rio("Can't get the Boot Conig register base address\n");
+		return -ENXIO;
+	}
+	pdata->boot_cfg_regs_base = (u32)addr;
+
+	addr = dev_get_addr_name(dev, "serdes");
+	if (addr == FDT_ADDR_T_NONE) {
+		debug_rio("Can't get the Serdes register base address\n");
+		return -ENXIO;
+	}
+	pdata->serdes_cfg_regs_base = (u32)addr;
+
+	if (fdt_get_property(fdt, node, "keystone2-serdes", NULL))
+		pdata->keystone2_serdes = KEYSTONE_RIO_IS_K2;
+
+	pdata->riohdid = fdtdec_get_int(fdt, node, "host-id", -1);
+
+	/* defaults to small system size if not specified */
+	pdata->size = (u16)fdtdec_get_uint(fdt, node, "dev-id-size", 0);
+
+	/* port(s) to probe defaults to 0x1 if not specified */
+	pdata->ports = (u16)fdtdec_get_uint(fdt, node, "ports", 1);
+
+	/* defaults to 5 Gbps if not specified */
+	pdata->serdes_baudrate = fdtdec_get_uint(fdt, node, "baudrate",
+						 KEYSTONE_RIO_BAUD_5_000);
+
+	/* defaults to 1-4x port if not specified */
+	pdata->path_mode = fdtdec_get_uint(fdt, node, "path-mode",
+					   KEYSTONE_RIO_MAX_PORTS_PATH_MODE_4);
+
+	if (pdata->keystone2_serdes) {
+		/*
+		 * K2 sRIO config 0
+		 */
+		pdata->serdes_config.prescalar_srv_clk = 0x001f;
+	} else {
+		/*
+		 * K1 sRIO config 0: MPY = 5x, div rate = half,
+		 * link rate = 3.125 Gbps, mode 1x
+		 */
+
+		/* setting control register config */
+		pdata->serdes_config.cfg_cntl = 0x0c053860;
+
+		/* SerDes PLL configuration */
+		pdata->serdes_config.serdes_cfg_pll = 0x0229;
+
+		/* prescalar_srv_clk */
+		pdata->serdes_config.prescalar_srv_clk = 0x001e;
+
+		/* serdes rx_chan_config */
+		for (i = 0; i < KEYSTONE_RIO_MAX_PORT; i++)
+			pdata->serdes_config.rx_chan_config[i] = 0x00440495;
+
+		/* serdes tx_chan_config */
+		for (i = 0; i < KEYSTONE_RIO_MAX_PORT; i++)
+			pdata->serdes_config.tx_chan_config[i] = 0x00180795;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id keystone_rio_ids[] = {
+	{ .compatible = "ti,keystone-rapidio" },
+	{ }
+};
+
+U_BOOT_DRIVER(rio_keystone) = {
+	.name				= "rio_keystone",
+	.id				= UCLASS_RIO,
+	.of_match			= keystone_rio_ids,
+	.ofdata_to_platdata		= keystone_rio_ofdata_to_platdata,
+	.ops				= &keystone_rio_ops,
+	.probe				= keystone_rio_probe,
+	.remove				= keystone_rio_remove,
+	.priv_auto_alloc_size		= sizeof(struct keystone_rio_data),
+	.platdata_auto_alloc_size	= sizeof(struct keystone_rio_pdata),
+};
diff -u -N U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c
--- U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c	2019-09-12 15:54:57.000000371 -0500
+++ U-Boot_SDcard/fs/jffs2/jffs2_nand_1pass.c	1969-12-31 19:29:21.000000824 -0600
@@ -796,7 +796,11 @@
 	u32 counterN = 0;
 
 	struct mtdids *id = part->dev->id;
-	mtd = nand_info[id->num];
+	mtd = get_nand_dev_by_index(id->num);
+	if (!mtd) {
+		error("\nno NAND devices available\n");
+		return 0;
+	}
 
 	/* if we are building a list we need to refresh the cache. */
 	jffs_init_1pass_list(part);
diff -u -N U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h
--- U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h	2019-09-12 15:54:52.000000379 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/omap_mmc.h	1969-12-31 19:29:28.000000650 -0600
@@ -27,14 +27,19 @@
 
 struct hsmmc {
 #ifdef CONFIG_DM_MMC
-	unsigned char res0[0x100];
+	unsigned int hl_rev;
+	unsigned int hl_hwinfo;
+	unsigned int hl_sysconfig;
+	unsigned char res0[0xf4];
 #endif
 	unsigned char res1[0x10];
 	unsigned int sysconfig;		/* 0x10 */
 	unsigned int sysstatus;		/* 0x14 */
 	unsigned char res2[0x14];
 	unsigned int con;		/* 0x2C */
-	unsigned char res3[0xD4];
+	unsigned int pwcnt;		/* 0x30 */
+	unsigned int dll;		/* 0x34 */
+	unsigned char res3[0xcc];
 	unsigned int blk;		/* 0x104 */
 	unsigned int arg;		/* 0x108 */
 	unsigned int cmd;		/* 0x10C */
@@ -48,13 +53,19 @@
 	unsigned int sysctl;		/* 0x12C */
 	unsigned int stat;		/* 0x130 */
 	unsigned int ie;		/* 0x134 */
-	unsigned char res4[0x8];
+	unsigned char res4[0x4];
+	unsigned int ac12;		/* 0x13C */
 	unsigned int capa;		/* 0x140 */
+	unsigned int capa2;		/* 0x144 */
+	unsigned char res5[0xc];
+	unsigned int admaes;		/* 0x254 */
+	unsigned int admasal;		/* 0x258 */
 };
 
 /*
  * OMAP HS MMC Bit definitions
  */
+#define MADMA_EN			(0x1 << 0)
 #define MMC_SOFTRESET			(0x1 << 1)
 #define RESETDONE			(0x1 << 0)
 #define NOOPENDRAIN			(0x0 << 0)
@@ -71,12 +82,13 @@
 #define WPP_ACTIVEHIGH			(0x0 << 8)
 #define RESERVED_MASK			(0x3 << 9)
 #define CTPL_MMC_SD			(0x0 << 11)
+#define DDR				(0x1 << 19)
+#define DMA_MASTER			(0x1 << 20)
 #define BLEN_512BYTESLEN		(0x200 << 0)
 #define NBLK_STPCNT			(0x0 << 16)
-#define DE_DISABLE			(0x0 << 0)
-#define BCE_DISABLE			(0x0 << 1)
+#define DE_ENABLE			(0x1 << 0)
 #define BCE_ENABLE			(0x1 << 1)
-#define ACEN_DISABLE			(0x0 << 2)
+#define ACEN_ENABLE			(0x1 << 2)
 #define DDIR_OFFSET			(4)
 #define DDIR_MASK			(0x1 << 4)
 #define DDIR_WRITE			(0x0 << 4)
@@ -108,15 +120,17 @@
 #define DTW_8_BITMODE                   (0x1 << 5) /* CON[DW8]*/
 #define SDBP_PWROFF			(0x0 << 8)
 #define SDBP_PWRON			(0x1 << 8)
+#define SDVS_MASK			(0x7 << 9)
 #define SDVS_1V8			(0x5 << 9)
 #define SDVS_3V0			(0x6 << 9)
+#define SDVS_3V3			(0x7 << 9)
+#define DMA_SELECT			(0x2 << 3)
 #define ICE_MASK			(0x1 << 0)
 #define ICE_STOP			(0x0 << 0)
 #define ICS_MASK			(0x1 << 1)
 #define ICS_NOTREADY			(0x0 << 1)
 #define ICE_OSCILLATE			(0x1 << 0)
 #define CEN_MASK			(0x1 << 2)
-#define CEN_DISABLE			(0x0 << 2)
 #define CEN_ENABLE			(0x1 << 2)
 #define CLKD_OFFSET			(6)
 #define CLKD_MASK			(0x3FF << 6)
@@ -139,12 +153,29 @@
 #define IE_DTO				(0x01 << 20)
 #define IE_DCRC				(0x01 << 21)
 #define IE_DEB				(0x01 << 22)
+#define IE_ADMAE			(0x01 << 25)
 #define IE_CERR				(0x01 << 28)
 #define IE_BADA				(0x01 << 29)
 
+#define VS33_3V3SUP			(1 << 24)
 #define VS30_3V0SUP			(1 << 25)
 #define VS18_1V8SUP			(1 << 26)
 
+#define IOV_3V3				3300000
+#define IOV_3V0				3000000
+#define IOV_1V8				1800000
+
+#define AC12_V1V8_SIGEN		(1 << 19)
+#define AC12_SCLK_SEL		(1 << 23)
+#define AC12_UHSMC_MASK			(7 << 16)
+#define AC12_UHSMC_SDR104		(3 << 16)
+#define AC12_UHSMC_SDR12		(0 << 16)
+#define AC12_UHSMC_SDR25		(1 << 16)
+#define AC12_UHSMC_SDR50		(2 << 16)
+#define AC12_UHSMC_SDR104		(3 << 16)
+#define AC12_UHSMC_DDR50		(4 << 16)
+#define AC12_UHSMC_RES			(0x7 << 16)
+
 /* Driver definitions */
 #define MMCSD_SECTOR_SIZE		512
 #define MMC_CARD			0
@@ -155,17 +186,47 @@
 #define CLK_400KHZ			1
 #define CLK_MISC			2
 
+#define CLKD_MAX			0x3FF	/* max clock divisor: 1023 */
+
 #define RSP_TYPE_NONE	(RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
 #define MMC_CMD0	(INDEX(0)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
 
 /* Clock Configurations and Macros */
+#ifdef CONFIG_OMAP54XX
+#define MMC_CLOCK_REFERENCE	192 /* MHz */
+#else
 #define MMC_CLOCK_REFERENCE	96 /* MHz */
+#endif
+
+/* DLL */
+#define DLL_SWT			(1 << 20)
+#define DLL_FORCE_SR_C_SHIFT	13
+#define DLL_FORCE_SR_C_MASK	0x7f
+#define DLL_FORCE_VALUE		(1 << 12)
+#define DLL_CALIB		(1 << 1)
+
+#define MAX_PHASE_DELAY		0x7c
+
+/* CAPA2 */
+#define CAPA2_TSDR50		(1 << 13)
 
 #define mmc_reg_out(addr, mask, val)\
 	writel((readl(addr) & (~(mask))) | ((val) & (mask)), (addr))
 
+#define INT_EN_MASK (IE_BADA | IE_CERR | IE_DEB | IE_DCRC |\
+		IE_DTO | IE_CIE | IE_CEB | IE_CCRC | IE_ADMAE | IE_CTO |\
+		IE_BRR | IE_BWR | IE_TC | IE_CC)
+
+#define CON_CLKEXTFREE		(1 << 16)
+#define CON_PADEN		(1 << 15)
+#define PSTATE_CLEV		(1 << 24)
+#define PSTATE_DLEV		(0xF << 20)
+#define PSTATE_DLEV_DAT0	(0x1 << 20)
+
 int omap_mmc_init(int dev_index, uint host_caps_mask, uint f_max, int cd_gpio,
 		int wp_gpio);
-
+int platform_fixup_disable_uhs_mode(void);
+struct omap_hsmmc_pinctrl_state *platform_fixup_get_pinctrl_by_mode
+	(struct hsmmc *base, const char *mode);
 void vmmc_pbias_config(uint voltage);
 #endif /* OMAP_MMC_H_ */
diff -u -N U-Boot_SDcard/board/amazon/kc1/kc1.c U-Boot_SDcard/board/amazon/kc1/kc1.c
--- U-Boot_SDcard/board/amazon/kc1/kc1.c	2019-09-12 15:54:26.000000120 -0500
+++ U-Boot_SDcard/board/amazon/kc1/kc1.c	1969-12-31 19:29:24.000000687 -0600
@@ -166,12 +166,10 @@
 	return omap_reboot_mode_store("b");
 }
 
-#ifndef CONFIG_SPL_BUILD
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(1, 0, 0, -1, -1);
 }
-#endif
 
 void board_mmc_power_init(void)
 {
diff -u -N U-Boot_SDcard/board/quipos/cairo/cairo.c U-Boot_SDcard/board/quipos/cairo/cairo.c
--- U-Boot_SDcard/board/quipos/cairo/cairo.c	2019-09-12 15:54:12.000000975 -0500
+++ U-Boot_SDcard/board/quipos/cairo/cairo.c	1969-12-31 19:29:26.000000708 -0600
@@ -62,7 +62,7 @@
 	MUX_CAIRO();
 }
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
@@ -93,7 +93,8 @@
 static const struct ns16550_platdata cairo_serial = {
 	.base = OMAP34XX_UART2,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(cairo_uart) = {
diff -u -N U-Boot_SDcard/board/logicpd/zoom1/zoom1.c U-Boot_SDcard/board/logicpd/zoom1/zoom1.c
--- U-Boot_SDcard/board/logicpd/zoom1/zoom1.c	2019-09-12 15:54:18.000000167 -0500
+++ U-Boot_SDcard/board/logicpd/zoom1/zoom1.c	1969-12-31 19:29:26.000000495 -0600
@@ -47,7 +47,8 @@
 static const struct ns16550_platdata zoom1_serial = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(zoom1_uart) = {
diff -u -N U-Boot_SDcard/include/dm/uclass-id.h U-Boot_SDcard/include/dm/uclass-id.h
--- U-Boot_SDcard/include/dm/uclass-id.h	2019-09-12 15:54:51.000000730 -0500
+++ U-Boot_SDcard/include/dm/uclass-id.h	1969-12-31 19:29:22.000000615 -0600
@@ -49,6 +49,7 @@
 	UCLASS_MMC,		/* SD / MMC card or chip */
 	UCLASS_MOD_EXP,		/* RSA Mod Exp device */
 	UCLASS_MTD,		/* Memory Technology Device (MTD) device */
+	UCLASS_NAND,		/* NAND device */
 	UCLASS_NORTHBRIDGE,	/* Intel Northbridge / SDRAM controller */
 	UCLASS_PANEL,		/* Display panel, such as an LCD */
 	UCLASS_PANEL_BACKLIGHT,	/* Backlight controller for panel */
@@ -65,6 +66,7 @@
 	UCLASS_REGULATOR,	/* Regulator device */
 	UCLASS_REMOTEPROC,	/* Remote Processor device */
 	UCLASS_RESET,		/* Reset controller device */
+	UCLASS_RIO,		/* RapidIO */
 	UCLASS_RTC,		/* Real time clock device */
 	UCLASS_SCSI,		/* SCSI device */
 	UCLASS_SERIAL,		/* Serial UART */
diff -u -N U-Boot_SDcard/board/ti/common/board_detect.c U-Boot_SDcard/board/ti/common/board_detect.c
--- U-Boot_SDcard/board/ti/common/board_detect.c	2019-09-12 15:54:18.000000121 -0500
+++ U-Boot_SDcard/board/ti/common/board_detect.c	1969-12-31 19:29:27.000000185 -0600
@@ -116,6 +116,30 @@
 	return 0;
 }
 
+int __maybe_unused ti_i2c_eeprom_am_set(const char *name, const char *rev)
+{
+	struct ti_common_eeprom *ep;
+
+	if (!name || !rev)
+		return -1;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		goto already_set;
+
+	/* Set to 0 all fields */
+	memset(ep, 0, sizeof(*ep));
+	strncpy(ep->name, name, TI_EEPROM_HDR_NAME_LEN);
+	strncpy(ep->version, rev, TI_EEPROM_HDR_REV_LEN);
+	/* Some dummy serial number to identify the platform */
+	strncpy(ep->serial, "0000", TI_EEPROM_HDR_SERIAL_LEN);
+	/* Mark it with a valid header */
+	ep->header = TI_EEPROM_HEADER_MAGIC;
+
+already_set:
+	return 0;
+}
+
 int __maybe_unused ti_i2c_eeprom_am_get(int bus_addr, int dev_addr)
 {
 	int rc;
@@ -314,3 +338,70 @@
 	else
 		setenv("board_serial", unknown);
 }
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+void board_ti_set_ethaddr(int index)
+{
+	uint8_t mac_addr[6];
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+	/*
+	 * Export any Ethernet MAC addresses from EEPROM.
+	 * The 2 MAC addresses in EEPROM define the address range.
+	 */
+	board_ti_get_eth_mac_addr(0, mac_addr1);
+	board_ti_get_eth_mac_addr(1, mac_addr2);
+
+	if (is_valid_ethaddr(mac_addr1) && is_valid_ethaddr(mac_addr2)) {
+		mac1 = mac_to_u64(mac_addr1);
+		mac2 = mac_to_u64(mac_addr2);
+
+		/* must contain an address range */
+		num_macs = mac2 - mac1 + 1;
+		/* <= 50 to protect against user programming error */
+		if (num_macs > 0 && num_macs <= 50) {
+			for (i = 0; i < num_macs; i++) {
+				u64_to_mac(mac1 + i, mac_addr);
+				if (is_valid_ethaddr(mac_addr)) {
+					eth_setenv_enetaddr_by_index("eth",
+								     i + index,
+								     mac_addr);
+				}
+			}
+		}
+	}
+}
+
+bool __maybe_unused board_ti_was_eeprom_read(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return true;
+	else
+		return false;
+}
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c	2019-09-12 15:54:55.000000310 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/clock_am33xx.c	1969-12-31 19:29:28.000000728 -0600
@@ -10,6 +10,7 @@
 
 #include <common.h>
 #include <asm/arch/cpu.h>
+#include <asm/arch/sys_proto.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/hardware.h>
 #include <asm/io.h>
@@ -55,26 +56,94 @@
 		CONFIG_SYS_MPUCLK, OSC-1, 1, -1, -1, -1, -1};
 const struct dpll_params dpll_core_opp100 = {
 		1000, OSC-1, -1, -1, 10, 8, 4};
-const struct dpll_params dpll_mpu = {
-		MPUPLL_M_300, OSC-1, 1, -1, -1, -1, -1};
-const struct dpll_params dpll_core = {
-		50, OSC-1, -1, -1, 1, 1, 1};
-const struct dpll_params dpll_per = {
-		960, OSC-1, 5, -1, -1, -1, -1};
 
-const struct dpll_params *get_dpll_mpu_params(void)
+const struct dpll_params dpll_mpu_opp[NUM_CRYSTAL_FREQ][NUM_OPPS] = {
+	{	/* 19.2 MHz */
+		{125, 3, 2, -1, -1, -1, -1},	/* OPP 50 */
+		{-1, -1, -1, -1, -1, -1, -1},	/* OPP RESERVED	*/
+		{125, 3, 1, -1, -1, -1, -1},	/* OPP 100 */
+		{150, 3, 1, -1, -1, -1, -1},	/* OPP 120 */
+		{125, 2, 1, -1, -1, -1, -1},	/* OPP TB */
+		{625, 11, 1, -1, -1, -1, -1}	/* OPP NT */
+	},
+	{	/* 24 MHz */
+		{25, 0, 2, -1, -1, -1, -1},	/* OPP 50 */
+		{-1, -1, -1, -1, -1, -1, -1},	/* OPP RESERVED	*/
+		{25, 0, 1, -1, -1, -1, -1},	/* OPP 100 */
+		{30, 0, 1, -1, -1, -1, -1},	/* OPP 120 */
+		{100, 3, 1, -1, -1, -1, -1},	/* OPP TB */
+		{125, 2, 1, -1, -1, -1, -1}	/* OPP NT */
+	},
+	{	/* 25 MHz */
+		{24, 0, 2, -1, -1, -1, -1},	/* OPP 50 */
+		{-1, -1, -1, -1, -1, -1, -1},	/* OPP RESERVED	*/
+		{24, 0, 1, -1, -1, -1, -1},	/* OPP 100 */
+		{144, 4, 1, -1, -1, -1, -1},	/* OPP 120 */
+		{32, 0, 1, -1, -1, -1, -1},	/* OPP TB */
+		{40, 0, 1, -1, -1, -1, -1}	/* OPP NT */
+	},
+	{	/* 26 MHz */
+		{300, 12, 2, -1, -1, -1, -1},	/* OPP 50 */
+		{-1, -1, -1, -1, -1, -1, -1},	/* OPP RESERVED	*/
+		{300, 12, 1, -1, -1, -1, -1},	/* OPP 100 */
+		{360, 12, 1, -1, -1, -1, -1},	/* OPP 120 */
+		{400, 12, 1, -1, -1, -1, -1},	/* OPP TB */
+		{500, 12, 1, -1, -1, -1, -1}	/* OPP NT */
+	},
+};
+
+const struct dpll_params dpll_core_1000MHz[NUM_CRYSTAL_FREQ] = {
+		{625, 11, -1, -1, 10, 8, 4},	/* 19.2 MHz */
+		{125, 2, -1, -1, 10, 8, 4},	/* 24 MHz */
+		{40, 0, -1, -1, 10, 8, 4},	/* 25 MHz */
+		{500, 12, -1, -1, 10, 8, 4}	/* 26 MHz */
+};
+
+const struct dpll_params dpll_per_192MHz[NUM_CRYSTAL_FREQ] = {
+		{400, 7, 5, -1, -1, -1, -1},	/* 19.2 MHz */
+		{400, 9, 5, -1, -1, -1, -1},	/* 24 MHz */
+		{384, 9, 5, -1, -1, -1, -1},	/* 25 MHz */
+		{480, 12, 5, -1, -1, -1, -1}	/* 26 MHz */
+};
+
+const struct dpll_params dpll_ddr3_303MHz[NUM_CRYSTAL_FREQ] = {
+		{505, 15, 2, -1, -1, -1, -1}, /*19.2*/
+		{101, 3, 2, -1, -1, -1, -1}, /* 24 MHz */
+		{303, 24, 1, -1, 4, -1, -1}, /* 25 MHz */
+		{303, 12, 2, -1, 4, -1, -1}  /* 26 MHz */
+};
+
+const struct dpll_params dpll_ddr3_400MHz[NUM_CRYSTAL_FREQ] = {
+		{125, 5, 1, -1, -1, -1, -1}, /*19.2*/
+		{50, 2, 1, -1, -1, -1, -1}, /* 24 MHz */
+		{16, 0, 1, -1, 4, -1, -1}, /* 25 MHz */
+		{200, 12, 1, -1, 4, -1, -1}  /* 26 MHz */
+};
+
+const struct dpll_params dpll_ddr2_266MHz[NUM_CRYSTAL_FREQ] = {
+		{665, 47, 1, -1, -1, -1, -1}, /*19.2*/
+		{133, 11, 1, -1, -1, -1, -1}, /* 24 MHz */
+		{266, 24, 1, -1, 4, -1, -1}, /* 25 MHz */
+		{133, 12, 1, -1, 4, -1, -1}  /* 26 MHz */
+};
+
+__weak const struct dpll_params *get_dpll_mpu_params(void)
 {
-	return &dpll_mpu;
+	return &dpll_mpu_opp100;
 }
 
 const struct dpll_params *get_dpll_core_params(void)
 {
-	return &dpll_core;
+	int ind = get_sys_clk_index();
+
+	return &dpll_core_1000MHz[ind];
 }
 
 const struct dpll_params *get_dpll_per_params(void)
 {
-	return &dpll_per;
+	int ind = get_sys_clk_index();
+
+	return &dpll_per_192MHz[ind];
 }
 
 void setup_clocks_for_console(void)
diff -u -N /dev/null U-Boot_SDcard/common/common_fit.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/common/common_fit.c	1969-12-31 19:31:37.000000901 -0600
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Google, Inc
+ * Written by Simon Glass <sjg@chromium.org>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <image.h>
+#include <libfdt.h>
+#include <spl.h>
+
+ulong fdt_getprop_u32(const void *fdt, int node, const char *prop)
+{
+	const u32 *cell;
+	int len;
+
+	cell = fdt_getprop(fdt, node, prop, &len);
+	if (len != sizeof(*cell))
+		return -1U;
+	return fdt32_to_cpu(*cell);
+}
+
+int fit_select_fdt(const void *fdt, int images, int *fdt_offsetp)
+{
+	const char *name, *fdt_name;
+	int conf, node, fdt_node;
+	int len;
+
+	*fdt_offsetp = 0;
+	conf = fdt_path_offset(fdt, FIT_CONFS_PATH);
+	if (conf < 0) {
+		debug("%s: Cannot find /configurations node: %d\n", __func__,
+		      conf);
+		return -EINVAL;
+	}
+	for (node = fdt_first_subnode(fdt, conf);
+	     node >= 0;
+	     node = fdt_next_subnode(fdt, node)) {
+		name = fdt_getprop(fdt, node, "description", &len);
+		if (!name) {
+#ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
+			printf("%s: Missing FDT description in DTB\n",
+			       __func__);
+#endif
+			return -EINVAL;
+		}
+		if (board_fit_config_name_match(name))
+			continue;
+
+		debug("Selecting config '%s'", name);
+		fdt_name = fdt_getprop(fdt, node, FIT_FDT_PROP, &len);
+		if (!fdt_name) {
+			debug("%s: Cannot find fdt name property: %d\n",
+			      __func__, len);
+			return -EINVAL;
+		}
+
+		debug(", fdt '%s'\n", fdt_name);
+		fdt_node = fdt_subnode_offset(fdt, images, fdt_name);
+		if (fdt_node < 0) {
+			debug("%s: Cannot find fdt node '%s': %d\n",
+			      __func__, fdt_name, fdt_node);
+			return -EINVAL;
+		}
+
+		*fdt_offsetp = fdt_getprop_u32(fdt, fdt_node, "data-offset");
+		len = fdt_getprop_u32(fdt, fdt_node, "data-size");
+		debug("FIT: Selected '%s'\n", name);
+
+		return len;
+	}
+
+#ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
+	printf("No matching DT out of these options:\n");
+	for (node = fdt_first_subnode(fdt, conf);
+	     node >= 0;
+	     node = fdt_next_subnode(fdt, node)) {
+		name = fdt_getprop(fdt, node, "description", &len);
+		printf("   %s\n", name);
+	}
+#endif
+
+	return -ENOENT;
+}
diff -u -N U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c
--- U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c	2019-09-12 15:54:12.000000216 -0500
+++ U-Boot_SDcard/drivers/mmc/arm_pl180_mmci.c	1969-12-31 19:29:21.000000176 -0600
@@ -275,7 +275,7 @@
 	return 0;
 }
 
-static void host_set_ios(struct mmc *dev)
+static int host_set_ios(struct mmc *dev)
 {
 	struct pl180_mmc_host *host = dev->priv;
 	u32 sdi_clkcr;
@@ -333,6 +333,8 @@
 
 	writel(sdi_clkcr, &host->base->clock);
 	udelay(CLK_CHANGE_DELAY);
+
+	return 0;
 }
 
 static const struct mmc_ops arm_pl180_mmci_ops = {
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2e-evm.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2e-evm.dts	1969-12-31 19:31:37.000000931 -0600
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Edison EVM device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone.dtsi"
+#include "keystone-k2e.dtsi"
+
+/ {
+	compatible =  "ti,k2e-evm","ti,keystone";
+	model = "Texas Instruments Keystone 2 Edison EVM";
+
+	soc {
+
+		clocks {
+			refclksys: refclksys {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <100000000>;
+				clock-output-names = "refclk-sys";
+			};
+
+			refclkpass: refclkpass {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <100000000>;
+				clock-output-names = "refclk-pass";
+			};
+
+			refclkddr3a: refclkddr3a {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <100000000>;
+				clock-output-names = "refclk-ddr3a";
+			};
+		};
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&i2c0 {
+	dtt@50 {
+		compatible = "at,24c1024";
+		reg = <0x50>;
+	};
+};
+
+&aemif {
+	cs0 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		clock-ranges;
+		ranges;
+
+		ti,cs-chipselect = <0>;
+		/* all timings in nanoseconds */
+		ti,cs-min-turnaround-ns = <12>;
+		ti,cs-read-hold-ns = <6>;
+		ti,cs-read-strobe-ns = <23>;
+		ti,cs-read-setup-ns = <9>;
+		ti,cs-write-hold-ns = <8>;
+		ti,cs-write-strobe-ns = <23>;
+		ti,cs-write-setup-ns = <8>;
+
+		nand@0,0 {
+			compatible = "ti,keystone-nand","ti,davinci-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0 0x4000000
+			       1 0 0x0000100>;
+
+			ti,davinci-chipselect = <0>;
+			ti,davinci-mask-ale = <0x2000>;
+			ti,davinci-mask-cle = <0x4000>;
+			ti,davinci-mask-chipsel = <0>;
+			nand-ecc-mode = "hw";
+			ti,davinci-ecc-bits = <4>;
+			nand-on-flash-bbt;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x0 0x100000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "params";
+				reg = <0x100000 0x80000>;
+				read-only;
+			};
+
+			partition@180000 {
+				label = "ubifs";
+				reg = <0x180000 0x1FE80000>;
+			};
+		};
+	};
+};
+
+&spi0 {
+	status = "okay";
+	nor_flash: n25q128a11@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "Micron,n25q128a11", "spi-flash";
+		spi-max-frequency = <54000000>;
+		m25p,fast-read;
+		reg = <0>;
+
+		partition@0 {
+			label = "u-boot-spl";
+			reg = <0x0 0x80000>;
+			read-only;
+		};
+
+		partition@1 {
+			label = "misc";
+			reg = <0x80000 0xf80000>;
+		};
+	};
+};
+
+&mdio {
+	status = "ok";
+	ethphy0: ethernet-phy@0 {
+		compatible = "marvell,88E1514", "marvell,88E1510", "ethernet-phy-ieee802.3-c22";
+		reg = <0>;
+	};
+
+	ethphy1: ethernet-phy@1 {
+		compatible = "marvell,88E1514", "marvell,88E1510", "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
diff -u -N U-Boot_SDcard/include/configs/baltos.h U-Boot_SDcard/include/configs/baltos.h
--- U-Boot_SDcard/include/configs/baltos.h	2019-09-12 15:54:53.000000249 -0500
+++ U-Boot_SDcard/include/configs/baltos.h	1969-12-31 19:29:22.000000073 -0600
@@ -257,7 +257,7 @@
 /* General network SPL, both CPSW and USB gadget RNDIS */
 #define CONFIG_SPL_NET_VCI_STRING	"AM335x U-Boot SPL"*/
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #ifdef CONFIG_NAND
 #define CONFIG_NAND_OMAP_GPMC
diff -u -N U-Boot_SDcard/drivers/clk/at91/pmc.c U-Boot_SDcard/drivers/clk/at91/pmc.c
--- U-Boot_SDcard/drivers/clk/at91/pmc.c	2019-09-12 15:54:38.000000126 -0500
+++ U-Boot_SDcard/drivers/clk/at91/pmc.c	1969-12-31 19:29:27.000000610 -0600
@@ -10,6 +10,7 @@
 #include <dm/device.h>
 #include <dm/lists.h>
 #include <dm/root.h>
+#include <dm/util.h>
 #include "pmc.h"
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -56,7 +57,7 @@
 	     offset > 0;
 	     offset = fdt_next_subnode(fdt, offset)) {
 		if (pre_reloc_only &&
-		    !fdt_getprop(fdt, offset, "u-boot,dm-pre-reloc", NULL))
+		    !dm_fdt_pre_reloc(fdt, offset))
 			continue;
 		/*
 		 * If this node has "compatible" property, this is not
diff -u -N U-Boot_SDcard/include/configs/am43xx_evm.h U-Boot_SDcard/include/configs/am43xx_evm.h
--- U-Boot_SDcard/include/configs/am43xx_evm.h	2019-09-12 15:54:39.000000168 -0500
+++ U-Boot_SDcard/include/configs/am43xx_evm.h	1969-12-31 19:29:22.000000039 -0600
@@ -14,14 +14,13 @@
 #define CONFIG_MAX_RAM_BANK_SIZE	(1024 << 21)	/* 2GB */
 #define CONFIG_SYS_TIMERBASE		0x48040000	/* Use Timer2 */
 
-#include <environment/ti/dfu.h>
 #include <asm/arch/omap.h>
 
 /* NS16550 Configuration */
 #define CONFIG_SYS_NS16550_CLK		48000000
-#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_DM_SERIAL)
+#if !defined(CONFIG_SPL_DM) || !defined(CONFIG_DM_SERIAL)
+#define CONFIG_SYS_NS16550_REG_SIZE    (-4)
 #define CONFIG_SYS_NS16550_SERIAL
-#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
 #endif
 
 /* I2C Configuration */
@@ -110,15 +109,22 @@
 #undef CONFIG_USB_GADGET_DUALSPEED
 #endif
 
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT))
+#define CONFIG_USB_ETHER
+#define CONFIG_USB_ETH_RNDIS
+#define CONFIG_USBNET_HOST_ADDR "de:ad:be:af:00:00"
+#endif
+
+#define CONFIG_SPL_LOAD_FIT_ADDRESS 0x80800000
+
 /*
  * Disable MMC DM for SPL build and can be re-enabled after adding
  * DM support in SPL
  */
 #ifdef CONFIG_SPL_BUILD
-#undef CONFIG_DM_MMC
-#undef CONFIG_DM_SPI
-#undef CONFIG_DM_SPI_FLASH
 #undef CONFIG_TIMER
+#undef CONFIG_DM_NAND
 #endif
 
 #ifndef CONFIG_SPL_BUILD
@@ -172,9 +178,96 @@
 #define CONFIG_CMD_GPT
 #define CONFIG_EFI_PARTITION
 
+#ifdef CONFIG_QSPI_BOOT 
 #ifndef CONFIG_SPL_BUILD
+#include <environment/ti/dfu.h>
+#include <environment/ti/qspi.h>
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	DEFAULT_LINUX_BOOT_ENV \
+	DEFAULT_QSPI_TI_ARGS \
+	DEFAULT_FIT_TI_ARGS \
+	"fdtfile=undefined\0" \
+	"bootpart=0:2\0" \
+	"bootdir=/boot\0" \
+	"bootfile=zImage\0" \
+	"console=ttyO0,115200n8\0" \
+	"partitions=" \
+		"uuid_disk=${uuid_gpt_disk};" \
+		"name=rootfs,start=2MiB,size=-,uuid=${uuid_gpt_rootfs}\0" \
+	"optargs=\0" \
+	"usbroot=/dev/sda2 rw\0" \
+	"usbrootfstype=ext4 rootwait\0" \
+	"usbdev=0\0" \
+	"ramroot=/dev/ram0 rw\0" \
+	"ramrootfstype=ext2\0" \
+	"usbargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${usbroot} " \
+		"rootfstype=${usbrootfstype}\0" \
+	"ramargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${ramroot} " \
+		"rootfstype=${ramrootfstype}\0" \
+	"loadramdisk=load ${devtype} ${devnum} ${rdaddr} ramdisk.gz\0" \
+	"usbboot=" \
+		"setenv devnum ${usbdev}; " \
+		"setenv devtype usb; " \
+		"usb start ${usbdev}; " \
+		"if usb dev ${usbdev}; then " \
+			"if run loadbootenv; then " \
+				"echo Loaded environment from ${bootenv};" \
+				"run importbootenv;" \
+			"fi;" \
+			"if test -n $uenvcmd; then " \
+				"echo Running uenvcmd ...;" \
+				"run uenvcmd;" \
+			"fi;" \
+			"if run loadimage; then " \
+				"run loadfdt; " \
+				"echo Booting from usb ${usbdev}...; " \
+				"run usbargs;" \
+				"bootz ${loadaddr} - ${fdtaddr}; " \
+			"fi;" \
+		"fi\0" \
+		"fi;" \
+		"usb stop ${usbdev};\0" \
+	"findfdt="\
+		"if test $board_name = AM43EPOS; then " \
+			"setenv fdtfile am43x-epos-evm.dtb; fi; " \
+		"if test $board_name = AM43__GP; then " \
+			"setenv fdtfile am437x-gp-evm.dtb; fi; " \
+		"if test $board_name = AM43XXHS; then " \
+			"setenv fdtfile am437x-gp-evm.dtb; fi; " \
+		"if test $board_name = AM43__SK; then " \
+			"setenv fdtfile am437x-sk-evm.dtb; fi; " \
+		"if test $board_name = AM43_IDK; then " \
+			"setenv fdtfile am437x-idk-evm.dtb; fi; " \
+		"if test $fdtfile = undefined; then " \
+			"echo WARNING: Could not determine device tree; fi; \0" \
+	NANDARGS \
+	NETARGS \
+	DFUARGS \
+
+#define CONFIG_BOOTCOMMAND \
+	"if test ${boot_fit} -eq 1; then "	\
+		"run update_to_fit;"	\
+	"fi;"	\
+	"run findfdt; " \
+	"run envboot;" \
+	"run usbboot;" \
+	NANDBOOT \
+
+#endif
+#endif
+
+#ifndef CONFIG_QSPI_BOOT 
+#ifndef CONFIG_SPL_BUILD
+#include <environment/ti/dfu.h>
+#include <environment/ti/mmc.h>
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	DEFAULT_LINUX_BOOT_ENV \
 	DEFAULT_MMC_TI_ARGS \
 	DEFAULT_FIT_TI_ARGS \
 	"fdtfile=undefined\0" \
@@ -250,6 +343,7 @@
 	NANDBOOT \
 
 #endif
+#endif
 
 #ifndef CONFIG_SPL_BUILD
 /* CPSW Ethernet */
@@ -357,4 +451,9 @@
 #define NANDBOOT
 #endif /* CONFIG_NAND */
 
+#if defined(CONFIG_TI_SECURE_DEVICE)
+/* Avoid relocating onto firewalled area at end of DRAM */
+#define CONFIG_PRAM (64 * 1024)
+#endif /* CONFIG_TI_SECURE_DEVICE */
+
 #endif	/* __CONFIG_AM43XX_EVM_H */
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h	2019-09-12 15:54:38.000000532 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware_am43xx.h	1969-12-31 19:29:30.000000332 -0600
@@ -85,19 +85,6 @@
 #define	USBOTGSSX_CLKCTRL_OPTFCLKEN_REFCLK960	(1 << 8)
 #define	USBPHY0_CLKCTRL_OPTFCLKEN_CLK32K	(1 << 8)
 
-/* Control status register */
-#define CTRL_CRYSTAL_FREQ_SRC_MASK		(1 << 31)
-#define CTRL_CRYSTAL_FREQ_SRC_SHIFT		31
-#define CTRL_CRYSTAL_FREQ_SELECTION_MASK	(0x3 << 29)
-#define CTRL_CRYSTAL_FREQ_SELECTION_SHIFT	29
-#define CTRL_SYSBOOT_15_14_MASK			(0x3 << 22)
-#define CTRL_SYSBOOT_15_14_SHIFT		22
-
-#define CTRL_CRYSTAL_FREQ_SRC_SYSBOOT		0x0
-#define CTRL_CRYSTAL_FREQ_SRC_EFUSE		0x1
-
-#define NUM_CRYSTAL_FREQ			0x4
-
 /* EDMA3 Base Address */
 #define EDMA3_BASE				0x49000000
 
diff -u -N U-Boot_SDcard/board/ti/omap5_uevm/evm.c U-Boot_SDcard/board/ti/omap5_uevm/evm.c
--- U-Boot_SDcard/board/ti/omap5_uevm/evm.c	2019-09-12 15:54:40.000000780 -0500
+++ U-Boot_SDcard/board/ti/omap5_uevm/evm.c	1969-12-31 19:29:27.000000219 -0600
@@ -211,7 +211,7 @@
 		   sizeof(struct pad_conf_entry));
 }
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/common/main.c U-Boot_SDcard/common/main.c
--- U-Boot_SDcard/common/main.c	2019-09-12 15:54:36.000000891 -0500
+++ U-Boot_SDcard/common/main.c	1969-12-31 19:29:17.000000518 -0600
@@ -12,7 +12,11 @@
 #include <cli.h>
 #include <console.h>
 #include <version.h>
+#include <malloc.h>
+#include "fw_validation.h"
+#include "fw_update.h"
 
+int reset_fwInfo(FW_INFO *fwlw);
 DECLARE_GLOBAL_DATA_PTR;
 
 /*
@@ -58,7 +62,10 @@
 #if defined(CONFIG_UPDATE_TFTP)
 	update_tftp(0UL, NULL, NULL);
 #endif /* CONFIG_UPDATE_TFTP */
-
+        
+        /* Verifying vxworks checksum*/  
+        am5728_os_checksum_validate();     
+  
 	s = bootdelay_process();
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
@@ -68,3 +75,200 @@
 	cli_loop();
 	panic("No CLI available");
 }
+
+unsigned short crc16_ccittt(const void *buf, int len)
+{
+        int counter;
+        unsigned short crc = 0;
+        for( counter = 0; counter < len; counter++)
+        {
+          crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *(char *)buf)&0x00FF];
+          buf = ((char *)buf) +1;
+        }
+        return crc;
+}
+
+static struct spi_flash *env_flash;
+
+void am5728_os_checksum_validate()
+{
+  #define FALSE   0
+  #define TRUE    1
+  #define REFERNCE_INFO_FLASH_OFFSET   0x1C0000
+ 
+  unsigned int bus = CONFIG_SF_DEFAULT_BUS;
+  unsigned int cs = CONFIG_SF_DEFAULT_CS;
+  unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
+  unsigned int mode = CONFIG_SF_DEFAULT_MODE;
+
+  struct spi_flash   *new;
+  binInfo_t *bInfo = NULL;
+  FW_INFO  *fwlw;
+  char * buffer=NULL;
+  int ret, osCrcResult = FALSE;
+  unsigned short   osCRC;
+  unsigned int     osSize;
+  unsigned int     osOffset;
+  unsigned short   calculated_crc;
+unsigned int testSize = 0;
+
+  int loadAddr =0;
+  if (env_flash)
+  {
+    spi_flash_free(env_flash);
+  }
+
+  new = spi_flash_probe(bus, cs, speed, mode);
+  env_flash = new;
+
+  if (!new)
+  {
+   printf("Failed to initialize SPI flash at %u:%u\n", bus, cs);
+   return;
+  }
+
+  fwlw = (FW_INFO *)memalign(ARCH_DMA_MINALIGN, sizeof(FW_INFO));
+  if(fwlw==NULL)
+  {
+    printf("Refernce struct allocation failed");
+  }
+
+  ret = spi_flash_read(env_flash, REFERNCE_INFO_FLASH_OFFSET,
+                                   sizeof(FW_INFO), (void *)fwlw);
+  if (ret) 
+  {
+     printf("spi_flash_read binInfo failed\n");
+  }
+
+#if 0
+  printf("Before reset....\n");
+  printf("fwlw->bootMode %x\n",fwlw->bootMode);
+  printf("fwlw->fwUpgrade %x\n",fwlw->fwUpgrade);
+  printf("fwlw->activePart %x\n",fwlw->activePart);
+  printf("fwlw->passivePart %x\n",fwlw->passivePart);
+#endif
+
+   if((fwlw->bootMode == 0xffffffff)|| (fwlw->bootMode == 0xeeeeeeee))
+     {
+       reset_fwInfo(fwlw);
+       #if 1
+	printf("Reset Partitioning information @ 0x1C0000....\n");
+       #endif
+     }
+
+#if 0
+   printf("After Reset.....\n");
+   printf("fwlw->bootMode %x\n",fwlw->bootMode);
+   printf("fwlw->fwUpgrade %x\n",fwlw->fwUpgrade);
+   printf("fwlw->activePart %x\n",fwlw->activePart);
+   printf("fwlw->passivePart %x\n",fwlw->passivePart);
+#endif
+
+   if((fwlw->bootMode == BRANSON_ACTIVE_BOOTMODE && fwlw->fwUpgrade == BRANSON_NORMAL_BOOT)
+       ||(fwlw->bootMode == BRANSON_PASSIVE_BOOTMODE && fwlw->fwUpgrade == BRANSON_FWUPGRADE))
+     {
+	#if 0
+       printf("If Hitted.....\n");
+	#endif
+                        loadAddr = fwlw->activePart;
+                        fwlw->bootMode = BRANSON_ACTIVE_BOOTMODE;
+                        fwlw->fwUpgrade = BRANSON_NORMAL_BOOT;
+     }
+   else if (fwlw->bootMode == BRANSON_ACTIVE_BOOTMODE && fwlw->fwUpgrade == BRANSON_FWUPGRADE)
+           {
+	#if 0
+           printf("Elseif hitted....\n");
+	#endif
+                        loadAddr = fwlw->passivePart;
+	                fwlw->bootMode =BRANSON_PASSIVE_BOOTMODE;
+	   }
+   ret = spi_flash_erase(env_flash, REFERNCE_INFO_FLASH_OFFSET, 0x10000);
+   if (ret)
+{
+         printf("Erasing Flash Info from QSPI flash failed.\n");
+         return;
+}
+	#if 0
+   printf("Erased flash Info from SPI flash....\n");
+	#endif
+
+
+   ret = spi_flash_write(env_flash, FIRMWARE_PARTITION_INFO,sizeof(FW_INFO), fwlw);
+   if (ret)
+{
+        printf("Boot config write failed.\n");
+return;
+}
+
+#if 0
+   printf("After If and Else....\n");
+   printf("fwlw->bootMode %x\n",fwlw->bootMode);
+   printf("fwlw->fwUpgrade %x\n",fwlw->fwUpgrade);
+   printf("fwlw->activePart %x\n",fwlw->activePart);
+   printf("fwlw->passivePart %x\n",fwlw->passivePart);
+#endif
+
+  free(fwlw);
+  fwlw = NULL;
+
+#if 0
+  buffer = (char *)memalign(ARCH_DMA_MINALIGN,osSize);
+  if (!buffer)
+  {
+     printf("memory allocation for vxworks buffer failed\n");
+  }
+
+  ret = spi_flash_read(env_flash, osOffset,osSize , buffer);
+  if (ret)
+  {
+     printf("reading vxworks details failed\n");
+  }
+#endif
+
+	testSize = VXWORKS_KERNEL_MAX_SIZE;
+/*printf("testSize: 0x%X\n", testSize);*/
+
+
+  printf("vxworks bin loading into 0x84100000 from : %x QSPI flash \n",loadAddr);
+  ret = spi_flash_read(env_flash, loadAddr, VXWORKS_KERNEL_MAX_SIZE,(void *)FW_LOAD_RAM_ADDR);
+  if (ret) {
+            printf("Boot config reading failed.\n");
+return;
+  }
+
+#if 0
+  calculated_crc = crc16_ccittt((void *)buffer, osSize);
+  
+  printf("VxWorks Image CRC %x\n",osCRC);
+  printf("Calculated Image CRC 0x%x\n",calculated_crc);
+
+  if(calculated_crc == osCRC)
+  {
+     printf("\nVxworks CRC matched\n");
+  }
+  else
+  {
+     printf("\n VxWorks CRC MisMatched\n");
+     printf("\n Please re-flash binaries using JTAG \n");
+   
+     /* CRC failed.Don't go further. Stuck here*/
+     osCrcResult = TRUE;
+     while(osCrcResult);
+  }
+#endif
+ //free(buffer);
+ return;
+}
+
+
+
+int reset_fwInfo(FW_INFO *fwlw) {
+	        if(fwlw->bootMode !=BRANSON_ACTIVE_BOOTMODE && fwlw->bootMode != BRANSON_PASSIVE_BOOTMODE) {
+			                fwlw->bootMode = BRANSON_ACTIVE_BOOTMODE;
+			                fwlw->fwUpgrade = BRANSON_NORMAL_BOOT;
+			                fwlw->activePart = BRANSON_ACTIVE_BOOTPART;
+			                fwlw->passivePart = BRANSON_PASSIVE_BOOTPART;
+											        }
+		        return 0;
+}
+
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h	2019-09-12 15:54:30.000000336 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/hardware.h	1969-12-31 19:29:30.000000330 -0600
@@ -61,5 +61,18 @@
 /* CPSW Config space */
 #define CPSW_BASE			0x4A100000
 
+/* Control status register */
+#define CTRL_CRYSTAL_FREQ_SRC_MASK		(1 << 31)
+#define CTRL_CRYSTAL_FREQ_SRC_SHIFT		31
+#define CTRL_CRYSTAL_FREQ_SELECTION_MASK	(0x3 << 29)
+#define CTRL_CRYSTAL_FREQ_SELECTION_SHIFT	29
+#define CTRL_SYSBOOT_15_14_MASK			(0x3 << 22)
+#define CTRL_SYSBOOT_15_14_SHIFT		22
+
+#define CTRL_CRYSTAL_FREQ_SRC_SYSBOOT		0x0
+#define CTRL_CRYSTAL_FREQ_SRC_EFUSE		0x1
+
+#define NUM_CRYSTAL_FREQ			0x4
+
 int clk_get(int clk);
 #endif /* __AM33XX_HARDWARE_H */
diff -u -N U-Boot_SDcard/drivers/mmc/omap_hsmmc.c U-Boot_SDcard/drivers/mmc/omap_hsmmc.c
--- U-Boot_SDcard/drivers/mmc/omap_hsmmc.c	2019-09-12 15:54:11.000000514 -0500
+++ U-Boot_SDcard/drivers/mmc/omap_hsmmc.c	1969-12-31 19:29:21.000000203 -0600
@@ -25,6 +25,7 @@
 #include <config.h>
 #include <common.h>
 #include <malloc.h>
+#include <memalign.h>
 #include <mmc.h>
 #include <part.h>
 #include <i2c.h>
@@ -33,11 +34,16 @@
 #include <palmas.h>
 #include <asm/io.h>
 #include <asm/arch/mmc_host_def.h>
+#ifdef CONFIG_OMAP54XX
+#include <asm/arch/mux_dra7xx.h>
+#include <asm/arch/dra7xx_iodelay.h>
+#endif
 #if !defined(CONFIG_SOC_KEYSTONE)
 #include <asm/gpio.h>
 #include <asm/arch/sys_proto.h>
 #endif
 #include <dm.h>
+#include <power/regulator.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -53,9 +59,18 @@
 #define SYSCTL_SRC	(1 << 25)
 #define SYSCTL_SRD	(1 << 26)
 
+struct omap_hsmmc_plat {
+	struct mmc_config cfg;
+	struct mmc mmc;
+};
+
 struct omap_hsmmc_data {
 	struct hsmmc *base_addr;
+#ifndef CONFIG_DM_MMC
 	struct mmc_config cfg;
+#endif
+	uint bus_width;
+	uint clock;
 #ifdef OMAP_HSMMC_USE_GPIO
 #ifdef CONFIG_DM_MMC
 	struct gpio_desc cd_gpio;	/* Change Detect GPIO */
@@ -66,14 +81,89 @@
 	int wp_gpio;
 #endif
 #endif
+#ifdef CONFIG_DM_MMC
+	uint iov;
+	uint timing;
+	u8 controller_flags;
+	struct omap_hsmmc_adma_desc *adma_desc_table;
+	uint desc_slot;
+	int node;
+	char *version;
+	struct udevice *vmmc_supply;
+	struct udevice *vmmc_aux_supply;
+	ushort last_cmd;
+#ifdef CONFIG_IODELAY_RECALIBRATION
+	struct omap_hsmmc_pinctrl_state *default_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *hs_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *hs200_1_8v_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *ddr_1_8v_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *sdr104_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *ddr50_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *sdr50_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *sdr25_pinctrl_state;
+	struct omap_hsmmc_pinctrl_state *sdr12_pinctrl_state;
+#endif
+#endif
+	uint signal_voltage;
+};
+
+#ifdef CONFIG_DM_MMC
+struct omap_hsmmc_adma_desc {
+	u8 attr;
+	u8 reserved;
+	u16 len;
+	u32 addr;
 };
 
+struct omap_mmc_of_data {
+	u8 controller_flags;
+};
+
+#define ADMA_MAX_LEN	63488
+
+/* Decriptor table defines */
+#define ADMA_DESC_ATTR_VALID		BIT(0)
+#define ADMA_DESC_ATTR_END		BIT(1)
+#define ADMA_DESC_ATTR_INT		BIT(2)
+#define ADMA_DESC_ATTR_ACT1		BIT(4)
+#define ADMA_DESC_ATTR_ACT2		BIT(5)
+
+#define ADMA_DESC_TRANSFER_DATA		ADMA_DESC_ATTR_ACT2
+#define ADMA_DESC_LINK_DESC	(ADMA_DESC_ATTR_ACT1 | ADMA_DESC_ATTR_ACT2)
+#endif
+
 /* If we fail after 1 second wait, something is really bad */
 #define MAX_RETRY_MS	1000
+#define MMC_TIMEOUT_MS	20
+#define OMAP_HSMMC_SUPPORTS_DUAL_VOLT		BIT(0)
+#define OMAP_HSMMC_NO_1_8_V			BIT(1)
+#define OMAP_HSMMC_USE_ADMA			BIT(2)
+#define OMAP_HSMMC_REQUIRE_IODELAY		BIT(3)
 
 static int mmc_read_data(struct hsmmc *mmc_base, char *buf, unsigned int size);
 static int mmc_write_data(struct hsmmc *mmc_base, const char *buf,
 			unsigned int siz);
+static void omap_hsmmc_start_clock(struct hsmmc *mmc_base);
+static void omap_hsmmc_stop_clock(struct hsmmc *mmc_base);
+static void mmc_reset_controller_fsm(struct hsmmc *mmc_base, u32 bit);
+
+static inline struct omap_hsmmc_data *omap_hsmmc_get_data(struct mmc *mmc)
+{
+#ifdef CONFIG_DM_MMC
+	return dev_get_priv(mmc->dev);
+#else
+	return (struct omap_hsmmc_data *)mmc->priv;
+#endif
+}
+static inline struct mmc_config *omap_hsmmc_get_cfg(struct mmc *mmc)
+{
+#ifdef CONFIG_DM_MMC
+	struct omap_hsmmc_plat *plat = dev_get_platdata(mmc->dev);
+	return &plat->cfg;
+#else
+	return &((struct omap_hsmmc_data *)mmc->priv)->cfg;
+#endif
+}
 
 #if defined(OMAP_HSMMC_USE_GPIO) && !defined(CONFIG_DM_MMC)
 static int omap_mmc_setup_gpio_in(int gpio, const char *label)
@@ -99,6 +189,7 @@
 static unsigned char mmc_board_init(struct mmc *mmc)
 {
 #if defined(CONFIG_OMAP34XX)
+	struct mmc_config *cfg = omap_hsmmc_get_cfg(mmc);
 	t2_t *t2_base = (t2_t *)T2_BASE;
 	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
 	u32 pbias_lite;
@@ -122,7 +213,7 @@
 		&t2_base->devconf1);
 
 	/* Change from default of 52MHz to 26MHz if necessary */
-	if (!(mmc->cfg->host_caps & MMC_MODE_HS_52MHz))
+	if (!(cfg->host_caps & MMC_MODE_HS_52MHz))
 		writel(readl(&t2_base->ctl_prog_io1) & ~CTLPROGIO1SPEEDCTRL,
 			&t2_base->ctl_prog_io1);
 
@@ -137,7 +228,7 @@
 
 #if defined(CONFIG_OMAP54XX) || defined(CONFIG_OMAP44XX)
 	/* PBIAS config needed for MMC1 only */
-	if (mmc->block_dev.devnum == 0)
+	if (mmc_get_blk_desc(mmc)->devnum == 0)
 		vmmc_pbias_config(LDO_VOLT_3V0);
 #endif
 
@@ -172,14 +263,506 @@
 	writel(readl(&mmc_base->con) & ~INIT_INITSTREAM, &mmc_base->con);
 }
 
+#ifdef CONFIG_DM_MMC
+#ifdef CONFIG_IODELAY_RECALIBRATION
+#ifdef DEBUG
+static inline void show_mmc_timing(struct mmc *mmc)
+{
+	const char *str;
+	switch (mmc->timing) {
+	case MMC_TIMING_MMC_HS200:
+		str = "HS200";
+		break;
+	case MMC_TIMING_UHS_SDR104:
+		str = "SDR104";
+		break;
+	case MMC_TIMING_UHS_DDR50:
+		str = "DDR50";
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		str = "SDR50";
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		str = "SDR25";
+		break;
+	case MMC_TIMING_UHS_SDR12:
+		str = "SDR12";
+		break;
+	case MMC_TIMING_SD_HS:
+		str = "HS(sd)";
+		break;
+	case MMC_TIMING_MMC_HS:
+		str = "HS(mmc)";
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		str = "DDR52";
+		break;
+	default:
+		str = "std";
+		break;
+	}
+	printf("mmc %d mode %s\n", mmc->block_dev.devnum + 1, str);
+}
+#else
+static inline void show_mmc_timing(struct mmc *mmc)
+{
+}
+#endif
+
+static void omap_hsmmc_set_timing(struct mmc *mmc)
+{
+	u32 val;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct omap_hsmmc_pinctrl_state *pinctrl_state;
+
+	mmc_base = priv->base_addr;
+
+	writel(readl(&mmc_base->con) & ~DDR, &mmc_base->con);
+	omap_hsmmc_stop_clock(mmc_base);
+	val = readl(&mmc_base->ac12);
+	val &= ~AC12_UHSMC_MASK;
+	switch (mmc->timing) {
+	case MMC_TIMING_MMC_HS200:
+		val |= AC12_UHSMC_SDR104;
+		pinctrl_state = priv->hs200_1_8v_pinctrl_state;
+		break;
+	case MMC_TIMING_UHS_SDR104:
+		val |= AC12_UHSMC_SDR104;
+		pinctrl_state = priv->sdr104_pinctrl_state;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+		val |= AC12_UHSMC_DDR50;
+		writel(readl(&mmc_base->con) | DDR, &mmc_base->con);
+		pinctrl_state = priv->ddr50_pinctrl_state;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		val |= AC12_UHSMC_SDR50;
+		pinctrl_state = priv->sdr50_pinctrl_state;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		val |= AC12_UHSMC_SDR25;
+		pinctrl_state = priv->sdr25_pinctrl_state;
+		break;
+	case MMC_TIMING_UHS_SDR12:
+		val |= AC12_UHSMC_SDR12;
+		pinctrl_state = priv->sdr12_pinctrl_state;
+		break;
+	case MMC_TIMING_SD_HS:
+	case MMC_TIMING_MMC_HS:
+		val |= AC12_UHSMC_RES;
+		pinctrl_state = priv->hs_pinctrl_state;
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		val |= AC12_UHSMC_RES;
+		writel(readl(&mmc_base->con) | DDR, &mmc_base->con);
+		pinctrl_state = priv->ddr_1_8v_pinctrl_state;
+		break;
+	default:
+		val |= AC12_UHSMC_RES;
+		pinctrl_state = priv->default_pinctrl_state;
+		break;
+	}
+	writel(val, &mmc_base->ac12);
+
+	if (priv->controller_flags & OMAP_HSMMC_REQUIRE_IODELAY) {
+		if (pinctrl_state->iodelay)
+			late_recalibrate_iodelay(pinctrl_state->padconf,
+						 pinctrl_state->npads,
+						 pinctrl_state->iodelay,
+						 pinctrl_state->niodelays);
+		else
+			do_set_mux32((*ctrl)->control_padconf_core_base,
+				     pinctrl_state->padconf,
+				     pinctrl_state->npads);
+	}
+
+	omap_hsmmc_start_clock(mmc_base);
+	priv->timing = mmc->timing;
+	show_mmc_timing(mmc);
+}
+#endif
+#endif
+
+static void omap_hsmmc_conf_bus_power(struct mmc *mmc, uint signal_voltage)
+{
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 val;
+
+	mmc_base = priv->base_addr;
+
+	val = readl(&mmc_base->hctl) & ~SDVS_MASK;
+
+	switch (signal_voltage) {
+	case IOV_3V3:
+		val |= SDVS_3V3;
+		break;
+	case IOV_3V0:
+		val |= SDVS_3V0;
+		break;
+	case IOV_1V8:
+		val |= SDVS_1V8;
+		break;
+	}
+
+	writel(val, &mmc_base->hctl);
+}
+
+#if defined(CONFIG_DM_MMC)
+static int omap_hsmmc_card_busy_low(struct mmc *mmc)
+{
+	u32 val;
+	int i;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+
+	val = readl(&mmc_base->con);
+	val &= ~CON_CLKEXTFREE;
+	val |= CON_PADEN;
+	writel(val, &mmc_base->con);
+
+	/* By observation, card busy status reflects in 100 - 200us */
+	for (i = 0; i < 5; i++) {
+		val = readl(&mmc_base->pstate);
+		if (!(val & (PSTATE_CLEV | PSTATE_DLEV)))
+			return true;
+
+		udelay(200);
+	}
+
+	return false;
+}
+
+static int omap_hsmmc_card_busy_high(struct mmc *mmc)
+{
+	int ret = true;
+	u32 val;
+	int i;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+
+	val = readl(&mmc_base->con);
+	val |= CON_CLKEXTFREE;
+	writel(val, &mmc_base->con);
+
+	/* By observation, card busy status reflects in 100 - 200us */
+	for (i = 0; i < 5; i++) {
+		val = readl(&mmc_base->pstate);
+		if ((val & PSTATE_CLEV) && (val & PSTATE_DLEV)) {
+			val = readl(&mmc_base->con);
+			val &= ~(CON_CLKEXTFREE | CON_PADEN);
+			writel(val, &mmc_base->con);
+			ret = false;
+			goto ret;
+		}
+
+		udelay(200);
+	}
+
+ret:
+	return ret;
+}
+
+static int omap_hsmmc_card_busy(struct mmc *mmc)
+{
+	int ret;
+	u32 val;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+
+	if (priv->last_cmd != SD_CMD_SWITCH_UHS18V) {
+		val = readl(&mmc_base->pstate);
+		if (val & PSTATE_DLEV_DAT0)
+			return true;
+		return false;
+	}
+
+	val = readl(&mmc_base->ac12);
+	if (val & AC12_V1V8_SIGEN)
+		ret = omap_hsmmc_card_busy_high(mmc);
+	else
+		ret = omap_hsmmc_card_busy_low(mmc);
+
+	return ret;
+}
+
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+static int omap_hsmmc_set_io_regulator(struct mmc *mmc, int uV)
+{
+	int ret;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	if (!priv->vmmc_aux_supply)
+		return 0;
+
+	ret = regulator_set_enable(priv->vmmc_aux_supply, false);
+	if (ret && ret != -ENOSYS)
+		return ret;
+
+	ret = regulator_set_value(priv->vmmc_aux_supply, uV);
+	if (ret)
+		return ret;
+
+	ret = regulator_set_enable(priv->vmmc_aux_supply, true);
+	if (ret && ret != -ENOSYS)
+		return ret;
+
+	return 0;
+}
+#endif
+#endif
+
+static int omap_hsmmc_set_signal_voltage(struct mmc *mmc)
+{
+	u32 val;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+	priv->signal_voltage = mmc->signal_voltage;
+
+	if (mmc->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		val = readl(&mmc_base->capa);
+		if (!(val & VS30_3V0SUP))
+			return -EOPNOTSUPP;
+
+		omap_hsmmc_conf_bus_power(mmc, IOV_3V0);
+
+		val = readl(&mmc_base->ac12);
+		val &= ~AC12_V1V8_SIGEN;
+		writel(val, &mmc_base->ac12);
+
+#if defined(CONFIG_OMAP54XX) && defined(CONFIG_PALMAS_POWER)
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+		return omap_hsmmc_set_io_regulator(mmc, 3000000);
+#else
+		vmmc_pbias_config(LDO_VOLT_3V0);
+#endif
+#endif
+	} else if (mmc->signal_voltage == MMC_SIGNAL_VOLTAGE_180) {
+		val = readl(&mmc_base->capa);
+		if (!(val & VS18_1V8SUP))
+			return -EOPNOTSUPP;
+
+		omap_hsmmc_conf_bus_power(mmc, IOV_1V8);
+
+		val = readl(&mmc_base->ac12);
+		val |= AC12_V1V8_SIGEN;
+		writel(val, &mmc_base->ac12);
+
+#if defined(CONFIG_OMAP54XX) && defined(CONFIG_PALMAS_POWER)
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+		return omap_hsmmc_set_io_regulator(mmc, 1800000);
+#else
+		vmmc_pbias_config(LDO_VOLT_1V8);
+#endif
+#endif
+	} else {
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_DM_MMC)
+static void omap_hsmmc_set_capabilities(struct mmc *mmc)
+{
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 val;
+
+	mmc_base = priv->base_addr;
+	val = readl(&mmc_base->capa);
+
+	if (priv->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {
+		val |= (VS30_3V0SUP | VS18_1V8SUP);
+		priv->iov = IOV_3V0;
+	} else if (priv->controller_flags & OMAP_HSMMC_NO_1_8_V) {
+		val |= VS30_3V0SUP;
+		val &= ~VS18_1V8SUP;
+		priv->iov = IOV_3V0;
+	} else {
+		val |= VS18_1V8SUP;
+		val &= ~VS30_3V0SUP;
+		priv->iov = IOV_1V8;
+	}
+
+	writel(val, &mmc_base->capa);
+}
+
+static void omap_hsmmc_disable_tuning(struct mmc *mmc)
+{
+	int val;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+	val = readl(&mmc_base->ac12);
+	val &= ~(AC12_SCLK_SEL);
+	writel(val, &mmc_base->ac12);
+
+	val = readl(&mmc_base->dll);
+	val &= ~(DLL_FORCE_VALUE | DLL_SWT);
+	writel(val, &mmc_base->dll);
+}
+
+static void omap_hsmmc_set_dll(struct mmc *mmc, int count)
+{
+	int i;
+	u32 val;
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	mmc_base = priv->base_addr;
+	val = readl(&mmc_base->dll);
+	val |= DLL_FORCE_VALUE;
+	val &= ~(DLL_FORCE_SR_C_MASK << DLL_FORCE_SR_C_SHIFT);
+	val |= (count << DLL_FORCE_SR_C_SHIFT);
+	writel(val, &mmc_base->dll);
+
+	val |= DLL_CALIB;
+	writel(val, &mmc_base->dll);
+	for (i = 0; i < 1000; i++) {
+		if (readl(&mmc_base->dll) & DLL_CALIB)
+			break;
+	}
+	val &= ~DLL_CALIB;
+	writel(val, &mmc_base->dll);
+}
+
+static int omap_hsmmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 val;
+	u8 cur_match, prev_match = 0;
+	int ret;
+	u32 phase_delay = 0;
+	u32 start_window = 0, max_window = 0;
+	u32 length = 0, max_len = 0;
+
+	/* clock tuning is not needed for upto 52MHz */
+	if (mmc->clock <= 52000000)
+		return 0;
+
+	mmc_base = priv->base_addr;
+
+	val = readl(&mmc_base->ac12);
+	val |= AC12_V1V8_SIGEN;
+	writel(val, &mmc_base->ac12);
+	val = readl(&mmc_base->dll);
+	val |= DLL_SWT;
+	writel(val, &mmc_base->dll);
+	while (phase_delay <= MAX_PHASE_DELAY) {
+		omap_hsmmc_set_dll(mmc, phase_delay);
+
+		cur_match = !mmc_send_tuning(mmc, opcode, NULL);
+
+		if (cur_match) {
+			if (prev_match) {
+				length++;
+			} else {
+				start_window = phase_delay;
+				length = 1;
+			}
+		}
+
+		if (length > max_len) {
+			max_window = start_window;
+			max_len = length;
+		}
+
+		prev_match = cur_match;
+		phase_delay += 4;
+		udelay(100);
+	val = readl(&mmc_base->dll);
+	val &= ~DLL_FORCE_VALUE;
+	writel(val, &mmc_base->dll);
+	}
+
+	if (!max_len) {
+		ret = -EIO;
+		goto tuning_error;
+	}
+
+	val = readl(&mmc_base->ac12);
+	if (!(val & AC12_SCLK_SEL)) {
+		ret = -EIO;
+		goto tuning_error;
+	}
+
+	phase_delay = max_window + 4 * ((3 * max_len) >> 2);
+	omap_hsmmc_set_dll(mmc, phase_delay);
+
+	mmc_reset_controller_fsm(mmc_base, SYSCTL_SRD);
+	mmc_reset_controller_fsm(mmc_base, SYSCTL_SRC);
+
+	return 0;
+
+tuning_error:
+
+	omap_hsmmc_disable_tuning(mmc);
+	mmc_reset_controller_fsm(mmc_base, SYSCTL_SRD);
+	mmc_reset_controller_fsm(mmc_base, SYSCTL_SRC);
+
+	return ret;
+}
+
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+static int omap_hsmmc_set_vdd(struct mmc *mmc, bool enable)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct hsmmc *mmc_base = priv->base_addr;
+
+	if (enable) {
+		regulator_set_enable(priv->vmmc_supply, true);
+		mmc_init_stream(mmc_base);
+	} else {
+		regulator_set_enable(priv->vmmc_supply, false);
+	}
+
+	return 0;
+}
+#endif
+#endif
+
+static void mmc_enable_irq(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 irq_mask = INT_EN_MASK;
+	struct hsmmc *mmc_base;
+
+	mmc_base = priv->base_addr;
+
+	/*
+	 * TODO: Errata i802 indicates only DCRC interrupts can occur during
+	 * tuning procedure and DCRC should be disabled. But see occurences
+	 * of DEB, CIE, CEB, CCRC interupts during tuning procedure. These
+	 * interrupts occur along with BRR, so the data is actually in the
+	 * buffer. It has to be debugged why these interrutps occur
+	 */
+	if (cmd && cmd->cmdidx == MMC_SEND_TUNING_BLOCK_HS200)
+		irq_mask &= ~(IE_DEB | IE_DCRC | IE_CIE | IE_CEB | IE_CCRC);
+
+	writel(irq_mask, &mmc_base->ie);
+}
+
 static int omap_hsmmc_init_setup(struct mmc *mmc)
 {
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	struct hsmmc *mmc_base;
 	unsigned int reg_val;
 	unsigned int dsor;
 	ulong start;
 
-	mmc_base = ((struct omap_hsmmc_data *)mmc->priv)->base_addr;
+	mmc_base = priv->base_addr;
 	mmc_board_init(mmc);
 
 	writel(readl(&mmc_base->sysconfig) | MMC_SOFTRESET,
@@ -200,9 +783,18 @@
 			return -ETIMEDOUT;
 		}
 	}
+
+#ifdef CONFIG_DM_MMC
+	omap_hsmmc_set_capabilities(mmc);
+	omap_hsmmc_conf_bus_power(mmc, priv->iov);
+	reg_val = readl(&mmc_base->hl_hwinfo);
+	if (reg_val & MADMA_EN)
+		priv->controller_flags |= OMAP_HSMMC_USE_ADMA;
+#else
 	writel(DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0, &mmc_base->hctl);
 	writel(readl(&mmc_base->capa) | VS30_3V0SUP | VS18_1V8SUP,
 		&mmc_base->capa);
+#endif
 
 	reg_val = readl(&mmc_base->con) & RESERVED_MASK;
 
@@ -212,7 +804,7 @@
 
 	dsor = 240;
 	mmc_reg_out(&mmc_base->sysctl, (ICE_MASK | DTO_MASK | CEN_MASK),
-		(ICE_STOP | DTO_15THDTO | CEN_DISABLE));
+		(ICE_STOP | DTO_15THDTO));
 	mmc_reg_out(&mmc_base->sysctl, ICE_MASK | CLKD_MASK,
 		(dsor << CLKD_OFFSET) | ICE_OSCILLATE);
 	start = get_timer(0);
@@ -226,11 +818,11 @@
 
 	writel(readl(&mmc_base->hctl) | SDBP_PWRON, &mmc_base->hctl);
 
-	writel(IE_BADA | IE_CERR | IE_DEB | IE_DCRC | IE_DTO | IE_CIE |
-		IE_CEB | IE_CCRC | IE_CTO | IE_BRR | IE_BWR | IE_TC | IE_CC,
-		&mmc_base->ie);
+	mmc_enable_irq(mmc, NULL);
 
+#ifndef CONFIG_DM_REGULATOR
 	mmc_init_stream(mmc_base);
+#endif
 
 	return 0;
 }
@@ -265,8 +857,9 @@
 	defined(CONFIG_AM33XX) || defined(CONFIG_AM43XX)
 	if (!(readl(&mmc_base->sysctl) & bit)) {
 		start = get_timer(0);
+		/* To check why this bit is never set in DRA7xx */
 		while (!(readl(&mmc_base->sysctl) & bit)) {
-			if (get_timer(0) - start > MAX_RETRY_MS)
+			if (get_timer(0) - start > MMC_TIMEOUT_MS)
 				return;
 		}
 	}
@@ -281,14 +874,134 @@
 	}
 }
 
+#ifdef CONFIG_DM_MMC
+static int omap_hsmmc_adma_desc(struct mmc *mmc, char *buf, u16 len, bool end)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct omap_hsmmc_adma_desc *desc;
+	u8 attr;
+
+	desc = &priv->adma_desc_table[priv->desc_slot];
+
+	attr = ADMA_DESC_ATTR_VALID | ADMA_DESC_TRANSFER_DATA;
+	if (!end)
+		priv->desc_slot++;
+	else
+		attr |= ADMA_DESC_ATTR_END;
+
+	desc->len = len;
+	desc->addr = (u32)buf;
+	desc->reserved = 0;
+	desc->attr = attr;
+
+	return 0;
+}
+
+static int omap_hsmmc_prepare_adma_table(struct mmc *mmc, struct mmc_data *data)
+{
+	uint total_len = data->blocksize * data->blocks;
+	uint desc_count = DIV_ROUND_UP(total_len, ADMA_MAX_LEN);
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	int i = desc_count;
+	char *buf;
+
+	priv->desc_slot = 0;
+	priv->adma_desc_table = (struct omap_hsmmc_adma_desc *)
+				memalign(ARCH_DMA_MINALIGN, desc_count *
+				sizeof(struct omap_hsmmc_adma_desc));
+
+	if (data->flags & MMC_DATA_READ)
+		buf = data->dest;
+	else
+		buf = (char *)data->src;
+
+	while (--i) {
+		omap_hsmmc_adma_desc(mmc, buf, ADMA_MAX_LEN, false);
+		buf += ADMA_MAX_LEN;
+		total_len -= ADMA_MAX_LEN;
+	}
+
+	omap_hsmmc_adma_desc(mmc, buf, total_len, true);
+
+	flush_dcache_range((long)priv->adma_desc_table,
+			   (long)priv->adma_desc_table +
+			   ROUND(desc_count *
+			   sizeof(struct omap_hsmmc_adma_desc),
+			   ARCH_DMA_MINALIGN));
+	return 0;
+}
+
+static void omap_hsmmc_prepare_data(struct mmc *mmc, struct mmc_data *data)
+{
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 val;
+	char *buf;
+
+	mmc_base = priv->base_addr;
+	omap_hsmmc_prepare_adma_table(mmc, data);
+
+	if (data->flags & MMC_DATA_READ)
+		buf = data->dest;
+	else
+		buf = (char *)data->src;
+
+	val = readl(&mmc_base->hctl);
+	val |= DMA_SELECT;
+	writel(val, &mmc_base->hctl);
+
+	val = readl(&mmc_base->con);
+	val |= DMA_MASTER;
+	writel(val, &mmc_base->con);
+
+	writel((u32)priv->adma_desc_table, &mmc_base->admasal);
+
+	/* TODO: This shouldn't be required for read. However I don't seem
+	 * to get valid data without this.
+	 */
+	flush_dcache_range((u32)buf,
+			   (u32)buf +
+			   ROUND(data->blocksize * data->blocks,
+			   ARCH_DMA_MINALIGN));
+}
+
+static void omap_hsmmc_dma_cleanup(struct mmc *mmc)
+{
+	struct hsmmc *mmc_base;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	u32 val;
+
+	mmc_base = priv->base_addr;
+
+	val = readl(&mmc_base->con);
+	val &= ~DMA_MASTER;
+	writel(val, &mmc_base->con);
+
+	val = readl(&mmc_base->hctl);
+	val &= ~DMA_SELECT;
+	writel(val, &mmc_base->hctl);
+
+	kfree(priv->adma_desc_table);
+}
+#endif
+
 static int omap_hsmmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 			struct mmc_data *data)
 {
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	struct hsmmc *mmc_base;
 	unsigned int flags, mmc_stat;
 	ulong start;
 
-	mmc_base = ((struct omap_hsmmc_data *)mmc->priv)->base_addr;
+#ifdef CONFIG_DM_MMC
+	priv->last_cmd = cmd->cmdidx;
+#endif
+
+	mmc_base = priv->base_addr;
+
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		return 0;
+
 	start = get_timer(0);
 	while ((readl(&mmc_base->pstate) & (DATI_MASK | CMDI_MASK)) != 0) {
 		if (get_timer(0) - start > MAX_RETRY_MS) {
@@ -335,7 +1048,8 @@
 
 	/* enable default flags */
 	flags =	flags | (CMD_TYPE_NORMAL | CICE_NOCHECK | CCCE_NOCHECK |
-			MSBS_SGLEBLK | ACEN_DISABLE | BCE_DISABLE | DE_DISABLE);
+			MSBS_SGLEBLK);
+	flags &= ~(ACEN_ENABLE | BCE_ENABLE | DE_ENABLE);
 
 	if (cmd->resp_type & MMC_RSP_CRC)
 		flags |= CCCE_CHECK;
@@ -345,7 +1059,7 @@
 	if (data) {
 		if ((cmd->cmdidx == MMC_CMD_READ_MULTIPLE_BLOCK) ||
 			 (cmd->cmdidx == MMC_CMD_WRITE_MULTIPLE_BLOCK)) {
-			flags |= (MSBS_MULTIBLK | BCE_ENABLE);
+			flags |= (MSBS_MULTIBLK | BCE_ENABLE | ACEN_ENABLE);
 			data->blocksize = 512;
 			writel(data->blocksize | (data->blocks << 16),
 							&mmc_base->blk);
@@ -356,8 +1070,18 @@
 			flags |= (DP_DATA | DDIR_READ);
 		else
 			flags |= (DP_DATA | DDIR_WRITE);
+
+#ifdef CONFIG_DM_MMC
+		if ((priv->controller_flags & OMAP_HSMMC_USE_ADMA) &&
+		    cmd->cmdidx != MMC_SEND_TUNING_BLOCK_HS200) {
+			omap_hsmmc_prepare_data(mmc, data);
+			flags |= DE_ENABLE;
+		}
+#endif
 	}
 
+	mmc_enable_irq(mmc, cmd);
+
 	writel(cmd->cmdarg, &mmc_base->arg);
 	udelay(20);		/* To fix "No status update" error on eMMC */
 	writel((cmd->cmdidx << 24) | flags, &mmc_base->cmd);
@@ -392,11 +1116,37 @@
 		}
 	}
 
+#ifdef CONFIG_DM_MMC
+	if ((priv->controller_flags & OMAP_HSMMC_USE_ADMA) && data &&
+	    cmd->cmdidx != MMC_SEND_TUNING_BLOCK_HS200) {
+		if (mmc_stat & IE_ADMAE) {
+			omap_hsmmc_dma_cleanup(mmc);
+			return -1;
+		}
+
+		do {
+			mmc_stat = readl(&mmc_base->stat);
+			if (mmc_stat & TC_MASK) {
+				writel(readl(&mmc_base->stat) | TC_MASK,
+				       &mmc_base->stat);
+				break;
+			}
+		} while (1);
+
+		omap_hsmmc_dma_cleanup(mmc);
+
+		if ((mmc_stat & ERRI_MASK) != 0)
+			return 1;
+
+		return 0;
+	}
+#endif
+
 	if (data && (data->flags & MMC_DATA_READ)) {
-		mmc_read_data(mmc_base,	data->dest,
+		return mmc_read_data(mmc_base,	data->dest,
 				data->blocksize * data->blocks);
 	} else if (data && (data->flags & MMC_DATA_WRITE)) {
-		mmc_write_data(mmc_base, data->src,
+		return mmc_write_data(mmc_base, data->src,
 				data->blocksize * data->blocks);
 	}
 	return 0;
@@ -511,13 +1261,57 @@
 	return 0;
 }
 
-static void omap_hsmmc_set_ios(struct mmc *mmc)
+static void omap_hsmmc_stop_clock(struct hsmmc *mmc_base)
+{
+	writel(readl(&mmc_base->sysctl) & ~CEN_ENABLE, &mmc_base->sysctl);
+}
+
+static void omap_hsmmc_start_clock(struct hsmmc *mmc_base)
+{
+	writel(readl(&mmc_base->sysctl) | CEN_ENABLE, &mmc_base->sysctl);
+}
+
+static void omap_hsmmc_set_clock(struct mmc *mmc)
 {
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	struct hsmmc *mmc_base;
 	unsigned int dsor = 0;
 	ulong start;
 
-	mmc_base = ((struct omap_hsmmc_data *)mmc->priv)->base_addr;
+	mmc_base = priv->base_addr;
+	omap_hsmmc_stop_clock(mmc_base);
+
+	/* TODO: Is setting DTO required here? */
+	mmc_reg_out(&mmc_base->sysctl, (ICE_MASK | DTO_MASK),
+		    (ICE_STOP | DTO_15THDTO));
+
+	if (mmc->clock != 0) {
+		dsor = DIV_ROUND_UP(MMC_CLOCK_REFERENCE * 1000000, mmc->clock);
+		if (dsor > CLKD_MAX)
+			dsor = CLKD_MAX;
+	}
+
+	mmc_reg_out(&mmc_base->sysctl, ICE_MASK | CLKD_MASK,
+		    (dsor << CLKD_OFFSET) | ICE_OSCILLATE);
+
+	start = get_timer(0);
+	while ((readl(&mmc_base->sysctl) & ICS_MASK) == ICS_NOTREADY) {
+		if (get_timer(0) - start > MAX_RETRY_MS) {
+			printf("%s: timedout waiting for ics!\n", __func__);
+			return;
+		}
+	}
+
+	priv->clock = mmc->clock;
+	omap_hsmmc_start_clock(mmc_base);
+}
+
+static void omap_hsmmc_set_bus_width(struct mmc *mmc)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct hsmmc *mmc_base;
+
+	mmc_base = priv->base_addr;
 	/* configue bus width */
 	switch (mmc->bus_width) {
 	case 8:
@@ -541,35 +1335,41 @@
 		break;
 	}
 
-	/* configure clock with 96Mhz system clock.
-	 */
-	if (mmc->clock != 0) {
-		dsor = (MMC_CLOCK_REFERENCE * 1000000 / mmc->clock);
-		if ((MMC_CLOCK_REFERENCE * 1000000) / dsor > mmc->clock)
-			dsor++;
-	}
+	priv->bus_width = mmc->bus_width;
+}
+
+static int omap_hsmmc_set_ios(struct mmc *mmc)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct hsmmc *mmc_base = priv->base_addr;
+	int ret = 0;
+
+	if (priv->bus_width != mmc->bus_width)
+		omap_hsmmc_set_bus_width(mmc);
+
+	if (priv->clock != mmc->clock)
+		omap_hsmmc_set_clock(mmc);
 
-	mmc_reg_out(&mmc_base->sysctl, (ICE_MASK | DTO_MASK | CEN_MASK),
-				(ICE_STOP | DTO_15THDTO | CEN_DISABLE));
+	if (mmc->clk_disable)
+		omap_hsmmc_stop_clock(mmc_base);
+	else
+		omap_hsmmc_start_clock(mmc_base);
 
-	mmc_reg_out(&mmc_base->sysctl, ICE_MASK | CLKD_MASK,
-				(dsor << CLKD_OFFSET) | ICE_OSCILLATE);
+#if defined(CONFIG_DM_MMC) && defined(CONFIG_IODELAY_RECALIBRATION)
+	if (priv->timing != mmc->timing)
+		omap_hsmmc_set_timing(mmc);
+#endif
+	if (priv->signal_voltage != mmc->signal_voltage)
+		ret = omap_hsmmc_set_signal_voltage(mmc);
 
-	start = get_timer(0);
-	while ((readl(&mmc_base->sysctl) & ICS_MASK) == ICS_NOTREADY) {
-		if (get_timer(0) - start > MAX_RETRY_MS) {
-			printf("%s: timedout waiting for ics!\n", __func__);
-			return;
-		}
-	}
-	writel(readl(&mmc_base->sysctl) | CEN_ENABLE, &mmc_base->sysctl);
+	return ret;
 }
 
 #ifdef OMAP_HSMMC_USE_GPIO
 #ifdef CONFIG_DM_MMC
 static int omap_hsmmc_getcd(struct mmc *mmc)
 {
-	struct omap_hsmmc_data *priv = mmc->priv;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	int value;
 
 	value = dm_gpio_get_value(&priv->cd_gpio);
@@ -584,7 +1384,7 @@
 
 static int omap_hsmmc_getwp(struct mmc *mmc)
 {
-	struct omap_hsmmc_data *priv = mmc->priv;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	int value;
 
 	value = dm_gpio_get_value(&priv->wp_gpio);
@@ -596,11 +1396,11 @@
 #else
 static int omap_hsmmc_getcd(struct mmc *mmc)
 {
-	struct omap_hsmmc_data *priv_data = mmc->priv;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	int cd_gpio;
 
 	/* if no CD return as 1 */
-	cd_gpio = priv_data->cd_gpio;
+	cd_gpio = priv->cd_gpio;
 	if (cd_gpio < 0)
 		return 1;
 
@@ -610,11 +1410,11 @@
 
 static int omap_hsmmc_getwp(struct mmc *mmc)
 {
-	struct omap_hsmmc_data *priv_data = mmc->priv;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
 	int wp_gpio;
 
 	/* if no WP return as 0 */
-	wp_gpio = priv_data->wp_gpio;
+	wp_gpio = priv->wp_gpio;
 	if (wp_gpio < 0)
 		return 0;
 
@@ -632,6 +1432,13 @@
 	.getcd		= omap_hsmmc_getcd,
 	.getwp		= omap_hsmmc_getwp,
 #endif
+#ifdef CONFIG_DM_MMC
+	.execute_tuning = omap_hsmmc_execute_tuning,
+	.card_busy = omap_hsmmc_card_busy,
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+	.set_vdd	= omap_hsmmc_set_vdd,
+#endif
+#endif
 };
 
 #ifndef CONFIG_DM_MMC
@@ -639,23 +1446,23 @@
 		int wp_gpio)
 {
 	struct mmc *mmc;
-	struct omap_hsmmc_data *priv_data;
+	struct omap_hsmmc_data *priv;
 	struct mmc_config *cfg;
 	uint host_caps_val;
 
-	priv_data = malloc(sizeof(*priv_data));
-	if (priv_data == NULL)
+	priv = malloc(sizeof(*priv));
+	if (priv == NULL)
 		return -1;
 
 	host_caps_val = MMC_MODE_4BIT | MMC_MODE_HS_52MHz | MMC_MODE_HS;
 
 	switch (dev_index) {
 	case 0:
-		priv_data->base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE;
+		priv->base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE;
 		break;
 #ifdef OMAP_HSMMC2_BASE
 	case 1:
-		priv_data->base_addr = (struct hsmmc *)OMAP_HSMMC2_BASE;
+		priv->base_addr = (struct hsmmc *)OMAP_HSMMC2_BASE;
 #if (defined(CONFIG_OMAP44XX) || defined(CONFIG_OMAP54XX) || \
 	defined(CONFIG_DRA7XX) || defined(CONFIG_AM33XX) || \
 	defined(CONFIG_AM43XX) || defined(CONFIG_SOC_KEYSTONE)) && \
@@ -667,7 +1474,7 @@
 #endif
 #ifdef OMAP_HSMMC3_BASE
 	case 2:
-		priv_data->base_addr = (struct hsmmc *)OMAP_HSMMC3_BASE;
+		priv->base_addr = (struct hsmmc *)OMAP_HSMMC3_BASE;
 #if defined(CONFIG_DRA7XX) && defined(CONFIG_HSMMC3_8BIT)
 		/* Enable 8-bit interface for eMMC on DRA7XX */
 		host_caps_val |= MMC_MODE_8BIT;
@@ -675,16 +1482,16 @@
 		break;
 #endif
 	default:
-		priv_data->base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE;
+		priv->base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE;
 		return 1;
 	}
 #ifdef OMAP_HSMMC_USE_GPIO
 	/* on error gpio values are set to -1, which is what we want */
-	priv_data->cd_gpio = omap_mmc_setup_gpio_in(cd_gpio, "mmc_cd");
-	priv_data->wp_gpio = omap_mmc_setup_gpio_in(wp_gpio, "mmc_wp");
+	priv->cd_gpio = omap_mmc_setup_gpio_in(cd_gpio, "mmc_cd");
+	priv->wp_gpio = omap_mmc_setup_gpio_in(wp_gpio, "mmc_wp");
 #endif
 
-	cfg = &priv_data->cfg;
+	cfg = &priv->cfg;
 
 	cfg->name = "OMAP SD/MMC";
 	cfg->ops = &omap_hsmmc_ops;
@@ -715,47 +1522,332 @@
 	if ((get_cpu_family() == CPU_OMAP34XX) && (get_cpu_rev() <= CPU_3XX_ES21))
 		cfg->b_max = 1;
 #endif
-	mmc = mmc_create(cfg, priv_data);
+	mmc = mmc_create(cfg, priv);
 	if (mmc == NULL)
 		return -1;
 
 	return 0;
 }
 #else
+#ifdef CONFIG_IODELAY_RECALIBRATION
+#ifdef CONFIG_SPL_BUILD
+__weak struct omap_hsmmc_pinctrl_state *platform_fixup_get_pinctrl_by_mode
+				(struct hsmmc *base, const char *mode)
+{
+	static struct omap_hsmmc_pinctrl_state empty = {
+		.padconf = NULL,
+		.npads = 0,
+		.iodelay = NULL,
+		.niodelays = 0,
+	};
+	return &empty;
+}
+
+static struct omap_hsmmc_pinctrl_state *
+omap_hsmmc_get_pinctrl_by_mode(struct mmc *mmc, char *mode)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+
+	return platform_fixup_get_pinctrl_by_mode(priv->base_addr, mode);
+}
+#else
+static struct pad_conf_entry *
+omap_hsmmc_get_pad_conf_entry(const fdt32_t *pinctrl, int count)
+{
+	int index = 0;
+	struct pad_conf_entry *padconf;
+
+	padconf = (struct pad_conf_entry *)malloc(sizeof(*padconf) * count);
+	if (!padconf) {
+		printf("failed to allocate memory\n");
+		return 0;
+	}
+
+	while (index < count) {
+		padconf[index].offset = fdt32_to_cpu(*pinctrl++);
+		padconf[index].val = fdt32_to_cpu(*pinctrl++);
+		index++;
+	}
+
+	return padconf;
+}
+
+static struct iodelay_cfg_entry *
+omap_hsmmc_get_iodelay_cfg_entry(const fdt32_t *pinctrl, int count)
+{
+	int index = 0;
+	struct iodelay_cfg_entry *iodelay;
+
+	iodelay = (struct iodelay_cfg_entry *)malloc(sizeof(*iodelay) * count);
+	if (!iodelay) {
+		printf("failed to allocate memory\n");
+		return 0;
+	}
+
+	while (index < count) {
+		iodelay[index].offset = fdt32_to_cpu(*pinctrl++);
+		iodelay[index].a_delay = fdt32_to_cpu(*pinctrl++);
+		iodelay[index].g_delay = fdt32_to_cpu(*pinctrl++);
+		index++;
+	}
+
+	return iodelay;
+}
+
+static const fdt32_t *omap_hsmmc_get_pinctrl_entry(uint32_t phandle,
+						   const char *name, int *len)
+{
+	const void *fdt = gd->fdt_blob;
+	int offset;
+	const fdt32_t *pinctrl;
+
+	offset = fdt_node_offset_by_phandle(fdt, phandle);
+	if (offset < 0) {
+		printf("failed to get pinctrl node %s.\n",
+		       fdt_strerror(offset));
+		return 0;
+	}
+
+	pinctrl = fdt_getprop(fdt, offset, name, len);
+	if (!pinctrl) {
+		printf("failed to get property %s\n", name);
+		return 0;
+	}
+
+	return pinctrl;
+}
+
+static uint32_t omap_hsmmc_get_pad_conf_phandle(struct mmc *mmc,
+						char *prop_name)
+{
+	const void *fdt = gd->fdt_blob;
+	const __be32 *phandle;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	int node = priv->node;
+
+	phandle = fdt_getprop(fdt, node, prop_name, NULL);
+	if (!phandle) {
+		printf("failed to get property %s\n", prop_name);
+		return 0;
+	}
+
+	return fdt32_to_cpu(*phandle);
+}
+
+static uint32_t omap_hsmmc_get_iodelay_phandle(struct mmc *mmc,
+					       char *prop_name)
+{
+	const void *fdt = gd->fdt_blob;
+	const __be32 *phandle;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	int len;
+	int count;
+	int node = priv->node;
+
+	phandle = fdt_getprop(fdt, node, prop_name, &len);
+	if (!phandle) {
+		printf("failed to get property %s\n", prop_name);
+		return 0;
+	}
+
+	/* No manual mode iodelay values if count < 2 */
+	count = len / sizeof(*phandle);
+	if (count < 2)
+		return 0;
+
+	return fdt32_to_cpu(*(phandle + 1));
+}
+
+
+static struct pad_conf_entry *
+omap_hsmmc_get_pad_conf(struct mmc *mmc, char *prop_name, int *npads)
+{
+	int len;
+	int count;
+	struct pad_conf_entry *padconf;
+	uint32_t phandle;
+	const fdt32_t *pinctrl;
+
+	phandle = omap_hsmmc_get_pad_conf_phandle(mmc, prop_name);
+	if (!phandle)
+		return ERR_PTR(-EINVAL);
+
+	pinctrl = omap_hsmmc_get_pinctrl_entry(phandle, "pinctrl-single,pins",
+					       &len);
+	if (!pinctrl)
+		return ERR_PTR(-EINVAL);
+
+	count = (len / sizeof(*pinctrl)) / 2;
+	padconf = omap_hsmmc_get_pad_conf_entry(pinctrl, count);
+	if (!padconf)
+		return ERR_PTR(-EINVAL);
+
+	*npads = count;
+
+	return padconf;
+}
+
+static struct iodelay_cfg_entry *
+omap_hsmmc_get_iodelay(struct mmc *mmc, char *prop_name, int *niodelay)
+{
+	int len;
+	int count;
+	struct iodelay_cfg_entry *iodelay;
+	uint32_t phandle;
+	const fdt32_t *pinctrl;
+
+	phandle = omap_hsmmc_get_iodelay_phandle(mmc, prop_name);
+	/* Not all modes have manual mode iodelay values. So its not fatal */
+	if (!phandle)
+		return 0;
+
+	pinctrl = omap_hsmmc_get_pinctrl_entry(phandle, "pinctrl-pin-array",
+					       &len);
+	if (!pinctrl)
+		return ERR_PTR(-EINVAL);
+
+	count = (len / sizeof(*pinctrl)) / 3;
+	iodelay = omap_hsmmc_get_iodelay_cfg_entry(pinctrl, count);
+	if (!iodelay)
+		return ERR_PTR(-EINVAL);
+
+	*niodelay = count;
+
+	return iodelay;
+}
+
+static struct omap_hsmmc_pinctrl_state *
+omap_hsmmc_get_pinctrl_by_mode(struct mmc *mmc, char *mode)
+{
+	int index;
+	int npads = 0;
+	int niodelays = 0;
+	const void *fdt = gd->fdt_blob;
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	int node = priv->node;
+	char prop_name[11];
+	struct omap_hsmmc_pinctrl_state *pinctrl_state;
+
+	pinctrl_state = (struct omap_hsmmc_pinctrl_state *)
+			 malloc(sizeof(*pinctrl_state));
+	if (!pinctrl_state) {
+		printf("%s: failed to allocate memory\n",
+		       fdt_get_name(fdt, node, NULL));
+		return 0;
+	}
+
+	index = fdt_stringlist_search(fdt, node, "pinctrl-names", mode);
+	if (index < 0) {
+		debug("%s: fail to find %s mode %s\n",
+		      fdt_get_name(fdt, node, NULL),
+		      mode, fdt_strerror(index));
+		goto err_pinctrl_state;
+	}
+
+	sprintf(prop_name, "pinctrl-%d", index);
+
+	pinctrl_state->padconf = omap_hsmmc_get_pad_conf(mmc, prop_name,
+							 &npads);
+	if (IS_ERR(pinctrl_state->padconf))
+		goto err_pinctrl_state;
+	pinctrl_state->npads = npads;
+
+	pinctrl_state->iodelay = omap_hsmmc_get_iodelay(mmc, prop_name,
+							&niodelays);
+	if (IS_ERR(pinctrl_state->iodelay))
+		goto err_padconf;
+	pinctrl_state->niodelays = niodelays;
+
+	return pinctrl_state;
+
+err_padconf:
+	kfree(pinctrl_state->padconf);
+
+err_pinctrl_state:
+	kfree(pinctrl_state);
+	return 0;
+}
+#endif
+
+#define OMAP_HSMMC_SETUP_PINCTRL(capmask, mode)				\
+	do {								\
+		struct omap_hsmmc_pinctrl_state *s = NULL;		\
+		char str[20];						\
+		if (!(cfg->host_caps & capmask))			\
+			break;						\
+									\
+		if (priv->version) {					\
+			sprintf(str, "%s-%s", #mode, priv->version);	\
+			s = omap_hsmmc_get_pinctrl_by_mode(mmc, str);	\
+		}							\
+									\
+		if (!s)							\
+			s = omap_hsmmc_get_pinctrl_by_mode(mmc, #mode);	\
+									\
+		if (!s) {						\
+			debug("no pinctrl for %s\n", #mode);		\
+			cfg->host_caps &= ~(capmask);			\
+		} else {						\
+			priv->mode##_pinctrl_state = s;			\
+		}							\
+	} while (0)
+
+static int omap_hsmmc_get_pinctrl_state(struct mmc *mmc)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct mmc_config *cfg = omap_hsmmc_get_cfg(mmc);
+
+	struct omap_hsmmc_pinctrl_state *default_pinctrl;
+
+	if (!(priv->controller_flags & OMAP_HSMMC_REQUIRE_IODELAY))
+		return 0;
+
+	default_pinctrl = omap_hsmmc_get_pinctrl_by_mode(mmc, "default");
+	if (!default_pinctrl) {
+		debug("no pinctrl state for default mode\n");
+		return -EINVAL;
+	}
+
+	priv->default_pinctrl_state = default_pinctrl;
+
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_HS200, hs200_1_8v);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_DDR_52MHz, ddr_1_8v);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_HS, hs);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_UHS_SDR104, sdr104);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_UHS_DDR50, ddr50);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_UHS_SDR50, sdr50);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_UHS_SDR25, sdr25);
+	OMAP_HSMMC_SETUP_PINCTRL(MMC_MODE_UHS_SDR12, sdr12);
+
+	return 0;
+}
+#endif
+
 static int omap_hsmmc_ofdata_to_platdata(struct udevice *dev)
 {
 	struct omap_hsmmc_data *priv = dev_get_priv(dev);
+	struct omap_hsmmc_plat *plat = dev_get_platdata(dev);
+	struct mmc_config *cfg = &plat->cfg;
 	const void *fdt = gd->fdt_blob;
 	int node = dev->of_offset;
-	struct mmc_config *cfg;
-	int val;
+	int ret;
 
 	priv->base_addr = map_physmem(dev_get_addr(dev), sizeof(struct hsmmc *),
 				      MAP_NOCACHE);
-	cfg = &priv->cfg;
+	priv->node = node;
 
-	cfg->host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS;
-	val = fdtdec_get_int(fdt, node, "bus-width", -1);
-	if (val < 0) {
-		printf("error: bus-width property missing\n");
-		return -ENOENT;
-	}
+	ret = mmc_of_parse(fdt, node, cfg);
+	if (ret < 0)
+		return ret;
 
-	switch (val) {
-	case 0x8:
-		cfg->host_caps |= MMC_MODE_8BIT;
-	case 0x4:
-		cfg->host_caps |= MMC_MODE_4BIT;
-		break;
-	default:
-		printf("error: invalid bus-width property\n");
-		return -ENOENT;
-	}
-
+	cfg->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
 	cfg->f_min = 400000;
-	cfg->f_max = fdtdec_get_int(fdt, node, "max-frequency", 52000000);
 	cfg->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
 	cfg->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+	if (fdtdec_get_bool(fdt, node, "ti,dual-volt"))
+		priv->controller_flags |= OMAP_HSMMC_SUPPORTS_DUAL_VOLT;
+	if (fdtdec_get_bool(fdt, node, "no-1-8-v"))
+		priv->controller_flags |= OMAP_HSMMC_NO_1_8_V;
 
 #ifdef OMAP_HSMMC_USE_GPIO
 	priv->cd_inverted = fdtdec_get_bool(fdt, node, "cd-inverted");
@@ -764,36 +1856,102 @@
 	return 0;
 }
 
+__weak int platform_fixup_disable_uhs_mode(void)
+{
+	return 0;
+}
+
+static int omap_hsmmc_platform_fixup(struct mmc *mmc)
+{
+	struct omap_hsmmc_data *priv = omap_hsmmc_get_data(mmc);
+	struct mmc_config *cfg = omap_hsmmc_get_cfg(mmc);
+
+	priv->version = NULL;
+
+	if (platform_fixup_disable_uhs_mode()) {
+		priv->version = "rev11";
+		cfg->host_caps &= ~(MMC_MODE_HS200 | MMC_MODE_UHS_SDR104
+				    | MMC_MODE_UHS_SDR50);
+	}
+
+	return 0;
+}
+
 static int omap_hsmmc_probe(struct udevice *dev)
 {
+	struct omap_hsmmc_plat *plat = dev_get_platdata(dev);
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
 	struct omap_hsmmc_data *priv = dev_get_priv(dev);
-	struct mmc_config *cfg;
+	struct mmc_config *cfg = &plat->cfg;
 	struct mmc *mmc;
+#ifdef CONFIG_IODELAY_RECALIBRATION
+	int ret;
+	struct omap_mmc_of_data *data;
+#endif
 
-	cfg = &priv->cfg;
 	cfg->name = "OMAP SD/MMC";
 	cfg->ops = &omap_hsmmc_ops;
 
+#ifdef CONFIG_BLK
+	mmc = &plat->mmc;
+#else
 	mmc = mmc_create(cfg, priv);
 	if (mmc == NULL)
 		return -1;
+#endif
+
+	mmc->dev = dev;
+	omap_hsmmc_platform_fixup(mmc);
 
+#if CONFIG_IS_ENABLED(DM_REGULATOR) && defined(CONFIG_DM_MMC)
+	device_get_supply_regulator(dev, "vmmc-supply", &priv->vmmc_supply);
+	device_get_supply_regulator(dev, "vmmc_aux-supply",
+				    &priv->vmmc_aux_supply);
+#endif
 #ifdef OMAP_HSMMC_USE_GPIO
 	gpio_request_by_name(dev, "cd-gpios", 0, &priv->cd_gpio, GPIOD_IS_IN);
 	gpio_request_by_name(dev, "wp-gpios", 0, &priv->wp_gpio, GPIOD_IS_IN);
 #endif
 
-	mmc->dev = dev;
+#ifdef CONFIG_IODELAY_RECALIBRATION
+	data  = (struct omap_mmc_of_data *)dev_get_driver_data(dev);
+	if (data && data->controller_flags & OMAP_HSMMC_REQUIRE_IODELAY)
+		priv->controller_flags |= OMAP_HSMMC_REQUIRE_IODELAY;
+
+	ret = omap_hsmmc_get_pinctrl_state(mmc);
+	if (ret < 0) {
+		priv->controller_flags &= ~OMAP_HSMMC_REQUIRE_IODELAY;
+		cfg->host_caps &= ~(MMC_MODE_UHS_SDR12 | MMC_MODE_UHS_SDR25
+				    | MMC_MODE_UHS_SDR50 | MMC_MODE_UHS_SDR104
+				    | MMC_MODE_UHS_DDR50 | MMC_MODE_DDR_52MHz
+				    | MMC_MODE_HS200);
+	}
+#endif
+
 	upriv->mmc = mmc;
 
 	return 0;
 }
 
+#ifdef CONFIG_BLK
+static int omap_hsmmc_bind(struct udevice *dev)
+{
+	struct omap_hsmmc_plat *plat = dev_get_platdata(dev);
+
+	return mmc_bind(dev, &plat->mmc, &plat->cfg);
+}
+#endif
+
+static const struct omap_mmc_of_data dra7_mmc_of_data = {
+	.controller_flags = OMAP_HSMMC_REQUIRE_IODELAY,
+};
+
+
 static const struct udevice_id omap_hsmmc_ids[] = {
 	{ .compatible = "ti,omap3-hsmmc" },
 	{ .compatible = "ti,omap4-hsmmc" },
 	{ .compatible = "ti,am33xx-hsmmc" },
+	{ .compatible = "ti,dra7-hsmmc", .data = (ulong)&dra7_mmc_of_data },
 	{ }
 };
 
@@ -802,7 +1960,11 @@
 	.id	= UCLASS_MMC,
 	.of_match = omap_hsmmc_ids,
 	.ofdata_to_platdata = omap_hsmmc_ofdata_to_platdata,
+#ifdef CONFIG_BLK
+	.bind = omap_hsmmc_bind,
+#endif
 	.probe	= omap_hsmmc_probe,
 	.priv_auto_alloc_size = sizeof(struct omap_hsmmc_data),
+	.platdata_auto_alloc_size = sizeof(struct omap_hsmmc_plat),
 };
 #endif
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2g-ice.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2g-ice.dts	1969-12-31 19:31:37.000000936 -0600
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2017 Texas Instruments, Inc.
+ *
+ * K2G Industrial Communication Engine EVM device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone-k2g.dtsi"
+#include <dt-bindings/net/ti-dp83867.h>
+
+/ {
+	compatible = "ti,k2g-ice", "ti,k2g", "ti,keystone";
+	model = "Texas Instruments K2G Industrial Communication EVM";
+
+	chosen {
+		stdout-path = &uart0;
+	};
+};
+
+&mmc1 {
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+
+	flash0: m25p80@0 {
+		compatible = "s25fl256s1","spi-flash";
+		reg = <0>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <96000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		tshsl-ns = <392>;
+		tsd2d-ns = <392>;
+		tchsh-ns = <100>;
+		tslch-ns = <100>;
+		block-size = <16>;
+
+		partition@0 {
+			label = "QSPI.u-boot";
+			reg = <0x00000000 0x00100000>;
+		};
+		partition@1 {
+			label = "QSPI.u-boot-env";
+			reg = <0x00100000 0x00040000>;
+		};
+		partition@2 {
+			label = "QSPI.skern";
+			reg = <0x00140000 0x0040000>;
+		};
+		partition@3 {
+			label = "QSPI.pmmc-firmware";
+			reg = <0x00180000 0x0040000>;
+		};
+		partition@4 {
+			label = "QSPI.kernel";
+			reg = <0x001c0000 0x0800000>;
+		};
+		partition@5 {
+			label = "QSPI.u-boot-spl-os";
+			reg = <0x009c0000 0x0040000>;
+		};
+		partition@6 {
+			label = "QSPI.file-system";
+			reg = <0x00a00000 0x1600000>;
+		};
+	};
+};
+
+&netcp {
+	status = "okay";
+};
+
+&mdio {
+	status = "okay";
+	ethphy0: ethernet-phy@0 {
+		reg = <0>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		ti,min-output-impedance;
+		ti,dp83867-rxctrl-strap-quirk;
+	};
+};
+
+&gbe0 {
+	phy-handle = <&ethphy0>;
+	phy-mode = "rgmii-id";
+};
diff -u -N U-Boot_SDcard/fs/fat/fat.c U-Boot_SDcard/fs/fat/fat.c
--- U-Boot_SDcard/fs/fat/fat.c	2019-09-12 15:54:26.000000130 -0500
+++ U-Boot_SDcard/fs/fat/fat.c	1969-12-31 19:29:21.000000813 -0600
@@ -278,7 +278,7 @@
 	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
 		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
 
-		printf("FAT: Misaligned buffer address (%p)\n", buffer);
+		debug("FAT: misaligned buffer address (%p)\n", buffer);
 
 		while (size >= mydata->sect_size) {
 			ret = disk_read(startsect++, 1, tmpbuf);
diff -u -N U-Boot_SDcard/board/ti/am57xx/board.c U-Boot_SDcard/board/ti/am57xx/board.c
--- U-Boot_SDcard/board/ti/am57xx/board.c	2019-09-12 15:54:14.000000890 -0500
+++ U-Boot_SDcard/board/ti/am57xx/board.c	1969-12-31 19:29:27.000000175 -0600
@@ -41,7 +41,7 @@
 #define board_is_am572x_evm_reva3()	\
 				(board_ti_is("AM572PM_") && \
 				 (strncmp("A.30", board_ti_get_rev(), 3) <= 0))
-#define board_is_am572x_idk()	board_ti_is("AM572IDK")
+#define board_is_am572x_idk()	1 /*board_ti_is("AM572IDK")*/
 #define board_is_am571x_idk()	board_ti_is("AM571IDK")
 
 #ifdef CONFIG_DRIVER_TI_CPSW
@@ -50,9 +50,23 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define GPIO_ETH_LCD		GPIO_TO_PIN(2, 22)
 /* GPIO 7_11 */
 #define GPIO_DDR_VTT_EN 203
 
+/* Touch screen controller to identify the LCD */
+#define OSD_TS_FT_BUS_ADDRESS	0
+#define OSD_TS_FT_CHIP_ADDRESS	0x38
+#define OSD_TS_FT_REG_ID	0xA3
+/*
+ * Touchscreen IDs for various OSD panels
+ * Ref: http://www.osddisplays.com/TI/OSD101T2587-53TS_A.1.pdf
+ */
+/* Used on newer osd101t2587 Panels */
+#define OSD_TS_FT_ID_5x46	0x54
+/* Used on older osd101t2045 Panels */
+#define OSD_TS_FT_ID_5606	0x08
+
 #define SYSINFO_BOARD_NAME_MAX_LEN	45
 
 #define TPS65903X_PRIMARY_SECONDARY_PAD2	0xFB
@@ -207,11 +221,39 @@
 	0x0
 };
 
+static const struct emif_regs am571x_emif1_ddr3_666mhz_emif_regs = {
+	.sdram_config_init		= 0x61863332,
+	.sdram_config			= 0x61863332,
+	.sdram_config2			= 0x08000000,
+	.ref_ctrl			= 0x0000514d,
+	.ref_ctrl_final			= 0x0000144a,
+	.sdram_tim1			= 0xd333887c,
+	.sdram_tim2			= 0x40b37fe3,
+	.sdram_tim3			= 0x409f8ada,
+	.read_idle_ctrl			= 0x00050000,
+	.zq_config			= 0x5007190b,
+	.temp_alert_config		= 0x00000000,
+	.emif_ddr_phy_ctlr_1_init	= 0x0024400f,
+	.emif_ddr_phy_ctlr_1		= 0x0e24400f,
+	.emif_ddr_ext_phy_ctrl_1	= 0x10040100,
+	.emif_ddr_ext_phy_ctrl_2	= 0x00910091,
+	.emif_ddr_ext_phy_ctrl_3	= 0x00950095,
+	.emif_ddr_ext_phy_ctrl_4	= 0x009b009b,
+	.emif_ddr_ext_phy_ctrl_5	= 0x009e009e,
+	.emif_rd_wr_lvl_rmp_win		= 0x00000000,
+	.emif_rd_wr_lvl_rmp_ctl		= 0x80000000,
+	.emif_rd_wr_lvl_ctl		= 0x00000000,
+	.emif_rd_wr_exec_thresh		= 0x00000305
+};
+
 void emif_get_reg_dump(u32 emif_nr, const struct emif_regs **regs)
 {
 	switch (emif_nr) {
 	case 1:
-		*regs = &beagle_x15_emif1_ddr3_532mhz_emif_regs;
+		if (board_is_am571x_idk())
+			*regs = &am571x_emif1_ddr3_666mhz_emif_regs;
+		else
+			*regs = &beagle_x15_emif1_ddr3_532mhz_emif_regs;
 		break;
 	case 2:
 		*regs = &beagle_x15_emif2_ddr3_532mhz_emif_regs;
@@ -329,6 +371,54 @@
 	.iva.abb_tx_done_mask	= OMAP_ABB_IVA_TXDONE_MASK,
 };
 
+struct vcores_data am571x_idk_volts = {
+	.mpu.value[OPP_NOM]	= VDD_MPU_DRA7_NOM,
+	.mpu.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_MPU_NOM,
+	.mpu.efuse.reg_bits     = DRA752_EFUSE_REGBITS,
+	.mpu.addr		= TPS659038_REG_ADDR_SMPS12,
+	.mpu.pmic		= &tps659038,
+	.mpu.abb_tx_done_mask = OMAP_ABB_MPU_TXDONE_MASK,
+
+	.eve.value[OPP_NOM]	= VDD_EVE_DRA7_NOM,
+	.eve.value[OPP_OD]	= VDD_EVE_DRA7_OD,
+	.eve.value[OPP_HIGH]	= VDD_EVE_DRA7_HIGH,
+	.eve.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_DSPEVE_NOM,
+	.eve.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_DSPEVE_OD,
+	.eve.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_DSPEVE_HIGH,
+	.eve.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.eve.addr		= TPS659038_REG_ADDR_SMPS45,
+	.eve.pmic		= &tps659038,
+	.eve.abb_tx_done_mask	= OMAP_ABB_EVE_TXDONE_MASK,
+
+	.gpu.value[OPP_NOM]	= VDD_GPU_DRA7_NOM,
+	.gpu.value[OPP_OD]	= VDD_GPU_DRA7_OD,
+	.gpu.value[OPP_HIGH]	= VDD_GPU_DRA7_HIGH,
+	.gpu.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_GPU_NOM,
+	.gpu.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_GPU_OD,
+	.gpu.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_GPU_HIGH,
+	.gpu.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.gpu.addr		= TPS659038_REG_ADDR_SMPS6,
+	.gpu.pmic		= &tps659038,
+	.gpu.abb_tx_done_mask	= OMAP_ABB_GPU_TXDONE_MASK,
+
+	.core.value[OPP_NOM]	= VDD_CORE_DRA7_NOM,
+	.core.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_CORE_NOM,
+	.core.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.core.addr		= TPS659038_REG_ADDR_SMPS7,
+	.core.pmic		= &tps659038,
+
+	.iva.value[OPP_NOM]	= VDD_IVA_DRA7_NOM,
+	.iva.value[OPP_OD]	= VDD_IVA_DRA7_OD,
+	.iva.value[OPP_HIGH]	= VDD_IVA_DRA7_HIGH,
+	.iva.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_IVA_NOM,
+	.iva.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_IVA_OD,
+	.iva.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_IVA_HIGH,
+	.iva.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.iva.addr		= TPS659038_REG_ADDR_SMPS45,
+	.iva.pmic		= &tps659038,
+	.iva.abb_tx_done_mask	= OMAP_ABB_IVA_TXDONE_MASK,
+};
+
 int get_voltrail_opp(int rail_offset)
 {
 	int opp;
@@ -438,6 +528,8 @@
 {
 	if (board_is_am572x_idk())
 		*omap_vcores = &am572x_idk_volts;
+	else if (board_is_am571x_idk())
+		*omap_vcores = &am571x_idk_volts;
 	else
 		*omap_vcores = &beagle_x15_volts;
 }
@@ -445,10 +537,28 @@
 void hw_data_init(void)
 {
 	*prcm = &dra7xx_prcm;
-	*dplls_data = &dra7xx_dplls;
+	if (is_dra72x())
+		*dplls_data = &dra72x_dplls;
+	else
+		*dplls_data = &dra7xx_dplls;
 	*ctrl = &dra7xx_ctrl;
 }
 
+bool am571x_idk_needs_lcd(void)
+{
+	bool needs_lcd;
+
+	gpio_request(GPIO_ETH_LCD, "nLCD_Detect");
+	if (gpio_get_value(GPIO_ETH_LCD))
+		needs_lcd = false;
+	else
+		needs_lcd = true;
+
+	gpio_free(GPIO_ETH_LCD);
+
+	return needs_lcd;
+}
+
 int board_init(void)
 {
 	gpmc_init();
@@ -457,6 +567,62 @@
 	return 0;
 }
 
+void am57x_idk_lcd_detect(void)
+{
+	int r = -ENODEV;
+	char *idk_lcd = "no";
+	uint8_t buf = 0;
+
+	/* Only valid for IDKs */
+	if (board_is_x15() || board_is_am572x_evm())
+		return;
+
+	/* Only AM571x IDK has gpio control detect.. so check that */
+	if (board_is_am571x_idk() && !am571x_idk_needs_lcd())
+		goto out;
+
+	r = i2c_set_bus_num(OSD_TS_FT_BUS_ADDRESS);
+	if (r) {
+		printf("%s: Failed to set bus address to %d: %d\n",
+		       __func__, OSD_TS_FT_BUS_ADDRESS, r);
+		goto out;
+	}
+	r = i2c_probe(OSD_TS_FT_CHIP_ADDRESS);
+	if (r) {
+		/* AM572x IDK has no explicit settings for optional LCD kit */
+		if (board_is_am571x_idk()) {
+			printf("%s: Touch screen detect failed: %d!\n",
+			       __func__, r);
+		}
+		goto out;
+	}
+
+	/* Read FT ID */
+	r = i2c_read(OSD_TS_FT_CHIP_ADDRESS, OSD_TS_FT_REG_ID, 1, &buf, 1);
+	if (r) {
+		printf("%s: Touch screen ID read %d:0x%02x[0x%02x] failed:%d\n",
+		       __func__, OSD_TS_FT_BUS_ADDRESS, OSD_TS_FT_CHIP_ADDRESS,
+		       OSD_TS_FT_REG_ID, r);
+		goto out;
+	}
+
+	switch (buf) {
+	case OSD_TS_FT_ID_5606:
+		idk_lcd = "osd101t2045";
+		break;
+	case OSD_TS_FT_ID_5x46:
+		idk_lcd = "osd101t2587";
+		break;
+	default:
+		printf("%s: Unidentifed Touch screen ID 0x%02x\n",
+		       __func__, buf);
+		/* we will let default be "no lcd" */
+	}
+out:
+	setenv("idk_lcd", idk_lcd);
+	return;
+}
+
 int board_late_init(void)
 {
 	setup_board_eeprom_env();
@@ -487,6 +653,12 @@
 	palmas_i2c_write_u8(TPS65903X_CHIP_P1, TPS65903X_PRIMARY_SECONDARY_PAD2,
 			    val);
 
+	am57x_idk_lcd_detect();
+
+#if !defined(CONFIG_SPL_BUILD)
+	board_ti_set_ethaddr(2);
+#endif
+
 	return 0;
 }
 
@@ -500,8 +672,8 @@
 void recalibrate_iodelay(void)
 {
 	const struct pad_conf_entry *pconf;
-	const struct iodelay_cfg_entry *iod;
-	int pconf_sz, iod_sz;
+	const struct iodelay_cfg_entry *iod, *delta_iod;
+	int pconf_sz, iod_sz, delta_iod_sz = 0;
 	int ret;
 
 	if (board_is_am572x_idk()) {
@@ -549,15 +721,33 @@
 		do_set_mux32((*ctrl)->control_padconf_core_base, pconf, pconf_sz);
 	}
 
+	if (board_is_am571x_idk()) {
+		if (am571x_idk_needs_lcd()) {
+			pconf = core_padconf_array_vout_am571x_idk;
+			pconf_sz = ARRAY_SIZE(core_padconf_array_vout_am571x_idk);
+			delta_iod = iodelay_cfg_array_am571x_idk_4port;
+			delta_iod_sz = ARRAY_SIZE(iodelay_cfg_array_am571x_idk_4port);
+
+		} else {
+			pconf = core_padconf_array_icss1eth_am571x_idk;
+			pconf_sz = ARRAY_SIZE(core_padconf_array_icss1eth_am571x_idk);
+		}
+		do_set_mux32((*ctrl)->control_padconf_core_base, pconf, pconf_sz);
+	}
+
 	/* Setup IOdelay configuration */
 	ret = do_set_iodelay((*ctrl)->iodelay_config_base, iod, iod_sz);
+	if (delta_iod_sz)
+		ret = do_set_iodelay((*ctrl)->iodelay_config_base, delta_iod,
+				     delta_iod_sz);
+
 err:
 	/* Closeup.. remove isolation */
 	__recalibrate_iodelay_end(ret);
 }
 #endif
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(0, 0, 0, -1, -1);
@@ -566,6 +756,74 @@
 }
 #endif
 
+#if defined(CONFIG_IODELAY_RECALIBRATION) && \
+	(defined(CONFIG_SPL_BUILD) || !defined(CONFIG_DM_MMC))
+
+struct pinctrl_desc {
+	const char *name;
+	struct omap_hsmmc_pinctrl_state *pinctrl;
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc1[] = {
+	{"default", &hsmmc1_default},
+	{"hs", &hsmmc1_default},
+	{NULL}
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc2_am572[] = {
+	{"default", &hsmmc2_default_hs},
+	{"hs", &hsmmc2_default_hs},
+	{"ddr_1_8v", &hsmmc2_ddr_am572},
+	{NULL}
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc2_am571[] = {
+	{"default", &hsmmc2_default_hs},
+	{"hs", &hsmmc2_default_hs},
+	{"ddr_1_8v", &hsmmc2_ddr_am571},
+	{NULL}
+};
+
+struct omap_hsmmc_pinctrl_state *platform_fixup_get_pinctrl_by_mode
+				  (struct hsmmc *base, const char *mode)
+{
+	struct pinctrl_desc *p = NULL;
+
+	switch ((u32)&base->res1) {
+	case OMAP_HSMMC1_BASE:
+		p = pinctrl_descs_hsmmc1;
+		break;
+	case OMAP_HSMMC2_BASE:
+		if (is_dra72x())
+			p = pinctrl_descs_hsmmc2_am571;
+		else
+			p = pinctrl_descs_hsmmc2_am572;
+		break;
+	default:
+		break;
+	}
+
+	if (!p) {
+		printf("%s no pinctrl defined for MMC@%p\n", __func__,
+		       base);
+		return NULL;
+	}
+	while (p->name) {
+		if (strcmp(mode, p->name) == 0)
+			return p->pinctrl;
+		p++;
+	}
+	return NULL;
+}
+#endif
+
+#ifdef CONFIG_OMAP_HSMMC
+int platform_fixup_disable_uhs_mode(void)
+{
+	return omap_revision() == DRA752_ES1_1;
+}
+#endif
+
 #if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_OS_BOOT)
 int spl_start_uboot(void)
 {
@@ -868,9 +1126,13 @@
 		} else if (!strcmp(name, "am57xx-beagle-x15")) {
 			return 0;
 		}
-	} else if (board_is_am572x_evm() &&
-		   !strcmp(name, "am57xx-beagle-x15")) {
-		return 0;
+	} else if (board_is_am572x_evm()) {
+		if (board_is_am572x_evm_reva3()) {
+			if (!strcmp(name, "am57xx-evm-reva3"))
+				return 0;
+		} else if (!strcmp(name, "am57xx-beagle-x15")) {
+			return 0;
+		}
 	} else if (board_is_am572x_idk() && !strcmp(name, "am572x-idk")) {
 		return 0;
 	} else if (board_is_am571x_idk() && !strcmp(name, "am571x-idk")) {
diff -u -N U-Boot_SDcard/drivers/mmc/mxcmmc.c U-Boot_SDcard/drivers/mmc/mxcmmc.c
--- U-Boot_SDcard/drivers/mmc/mxcmmc.c	2019-09-12 15:54:32.000000258 -0500
+++ U-Boot_SDcard/drivers/mmc/mxcmmc.c	1969-12-31 19:29:21.000000201 -0600
@@ -448,7 +448,7 @@
 	writel((prescaler << 4) | divider, &host->base->clk_rate);
 }
 
-static void mxcmci_set_ios(struct mmc *mmc)
+static int mxcmci_set_ios(struct mmc *mmc)
 {
 	struct mxcmci_host *host = mmc->priv;
 	if (mmc->bus_width == 4)
@@ -464,6 +464,8 @@
 	}
 
 	host->clock = mmc->clock;
+
+	return 0;
 }
 
 static int mxcmci_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c
--- U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c	2019-09-12 15:55:00.000000508 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/ddr3_k2g.c	1969-12-31 19:29:27.000000211 -0600
@@ -10,7 +10,9 @@
 #include <common.h>
 #include "ddr3_cfg.h"
 #include <asm/arch/ddr3.h>
+#include "board.h"
 
+/* K2G GP EVM DDR3 Configuration */
 struct ddr3_phy_config ddr3phy_800_2g = {
 	.pllcr          = 0x000DC000ul,
 	.pgcr1_mask     = (IODDRM_MASK | ZCKSEL_MASK),
@@ -27,13 +29,27 @@
 	.dtpr2          = 0x50022A00ul,
 	.mr0            = 0x00001430ul,
 	.mr1            = 0x00000006ul,
-	.mr2            = 0x00000018ul,
+	.mr2            = 0x00000000ul,
 	.dtcr           = 0x710035C7ul,
 	.pgcr2          = 0x00F03D09ul,
 	.zq0cr1         = 0x0001005Dul,
 	.zq1cr1         = 0x0001005Bul,
 	.zq2cr1         = 0x0001005Bul,
 	.pir_v1         = 0x00000033ul,
+	.datx8_2_mask	= 0,
+	.datx8_2_val	= 0,
+	.datx8_3_mask	= 0,
+	.datx8_3_val	= 0,
+	.datx8_4_mask	= 0,
+	.datx8_4_val	= ((1 << 0)),
+	.datx8_5_mask	= DXEN_MASK,
+	.datx8_5_val	= 0,
+	.datx8_6_mask	= DXEN_MASK,
+	.datx8_6_val	= 0,
+	.datx8_7_mask	= DXEN_MASK,
+	.datx8_7_val	= 0,
+	.datx8_8_mask	= DXEN_MASK,
+	.datx8_8_val	= 0,
 	.pir_v2         = 0x00000F81ul,
 };
 
@@ -47,13 +63,69 @@
 	.sdrfc          = 0x00000C34ul,
 };
 
+/* K2G ICE evm DDR3 Configuration */
+struct ddr3_phy_config ddr3phy_800_512mb = {
+	.pllcr          = 0x000DC000ul,
+	.pgcr1_mask     = (IODDRM_MASK | ZCKSEL_MASK),
+	.pgcr1_val      = ((1 << 2) | (2 << 7) | (1 << 23)),
+	.ptr0           = 0x42C21590ul,
+	.ptr1           = 0xD05612C0ul,
+	.ptr2           = 0,
+	.ptr3           = 0x06C30D40ul,
+	.ptr4           = 0x06413880ul,
+	.dcr_mask       = (PDQ_MASK | MPRDQ_MASK | BYTEMASK_MASK),
+	.dcr_val        = ((1 << 10)),
+	.dtpr0          = 0x550E6644ul,
+	.dtpr1          = 0x32834200ul,
+	.dtpr2          = 0x50022A00ul,
+	.mr0            = 0x00001430ul,
+	.mr1            = 0x00000006ul,
+	.mr2            = 0x00000008ul,
+	.dtcr           = 0x710035C7ul,
+	.pgcr2          = 0x00F03D09ul,
+	.zq0cr1         = 0x0001005Dul,
+	.zq1cr1         = 0x0001005Bul,
+	.zq2cr1         = 0x0001005Bul,
+	.pir_v1         = 0x00000033ul,
+	.datx8_2_mask	= DXEN_MASK,
+	.datx8_2_val	= 0,
+	.datx8_3_mask	= DXEN_MASK,
+	.datx8_3_val	= 0,
+	.datx8_4_mask	= DXEN_MASK,
+	.datx8_4_val	= 0,
+	.datx8_5_mask	= DXEN_MASK,
+	.datx8_5_val	= 0,
+	.datx8_6_mask	= DXEN_MASK,
+	.datx8_6_val	= 0,
+	.datx8_7_mask	= DXEN_MASK,
+	.datx8_7_val	= 0,
+	.datx8_8_mask	= DXEN_MASK,
+	.datx8_8_val	= 0,
+	.pir_v2         = 0x00000F81ul,
+};
+
+struct ddr3_emif_config ddr3_800_512mb = {
+	.sdcfg          = 0x62006662ul,
+	.sdtim1         = 0x0A385033ul,
+	.sdtim2         = 0x00001CA5ul,
+	.sdtim3         = 0x21ADFF32ul,
+	.sdtim4         = 0x533F067Ful,
+	.zqcfg          = 0x70073200ul,
+	.sdrfc          = 0x00000C34ul,
+};
+
 u32 ddr3_init(void)
 {
 	/* Reset DDR3 PHY after PLL enabled */
 	ddr3_reset_ddrphy();
 
-	ddr3_init_ddrphy(KS2_DDR3A_DDRPHYC, &ddr3phy_800_2g);
-	ddr3_init_ddremif(KS2_DDR3A_EMIF_CTRL_BASE, &ddr3_800_2g);
+	if (board_is_k2g_gp()) {
+		ddr3_init_ddrphy(KS2_DDR3A_DDRPHYC, &ddr3phy_800_2g);
+		ddr3_init_ddremif(KS2_DDR3A_EMIF_CTRL_BASE, &ddr3_800_2g);
+	} else if (board_is_k2g_ice()) {
+		ddr3_init_ddrphy(KS2_DDR3A_DDRPHYC, &ddr3phy_800_512mb);
+		ddr3_init_ddremif(KS2_DDR3A_EMIF_CTRL_BASE, &ddr3_800_512mb);
+	}
 
 	return 0;
 }
diff -u -N U-Boot_SDcard/include/configs/am57xx_evm.h U-Boot_SDcard/include/configs/am57xx_evm.h
--- U-Boot_SDcard/include/configs/am57xx_evm.h	2019-09-12 15:54:21.000000734 -0500
+++ U-Boot_SDcard/include/configs/am57xx_evm.h	1969-12-31 19:29:22.000000040 -0600
@@ -16,9 +16,7 @@
 
 #define CONFIG_DRA7XX
 
-#ifdef CONFIG_SPL_BUILD
 #define CONFIG_IODELAY_RECALIBRATION
-#endif
 
 #define CONFIG_BOARD_EARLY_INIT_F
 
@@ -47,8 +45,8 @@
 	"partitions_android=" \
 	"uuid_disk=${uuid_gpt_disk};" \
 	"name=xloader,start=128K,size=256K,uuid=${uuid_gpt_xloader};" \
-	"name=bootloader,size=768K,uuid=${uuid_gpt_bootloader};" \
-	"name=environment,size=128K,uuid=${uuid_gpt_environment};" \
+	"name=bootloader,size=2304K,uuid=${uuid_gpt_bootloader};" \
+	"name=environment,size=256K,uuid=${uuid_gpt_environment};" \
 	"name=misc,size=128K,uuid=${uuid_gpt_misc};" \
 	"name=reserved,size=256K,uuid=${uuid_gpt_reserved};" \
 	"name=efs,size=16M,uuid=${uuid_gpt_efs};" \
@@ -86,7 +84,7 @@
 #define CONFIG_MII			/* Required in net/eth.c */
 #define CONFIG_PHY_GIGE			/* per-board part of CPSW */
 #define CONFIG_PHYLIB
-#define PHY_ANEG_TIMEOUT	8000	/* PHY needs longer aneg time at 1G */
+#define PHY_ANEG_TIMEOUT	16000	/* PHY needs longer aneg time at 1G */
 
 #define CONFIG_SUPPORT_EMMC_BOOT
 
@@ -108,10 +106,6 @@
 #define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
 						CONFIG_SYS_SCSI_MAX_LUN)
 
-/* EEPROM */
-#define CONFIG_EEPROM_CHIP_ADDRESS 0x50
-#define CONFIG_EEPROM_BUS_ADDRESS 0
-
 /*
  * Default to using SPI for environment, etc.
  * 0x000000 - 0x040000 : QSPI.SPL (256KiB)
@@ -126,11 +120,6 @@
 #define CONFIG_SYS_SPI_ARGS_OFFS        0x140000
 #define CONFIG_SYS_SPI_ARGS_SIZE        0x80000
 
-#ifdef CONFIG_SPL_BUILD
-#undef CONFIG_DM_SPI
-#undef CONFIG_DM_SPI_FLASH
-#endif
-
 /* SPI SPL */
 #define CONFIG_TI_EDMA3
 #define CONFIG_SPL_SPI_LOAD
@@ -143,4 +132,72 @@
 #define CONFIG_SF_DEFAULT_MODE                 SPI_MODE_0
 #define CONFIG_QSPI_QUAD_SUPPORT
 
+#define AM5728_QSPI_BOOT
+ 
+#ifdef AM5728_QSPI_BOOT
+ #include <environment/ti/qspi_am5728.h>
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        DEFAULT_LINUX_BOOT_ENV \
+        DEFAULT_QSPI_AM5728_ARGS \
+        DEFAULT_FIT_TI_ARGS \
+        "console=" CONSOLEDEV ",115200n8\0" \
+        "fdtfile=undefined\0" \
+        "bootpart=0:2\0" \
+        "bootdir=/boot\0" \
+        "bootfile=zImage\0" \
+        "usbtty=cdc_acm\0" \
+        "vram=16M\0" \
+        "partitions=" PARTS_DEFAULT "\0" \
+        "optargs=\0" \
+        "dofastboot=0\0" \
+        "findfdt="\
+                "if test $board_name = omap5_uevm; then " \
+                        "setenv fdtfile omap5-uevm.dtb; fi; " \
+                "if test $board_name = dra7xx; then " \
+                        "setenv fdtfile dra7-evm.dtb; fi;" \
+                "if test $board_name = dra72x-revc; then " \
+                        "setenv fdtfile dra72-evm-revc.dtb; fi;" \
+                "if test $board_name = dra72x; then " \
+                        "setenv fdtfile dra72-evm.dtb; fi;" \
+                "if test $board_name = dra71x; then " \
+                        "setenv fdtfile dra71-evm.dtb; fi;" \
+                "if test $board_name = beagle_x15; then " \
+                        "setenv fdtfile am57xx-beagle-x15.dtb; fi;" \
+                "if test $board_name = beagle_x15_revb1; then " \
+                        "setenv fdtfile am57xx-beagle-x15-revb1.dtb; fi;" \
+                "if test $board_name = am572x_idk && test $idk_lcd = no; then " \
+                        "setenv fdtfile am572x-idk.dtb; fi;" \
+                "if test $board_name = am572x_idk && test $idk_lcd = osd101t2045; then " \
+                        "setenv fdtfile am572x-idk-lcd-osd101t2045.dtb; fi;" \
+                "if test $board_name = am572x_idk && test $idk_lcd = osd101t2587; then " \
+                        "setenv fdtfile am572x-idk-lcd-osd101t2587.dtb; fi;" \
+                "if test $board_name = am57xx_evm; then " \
+                        "setenv fdtfile am57xx-evm.dtb; fi;" \
+                "if test $board_name = am57xx_evm_reva3; then " \
+                        "setenv fdtfile am57xx-evm-reva3.dtb; fi;" \
+                "if test $board_name = am571x_idk && test $idk_lcd = no; then " \
+                        "setenv fdtfile am571x-idk.dtb; fi;" \
+                "if test $board_name = am571x_idk && test $idk_lcd = osd101t2045; then " \
+                        "setenv fdtfile am571x-idk-lcd-osd101t2045.dtb; fi;" \
+                "if test $board_name = am571x_idk && test $idk_lcd = osd101t2587; then " \
+                        "setenv fdtfile am571x-idk-lcd-osd101t2587.dtb; fi;" \
+                "if test $fdtfile = undefined; then " \
+                        "echo WARNING: Could not determine device tree to use; fi; \0" \
+        DFUARGS \
+        NETARGS \
+
+#endif
+
+
+
+#define CONFIG_BOOTCOMMAND \
+        "if test ${boot_fit} -eq 1; then "      \
+                "run update_to_fit;"    \
+        "fi;"   \
+        "run findfdt; " \
+        "run envboot;" \
+
+
 #endif /* __CONFIG_AM57XX_EVM_H */
diff -u -N U-Boot_SDcard/board/ti/sdp4430/sdp.c U-Boot_SDcard/board/ti/sdp4430/sdp.c
--- U-Boot_SDcard/board/ti/sdp4430/sdp.c	2019-09-12 15:54:11.000000468 -0500
+++ U-Boot_SDcard/board/ti/sdp4430/sdp.c	1969-12-31 19:29:27.000000230 -0600
@@ -73,7 +73,7 @@
 				 sizeof(struct pad_conf_entry));
 }
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(0, 0, 0, -1, -1);
@@ -81,12 +81,14 @@
 	return 0;
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 void board_mmc_power_init(void)
 {
 	twl6030_power_mmc_init(0);
 	twl6030_power_mmc_init(1);
 }
 #endif
+#endif
 
 /*
  * get_board_rev() - get board revision
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h	2019-09-12 15:54:32.000000447 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h	1969-12-31 19:29:30.000000326 -0600
@@ -16,12 +16,12 @@
 #define MPUPLL_M_800	800
 #define MPUPLL_M_720	720
 #define MPUPLL_M_600	600
-#define MPUPLL_M_550	550
+#define MPUPLL_M_500	500
 #define MPUPLL_M_300	300
 
 /* MAIN PLL Fdll = 550 MHz, by default */
 #ifndef CONFIG_SYS_MPUCLK
-#define CONFIG_SYS_MPUCLK	MPUPLL_M_550
+#define CONFIG_SYS_MPUCLK      MPUPLL_M_500
 #endif
 
 #define UART_RESET		(0x1 << 1)
@@ -31,6 +31,8 @@
 #define CM_DLL_CTRL_NO_OVERRIDE	0x0
 #define CM_DLL_READYST		0x4
 
+#define NUM_OPPS	6
+
 extern void enable_dmm_clocks(void);
 extern const struct dpll_params dpll_core_opp100;
 extern struct dpll_params dpll_mpu_opp100;
diff -u -N U-Boot_SDcard/common/image.c U-Boot_SDcard/common/image.c
--- U-Boot_SDcard/common/image.c	2019-09-12 15:54:12.000000565 -0500
+++ U-Boot_SDcard/common/image.c	1969-12-31 19:29:17.000000506 -0600
@@ -167,6 +167,7 @@
 	{	IH_TYPE_FPGA,       "fpga",       "FPGA Image" },
 	{       IH_TYPE_TEE,        "tee",        "Trusted Execution Environment Image",},
 	{	IH_TYPE_FIRMWARE_IVT, "firmware_ivt", "Firmware with HABv4 IVT" },
+	{       IH_TYPE_PMMC,        "pmmc",        "TI Power Management Micro-Controller Firmware",},
 	{	-1,		    "",		  "",			},
 };
 
diff -u -N U-Boot_SDcard/common/spl/spl.c U-Boot_SDcard/common/spl/spl.c
--- U-Boot_SDcard/common/spl/spl.c	2019-09-12 15:54:43.000000607 -0500
+++ U-Boot_SDcard/common/spl/spl.c	1969-12-31 19:29:20.000000766 -0600
@@ -17,6 +17,7 @@
 #include <malloc.h>
 #include <dm/root.h>
 #include <linux/compiler.h>
+#include <fdt_support.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -66,6 +67,33 @@
 }
 #endif
 
+void spl_fixup_fdt(void)
+{
+#ifdef CONFIG_SPL_OF_LIBFDT
+	void *fdt_blob = (void *)CONFIG_SYS_SPL_ARGS_ADDR;
+	int err;
+
+	err = fdt_check_header(fdt_blob);
+	if (err < 0) {
+		printf("fdt_root: %s\n", fdt_strerror(err));
+		return;
+	}
+
+	/* fixup the memory dt node */
+	err = fdt_shrink_to_minimum(fdt_blob, 0);
+	if (err == 0) {
+		printf("spl: fdt_shrink_to_minimum err - %d\n", err);
+		return;
+	}
+
+	err = arch_fixup_fdt(fdt_blob);
+	if (err) {
+		printf("spl: arch_fixup_fdt err - %d\n", err);
+		return;
+	}
+#endif
+}
+
 /*
  * Weak default function for board specific cleanup/preparation before
  * Linux boot. Some boards/platforms might not need it, so just provide
@@ -93,9 +121,10 @@
 int spl_parse_image_header(struct spl_image_info *spl_image,
 			   const struct image_header *header)
 {
-	u32 header_size = sizeof(struct image_header);
+	if (image_get_magic(header) == IH_MAGIC) {
+#ifdef CONFIG_SPL_LEGACY_IMAGE_SUPPORT
+		u32 header_size = sizeof(struct image_header);
 
-	if (image_get_magic(header) == IH_MAGIC) {
 		if (spl_image->flags & SPL_COPY_PAYLOAD_ONLY) {
 			/*
 			 * On some system (e.g. powerpc), the load-address and
@@ -118,6 +147,11 @@
 		debug("spl: payload image: %.*s load addr: 0x%x size: %d\n",
 			(int)sizeof(spl_image->name), spl_image->name,
 			spl_image->load_addr, spl_image->size);
+#else
+		/* LEGACY image not supported */
+		debug("Legacy boot image support not enabled, proceeding to other boot methods");
+		return -EINVAL;
+#endif
 	} else {
 #ifdef CONFIG_SPL_PANIC_ON_RAW_IMAGE
 		/*
@@ -146,16 +180,18 @@
 		}
 #endif
 
-#ifdef CONFIG_SPL_ABORT_ON_RAW_IMAGE
-		/* Signature not found, proceed to other boot methods. */
-		return -EINVAL;
-#else
+#ifdef CONFIG_SPL_RAW_IMAGE_SUPPORT
 		/* Signature not found - assume u-boot.bin */
 		debug("mkimage signature not found - ih_magic = %x\n",
 			header->ih_magic);
 		spl_set_header_raw_uboot(spl_image);
+#else
+		/* RAW image not supported, proceed to other boot methods. */
+		debug("Raw boot image support not enabled, proceeding to other boot methods");
+		return -EINVAL;
 #endif
 	}
+
 	return 0;
 }
 
@@ -170,75 +206,20 @@
 	image_entry();
 }
 
-#ifndef CONFIG_SPL_LOAD_FIT_ADDRESS
-# define CONFIG_SPL_LOAD_FIT_ADDRESS	0
-#endif
-
-#if defined(CONFIG_SPL_RAM_DEVICE) || defined(CONFIG_SPL_DFU_SUPPORT)
-static ulong spl_ram_load_read(struct spl_load_info *load, ulong sector,
-			       ulong count, void *buf)
+static int spl_common_init(bool setup_malloc)
 {
-	debug("%s: sector %lx, count %lx, buf %lx\n",
-	      __func__, sector, count, (ulong)buf);
-	memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS + sector), count);
-	return count;
-}
+	int ret;
 
-static int spl_ram_load_image(struct spl_image_info *spl_image,
-			      struct spl_boot_device *bootdev)
-{
-	struct image_header *header;
-
-	header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS;
-
-#if defined(CONFIG_SPL_DFU_SUPPORT)
-	if (bootdev->boot_device == BOOT_DEVICE_DFU)
-		spl_dfu_cmd(0, "dfu_alt_info_ram", "ram", "0");
-#endif
-
-	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
-	    image_get_magic(header) == FDT_MAGIC) {
-		struct spl_load_info load;
-
-		debug("Found FIT\n");
-		load.bl_len = 1;
-		load.read = spl_ram_load_read;
-		spl_load_simple_fit(spl_image, &load, 0, header);
-	} else {
-		debug("Legacy image\n");
-		/*
-		 * Get the header.  It will point to an address defined by
-		 * handoff which will tell where the image located inside
-		 * the flash. For now, it will temporary fixed to address
-		 * pointed by U-Boot.
-		 */
-		header = (struct image_header *)
-			(CONFIG_SYS_TEXT_BASE -	sizeof(struct image_header));
-
-		spl_parse_image_header(spl_image, header);
-	}
+	debug("spl_early_init()\n");
 
-	return 0;
-}
-#if defined(CONFIG_SPL_RAM_DEVICE)
-SPL_LOAD_IMAGE_METHOD("RAM", 0, BOOT_DEVICE_RAM, spl_ram_load_image);
-#endif
-#if defined(CONFIG_SPL_DFU_SUPPORT)
-SPL_LOAD_IMAGE_METHOD("USB DFU", 0, BOOT_DEVICE_DFU, spl_ram_load_image);
-#endif
-#endif
-
-int spl_init(void)
-{
-	int ret;
-
-	debug("spl_init()\n");
 #if defined(CONFIG_SYS_MALLOC_F_LEN)
+	if (setup_malloc) {
 #ifdef CONFIG_MALLOC_F_ADDR
-	gd->malloc_base = CONFIG_MALLOC_F_ADDR;
+		gd->malloc_base = CONFIG_MALLOC_F_ADDR;
 #endif
-	gd->malloc_limit = CONFIG_SYS_MALLOC_F_LEN;
-	gd->malloc_ptr = 0;
+		gd->malloc_limit = CONFIG_SYS_MALLOC_F_LEN;
+		gd->malloc_ptr = 0;
+	}
 #endif
 	if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
 		ret = fdtdec_setup();
@@ -255,6 +236,33 @@
 			return ret;
 		}
 	}
+
+	return 0;
+}
+
+int spl_early_init(void)
+{
+	int ret;
+
+	ret = spl_common_init(true);
+	if (ret)
+		return ret;
+	gd->flags |= GD_FLG_SPL_EARLY_INIT;
+
+	return 0;
+}
+
+int spl_init(void)
+{
+	int ret;
+	bool setup_malloc = !(IS_ENABLED(CONFIG_SPL_STACK_R) &&
+			IS_ENABLED(CONFIG_SPL_SYS_MALLOC_SIMPLE));
+
+	if (!(gd->flags & GD_FLG_SPL_EARLY_INIT)) {
+		ret = spl_common_init(setup_malloc);
+		if (ret)
+			return ret;
+	}
 	gd->flags |= GD_FLG_SPL_INIT;
 
 	return 0;
@@ -316,7 +324,7 @@
 		loader = spl_ll_find_loader(spl_boot_list[i]);
 #if defined(CONFIG_SPL_SERIAL_SUPPORT) && defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
 		if (loader)
-			printf("Trying to boot from %s", loader->name);
+			printf("Trying to boot from %s\n", loader->name);
 		else
 			puts("SPL: Unsupported Boot Device!\n");
 #endif
@@ -327,6 +335,34 @@
 	return -ENODEV;
 }
 
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF)) && \
+		defined(CONFIG_ARM)
+static int reserve_mmu(void)
+{
+	phys_addr_t ram_top = 0;
+	/* reserve TLB table */
+	gd->arch.tlb_size = PGTABLE_SIZE;
+
+#ifdef CONFIG_SYS_SDRAM_BASE
+	ram_top = CONFIG_SYS_SDRAM_BASE;
+#endif
+	ram_top += get_effective_memsize();
+	gd->arch.tlb_addr = ram_top - gd->arch.tlb_size;
+	debug("TLB table from %08lx to %08lx\n", gd->arch.tlb_addr,
+	      gd->arch.tlb_addr + gd->arch.tlb_size);
+	return 0;
+}
+
+__weak void dram_init_banksize(void)
+{
+#if defined(CONFIG_NR_DRAM_BANKS) && defined(CONFIG_SYS_SDRAM_BASE)
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	gd->bd->bi_dram[0].size = get_effective_memsize();
+#endif
+}
+
+#endif
+
 void board_init_r(gd_t *dummy1, ulong dummy2)
 {
 	u32 spl_boot_list[] = {
@@ -339,6 +375,14 @@
 	struct spl_image_info spl_image;
 
 	debug(">>spl:board_init_r()\n");
+	gd->bd = &bdata;
+
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF)) && \
+		defined(CONFIG_ARM)
+	dram_init_banksize();
+	reserve_mmu();
+	enable_caches();
+#endif
 
 #if defined(CONFIG_SYS_SPL_MALLOC_START)
 	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,
@@ -370,6 +414,11 @@
 		hang();
 	}
 
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF)) && \
+		defined(CONFIG_ARM)
+	cleanup_before_linux();
+#endif
+
 	switch (spl_image.os) {
 	case IH_OS_U_BOOT:
 		debug("Jumping to U-Boot\n");
@@ -377,6 +426,7 @@
 #ifdef CONFIG_SPL_OS_BOOT
 	case IH_OS_LINUX:
 		debug("Jumping to Linux\n");
+		spl_fixup_fdt();
 		spl_board_prepare_for_linux();
 		jump_to_image_linux(&spl_image,
 				    (void *)CONFIG_SYS_SPL_ARGS_ADDR);
@@ -389,7 +439,7 @@
 	      gd->malloc_ptr / 1024);
 #endif
 
-	debug("loaded - jumping to U-Boot...");
+	debug("loaded - jumping to U-Boot...\n");
 	spl_board_prepare_for_boot();
 	jump_to_image_no_args(&spl_image);
 }
@@ -400,7 +450,6 @@
  */
 void preloader_console_init(void)
 {
-	gd->bd = &bdata;
 	gd->baudrate = CONFIG_BAUDRATE;
 
 	serial_init();		/* serial communications setup */
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h	2019-09-12 15:54:44.000000978 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/clock-k2g.h	1969-12-31 19:29:30.000000919 -0600
@@ -12,8 +12,8 @@
 
 #define PLLSET_CMD_LIST		"<pa|arm|ddr3>"
 
-#define DEV_SUPPORTED_SPEEDS	0x1ff
-#define ARM_SUPPORTED_SPEEDS	0xff
+#define DEV_SUPPORTED_SPEEDS	0xff
+#define ARM_SUPPORTED_SPEEDS	0x3ff
 
 #define KS2_CLK1_6 sys_clk0_6_clk
 
diff -u -N U-Boot_SDcard/common/spl/spl_fit.c U-Boot_SDcard/common/spl/spl_fit.c
--- U-Boot_SDcard/common/spl/spl_fit.c	2019-09-12 15:54:27.000000111 -0500
+++ U-Boot_SDcard/common/spl/spl_fit.c	1969-12-31 19:29:20.000000770 -0600
@@ -11,80 +11,6 @@
 #include <libfdt.h>
 #include <spl.h>
 
-static ulong fdt_getprop_u32(const void *fdt, int node, const char *prop)
-{
-	const u32 *cell;
-	int len;
-
-	cell = fdt_getprop(fdt, node, prop, &len);
-	if (len != sizeof(*cell))
-		return -1U;
-	return fdt32_to_cpu(*cell);
-}
-
-static int spl_fit_select_fdt(const void *fdt, int images, int *fdt_offsetp)
-{
-	const char *name, *fdt_name;
-	int conf, node, fdt_node;
-	int len;
-
-	*fdt_offsetp = 0;
-	conf = fdt_path_offset(fdt, FIT_CONFS_PATH);
-	if (conf < 0) {
-		debug("%s: Cannot find /configurations node: %d\n", __func__,
-		      conf);
-		return -EINVAL;
-	}
-	for (node = fdt_first_subnode(fdt, conf);
-	     node >= 0;
-	     node = fdt_next_subnode(fdt, node)) {
-		name = fdt_getprop(fdt, node, "description", &len);
-		if (!name) {
-#ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
-			printf("%s: Missing FDT description in DTB\n",
-			       __func__);
-#endif
-			return -EINVAL;
-		}
-		if (board_fit_config_name_match(name))
-			continue;
-
-		debug("Selecting config '%s'", name);
-		fdt_name = fdt_getprop(fdt, node, FIT_FDT_PROP, &len);
-		if (!fdt_name) {
-			debug("%s: Cannot find fdt name property: %d\n",
-			      __func__, len);
-			return -EINVAL;
-		}
-
-		debug(", fdt '%s'\n", fdt_name);
-		fdt_node = fdt_subnode_offset(fdt, images, fdt_name);
-		if (fdt_node < 0) {
-			debug("%s: Cannot find fdt node '%s': %d\n",
-			      __func__, fdt_name, fdt_node);
-			return -EINVAL;
-		}
-
-		*fdt_offsetp = fdt_getprop_u32(fdt, fdt_node, "data-offset");
-		len = fdt_getprop_u32(fdt, fdt_node, "data-size");
-		debug("FIT: Selected '%s'\n", name);
-
-		return len;
-	}
-
-#ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
-	printf("No matching DT out of these options:\n");
-	for (node = fdt_first_subnode(fdt, conf);
-	     node >= 0;
-	     node = fdt_next_subnode(fdt, node)) {
-		name = fdt_getprop(fdt, node, "description", &len);
-		printf("   %s\n", name);
-	}
-#endif
-
-	return -ENOENT;
-}
-
 static int get_aligned_image_offset(struct spl_load_info *info, int offset)
 {
 	/*
@@ -218,7 +144,7 @@
 	memcpy(dst, src, data_size);
 
 	/* Figure out which device tree the board wants to use */
-	fdt_len = spl_fit_select_fdt(fit, images, &fdt_offset);
+	fdt_len = fit_select_fdt(fit, images, &fdt_offset);
 	if (fdt_len < 0)
 		return fdt_len;
 
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c
--- U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c	2019-09-12 15:54:38.000000302 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board_k2g.c	1969-12-31 19:29:27.000000205 -0600
@@ -11,18 +11,50 @@
 #include <asm/ti-common/keystone_net.h>
 #include <asm/arch/psc_defs.h>
 #include <asm/arch/mmc_host_def.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <remoteproc.h>
 #include "mux-k2g.h"
+#include "../common/board_detect.h"
 
-#define SYS_CLK		24000000
+#define K2G_GP_AUDIO_CODEC_ADDRESS	0x1B
 
-unsigned int external_clk[ext_clk_count] = {
-	[sys_clk]	=	SYS_CLK,
-	[pa_clk]	=	SYS_CLK,
-	[tetris_clk]	=	SYS_CLK,
-	[ddr3a_clk]	=	SYS_CLK,
-	[uart_clk]	=	SYS_CLK,
+const unsigned int sysclk_array[MAX_SYSCLK] = {
+	19200000,
+	24000000,
+	25000000,
+	26000000,
 };
 
+unsigned int get_external_clk(u32 clk)
+{
+	unsigned int clk_freq;
+	u8 sysclk_index = get_sysclk_index();
+
+	switch (clk) {
+	case sys_clk:
+		clk_freq = sysclk_array[sysclk_index];
+		break;
+	case pa_clk:
+		clk_freq = sysclk_array[sysclk_index];
+		break;
+	case tetris_clk:
+		clk_freq = sysclk_array[sysclk_index];
+		break;
+	case ddr3a_clk:
+		clk_freq = sysclk_array[sysclk_index];
+		break;
+	case uart_clk:
+		clk_freq = sysclk_array[sysclk_index];
+		break;
+	default:
+		clk_freq = 0;
+		break;
+	}
+
+	return clk_freq;
+}
+
 static int arm_speeds[DEVSPEED_NUMSPDS] = {
 	SPD400,
 	SPD600,
@@ -47,49 +79,116 @@
 	SPD400,
 };
 
-static struct pll_init_data main_pll_config[NUM_SPDS] = {
-	[SPD400]	= {MAIN_PLL, 100, 3, 2},
-	[SPD600]	= {MAIN_PLL, 300, 6, 2},
-	[SPD800]	= {MAIN_PLL, 200, 3, 2},
-	[SPD900] =	{TETRIS_PLL, 75, 1, 2},
-	[SPD1000] =	{TETRIS_PLL, 250, 3, 2},
+static struct pll_init_data main_pll_config[MAX_SYSCLK][NUM_SPDS] = {
+	[SYSCLK_19MHz] = {
+		[SPD400]	= {MAIN_PLL, 125, 3, 2},
+		[SPD600]	= {MAIN_PLL, 125, 2, 2},
+		[SPD800]	= {MAIN_PLL, 250, 3, 2},
+		[SPD900]	= {MAIN_PLL, 187, 2, 2},
+		[SPD1000]	= {MAIN_PLL, 104, 1, 2},
+	},
+	[SYSCLK_24MHz] = {
+		[SPD400]	= {MAIN_PLL, 100, 3, 2},
+		[SPD600]	= {MAIN_PLL, 300, 6, 2},
+		[SPD800]	= {MAIN_PLL, 200, 3, 2},
+		[SPD900]	= {MAIN_PLL, 75, 1, 2},
+		[SPD1000]	= {MAIN_PLL, 250, 3, 2},
+	},
+	[SYSCLK_25MHz] = {
+		[SPD400]	= {MAIN_PLL, 32, 1, 2},
+		[SPD600]	= {MAIN_PLL, 48, 1, 2},
+		[SPD800]	= {MAIN_PLL, 64, 1, 2},
+		[SPD900]	= {MAIN_PLL, 72, 1, 2},
+		[SPD1000]	= {MAIN_PLL, 80, 1, 2},
+	},
+	[SYSCLK_26MHz] = {
+		[SPD400]	= {MAIN_PLL, 400, 13, 2},
+		[SPD600]	= {MAIN_PLL, 230, 5, 2},
+		[SPD800]	= {MAIN_PLL, 123, 2, 2},
+		[SPD900]	= {MAIN_PLL, 69, 1, 2},
+		[SPD1000]	= {MAIN_PLL, 384, 5, 2},
+	},
+};
+
+static struct pll_init_data tetris_pll_config[MAX_SYSCLK][NUM_SPDS] = {
+	[SYSCLK_19MHz] = {
+		[SPD200]	= {TETRIS_PLL, 625, 6, 10},
+		[SPD400]	= {TETRIS_PLL, 125, 1, 6},
+		[SPD600]	= {TETRIS_PLL, 125, 1, 4},
+		[SPD800]	= {TETRIS_PLL, 333, 2, 4},
+		[SPD900]	= {TETRIS_PLL, 187, 2, 2},
+		[SPD1000]	= {TETRIS_PLL, 104, 1, 2},
+	},
+	[SYSCLK_24MHz] = {
+		[SPD200]	= {TETRIS_PLL, 250, 3, 10},
+		[SPD400]	= {TETRIS_PLL, 100, 1, 6},
+		[SPD600]	= {TETRIS_PLL, 100, 1, 4},
+		[SPD800]	= {TETRIS_PLL, 400, 3, 4},
+		[SPD900]	= {TETRIS_PLL, 75, 1, 2},
+		[SPD1000]	= {TETRIS_PLL, 250, 3, 2},
+	},
+	[SYSCLK_25MHz] = {
+		[SPD200]	= {TETRIS_PLL, 80, 1, 10},
+		[SPD400]	= {TETRIS_PLL, 96, 1, 6},
+		[SPD600]	= {TETRIS_PLL, 96, 1, 4},
+		[SPD800]	= {TETRIS_PLL, 128, 1, 4},
+		[SPD900]	= {TETRIS_PLL, 72, 1, 2},
+		[SPD1000]	= {TETRIS_PLL, 80, 1, 2},
+	},
+	[SYSCLK_26MHz] = {
+		[SPD200]	= {TETRIS_PLL, 307, 4, 10},
+		[SPD400]	= {TETRIS_PLL, 369, 4, 6},
+		[SPD600]	= {TETRIS_PLL, 369, 4, 4},
+		[SPD800]	= {TETRIS_PLL, 123, 1, 4},
+		[SPD900]	= {TETRIS_PLL, 69, 1, 2},
+		[SPD1000]	= {TETRIS_PLL, 384, 5, 2},
+	},
+};
+
+static struct pll_init_data uart_pll_config[MAX_SYSCLK] = {
+	[SYSCLK_19MHz] = {UART_PLL, 160, 1, 8},
+	[SYSCLK_24MHz] = {UART_PLL, 128, 1, 8},
+	[SYSCLK_25MHz] = {UART_PLL, 768, 5, 10},
+	[SYSCLK_26MHz] = {UART_PLL, 384, 13, 2},
 };
 
-static struct pll_init_data tetris_pll_config[NUM_SPDS] = {
-	[SPD200] =	{TETRIS_PLL, 250, 3, 10},
-	[SPD400] =	{TETRIS_PLL, 100, 1, 6},
-	[SPD600] =	{TETRIS_PLL, 100, 1, 4},
-	[SPD800] =	{TETRIS_PLL, 400, 3, 4},
-	[SPD900] =	{TETRIS_PLL, 75, 1, 2},
-	[SPD1000] =	{TETRIS_PLL, 250, 3, 2},
+static struct pll_init_data nss_pll_config[MAX_SYSCLK] = {
+	[SYSCLK_19MHz] = {NSS_PLL, 625, 6, 2},
+	[SYSCLK_24MHz] = {NSS_PLL, 250, 3, 2},
+	[SYSCLK_25MHz] = {NSS_PLL, 80, 1, 2},
+	[SYSCLK_26MHz] = {NSS_PLL, 1000, 13, 2},
 };
 
-static struct pll_init_data uart_pll_config = {UART_PLL, 64, 1, 4};
-static struct pll_init_data nss_pll_config = {NSS_PLL, 250, 3, 2};
-static struct pll_init_data ddr3_pll_config = {DDR3A_PLL, 133, 1, 16};
+static struct pll_init_data ddr3_pll_config[MAX_SYSCLK] = {
+	[SYSCLK_19MHz] = {DDR3A_PLL, 167, 1, 16},
+	[SYSCLK_24MHz] = {DDR3A_PLL, 133, 1, 16},
+	[SYSCLK_25MHz] = {DDR3A_PLL, 128, 1, 16},
+	[SYSCLK_26MHz] = {DDR3A_PLL, 123, 1, 16},
+};
 
 struct pll_init_data *get_pll_init_data(int pll)
 {
 	int speed;
 	struct pll_init_data *data = NULL;
+	u8 sysclk_index = get_sysclk_index();
 
 	switch (pll) {
 	case MAIN_PLL:
 		speed = get_max_dev_speed(dev_speeds);
-		data = &main_pll_config[speed];
+		data = &main_pll_config[sysclk_index][speed];
 		break;
 	case TETRIS_PLL:
 		speed = get_max_arm_speed(arm_speeds);
-		data = &tetris_pll_config[speed];
+		data = &tetris_pll_config[sysclk_index][speed];
 		break;
 	case NSS_PLL:
-		data = &nss_pll_config;
+		data = &nss_pll_config[sysclk_index];
 		break;
 	case UART_PLL:
-		data = &uart_pll_config;
+		data = &uart_pll_config[sysclk_index];
 		break;
 	case DDR3_PLL:
-		data = &ddr3_pll_config;
+		data = &ddr3_pll_config[sysclk_index];
 		break;
 	default:
 		data = NULL;
@@ -102,7 +201,7 @@
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
 };
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	if (psc_enable_module(KS2_LPSC_MMC)) {
@@ -110,13 +209,47 @@
 		return -1;
 	}
 
-	omap_mmc_init(0, 0, 0, -1, -1);
+	if (board_is_k2g_gp())
+		omap_mmc_init(0, 0, 0, -1, -1);
+
 	omap_mmc_init(1, 0, 0, -1, -1);
 	return 0;
 }
 #endif
 
-#ifdef CONFIG_BOARD_EARLY_INIT_F
+#if defined(CONFIG_FIT_EMBED)
+int board_fit_config_name_match(const char *name)
+{
+	bool eeprom_read = board_ti_was_eeprom_read();
+
+	if (!strcmp(name, "keystone-k2g-generic") && !eeprom_read)
+		return 0;
+	else if (!strcmp(name, "keystone-k2g-evm") && board_ti_is("66AK2GGP"))
+		return 0;
+	else if (!strcmp(name, "keystone-k2g-ice") && board_ti_is("66AK2GIC"))
+		return 0;
+	else
+		return -1;
+}
+#endif
+
+#if defined(CONFIG_DTB_RESELECT)
+static int alt_board_detect(void)
+{
+	int rc;
+
+	rc = i2c_set_bus_num(1);
+	if (rc)
+		return rc;
+
+	rc = i2c_probe(K2G_GP_AUDIO_CODEC_ADDRESS);
+	if (rc)
+		return rc;
+
+	ti_i2c_eeprom_am_set("66AK2GGP", "1.0X");
+
+	return 0;
+}
 
 static void k2g_reset_mux_config(void)
 {
@@ -131,19 +264,85 @@
 	setbits_le32(KS2_RSTMUX8, RSTMUX_LOCK8_MASK);
 }
 
-int board_early_init_f(void)
+int embedded_dtb_select(void)
 {
-	init_plls();
+	int rc;
+	rc = ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
+			CONFIG_EEPROM_CHIP_ADDRESS);
+	if (rc) {
+		rc = alt_board_detect();
+		if (rc) {
+			printf("Unable to do board detection\n");
+			return -1;
+		}
+	}
+
+	fdtdec_setup();
 
 	k2g_mux_config();
 
 	k2g_reset_mux_config();
 
-	/* deassert FLASH_HOLD */
-	clrbits_le32(K2G_GPIO1_BANK2_BASE + K2G_GPIO_DIR_OFFSET,
-		     BIT(9));
-	setbits_le32(K2G_GPIO1_BANK2_BASE + K2G_GPIO_SETDATA_OFFSET,
-		     BIT(9));
+	if (board_is_k2g_gp()) {
+		/* deassert FLASH_HOLD */
+		clrbits_le32(K2G_GPIO1_BANK2_BASE + K2G_GPIO_DIR_OFFSET,
+			     BIT(9));
+		setbits_le32(K2G_GPIO1_BANK2_BASE + K2G_GPIO_SETDATA_OFFSET,
+			     BIT(9));
+	} else if (board_is_k2g_ice()) {
+		/* GBE Phy workaround. For Phy to latch the input
+		 * configuration, a GPIO reset is asserted at the
+		 * Phy reset pin to latch configuration correctly after SoC
+		 * reset. GPIO0 Pin 10 (Ball AA20) is used for this on ICE
+		 * board. Just do a low to high transition.
+		 */
+		clrbits_le32(K2G_GPIO0_BANK0_BASE + K2G_GPIO_DIR_OFFSET,
+			     BIT(10));
+		setbits_le32(K2G_GPIO0_BANK0_BASE + K2G_GPIO_CLRDATA_OFFSET,
+			     BIT(10));
+		/* Delay just to get a transition to high */
+		udelay(100);
+		setbits_le32(K2G_GPIO0_BANK0_BASE + K2G_GPIO_SETDATA_OFFSET,
+			     BIT(10));
+	}
+
+	if (psc_enable_module(KS2_LPSC_GPMC))
+		printf("%s can't enable gpmc\n", __func__);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_TI_I2C_BOARD_DETECT)
+	int rc;
+
+	rc = ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
+			CONFIG_EEPROM_CHIP_ADDRESS);
+	if (rc)
+		printf("ti_i2c_eeprom_init failed %d\n", rc);
+
+	board_ti_set_ethaddr(1);
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	if (board_is_k2g_gp())
+		setenv("board_name", "66AK2GGP\0");
+	else if (board_is_k2g_ice())
+		setenv("board_name", "66AK2GIC\0");
+#endif
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+int board_early_init_f(void)
+{
+	init_plls();
+
+	k2g_mux_config();
 
 	return 0;
 }
@@ -173,3 +372,23 @@
 	return sizeof(eth_priv_cfg) / sizeof(struct eth_priv_t);
 }
 #endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_pmmc_image_process(ulong pmmc_image, size_t pmmc_size)
+{
+	int id = getenv_ulong("dev_pmmc", 10, 0);
+	int ret;
+
+	if (!rproc_is_initialized())
+		rproc_init();
+
+	ret = rproc_load(id, pmmc_image, pmmc_size);
+	printf("Load Remote Processor %d with data@addr=0x%08lx %u bytes:%s\n",
+	       id, pmmc_image, pmmc_size, ret ? " Failed!" : " Success!");
+
+	if (!ret)
+		rproc_start(id);
+}
+
+U_BOOT_FIT_LOADABLE_HANDLER(IH_TYPE_PMMC, board_pmmc_image_process);
+#endif
diff -u -N /dev/null U-Boot_SDcard/arch/arm/mach-omap2/am33xx/fdt.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/fdt.c	1969-12-31 19:31:37.000000954 -0600
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2017 Texas Instruments, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <malloc.h>
+
+#include <asm/omap_common.h>
+#include <asm/arch-am33xx/sys_proto.h>
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+
+static void ft_hs_fixups(void *fdt, bd_t *bd)
+{
+	/* Check we are running on an HS/EMU device type */
+	if (GP_DEVICE != get_device_type()) {
+		if ((ft_hs_disable_rng(fdt, bd) == 0) &&
+		    (ft_hs_fixup_dram(fdt, bd) == 0) &&
+		    (ft_hs_add_tee(fdt, bd) == 0))
+			return;
+	} else {
+		printf("ERROR: Incorrect device type (GP) detected!");
+	}
+	/* Fixup failed or wrong device type */
+	hang();
+}
+#else
+static void ft_hs_fixups(void *fdt, bd_t *bd) { }
+#endif /* #ifdef CONFIG_TI_SECURE_DEVICE */
+
+/*
+ * Place for general cpu/SoC FDT fixups. Board specific
+ * fixups should remain in the board files which is where
+ * this function should be called from.
+ */
+void ft_cpu_setup(void *fdt, bd_t *bd)
+{
+	ft_hs_fixups(fdt, bd);
+}
diff -u -N U-Boot_SDcard/common/splash_source.c U-Boot_SDcard/common/splash_source.c
--- U-Boot_SDcard/common/splash_source.c	2019-09-12 15:54:51.000000010 -0500
+++ U-Boot_SDcard/common/splash_source.c	1969-12-31 19:29:17.000000528 -0600
@@ -45,9 +45,10 @@
 #ifdef CONFIG_CMD_NAND
 static int splash_nand_read_raw(u32 bmp_load_addr, int offset, size_t read_size)
 {
-	return nand_read_skip_bad(nand_info[nand_curr_device], offset,
+	struct mtd_info *mtd = get_nand_dev_by_index(nand_curr_device);
+	return nand_read_skip_bad(mtd, offset,
 				  &read_size, NULL,
-				  nand_info[nand_curr_device]->size,
+				  mtd->size,
 				  (u_char *)bmp_load_addr);
 }
 #else
diff -u -N U-Boot_SDcard/board/overo/overo.c U-Boot_SDcard/board/overo/overo.c
--- U-Boot_SDcard/board/overo/overo.c	2019-09-12 15:54:53.000000360 -0500
+++ U-Boot_SDcard/board/overo/overo.c	1969-12-31 19:29:20.000000460 -0600
@@ -70,7 +70,8 @@
 static const struct ns16550_platdata overo_serial = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(overo_uart) = {
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board.h U-Boot_SDcard/board/ti/ks2_evm/board.h
--- U-Boot_SDcard/board/ti/ks2_evm/board.h	2019-09-12 15:54:19.000000306 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board.h	1969-12-31 19:29:27.000000203 -0600
@@ -11,9 +11,30 @@
 #define _KS2_BOARD
 
 #include <asm/ti-common/keystone_net.h>
+#include "../common/board_detect.h"
 
 extern struct eth_priv_t eth_priv_cfg[];
 
+#if defined(CONFIG_TI_I2C_BOARD_DETECT)
+static inline int board_is_k2g_gp(void)
+{
+	return board_ti_is("66AK2GGP");
+}
+static inline int board_is_k2g_ice(void)
+{
+	return board_ti_is("66AK2GIC");
+}
+#else
+static inline int board_is_k2g_gp(void)
+{
+	return false;
+}
+static inline int board_is_k2g_ice(void)
+{
+	return false;
+}
+#endif
+
 int get_num_eth_ports(void);
 void spl_init_keystone_plls(void);
 
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h	2019-09-12 15:54:35.000000336 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-omap5/omap.h	1969-12-31 19:29:30.000000548 -0600
@@ -188,7 +188,7 @@
 #if defined(CONFIG_DRA7XX)
 #define NON_SECURE_SRAM_START	0x40300000
 #define NON_SECURE_SRAM_END	0x40380000	/* Not inclusive */
-#define NON_SECURE_SRAM_IMG_END	0x4037E000
+#define NON_SECURE_SRAM_IMG_END	0x4037C000
 #else
 #define NON_SECURE_SRAM_START	0x40300000
 #define NON_SECURE_SRAM_END	0x40320000	/* Not inclusive */
diff -u -N U-Boot_SDcard/include/configs/bav335x.h U-Boot_SDcard/include/configs/bav335x.h
--- U-Boot_SDcard/include/configs/bav335x.h	2019-09-12 15:54:33.000000723 -0500
+++ U-Boot_SDcard/include/configs/bav335x.h	1969-12-31 19:29:22.000000075 -0600
@@ -357,7 +357,7 @@
 
 /* USB gadget RNDIS */
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 #endif
 
 #ifdef CONFIG_NAND
diff -u -N U-Boot_SDcard/common/cli.c U-Boot_SDcard/common/cli.c
--- U-Boot_SDcard/common/cli.c	2019-09-12 15:54:43.000000870 -0500
+++ U-Boot_SDcard/common/cli.c	1969-12-31 19:29:17.000000461 -0600
@@ -28,7 +28,7 @@
  */
 int run_command(const char *cmd, int flag)
 {
-#ifndef CONFIG_HUSH_PARSER
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_HUSH_PARSER)
 	/*
 	 * cli_run_command can return 0 or 1 for success, so clean up
 	 * its result.
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile	2019-09-12 15:54:48.000000692 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Makefile	1969-12-31 19:29:28.000000725 -0600
@@ -1,22 +1,23 @@
-#
-# Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-$(CONFIG_AM33XX)	+= clock_am33xx.o
-obj-$(CONFIG_TI814X)	+= clock_ti814x.o
-obj-$(CONFIG_AM43XX)	+= clock_am43xx.o
-
-ifneq ($(CONFIG_AM43XX)$(CONFIG_AM33XX),)
-obj-y	+= clock.o
-endif
-
-obj-$(CONFIG_TI816X)	+= clock_ti816x.o
-obj-y	+= sys_info.o
-obj-y	+= ddr.o
-obj-y	+= emif4.o
-obj-y	+= board.o
-obj-y	+= mux.o
-
-obj-$(CONFIG_CLOCK_SYNTHESIZER)	+= clk_synthesizer.o
+#
+# Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_AM33XX)	+= clock_am33xx.o
+obj-$(CONFIG_TI814X)	+= clock_ti814x.o
+obj-$(CONFIG_AM43XX)	+= clock_am43xx.o
+
+ifneq ($(CONFIG_AM43XX)$(CONFIG_AM33XX),)
+obj-y	+= clock.o
+endif
+
+obj-$(CONFIG_TI816X)	+= clock_ti816x.o
+obj-y	+= sys_info.o
+obj-y	+= ddr.o
+obj-y	+= emif4.o
+obj-y	+= board.o
+obj-y	+= mux.o
+obj-y	+= fdt.o
+
+obj-$(CONFIG_CLOCK_SYNTHESIZER)	+= clk_synthesizer.o
diff -u -N U-Boot_SDcard/include/configs/ti_armv7_common.h U-Boot_SDcard/include/configs/ti_armv7_common.h
--- U-Boot_SDcard/include/configs/ti_armv7_common.h	2019-09-12 15:54:48.000000054 -0500
+++ U-Boot_SDcard/include/configs/ti_armv7_common.h	1969-12-31 19:29:22.000000527 -0600
@@ -57,75 +57,12 @@
 	"bootm_size=0x10000000\0" \
 	"boot_fdt=try\0"
 
-#define DEFAULT_MMC_TI_ARGS \
-	"mmcdev=0\0" \
-	"mmcrootfstype=ext4 rootwait\0" \
-	"finduuid=part uuid mmc ${bootpart} uuid\0" \
-	"args_mmc=run finduuid;setenv bootargs console=${console} " \
-		"${optargs} " \
-		"root=PARTUUID=${uuid} rw " \
-		"rootfstype=${mmcrootfstype}\0" \
-	"loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr\0" \
-	"bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
-		"source ${loadaddr}\0" \
-	"bootenvfile=uEnv.txt\0" \
-	"importbootenv=echo Importing environment from mmc${mmcdev} ...; " \
-		"env import -t ${loadaddr} ${filesize}\0" \
-	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenvfile}\0" \
-	"loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
-	"loadfdt=load ${devtype} ${bootpart} ${fdtaddr} ${bootdir}/${fdtfile}\0" \
-	"envboot=mmc dev ${mmcdev}; " \
-		"if mmc rescan; then " \
-			"echo SD/MMC found on device ${mmcdev};" \
-			"if run loadbootscript; then " \
-				"run bootscript;" \
-			"else " \
-				"if run loadbootenv; then " \
-					"echo Loaded env from ${bootenvfile};" \
-					"run importbootenv;" \
-				"fi;" \
-				"if test -n $uenvcmd; then " \
-					"echo Running uenvcmd ...;" \
-					"run uenvcmd;" \
-				"fi;" \
-			"fi;" \
-		"fi;\0" \
-	"mmcloados=run args_mmc; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootz ${loadaddr} - ${fdtaddr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootz; " \
-		"fi;\0" \
-	"mmcboot=mmc dev ${mmcdev}; " \
-		"setenv devnum ${mmcdev}; " \
-		"setenv devtype mmc; " \
-		"if mmc rescan; then " \
-			"echo SD/MMC found on device ${mmcdev};" \
-			"if run loadimage; then " \
-				"if test ${boot_fit} -eq 1; then " \
-					"run loadfit; " \
-				"else " \
-					"run mmcloados;" \
-				"fi;" \
-			"fi;" \
-		"fi;\0" \
-
 #define DEFAULT_FIT_TI_ARGS \
 	"boot_fit=0\0" \
-	"fit_loadaddr=0x88000000\0" \
-	"fit_bootfile=fitImage.itb\0" \
+	"fit_loadaddr=0x87000000\0" \
+	"fit_bootfile=fitImage\0" \
 	"update_to_fit=setenv loadaddr ${fit_loadaddr}; setenv bootfile ${fit_bootfile}\0" \
-	"args_fit=setenv bootargs console=${console} \0" \
-	"loadfit=run args_fit; bootm ${loadaddr}:kernel@1 " \
-		"${loadaddr}:ramdisk@1 ${loadaddr}:${fdtfile};\0" \
+	"loadfit=run args_mmc; bootm ${loadaddr}#${fdtfile};\0" \
 
 /*
  * DDR information.  If the CONFIG_NR_DRAM_BANKS is not defined,
@@ -283,9 +220,10 @@
 #define CONFIG_SPL_FS_LOAD_ARGS_NAME		"args"
 
 /* RAW SD card / eMMC */
-#define CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR	0x900	/* address 0x120000 */
-#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR	0x80	/* address 0x10000 */
-#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS	0x80	/* 64KiB */
+#define CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR	0x1700  /* address 0x2E0000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR	0x1500  /* address 0x2A0000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS	0x200   /* 256KiB */
+
 
 /* spl export command */
 #define CONFIG_CMD_SPL
@@ -332,4 +270,6 @@
 
 #include <config_distro_defaults.h>
 
+#define CONFIG_CMD_TIME
+
 #endif	/* __CONFIG_TI_ARMV7_COMMON_H__ */
diff -u -N U-Boot_SDcard/include/configs/am335x_evm.h U-Boot_SDcard/include/configs/am335x_evm.h
--- U-Boot_SDcard/include/configs/am335x_evm.h	2019-09-12 15:54:54.000000691 -0500
+++ U-Boot_SDcard/include/configs/am335x_evm.h	1969-12-31 19:29:22.000000033 -0600
@@ -17,7 +17,6 @@
 #define __CONFIG_AM335X_EVM_H
 
 #include <configs/ti_am335x_common.h>
-#include <environment/ti/dfu.h>
 
 #ifndef CONFIG_SPL_BUILD
 # define CONFIG_TIMESTAMP
@@ -102,6 +101,9 @@
 #include <config_distro_bootcmd.h>
 
 #ifndef CONFIG_SPL_BUILD
+#include <environment/ti/dfu.h>
+#include <environment/ti/mmc.h>
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	DEFAULT_LINUX_BOOT_ENV \
 	DEFAULT_MMC_TI_ARGS \
@@ -193,7 +195,7 @@
 
 /* USB gadget RNDIS */
 
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 #endif
 
 #ifdef CONFIG_NAND
@@ -281,12 +283,9 @@
 #endif
 
 #ifdef CONFIG_USB_MUSB_GADGET
-/* Removing USB gadget and can be enabled adter adding support usb DM */
-#ifndef CONFIG_DM_ETH
 #define CONFIG_USB_ETHER
 #define CONFIG_USB_ETH_RNDIS
 #define CONFIG_USBNET_HOST_ADDR	"de:ad:be:af:00:00"
-#endif /* CONFIG_DM_ETH */
 #endif /* CONFIG_USB_MUSB_GADGET */
 
 /*
@@ -297,12 +296,10 @@
 #undef CONFIG_DM_MMC
 #undef CONFIG_TIMER
 #undef CONFIG_DM_USB
+#undef CONFIG_DM_NAND
 #endif
 
 #if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT)
-/* Remove other SPL modes. */
-#define CONFIG_ENV_IS_NOWHERE
-#undef CONFIG_ENV_IS_IN_NAND
 /* disable host part of MUSB in SPL */
 /* disable EFI partitions and partition UUID support */
 #undef CONFIG_PARTITION_UUIDS
@@ -415,4 +412,8 @@
 #define CLK_SYNTHESIZER_I2C_ADDR 0x65
 #endif
 
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_TI_SECURE_DEVICE)
+#undef CONFIG_EFI_PARTITION
+#endif /* CONFIG_SPL_BUILD && CONFIG_TI_SECURE_DEVICE */
+
 #endif	/* ! __CONFIG_AM335X_EVM_H */
diff -u -N U-Boot_SDcard/board/gumstix/duovero/duovero.c U-Boot_SDcard/board/gumstix/duovero/duovero.c
--- U-Boot_SDcard/board/gumstix/duovero/duovero.c	2019-09-12 15:54:40.000000612 -0500
+++ U-Boot_SDcard/board/gumstix/duovero/duovero.c	1969-12-31 19:29:26.000000280 -0600
@@ -110,17 +110,19 @@
 		   sizeof(struct pad_conf_entry));
 }
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 void board_mmc_power_init(void)
 {
 	twl6030_power_mmc_init(0);
 }
 #endif
+#endif
 
 #if defined(CONFIG_CMD_NET)
 
diff -u -N U-Boot_SDcard/drivers/mmc/mmc_private.h U-Boot_SDcard/drivers/mmc/mmc_private.h
--- U-Boot_SDcard/drivers/mmc/mmc_private.h	2019-09-12 15:54:17.000000153 -0500
+++ U-Boot_SDcard/drivers/mmc/mmc_private.h	1969-12-31 19:29:21.000000195 -0600
@@ -12,6 +12,8 @@
 
 #include <mmc.h>
 
+bool mmc_check_error_rate(struct mmc *mmc, struct mmc_statistics *stats);
+bool mmc_disable_current_mode(struct mmc *mmc);
 extern int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 			struct mmc_data *data);
 extern int mmc_send_status(struct mmc *mmc, int timeout);
diff -u -N U-Boot_SDcard/drivers/core/regmap.c U-Boot_SDcard/drivers/core/regmap.c
--- U-Boot_SDcard/drivers/core/regmap.c	2019-09-12 15:54:56.000000953 -0500
+++ U-Boot_SDcard/drivers/core/regmap.c	1969-12-31 19:29:20.000000934 -0600
@@ -70,6 +70,7 @@
 	int addr_len, size_len, both_len;
 	int parent;
 	int len;
+	int index;
 
 	parent = dev->parent->of_offset;
 	addr_len = fdt_address_cells(blob, parent);
@@ -86,13 +87,14 @@
 	if (!map)
 		return -ENOMEM;
 
-	map->base = fdtdec_get_number(cell, addr_len);
-
-	for (range = map->range; count > 0;
-	     count--, cell += both_len, range++) {
-		range->start = fdtdec_get_number(cell, addr_len);
-		range->size = fdtdec_get_number(cell + addr_len, size_len);
+	for (range = map->range, index = 0; count > 0;
+	     count--, cell += both_len, range++, index++) {
+		fdt_size_t sz;
+		range->start = fdtdec_get_addr_size_fixed(blob, dev->of_offset,
+				"reg", index, addr_len, size_len, &sz, true);
+		range->size = sz;
 	}
+	map->base = map->range[0].start;
 
 	*mapp = map;
 
diff -u -N /dev/null U-Boot_SDcard/include/boot_fit.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/include/boot_fit.h	1969-12-31 19:31:37.000000914 -0600
@@ -0,0 +1,9 @@
+/*
+ * Copyright (C) 2017 Texas Instruments
+ * Written by Franklin Cooper Jr. <fcooper@ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+int fdt_offset(void *fit);
+void *locate_dtb_in_fit(void *fit);
diff -u -N U-Boot_SDcard/fs/ext4/dev.c U-Boot_SDcard/fs/ext4/dev.c
--- U-Boot_SDcard/fs/ext4/dev.c	2019-09-12 15:54:35.000000019 -0500
+++ U-Boot_SDcard/fs/ext4/dev.c	1969-12-31 19:29:21.000000804 -0600
@@ -60,9 +60,8 @@
 	}
 
 	/* Check partition boundaries */
-	if ((sector < 0) ||
-	    ((sector + ((byte_offset + byte_len - 1) >> log2blksz))
-	     >= part_info->size)) {
+	if ((sector + ((byte_offset + byte_len - 1) >> log2blksz))
+	    >= part_info->size) {
 		printf("%s read outside partition " LBAFU "\n", __func__,
 		       sector);
 		return 0;
diff -u -N U-Boot_SDcard/common/spl/Makefile U-Boot_SDcard/common/spl/Makefile
--- U-Boot_SDcard/common/spl/Makefile	2019-09-12 15:55:00.000000731 -0500
+++ U-Boot_SDcard/common/spl/Makefile	1969-12-31 19:29:20.000000766 -0600
@@ -1,29 +1,30 @@
-#
-# (C) Copyright 2012
-# Texas Instruments Incorporated - http://www.ti.com/
-# Aneesh V <aneesh@ti.com>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-# Based on common/Makefile.
-#
-
-ifdef CONFIG_SPL_BUILD
-obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
-obj-$(CONFIG_SPL_LOAD_FIT) += spl_fit.o
-obj-$(CONFIG_SPL_NOR_SUPPORT) += spl_nor.o
-obj-$(CONFIG_SPL_YMODEM_SUPPORT) += spl_ymodem.o
-ifndef CONFIG_SPL_UBI
-obj-$(CONFIG_SPL_NAND_SUPPORT) += spl_nand.o
-obj-$(CONFIG_SPL_ONENAND_SUPPORT) += spl_onenand.o
-endif
-obj-$(CONFIG_SPL_UBI) += spl_ubi.o
-obj-$(CONFIG_SPL_NET_SUPPORT) += spl_net.o
-obj-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc.o
-obj-$(CONFIG_SPL_USB_SUPPORT) += spl_usb.o
-obj-$(CONFIG_SPL_FAT_SUPPORT) += spl_fat.o
-obj-$(CONFIG_SPL_EXT_SUPPORT) += spl_ext.o
-obj-$(CONFIG_SPL_SATA_SUPPORT) += spl_sata.o
-obj-$(CONFIG_SPL_DFU_SUPPORT) += spl_dfu.o
-obj-$(CONFIG_SPL_SPI_LOAD) += spl_spi.o
-endif
+#
+# (C) Copyright 2012
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+# Based on common/Makefile.
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
+obj-$(CONFIG_SPL_LOAD_FIT) += spl_fit.o
+obj-$(CONFIG_SPL_NOR_SUPPORT) += spl_nor.o
+obj-$(CONFIG_SPL_YMODEM_SUPPORT) += spl_ymodem.o
+ifndef CONFIG_SPL_UBI
+obj-$(CONFIG_SPL_NAND_SUPPORT) += spl_nand.o
+obj-$(CONFIG_SPL_ONENAND_SUPPORT) += spl_onenand.o
+endif
+obj-$(CONFIG_SPL_UBI) += spl_ubi.o
+obj-$(CONFIG_SPL_NET_SUPPORT) += spl_net.o
+obj-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc.o
+obj-$(CONFIG_SPL_USB_SUPPORT) += spl_usb.o
+obj-$(CONFIG_SPL_FAT_SUPPORT) += spl_fat.o
+obj-$(CONFIG_SPL_EXT_SUPPORT) += spl_ext.o
+obj-$(CONFIG_SPL_SATA_SUPPORT) += spl_sata.o
+obj-$(CONFIG_SPL_DFU_SUPPORT) += spl_dfu.o
+obj-$(CONFIG_SPL_SPI_LOAD) += spl_spi.o
+obj-$(CONFIG_SPL_RAM_SUPPORT) += spl_ram.o
+endif
diff -u -N U-Boot_SDcard/include/configs/bur_am335x_common.h U-Boot_SDcard/include/configs/bur_am335x_common.h
--- U-Boot_SDcard/include/configs/bur_am335x_common.h	2019-09-12 15:54:41.000000444 -0500
+++ U-Boot_SDcard/include/configs/bur_am335x_common.h	1969-12-31 19:29:22.000000111 -0600
@@ -112,6 +112,6 @@
 
 /* General parts of the framework, required. */
 #define CONFIG_SPL_BOARD_INIT
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #endif	/* ! __BUR_AM335X_COMMON_H__ */
diff -u -N U-Boot_SDcard/include/configs/pepper.h U-Boot_SDcard/include/configs/pepper.h
--- U-Boot_SDcard/include/configs/pepper.h	2019-09-12 15:55:00.000000764 -0500
+++ U-Boot_SDcard/include/configs/pepper.h	1969-12-31 19:29:22.000000393 -0600
@@ -89,6 +89,6 @@
 #define CONFIG_PHY_RESET_DELAY 1000
 
 /* SPL */
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/am33xx/u-boot-spl.lds"
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/mach-omap2/u-boot-spl.lds"
 
 #endif /* __CONFIG_PEPPER_H */
diff -u -N U-Boot_SDcard/arch/arm/dts/am571x-idk.dts U-Boot_SDcard/arch/arm/dts/am571x-idk.dts
--- U-Boot_SDcard/arch/arm/dts/am571x-idk.dts	2019-09-12 15:54:30.000000246 -0500
+++ U-Boot_SDcard/arch/arm/dts/am571x-idk.dts	1969-12-31 19:29:23.000000224 -0600
@@ -1,81 +1,290 @@
-/*
- * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-/dts-v1/;
-
-#include "dra72x.dtsi"
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/interrupt-controller/irq.h>
-#include "am57xx-idk-common.dtsi"
-
-/ {
-	model = "TI AM5718 IDK";
-	compatible = "ti,am5718-idk", "ti,am5718", "ti,dra7";
-
-	memory@80000000 {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x40000000>;
-	};
-
-	leds {
-		compatible = "gpio-leds";
-		cpu0-led {
-			label = "status0:red:cpu0";
-			gpios = <&gpio2 25 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "cpu0";
-		};
-
-		usr0-led {
-			label = "status0:green:usr";
-			gpios = <&gpio2 26 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-		};
-
-		heartbeat-led {
-			label = "status0:blue:heartbeat";
-			gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "heartbeat";
-		};
-
-		usr1-led {
-			label = "status1:red:usr";
-			gpios = <&gpio2 28 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-		};
-
-		usr2-led {
-			label = "status1:green:usr";
-			gpios = <&gpio2 21 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-		};
-
-		mmc0-led {
-			label = "status1:blue:mmc0";
-			gpios = <&gpio2 19 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
-			linux,default-trigger = "mmc0";
-		};
-	};
-
-	extcon_usb2: extcon_usb2 {
-	     compatible = "linux,extcon-usb-gpio";
-	     id-gpio = <&gpio5 7 GPIO_ACTIVE_HIGH>;
-	};
-};
-
-&mmc1 {
-	status = "okay";
-	vmmc-supply = <&ldo1_reg>;
-	bus-width = <4>;
-	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>; /* gpio 219 */
-};
-
-&omap_dwc3_2 {
-	extcon = <&extcon_usb2>;
-};
+/*
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "dra72x.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am57xx-idk-common.dtsi"
+
+/ {
+	model = "TI AM5718 IDK";
+	compatible = "ti,am5718-idk", "ti,am5718", "ti,dra7";
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x40000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		cpu0-led {
+			label = "status0:red:cpu0";
+			gpios = <&gpio2 25 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "cpu0";
+		};
+
+		usr0-led {
+			label = "status0:green:usr";
+			gpios = <&gpio2 26 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		heartbeat-led {
+			label = "status0:blue:heartbeat";
+			gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "heartbeat";
+		};
+
+		usr1-led {
+			label = "status1:red:usr";
+			gpios = <&gpio2 28 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		usr2-led {
+			label = "status1:green:usr";
+			gpios = <&gpio2 21 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		mmc0-led {
+			label = "status1:blue:mmc0";
+			gpios = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "mmc0";
+		};
+	};
+
+	extcon_usb2: extcon_usb2 {
+	     compatible = "linux,extcon-usb-gpio";
+	     id-gpio = <&gpio5 7 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&dra7_pmx_core {
+	mmc1_pins_default: mmc1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: mmc1_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: mmc2_pins_ddr_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_conf: mmc1_iodelay_ddr50_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_CLK_IN */
+			0x624 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_CMD_IN */
+			0x630 A_DELAY_PS(495) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x63C A_DELAY_PS(116) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x648 A_DELAY_PS(117) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x654 A_DELAY_PS(32) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x620 A_DELAY_PS(1224) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(44) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(64) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(79) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65C A_DELAY_PS(87) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_DAT1_OEN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(520) G_DELAY_PS(320)	/* CFG_MMC1_CLK_OUT */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(40) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(83) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(98) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65c A_DELAY_PS(106) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(51) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(363) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64c A_DELAY_PS(199) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(273) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc2_iodelay_ddr_1_8v_conf: mmc2_iodelay_ddr_1_8v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(121) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(108) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(31) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(24) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_CS1_IN */
+			0x194 A_DELAY_PS(152) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(206) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(78) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(2) G_DELAY_PS(0)		/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(266) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(43) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)		/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_conf>;
+};
+
+&omap_dwc3_2 {
+	extcon = <&extcon_usb2>;
+};
diff -u -N U-Boot_SDcard/board/htkw/mcx/mcx.c U-Boot_SDcard/board/htkw/mcx/mcx.c
--- U-Boot_SDcard/board/htkw/mcx/mcx.c	2019-09-12 15:54:21.000000069 -0500
+++ U-Boot_SDcard/board/htkw/mcx/mcx.c	1969-12-31 19:29:26.000000297 -0600
@@ -100,7 +100,7 @@
 	MUX_MCX();
 }
 
-#if defined(CONFIG_OMAP_HSMMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_OMAP_HSMMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/drivers/core/root.c U-Boot_SDcard/drivers/core/root.c
--- U-Boot_SDcard/drivers/core/root.c	2019-09-12 15:54:38.000000477 -0500
+++ U-Boot_SDcard/drivers/core/root.c	1969-12-31 19:29:20.000000935 -0600
@@ -44,8 +44,10 @@
 void dm_fixup_for_gd_move(struct global_data *new_gd)
 {
 	/* The sentinel node has moved, so update things that point to it */
-	new_gd->uclass_root.next->prev = &new_gd->uclass_root;
-	new_gd->uclass_root.prev->next = &new_gd->uclass_root;
+	if (gd->dm_root) {
+		new_gd->uclass_root.next->prev = &new_gd->uclass_root;
+		new_gd->uclass_root.prev->next = &new_gd->uclass_root;
+	}
 }
 
 fdt_addr_t dm_get_translation_offset(void)
@@ -205,7 +207,7 @@
 	     offset > 0;
 	     offset = fdt_next_subnode(blob, offset)) {
 		if (pre_reloc_only &&
-		    !fdt_getprop(blob, offset, "u-boot,dm-pre-reloc", NULL))
+		    !dm_fdt_pre_reloc(blob, offset))
 			continue;
 		if (!fdtdec_get_is_enabled(blob, offset)) {
 			dm_dbg("   - ignoring disabled device\n");
diff -u -N U-Boot_SDcard/include/dfu.h U-Boot_SDcard/include/dfu.h
--- U-Boot_SDcard/include/dfu.h	2019-09-12 15:54:18.000000715 -0500
+++ U-Boot_SDcard/include/dfu.h	1969-12-31 19:29:19.000000112 -0600
@@ -203,7 +203,7 @@
 int dfu_write_from_mem_addr(struct dfu_entity *dfu, void *buf, int size);
 
 /* Device specific */
-#ifdef CONFIG_DFU_MMC
+#if CONFIG_IS_ENABLED(DFU_MMC)
 extern int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr, char *s);
 #else
 static inline int dfu_fill_entity_mmc(struct dfu_entity *dfu, char *devstr,
diff -u -N U-Boot_SDcard/arch/arm/dts/dra72-evm.dts U-Boot_SDcard/arch/arm/dts/dra72-evm.dts
--- U-Boot_SDcard/arch/arm/dts/dra72-evm.dts	2019-09-12 15:54:40.000000389 -0500
+++ U-Boot_SDcard/arch/arm/dts/dra72-evm.dts	1969-12-31 19:29:23.000000303 -0600
@@ -1,45 +1,220 @@
-/*
- * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include "dra72-evm-common.dtsi"
-/ {
-	model = "TI DRA722";
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x40000000>; /* 1024 MB */
-	};
-};
-
-&i2c1 {
-	tps65917: tps65917@58 {
-		reg = <0x58>;
-
-		interrupts = <GIC_SPI 2 IRQ_TYPE_NONE>;  /* IRQ_SYS_1N */
-	};
-};
-
-#include "dra72-evm-tps65917.dtsi"
-
-&hdmi {
-	vdda-supply = <&ldo3_reg>;
-};
-
-&pcf_gpio_21 {
-	interrupt-parent = <&gpio6>;
-	interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
-};
-
-&mac {
-	slaves = <1>;
-	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_HIGH>;
-};
-
-&cpsw_emac0 {
-	phy_id = <&davinci_mdio>, <3>;
-	phy-mode = "rgmii";
-};
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "dra72-evm-common.dtsi"
+/ {
+	model = "TI DRA722";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x40000000>; /* 1024 MB */
+	};
+};
+
+&i2c1 {
+	tps65917: tps65917@58 {
+		reg = <0x58>;
+
+		interrupts = <GIC_SPI 2 IRQ_TYPE_NONE>;  /* IRQ_SYS_1N */
+	};
+};
+
+#include "dra72-evm-tps65917.dtsi"
+
+&dra7_pmx_core {
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_clk.mmc1_clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_cmd.mmc1_cmd */
+			DRA7XX_CORE_IOPAD(0x375C, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat0.mmc1_dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat1.mmc1_dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat2.mmc1_dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat3.mmc1_dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_clk.mmc1_clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_cmd.mmc1_cmd */
+			DRA7XX_CORE_IOPAD(0x375C, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_dat0.mmc1_dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_dat1.mmc1_dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_dat2.mmc1_dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE14 | MUX_MODE0)	/* mmc1_dat3.mmc1_dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.mmc1_clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.mmc1_cmd */
+			DRA7XX_CORE_IOPAD(0x375C, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.mmc1_dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.mmc1_dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.mmc1_dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.mmc1_dat3 */
+		>;
+	};
+
+	mmc2_pins_hs: pinmux_mmc2_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a22.mmc2_dat7 */
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_cs1.mmc2_cmd */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: pinmux_mmc2_ddr_1_8v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a22.mmc2_dat7 */
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1)	/* gpmc_cs1.mmc2_cmd */
+		>;
+	};
+
+	mmc2_pins_hs200_1_8v: pinmux_mmc2_hs200_1_8v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a22.mmc2_dat7 */
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1)	/* gpmc_cs1.mmc2_cmd */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(560) G_DELAY_PS(365)	/* CFG_MMC1_CLK_OUT */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(29) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(47) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65c A_DELAY_PS(30) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(125) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(43) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(433) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64c A_DELAY_PS(287) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(351) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc2_iodelay_hs200_1_8v_conf: mmc2_iodelay_hs200_1_8v_conf {
+		pinctrl-pin-array = <
+			0x194 A_DELAY_PS(150) G_DELAY_PS(95)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(250) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(125) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(100) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(870) G_DELAY_PS(415)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(30) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(200) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(200) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(240) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(695) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(924) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(719) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(824) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(877) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(446) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(847) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(586) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(1039) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+};
+
+&hdmi {
+	vdda-supply = <&ldo3_reg>;
+};
+
+&pcf_gpio_21 {
+	interrupt-parent = <&gpio6>;
+	interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+	vmmc_aux-supply = <&ldo1_reg>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v", "hs200_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v>;
+	pinctrl-3 = <&mmc2_pins_hs200_1_8v &mmc2_iodelay_hs200_1_8v_conf>;
+};
+
+&mac {
+	slaves = <1>;
+	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_HIGH>;
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <3>;
+	phy-mode = "rgmii";
+};
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c
--- U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c	2019-09-12 15:55:02.000000337 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/boot-common.c	1969-12-31 19:29:23.000000891 -0600
@@ -178,13 +178,6 @@
 
 void spl_board_init(void)
 {
-	/*
-	 * Save the boot parameters passed from romcode.
-	 * We cannot delay the saving further than this,
-	 * to prevent overwrites.
-	 */
-	save_omap_boot_params();
-
 	/* Prepare console output */
 	preloader_console_init();
 
@@ -205,21 +198,6 @@
 #endif
 }
 
-__weak int board_mmc_init(bd_t *bis)
-{
-	switch (spl_boot_device()) {
-	case BOOT_DEVICE_MMC1:
-		omap_mmc_init(0, 0, 0, -1, -1);
-		break;
-	case BOOT_DEVICE_MMC2:
-	case BOOT_DEVICE_MMC2_2:
-		omap_mmc_init(0, 0, 0, -1, -1);
-		omap_mmc_init(1, 0, 0, -1, -1);
-		break;
-	}
-	return 0;
-}
-
 void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 {
 	typedef void __noreturn (*image_entry_noargs_t)(u32 *);
diff -u -N U-Boot_SDcard/include/configs/ti_omap4_common.h U-Boot_SDcard/include/configs/ti_omap4_common.h
--- U-Boot_SDcard/include/configs/ti_omap4_common.h	2019-09-12 15:54:37.000000429 -0500
+++ U-Boot_SDcard/include/configs/ti_omap4_common.h	1969-12-31 19:29:22.000000531 -0600
@@ -106,6 +106,7 @@
 	"run distro_bootcmd"
 
 #include <config_distro_bootcmd.h>
+#include <environment/ti/mmc.h>
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	DEFAULT_LINUX_BOOT_ENV \
diff -u -N U-Boot_SDcard/drivers/mmc/mvebu_mmc.c U-Boot_SDcard/drivers/mmc/mvebu_mmc.c
--- U-Boot_SDcard/drivers/mmc/mvebu_mmc.c	2019-09-12 15:54:51.000000595 -0500
+++ U-Boot_SDcard/drivers/mmc/mvebu_mmc.c	1969-12-31 19:29:21.000000200 -0600
@@ -316,12 +316,14 @@
 	mvebu_mmc_write(SDIO_HOST_CTRL, ctrl_reg);
 }
 
-static void mvebu_mmc_set_ios(struct mmc *mmc)
+static int mvebu_mmc_set_ios(struct mmc *mmc)
 {
 	debug("%s: bus[%d] clock[%d]\n", DRIVER_NAME,
 	      mmc->bus_width, mmc->clock);
 	mvebu_mmc_set_bus(mmc->bus_width);
 	mvebu_mmc_set_clk(mmc->clock);
+
+	return 0;
 }
 
 /*
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/board.c U-Boot_SDcard/board/ti/ks2_evm/board.c
--- U-Boot_SDcard/board/ti/ks2_evm/board.c	2019-09-12 15:55:00.000000362 -0500
+++ U-Boot_SDcard/board/ti/ks2_evm/board.c	1969-12-31 19:29:27.000000202 -0600
@@ -16,10 +16,22 @@
 #include <asm/arch/psc_defs.h>
 #include <asm/arch/clock.h>
 #include <asm/ti-common/ti-aemif.h>
+#include <asm/ti-common/ti-gpmc.h>
 #include <asm/ti-common/keystone_net.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#if defined(CONFIG_TI_GPMC)
+static struct ti_gpmc_config gpmc_config = {
+	.config1 = M_NAND_GPMC_CONFIG1,
+	.config2 = M_NAND_GPMC_CONFIG2,
+	.config3 = M_NAND_GPMC_CONFIG3,
+	.config4 = M_NAND_GPMC_CONFIG4,
+	.config5 = M_NAND_GPMC_CONFIG5,
+	.config6 = M_NAND_GPMC_CONFIG6,
+};
+#endif
+
 #if defined(CONFIG_TI_AEMIF)
 static struct aemif_config aemif_configs[] = {
 	{			/* CS0 */
@@ -45,13 +57,17 @@
 	gd->ram_size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
 				    CONFIG_MAX_RAM_BANK_SIZE);
 #if defined(CONFIG_TI_AEMIF)
-	aemif_init(ARRAY_SIZE(aemif_configs), aemif_configs);
+	if (!board_is_k2g_ice())
+		aemif_init(ARRAY_SIZE(aemif_configs), aemif_configs);
 #endif
 
-	if (ddr3_size)
-		ddr3_init_ecc(KS2_DDR3A_EMIF_CTRL_BASE, ddr3_size);
-	else
-		ddr3_init_ecc(KS2_DDR3A_EMIF_CTRL_BASE, gd->ram_size >> 30);
+	if (!board_is_k2g_ice()) {
+		if (ddr3_size)
+			ddr3_init_ecc(KS2_DDR3A_EMIF_CTRL_BASE, ddr3_size);
+		else
+			ddr3_init_ecc(KS2_DDR3A_EMIF_CTRL_BASE,
+				      gd->ram_size >> 30);
+	}
 
 	return 0;
 }
@@ -60,6 +76,13 @@
 {
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 
+#if defined(CONFIG_TI_GPMC)
+	ti_gpmc_init(&gpmc_config);
+#endif
+
+#if defined(CONFIG_TI_AEMIF)
+	aemif_init(ARRAY_SIZE(aemif_configs), aemif_configs);
+#endif
 	return 0;
 }
 
@@ -277,3 +300,10 @@
 	ddr3_check_ecc_int(KS2_DDR3A_EMIF_CTRL_BASE);
 }
 #endif /* CONFIG_OF_BOARD_SETUP */
+
+#if defined(CONFIG_DTB_RESELECT)
+int __weak embedded_dtb_select(void)
+{
+	return 0;
+}
+#endif
diff -u -N U-Boot_SDcard/board/ti/dra7xx/evm.c U-Boot_SDcard/board/ti/dra7xx/evm.c
--- U-Boot_SDcard/board/ti/dra7xx/evm.c	2019-09-12 15:54:18.000000499 -0500
+++ U-Boot_SDcard/board/ti/dra7xx/evm.c	1969-12-31 19:29:27.000000191 -0600
@@ -438,14 +438,18 @@
 	 * and are powered by BUCK1 of LP873X PMIC
 	 */
 	.eve.value[OPP_NOM]	= VDD_EVE_DRA7_NOM,
+	.eve.value[OPP_HIGH]	= VDD_EVE_DRA7_HIGH,
 	.eve.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_DSPEVE_NOM,
+	.eve.efuse.reg[OPP_HIGH] = STD_FUSE_OPP_VMIN_DSPEVE_HIGH,
 	.eve.efuse.reg_bits = DRA752_EFUSE_REGBITS,
 	.eve.addr	= LP873X_REG_ADDR_BUCK1,
 	.eve.pmic	= &lp8733,
 	.eve.abb_tx_done_mask = OMAP_ABB_EVE_TXDONE_MASK,
 
 	.iva.value[OPP_NOM]	= VDD_IVA_DRA7_NOM,
+	.iva.value[OPP_HIGH]	= VDD_IVA_DRA7_HIGH,
 	.iva.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_IVA_NOM,
+	.iva.efuse.reg[OPP_HIGH] = STD_FUSE_OPP_VMIN_IVA_HIGH,
 	.iva.efuse.reg_bits = DRA752_EFUSE_REGBITS,
 	.iva.addr	= LP873X_REG_ADDR_BUCK1,
 	.iva.pmic	= &lp8733,
@@ -456,27 +460,44 @@
 {
 	int opp;
 
-	/*
-	 * DRA71x supports only OPP_NOM.
-	 */
-	if (board_is_dra71x_evm())
-		return OPP_NOM;
-
 	switch (rail_offset) {
 	case VOLT_MPU:
 		opp = DRA7_MPU_OPP;
+		/* DRA71x supports only OPP_NOM for MPU */
+		if (board_is_dra71x_evm())
+			opp = OPP_NOM;
 		break;
 	case VOLT_CORE:
 		opp = DRA7_CORE_OPP;
+		/* DRA71x supports only OPP_NOM for CORE */
+		if (board_is_dra71x_evm())
+			opp = OPP_NOM;
 		break;
 	case VOLT_GPU:
 		opp = DRA7_GPU_OPP;
+		/* DRA71x supports only OPP_NOM for GPU */
+		if (board_is_dra71x_evm())
+			opp = OPP_NOM;
 		break;
 	case VOLT_EVE:
 		opp = DRA7_DSPEVE_OPP;
+		/*
+		 * DRA71x does not support OPP_OD for EVE.
+		 * If OPP_OD is selected by menuconfig, fallback
+		 * to OPP_NOM.
+		 */
+		if (board_is_dra71x_evm() && opp == OPP_OD)
+			opp = OPP_NOM;
 		break;
 	case VOLT_IVA:
 		opp = DRA7_IVA_OPP;
+		/*
+		 * DRA71x does not support OPP_OD for IVA.
+		 * If OPP_OD is selected by menuconfig, fallback
+		 * to OPP_NOM.
+		 */
+		if (board_is_dra71x_evm() && opp == OPP_OD)
+			opp = OPP_NOM;
 		break;
 	default:
 		opp = OPP_NOM;
@@ -679,7 +700,7 @@
 }
 #endif
 
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_GENERIC_MMC)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	omap_mmc_init(0, 0, 0, -1, -1);
@@ -688,6 +709,86 @@
 }
 #endif
 
+#ifdef CONFIG_OMAP_HSMMC
+#if defined(CONFIG_IODELAY_RECALIBRATION) && defined(CONFIG_SPL_BUILD)
+
+struct pinctrl_desc {
+	const char *name;
+	struct omap_hsmmc_pinctrl_state *pinctrl;
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc1[] = {
+	{"default", &hsmmc1_default},
+	{"hs", &hsmmc1_default},
+	{NULL}
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc2_rev20[] = {
+	{"default", &hsmmc2_default_hs},
+	{"hs", &hsmmc2_default_hs},
+	{"ddr_1_8v", &hsmmc2_ddr_1v8_rev20},
+	{"hs200_1_8v", &hsmmc2_hs200_1v8_rev20},
+	{NULL}
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc2_rev11[] = {
+	{"default", &hsmmc2_default_hs},
+	{"hs", &hsmmc2_default_hs},
+	{"ddr_1_8v", &hsmmc2_ddr_1v8_rev11},
+	{"hs200_1_8v", &hsmmc2_hs200_1v8_rev11},
+	{NULL}
+};
+
+static struct pinctrl_desc pinctrl_descs_hsmmc2_dra72x[] = {
+	{"default", &hsmmc2_default_hs},
+	{"hs", &hsmmc2_default_hs},
+	{"ddr_1_8v", &hsmmc2_ddr_1v8_dra72},
+	{"hs200_1_8v", &hsmmc2_hs200_1v8_dra72},
+	{NULL}
+};
+
+struct omap_hsmmc_pinctrl_state *platform_fixup_get_pinctrl_by_mode
+				  (struct hsmmc *base, const char *mode)
+{
+	struct pinctrl_desc *p = NULL;
+
+	switch ((u32)&base->res1) {
+	case OMAP_HSMMC1_BASE:
+		p = pinctrl_descs_hsmmc1;
+		break;
+	case OMAP_HSMMC2_BASE:
+		if ((omap_revision() == DRA752_ES1_0) ||
+		    (omap_revision() == DRA752_ES1_1))
+			p = pinctrl_descs_hsmmc2_rev11;
+		else if (is_dra72x())
+			p = pinctrl_descs_hsmmc2_dra72x;
+		else if (is_dra7xx())
+			p = pinctrl_descs_hsmmc2_rev20;
+		break;
+	default:
+		break;
+	}
+
+	if (!p) {
+		printf("%s no pinctrl defined for MMC@%p\n", __func__,
+		       base);
+		return NULL;
+	}
+	while (p->name) {
+		if (strcmp(mode, p->name) == 0)
+			return p->pinctrl;
+		p++;
+	}
+	return NULL;
+}
+#endif
+
+int platform_fixup_disable_uhs_mode(void)
+{
+	return omap_revision() == DRA752_ES1_1;
+}
+#endif
+
 #ifdef CONFIG_USB_DWC3
 static struct dwc3_device usb_otg_ss1 = {
 	.maximum_speed = USB_SPEED_SUPER,
diff -u -N U-Boot_SDcard/lib/tiny-printf.c U-Boot_SDcard/lib/tiny-printf.c
--- U-Boot_SDcard/lib/tiny-printf.c	2019-09-12 15:54:59.000000656 -0500
+++ U-Boot_SDcard/lib/tiny-printf.c	1969-12-31 19:29:19.000000492 -0600
@@ -12,6 +12,7 @@
 #include <common.h>
 #include <stdarg.h>
 #include <serial.h>
+#include <linux/ctype.h>
 
 struct printf_info {
 	char *bf;	/* Digit buffer */
@@ -38,8 +39,8 @@
 	info->zs = 1;
 }
 
-static void div_out(struct printf_info *info, unsigned int *num,
-		    unsigned int div)
+static void div_out(struct printf_info *info, unsigned long *num,
+		    unsigned long div)
 {
 	unsigned char dgt = 0;
 
@@ -52,13 +53,161 @@
 		out_dgt(info, dgt);
 }
 
+#ifdef CONFIG_SPL_NET_SUPPORT
+static void string(struct printf_info *info, char *s)
+{
+	char ch;
+
+	while ((ch = *s++))
+		out(info, ch);
+}
+
+static const char hex_asc[] = "0123456789abcdef";
+#define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]
+#define hex_asc_hi(x)	hex_asc[((x) & 0xf0) >> 4]
+
+static inline char *pack_hex_byte(char *buf, u8 byte)
+{
+	*buf++ = hex_asc_hi(byte);
+	*buf++ = hex_asc_lo(byte);
+	return buf;
+}
+
+static void mac_address_string(struct printf_info *info, u8 *addr,
+				bool separator)
+{
+	/* (6 * 2 hex digits), 5 colons and trailing zero */
+	char mac_addr[6 * 3];
+	char *p = mac_addr;
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		p = pack_hex_byte(p, addr[i]);
+		if (separator && i != 5)
+			*p++ = ':';
+	}
+	*p = '\0';
+
+	string(info, mac_addr);
+}
+
+static char *put_dec_trunc(char *buf, unsigned int q)
+{
+	unsigned int d3, d2, d1, d0;
+	d1 = (q >> 4) & 0xf;
+	d2 = (q >> 8) & 0xf;
+	d3 = (q >> 12);
+
+	d0 = 6 * (d3 + d2 + d1) + (q & 0xf);
+	q = (d0 * 0xcd) >> 11;
+	d0 = d0 - 10 * q;
+	*buf++ = d0 + '0'; /* least significant digit */
+	d1 = q + 9 * d3 + 5 * d2 + d1;
+	if (d1 != 0) {
+		q = (d1 * 0xcd) >> 11;
+		d1 = d1 - 10 * q;
+		*buf++ = d1 + '0'; /* next digit */
+
+		d2 = q + 2 * d2;
+		if ((d2 != 0) || (d3 != 0)) {
+			q = (d2 * 0xd) >> 7;
+			d2 = d2 - 10 * q;
+			*buf++ = d2 + '0'; /* next digit */
+
+			d3 = q + 4 * d3;
+			if (d3 != 0) {
+				q = (d3 * 0xcd) >> 11;
+				d3 = d3 - 10 * q;
+				*buf++ = d3 + '0';  /* next digit */
+				if (q != 0)
+					*buf++ = q + '0'; /* most sign. digit */
+			}
+		}
+	}
+	return buf;
+}
+
+static void ip4_addr_string(struct printf_info *info, u8 *addr)
+{
+	/* (4 * 3 decimal digits), 3 dots and trailing zero */
+	char ip4_addr[4 * 4];
+	char temp[3];	/* hold each IP quad in reverse order */
+	char *p = ip4_addr;
+	int i, digits;
+
+	for (i = 0; i < 4; i++) {
+		digits = put_dec_trunc(temp, addr[i]) - temp;
+		/* reverse the digits in the quad */
+		while (digits--)
+			*p++ = temp[digits];
+		if (i != 3)
+			*p++ = '.';
+	}
+	*p = '\0';
+
+	string(info, ip4_addr);
+}
+#endif
+
+/*
+ * Show a '%p' thing.  A kernel extension is that the '%p' is followed
+ * by an extra set of characters that are extended format
+ * specifiers.
+ *
+ * Right now we handle:
+ *
+ * - 'M' For a 6-byte MAC address, it prints the address in the
+ *       usual colon-separated hex notation.
+ * - 'm' Same as above except there is no colon-separator.
+ * - 'I4'for IPv4 addresses printed in the usual way (dot-separated
+ *       decimal).
+ */
+
+static void pointer(struct printf_info *info, const char *fmt, void *ptr)
+{
+#ifdef DEBUG
+	unsigned long num = (uintptr_t)ptr;
+	unsigned long div;
+#endif
+
+	switch (*fmt) {
+#ifdef DEBUG
+	case 'a':
+
+		switch (fmt[1]) {
+		case 'p':
+		default:
+			num = *(phys_addr_t *)ptr;
+			break;
+		}
+		break;
+#endif
+#ifdef CONFIG_SPL_NET_SUPPORT
+	case 'm':
+		return mac_address_string(info, ptr, false);
+	case 'M':
+		return mac_address_string(info, ptr, true);
+	case 'I':
+		if (fmt[1] == '4')
+			return ip4_addr_string(info, ptr);
+#endif
+	default:
+		break;
+	}
+#ifdef DEBUG
+	div = 1UL << (sizeof(long) * 8 - 4);
+	for (; div; div /= 0x10)
+		div_out(info, &num, div);
+#endif
+}
+
 int _vprintf(struct printf_info *info, const char *fmt, va_list va)
 {
 	char ch;
 	char *p;
-	unsigned int num;
+	unsigned long num;
 	char buf[12];
-	unsigned int div;
+	unsigned long div;
 
 	while ((ch = *(fmt++))) {
 		if (ch != '%') {
@@ -66,6 +215,7 @@
 		} else {
 			bool lz = false;
 			int width = 0;
+			bool islong = false;
 
 			ch = *(fmt++);
 			if (ch == '0') {
@@ -80,6 +230,11 @@
 					ch = *fmt++;
 				}
 			}
+			if (ch == 'l') {
+				ch = *(fmt++);
+				islong = true;
+			}
+
 			info->bf = buf;
 			p = info->bf;
 			info->zs = 0;
@@ -89,24 +244,43 @@
 				goto abort;
 			case 'u':
 			case 'd':
-				num = va_arg(va, unsigned int);
-				if (ch == 'd' && (int)num < 0) {
-					num = -(int)num;
-					out(info, '-');
+				div = 1000000000;
+				if (islong) {
+					num = va_arg(va, unsigned long);
+					if (sizeof(long) > 4)
+						div *= div * 10;
+				} else {
+					num = va_arg(va, unsigned int);
+				}
+
+				if (ch == 'd') {
+					if (islong && (long)num < 0) {
+						num = -(long)num;
+						out(info, '-');
+					} else if (!islong && (int)num < 0) {
+						num = -(int)num;
+						out(info, '-');
+					}
 				}
 				if (!num) {
 					out_dgt(info, 0);
 				} else {
-					for (div = 1000000000; div; div /= 10)
+					for (; div; div /= 10)
 						div_out(info, &num, div);
 				}
 				break;
 			case 'x':
-				num = va_arg(va, unsigned int);
+				if (islong) {
+					num = va_arg(va, unsigned long);
+					div = 1UL << (sizeof(long) * 8 - 4);
+				} else {
+					num = va_arg(va, unsigned int);
+					div = 0x10000000;
+				}
 				if (!num) {
 					out_dgt(info, 0);
 				} else {
-					for (div = 0x10000000; div; div /= 0x10)
+					for (; div; div /= 0x10)
 						div_out(info, &num, div);
 				}
 				break;
@@ -116,6 +290,11 @@
 			case 's':
 				p = va_arg(va, char*);
 				break;
+			case 'p':
+				pointer(info, fmt, va_arg(va, void *));
+				while (isalnum(fmt[0]))
+					fmt++;
+				break;
 			case '%':
 				out(info, '%');
 			default:
diff -u -N U-Boot_SDcard/board/ti/am335x/board.c U-Boot_SDcard/board/ti/am335x/board.c
--- U-Boot_SDcard/board/ti/am335x/board.c	2019-09-12 15:54:31.000000482 -0500
+++ U-Boot_SDcard/board/ti/am335x/board.c	1969-12-31 19:29:27.000000157 -0600
@@ -34,6 +34,9 @@
 #include <environment.h>
 #include <watchdog.h>
 #include <environment.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
 #include "../common/board_detect.h"
 #include "board.h"
 
@@ -254,163 +257,215 @@
 }
 #endif
 
-#define OSC	(V_OSCK/1000000)
-const struct dpll_params dpll_ddr = {
-		266, OSC-1, 1, -1, -1, -1, -1};
-const struct dpll_params dpll_ddr_evm_sk = {
-		303, OSC-1, 1, -1, -1, -1, -1};
-const struct dpll_params dpll_ddr_bone_black = {
-		400, OSC-1, 1, -1, -1, -1, -1};
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	int ind = get_sys_clk_index();
+
+	if (board_is_evm_sk())
+		return &dpll_ddr3_303MHz[ind];
+	else if (board_is_bone_lt() || board_is_icev2())
+		return &dpll_ddr3_400MHz[ind];
+	else if (board_is_evm_15_or_later())
+		return &dpll_ddr3_303MHz[ind];
+	else
+		return &dpll_ddr2_266MHz[ind];
+}
+
+static u8 bone_not_connected_to_ac_power(void)
+{
+	if (board_is_bone()) {
+		uchar pmic_status_reg;
+		if (tps65217_reg_read(TPS65217_STATUS,
+				      &pmic_status_reg))
+			return 1;
+		if (!(pmic_status_reg & TPS65217_PWR_SRC_AC_BITMASK)) {
+			puts("No AC power, switching to default OPP\n");
+			return 1;
+		}
+	}
+	return 0;
+}
 
-void am33xx_spl_board_init(void)
+const struct dpll_params *get_dpll_mpu_params(void)
 {
-	int mpu_vdd;
+	int ind = get_sys_clk_index();
+	int freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
 
-	/* Get the frequency */
-	dpll_mpu_opp100.m = am335x_get_efuse_mpu_max_freq(cdev);
+	if (board_is_bone_lt())
+		freq = MPUPLL_M_1000;
 
-	if (board_is_bone() || board_is_bone_lt()) {
-		/* BeagleBone PMIC Code */
-		int usb_cur_lim;
+	switch (freq) {
+	case MPUPLL_M_1000:
+		return &dpll_mpu_opp[ind][5];
+	case MPUPLL_M_800:
+		return &dpll_mpu_opp[ind][4];
+	case MPUPLL_M_720:
+		return &dpll_mpu_opp[ind][3];
+	case MPUPLL_M_600:
+		return &dpll_mpu_opp[ind][2];
+	case MPUPLL_M_500:
+		return &dpll_mpu_opp100;
+	case MPUPLL_M_300:
+		return &dpll_mpu_opp[ind][0];
+	}
 
-		/*
-		 * Only perform PMIC configurations if board rev > A1
-		 * on Beaglebone White
-		 */
-		if (board_is_bone() && !strncmp(board_ti_get_rev(), "00A1", 4))
-			return;
+	return &dpll_mpu_opp[ind][0];
+}
 
-		if (i2c_probe(TPS65217_CHIP_PM))
-			return;
+static void scale_vcores_bone(int freq)
+{
+	int usb_cur_lim, mpu_vdd;
 
-		/*
-		 * On Beaglebone White we need to ensure we have AC power
-		 * before increasing the frequency.
-		 */
-		if (board_is_bone()) {
-			uchar pmic_status_reg;
-			if (tps65217_reg_read(TPS65217_STATUS,
-					      &pmic_status_reg))
-				return;
-			if (!(pmic_status_reg & TPS65217_PWR_SRC_AC_BITMASK)) {
-				puts("No AC power, disabling frequency switch\n");
-				return;
-			}
-		}
+	/*
+	 * Only perform PMIC configurations if board rev > A1
+	 * on Beaglebone White
+	 */
+	if (board_is_bone() && !strncmp(board_ti_get_rev(), "00A1", 4))
+		return;
 
-		/*
-		 * Override what we have detected since we know if we have
-		 * a Beaglebone Black it supports 1GHz.
-		 */
-		if (board_is_bone_lt())
-			dpll_mpu_opp100.m = MPUPLL_M_1000;
+	if (i2c_probe(TPS65217_CHIP_PM))
+		return;
 
-		/*
-		 * Increase USB current limit to 1300mA or 1800mA and set
-		 * the MPU voltage controller as needed.
-		 */
-		if (dpll_mpu_opp100.m == MPUPLL_M_1000) {
-			usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1800MA;
-			mpu_vdd = TPS65217_DCDC_VOLT_SEL_1325MV;
-		} else {
-			usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
-			mpu_vdd = TPS65217_DCDC_VOLT_SEL_1275MV;
-		}
+	/*
+	 * On Beaglebone White we need to ensure we have AC power
+	 * before increasing the frequency.
+	 */
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
 
-		if (tps65217_reg_write(TPS65217_PROT_LEVEL_NONE,
-				       TPS65217_POWER_PATH,
-				       usb_cur_lim,
-				       TPS65217_USB_INPUT_CUR_LIMIT_MASK))
-			puts("tps65217_reg_write failure\n");
+	/*
+	 * Override what we have detected since we know if we have
+	 * a Beaglebone Black it supports 1GHz.
+	 */
+	if (board_is_bone_lt())
+		freq = MPUPLL_M_1000;
 
-		/* Set DCDC3 (CORE) voltage to 1.125V */
-		if (tps65217_voltage_update(TPS65217_DEFDCDC3,
-					    TPS65217_DCDC_VOLT_SEL_1125MV)) {
-			puts("tps65217_voltage_update failure\n");
-			return;
-		}
+	switch (freq) {
+	case MPUPLL_M_1000:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1325MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1800MA;
+		break;
+	case MPUPLL_M_800:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1275MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_720:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1200MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_600:
+	case MPUPLL_M_500:
+	case MPUPLL_M_300:
+	default:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1100MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	}
 
-		/* Set CORE Frequencies to OPP100 */
-		do_setup_dpll(&dpll_core_regs, &dpll_core_opp100);
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_NONE,
+			       TPS65217_POWER_PATH,
+			       usb_cur_lim,
+			       TPS65217_USB_INPUT_CUR_LIMIT_MASK))
+		puts("tps65217_reg_write failure\n");
 
-		/* Set DCDC2 (MPU) voltage */
-		if (tps65217_voltage_update(TPS65217_DEFDCDC2, mpu_vdd)) {
-			puts("tps65217_voltage_update failure\n");
-			return;
-		}
+	/* Set DCDC3 (CORE) voltage to 1.10V */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC3,
+				    TPS65217_DCDC_VOLT_SEL_1100MV)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
 
-		/*
-		 * Set LDO3, LDO4 output voltage to 3.3V for Beaglebone.
-		 * Set LDO3 to 1.8V and LDO4 to 3.3V for Beaglebone Black.
-		 */
-		if (board_is_bone()) {
-			if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
-					       TPS65217_DEFLS1,
-					       TPS65217_LDO_VOLTAGE_OUT_3_3,
-					       TPS65217_LDO_MASK))
-				puts("tps65217_reg_write failure\n");
-		} else {
-			if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
-					       TPS65217_DEFLS1,
-					       TPS65217_LDO_VOLTAGE_OUT_1_8,
-					       TPS65217_LDO_MASK))
-				puts("tps65217_reg_write failure\n");
-		}
+	/* Set DCDC2 (MPU) voltage */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC2, mpu_vdd)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
 
+	/*
+	 * Set LDO3, LDO4 output voltage to 3.3V for Beaglebone.
+	 * Set LDO3 to 1.8V and LDO4 to 3.3V for Beaglebone Black.
+	 */
+	if (board_is_bone()) {
 		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
-				       TPS65217_DEFLS2,
+				       TPS65217_DEFLS1,
 				       TPS65217_LDO_VOLTAGE_OUT_3_3,
 				       TPS65217_LDO_MASK))
 			puts("tps65217_reg_write failure\n");
 	} else {
-		int sil_rev;
+		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				       TPS65217_DEFLS1,
+				       TPS65217_LDO_VOLTAGE_OUT_1_8,
+				       TPS65217_LDO_MASK))
+			puts("tps65217_reg_write failure\n");
+	}
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+			       TPS65217_DEFLS2,
+			       TPS65217_LDO_VOLTAGE_OUT_3_3,
+			       TPS65217_LDO_MASK))
+		puts("tps65217_reg_write failure\n");
+}
+
+void scale_vcores_generic(int freq)
+{
+	int sil_rev, mpu_vdd;
+
+	/*
+	 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+	 * MPU frequencies we support we use a CORE voltage of
+	 * 1.10V.  For MPU voltage we need to switch based on
+	 * the frequency we are running at.
+	 */
+	if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		return;
+
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, freq);
 
-		/*
-		 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
-		 * MPU frequencies we support we use a CORE voltage of
-		 * 1.1375V.  For MPU voltage we need to switch based on
-		 * the frequency we are running at.
-		 */
-		if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
-			return;
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
 
-		/*
-		 * Depending on MPU clock and PG we will need a different
-		 * VDD to drive at that speed.
-		 */
-		sil_rev = readl(&cdev->deviceid) >> 28;
-		mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev,
-						      dpll_mpu_opp100.m);
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
 
-		/* Tell the TPS65910 to use i2c */
-		tps65910_set_i2c_control();
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_0))
+		return;
 
-		/* First update MPU voltage. */
-		if (tps65910_voltage_update(MPU, mpu_vdd))
-			return;
+}
 
-		/* Second, update the CORE voltage. */
-		if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
-			return;
+void gpi2c_init(void)
+{
+	/* When needed to be invoked prior to BSS initialization */
+	static bool first_time = true;
 
-		/* Set CORE Frequencies to OPP100 */
-		do_setup_dpll(&dpll_core_regs, &dpll_core_opp100);
+	if (first_time) {
+		enable_i2c0_pin_mux();
+		i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED,
+			 CONFIG_SYS_OMAP24_I2C_SLAVE);
+		first_time = false;
 	}
-
-	/* Set MPU Frequency to what we detected now that voltages are set */
-	do_setup_dpll(&dpll_mpu_regs, &dpll_mpu_opp100);
 }
 
-const struct dpll_params *get_dpll_ddr_params(void)
+void scale_vcores(void)
 {
-	if (board_is_evm_sk())
-		return &dpll_ddr_evm_sk;
-	else if (board_is_bone_lt() || board_is_icev2())
-		return &dpll_ddr_bone_black;
-	else if (board_is_evm_15_or_later())
-		return &dpll_ddr_evm_sk;
+	int freq;
+
+	gpi2c_init();
+	freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	if (board_is_beaglebonex())
+		scale_vcores_bone(freq);
 	else
-		return &dpll_ddr;
+		scale_vcores_generic(freq);
 }
 
 void set_uart_mux_conf(void)
@@ -551,6 +606,14 @@
 };
 #endif
 
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP))
+
+static bool eth0_is_mii;
+static bool eth1_is_mii;
+#endif
+
 /*
  * Basic board specific setup.  Pinmux has been handled already.
  */
@@ -571,6 +634,10 @@
 		int rv;
 		u32 reg;
 
+		/* factory default configuration */
+		eth0_is_mii = true;
+		eth1_is_mii = true;
+
 		REQUEST_AND_SET_GPIO(GPIO_PR1_MII_CTRL);
 		/* Make J19 status available on GPIO1_26 */
 		REQUEST_AND_CLR_GPIO(GPIO_MUX_MII_CTRL);
@@ -600,6 +667,7 @@
 			writel(reg, GPIO0_IRQSTATUS1); /* clear irq */
 			/* RMII mode */
 			printf("ETH0, CPSW\n");
+			eth0_is_mii = false;
 		} else {
 			/* MII mode */
 			printf("ETH0, PRU\n");
@@ -612,6 +680,7 @@
 			/* RMII mode */
 			printf("ETH1, CPSW\n");
 			gpio_set_value(GPIO_MUX_MII_CTRL, 1);
+			eth1_is_mii = false;
 		} else {
 			/* MII mode */
 			printf("ETH1, PRU\n");
@@ -786,6 +855,11 @@
 
 #if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
 	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		puts("<ethaddr> not set. Validating first E-fuse MAC\n");
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
 
 #ifdef CONFIG_DRIVER_TI_CPSW
 	if (board_is_bone() || board_is_bone_lt() ||
@@ -877,3 +951,132 @@
 	secure_boot_verify_image(p_image, p_size);
 }
 #endif
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+
+static const char pruss_eth0_alias[] = "/pruss_eth/ethernet-mii0";
+static const char pruss_eth1_alias[] = "/pruss_eth/ethernet-mii1";
+
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	const char *path;
+	int offs;
+	int ret;
+
+	if (!board_is_icev2())
+		return 0;
+
+	/* Board DT default is both ports are RMII */
+	if (!eth0_is_mii && !eth1_is_mii)
+		return 0;
+
+	if (eth0_is_mii != eth1_is_mii) {
+		printf("Unsupported Ethernet port configuration\n");
+		printf("Both ports must be set as RMII or MII\n");
+		return 0;
+	}
+
+	printf("Fixing up ETH0 & ETH1 to PRUSS Ethernet\n");
+	/* Enable PRUSS-MDIO */
+	path = "/ocp/pruss_soc_bus@4a326000/pruss@4a300000/mdio@4a332400";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_okay(fdt, offs);
+	if (ret < 0)
+		goto enable_failed;
+
+	/* Enable PRU-ICSS Ethernet */
+	path = "/pruss_eth";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_okay(fdt, offs);
+	if (ret < 0)
+		goto enable_failed;
+
+	/* Disable CPSW Ethernet */
+	path = "/ocp/ethernet@4a100000";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_disabled(fdt, offs);
+	if (ret < 0)
+		goto disable_failed;
+
+	/* Disable CPSW-MDIO */
+	path = "/ocp/ethernet@4a100000/mdio@4a101000";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_disabled(fdt, offs);
+	if (ret < 0)
+		goto disable_failed;
+
+	/* Set MUX_MII_CTL1 pin low */
+	path = "/ocp/gpio@481ae000/p10";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0) {
+		printf("Node %s not found.\n", path);
+		return offs;
+	}
+
+	ret = fdt_delprop(fdt, offs, "output-high");
+	if (ret < 0) {
+		printf("Could not delete output-high property from node %s: %s\n",
+		       path, fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop(fdt, offs, "output-low", NULL, 0);
+	if (ret < 0) {
+		printf("Could not add output-low property to node %s: %s\n",
+		       path, fdt_strerror(ret));
+		return ret;
+	}
+
+	/* Fixup ethernet aliases */
+	path = "/aliases";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_setprop(fdt, offs, "ethernet0", pruss_eth0_alias,
+			  strlen(pruss_eth0_alias) + 1);
+	if (ret < 0) {
+		printf("Could not change ethernet0 alias: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop(fdt, offs, "ethernet1", pruss_eth1_alias,
+			  strlen(pruss_eth0_alias) + 1);
+	if (ret < 0) {
+		printf("Could not change ethernet0 alias: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	return 0;
+
+no_node:
+	printf("Node %s not found. Please update DTB.\n", path);
+
+	/* Return 0 as we don't want to prevent booting with older DTBs */
+	return 0;
+
+disable_failed:
+	printf("Could not disable node %s: %s\n",
+	       path, fdt_strerror(ret));
+	return ret;
+
+enable_failed:
+	printf("Could not enable node %s: %s\n",
+	       path, fdt_strerror(ret));
+	return ret;
+}
+#endif
diff -u -N U-Boot_SDcard/drivers/serial/serial_rockchip.c U-Boot_SDcard/drivers/serial/serial_rockchip.c
--- U-Boot_SDcard/drivers/serial/serial_rockchip.c	2019-09-12 15:54:13.000000324 -0500
+++ U-Boot_SDcard/drivers/serial/serial_rockchip.c	1969-12-31 19:29:21.000000558 -0600
@@ -27,6 +27,7 @@
 	plat->plat.base = plat->dtplat.reg[0];
 	plat->plat.reg_shift = plat->dtplat.reg_shift;
 	plat->plat.clock = plat->dtplat.clock_frequency;
+	plat->plat.fcr = UART_FCR_DEFVAL;
 	dev->platdata = &plat->plat;
 
 	return ns16550_serial_probe(dev);
diff -u -N U-Boot_SDcard/drivers/mmc/mmc_spi.c U-Boot_SDcard/drivers/mmc/mmc_spi.c
--- U-Boot_SDcard/drivers/mmc/mmc_spi.c	2019-09-12 15:54:30.000000379 -0500
+++ U-Boot_SDcard/drivers/mmc/mmc_spi.c	1969-12-31 19:29:21.000000196 -0600
@@ -236,13 +236,15 @@
 	return ret;
 }
 
-static void mmc_spi_set_ios(struct mmc *mmc)
+static int mmc_spi_set_ios(struct mmc *mmc)
 {
 	struct spi_slave *spi = mmc->priv;
 
 	debug("%s: clock %u\n", __func__, mmc->clock);
 	if (mmc->clock)
 		spi_set_speed(spi, mmc->clock);
+
+	return 0;
 }
 
 static int mmc_spi_init_p(struct mmc *mmc)
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h
--- U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h	2019-09-12 15:54:42.000000069 -0500
+++ U-Boot_SDcard/arch/arm/mach-keystone/include/mach/ddr3.h	1969-12-31 19:29:30.000000924 -0600
@@ -35,6 +35,20 @@
 	unsigned int zq1cr1;
 	unsigned int zq2cr1;
 	unsigned int pir_v1;
+	unsigned int datx8_2_mask;
+	unsigned int datx8_2_val;
+	unsigned int datx8_3_mask;
+	unsigned int datx8_3_val;
+	unsigned int datx8_4_mask;
+	unsigned int datx8_4_val;
+	unsigned int datx8_5_mask;
+	unsigned int datx8_5_val;
+	unsigned int datx8_6_mask;
+	unsigned int datx8_6_val;
+	unsigned int datx8_7_mask;
+	unsigned int datx8_7_val;
+	unsigned int datx8_8_mask;
+	unsigned int datx8_8_val;
 	unsigned int pir_v2;
 };
 
diff -u -N U-Boot_SDcard/include/configs/socfpga_de1_soc.h U-Boot_SDcard/include/configs/socfpga_de1_soc.h
--- U-Boot_SDcard/include/configs/socfpga_de1_soc.h	2019-09-12 15:54:41.000000640 -0500
+++ U-Boot_SDcard/include/configs/socfpga_de1_soc.h	1969-12-31 19:29:22.000000473 -0600
@@ -52,6 +52,6 @@
 /* The rest of the configuration is shared */
 #include <configs/socfpga_common.h>
 
-#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+#undef CONFIG_SPL_RAW_IMAGE_SUPPORT
 
 #endif	/* __CONFIG_TERASIC_DE1_SOC_H__ */
diff -u -N U-Boot_SDcard/common/xyzModem.c U-Boot_SDcard/common/xyzModem.c
--- U-Boot_SDcard/common/xyzModem.c	2019-09-12 15:55:01.000000282 -0500
+++ U-Boot_SDcard/common/xyzModem.c	1969-12-31 19:29:17.000000536 -0600
@@ -71,12 +71,12 @@
 static int
 CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
 {
-
-  ulong now = get_timer(0);
-  while (!tstc ())
+#define DELAY 20
+  unsigned long counter = 0;
+  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
     {
-      if (get_timer(now) > xyzModem_CHAR_TIMEOUT)
-        break;
+      udelay (DELAY);
+      counter++;
     }
   if (tstc ())
     {
diff -u -N U-Boot_SDcard/drivers/net/phy/cortina.c U-Boot_SDcard/drivers/net/phy/cortina.c
--- U-Boot_SDcard/drivers/net/phy/cortina.c	2019-09-12 15:54:20.000000799 -0500
+++ U-Boot_SDcard/drivers/net/phy/cortina.c	1969-12-31 19:29:27.000000821 -0600
@@ -139,7 +139,8 @@
 	size_t fw_length = CONFIG_CORTINA_FW_LENGTH;
 
 	addr = malloc(CONFIG_CORTINA_FW_LENGTH);
-	ret = nand_read(nand_info[0], (loff_t)CONFIG_CORTINA_FW_ADDR,
+	ret = nand_read(get_nand_dev_by_index(0),
+			(loff_t)CONFIG_CORTINA_FW_ADDR,
 			&fw_length, (u_char *)addr);
 	if (ret == -EUCLEAN) {
 		printf("NAND read of Cortina firmware at 0x%x failed %d\n",
diff -u -N /dev/null U-Boot_SDcard/build_sdcard_sc.sh
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/build_sdcard_sc.sh	1969-12-31 19:31:37.000000896 -0600
@@ -0,0 +1,4 @@
+sudo make CROSS_COMPILE=/home/builder4/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- ARCH=arm distclean
+#sudo make CROSS_COMPILE=/home/builder4/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- ARCH=arm O=u-boot-sdcard_sc am57xx_evm_nodt_defconfig
+sudo make CROSS_COMPILE=/home/builder4/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- ARCH=arm O=u-boot-sdcard_sc am57xx_evm_defconfig
+sudo make CROSS_COMPILE=/home/builder4/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- ARCH=arm O=u-boot-sdcard_sc
diff -u -N U-Boot_SDcard/include/environment/ti/dfu.h U-Boot_SDcard/include/environment/ti/dfu.h
--- U-Boot_SDcard/include/environment/ti/dfu.h	2019-09-12 15:54:42.000000139 -0500
+++ U-Boot_SDcard/include/environment/ti/dfu.h	1969-12-31 19:29:28.000000265 -0600
@@ -12,9 +12,10 @@
 	"rootfs part 0 2;" \
 	"MLO fat 0 1;" \
 	"MLO.raw raw 0x100 0x100;" \
-	"u-boot.img.raw raw 0x300 0x400;" \
-	"spl-os-args.raw raw 0x80 0x80;" \
-	"spl-os-image.raw raw 0x900 0x2000;" \
+	"u-boot.img.raw raw 0x300 0x1000;" \
+	"u-env.raw raw 0x1300 0x200;" \
+	"spl-os-args.raw raw 0x1500 0x200;" \
+	"spl-os-image.raw raw 0x1700 0x6900;" \
 	"spl-os-args fat 0 1;" \
 	"spl-os-image fat 0 1;" \
 	"u-boot.img fat 0 1;" \
@@ -28,8 +29,9 @@
 	"MLO fat 1 1;" \
 	"MLO.raw raw 0x100 0x100;" \
 	"u-boot.img.raw raw 0x300 0x1000;" \
-	"spl-os-args.raw raw 0x80 0x80;" \
-	"spl-os-image.raw raw 0x900 0x2000;" \
+	"u-env.raw raw 0x1300 0x200;" \
+	"spl-os-args.raw raw 0x1500 0x200;" \
+	"spl-os-image.raw raw 0x1700 0x6900;" \
 	"spl-os-args fat 1 1;" \
 	"spl-os-image fat 1 1;" \
 	"u-boot.img fat 1 1;" \
diff -u -N U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c
--- U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c	2019-09-12 15:54:42.000000921 -0500
+++ U-Boot_SDcard/drivers/mtd/nand/omap_gpmc.c	1969-12-31 19:29:27.000000725 -0600
@@ -8,7 +8,11 @@
 #include <common.h>
 #include <asm/io.h>
 #include <linux/errno.h>
+#if defined(CONFIG_SOC_KEYSTONE)
+#include <asm/ti-common/ti-gpmc.h>
+#else
 #include <asm/arch/mem.h>
+#endif
 #include <linux/mtd/omap_gpmc.h>
 #include <linux/mtd/nand_ecc.h>
 #include <linux/bch.h>
@@ -16,6 +20,10 @@
 #include <nand.h>
 #include <linux/mtd/omap_elm.h>
 
+#include <dm.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
 #define BADBLOCK_MARKER_LENGTH	2
 #define SECTOR_BYTES		512
 #define ECCCLEAR		(0x1 << 8)
@@ -46,11 +54,22 @@
 	enum omap_ecc ecc_scheme;
 	uint8_t cs;
 	uint8_t ws;		/* wait status pin (0,1) */
+	uint8_t bus_width;	/* Bus width of NAND device */
 };
 
+#ifndef CONFIG_DM_NAND
 /* We are wasting a bit of memory but al least we are safe */
 static struct omap_nand_info omap_nand_info[GPMC_MAX_CS];
 
+#else
+
+struct omap_gpmc_platdata {
+	struct omap_nand_info *omap_nand_info;
+	struct gpmc *gpmc_cfg;
+	int max_cs;
+};
+#endif
+
 /*
  * omap_nand_hwcontrol - Set the address pointers corretly for the
  *			following address/data/command operation
@@ -894,17 +913,14 @@
 int __maybe_unused omap_nand_switch_ecc(uint32_t hardware, uint32_t eccstrength)
 {
 	struct nand_chip *nand;
-	struct mtd_info *mtd;
+	struct mtd_info *mtd = get_nand_dev_by_index(nand_curr_device);
 	int err = 0;
 
-	if (nand_curr_device < 0 ||
-	    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-	    !nand_info[nand_curr_device]) {
+	if (!mtd) {
 		printf("nand: error: no NAND devices found\n");
 		return -ENODEV;
 	}
 
-	mtd = nand_info[nand_curr_device];
 	nand = mtd_to_nand(mtd);
 	nand->options |= NAND_OWN_BUFFERS;
 	nand->options &= ~NAND_SUBPAGE_READ;
@@ -948,34 +964,17 @@
 }
 #endif /* CONFIG_SPL_BUILD */
 
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific:
- * - IO_ADDR_R: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W: address to write the 8 I/O lines of the flash device
- * - cmd_ctrl: hardwarespecific function for accesing control-lines
- * - waitfunc: hardwarespecific function for accesing device ready/busy line
- * - ecc.hwctl: function to enable (reset) hardware ecc generator
- * - ecc.mode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- */
-int board_nand_init(struct nand_chip *nand)
+
+static int omap_gpmc_get_default_cs(int max_cs)
 {
-	int32_t gpmc_config = 0;
 	int cs = cs_next++;
-	int err = 0;
+
 	/*
 	 * xloader/Uboot's gpmc configuration would have configured GPMC for
 	 * nand type of memory. The following logic scans and latches on to the
 	 * first CS with NAND type memory.
-	 * TBD: need to make this logic generic to handle multiple CS NAND
-	 * devices.
 	 */
-	while (cs < GPMC_MAX_CS) {
+	while (cs < max_cs) {
 		/* Check if NAND type is set */
 		if ((readl(&gpmc_cfg->cs[cs].config1) & 0xC00) == 0x800) {
 			/* Found it!! */
@@ -983,12 +982,31 @@
 		}
 		cs++;
 	}
-	if (cs >= GPMC_MAX_CS) {
-		printf("nand: error: Unable to find NAND settings in "
-			"GPMC Configuration - quitting\n");
+
+	if (cs >= max_cs) {
+		printf("nand: error: Unable to find NAND settings in GPMC Configuration - quitting\n");
 		return -ENODEV;
 	}
 
+	return cs;
+}
+
+#if !defined(CONFIG_NAND_OMAP_ECCSCHEME) && !defined(CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	0
+#endif
+
+#if !defined(CONFIG_NAND_OMAP_ECCSCHEME) && !defined(CONFIG_SYS_NAND_OOBSIZE)
+#define CONFIG_SYS_NAND_OOBSIZE		0
+#endif
+
+static int omap_gpmc_init(struct nand_chip *nand,
+			  int cs, uint8_t bus_width, enum omap_ecc ecc_opt,
+			  const struct gpmc *gpmc_cfg,
+			  struct omap_nand_info *omap_nand_info)
+{
+	int32_t gpmc_config = 0;
+	int err = 0;
+
 	gpmc_config = readl(&gpmc_cfg->config);
 	/* Disable Write protect */
 	gpmc_config |= 0x10;
@@ -996,10 +1014,7 @@
 
 	nand->IO_ADDR_R = (void __iomem *)&gpmc_cfg->cs[cs].nand_dat;
 	nand->IO_ADDR_W = (void __iomem *)&gpmc_cfg->cs[cs].nand_cmd;
-	omap_nand_info[cs].control = NULL;
-	omap_nand_info[cs].cs = cs;
-	omap_nand_info[cs].ws = wscfg[cs];
-	nand_set_controller_data(nand, &omap_nand_info[cs]);
+	nand_set_controller_data(nand, omap_nand_info);
 	nand->cmd_ctrl	= omap_nand_hwcontrol;
 	nand->options	|= NAND_NO_PADDING | NAND_CACHEPRG;
 	nand->chip_delay = 100;
@@ -1007,22 +1022,26 @@
 
 	/* configure driver and controller based on NAND device bus-width */
 	gpmc_config = readl(&gpmc_cfg->cs[cs].config1);
-#if defined(CONFIG_SYS_NAND_BUSWIDTH_16BIT)
-	nand->options |= NAND_BUSWIDTH_16;
-	writel(gpmc_config | (0x1 << 12), &gpmc_cfg->cs[cs].config1);
-#else
-	nand->options &= ~NAND_BUSWIDTH_16;
-	writel(gpmc_config & ~(0x1 << 12), &gpmc_cfg->cs[cs].config1);
-#endif
+	if (bus_width == 16) {
+		nand->options |= NAND_BUSWIDTH_16;
+		writel(gpmc_config | (0x1 << 12), &gpmc_cfg->cs[cs].config1);
+	} else {
+		nand->options &= ~NAND_BUSWIDTH_16;
+		writel(gpmc_config & ~(0x1 << 12), &gpmc_cfg->cs[cs].config1);
+	}
+
 	/* select ECC scheme */
-#if defined(CONFIG_NAND_OMAP_ECCSCHEME)
-	err = omap_select_ecc_scheme(nand, CONFIG_NAND_OMAP_ECCSCHEME,
-			CONFIG_SYS_NAND_PAGE_SIZE, CONFIG_SYS_NAND_OOBSIZE);
-#else
-	/* pagesize and oobsize are not required to configure sw ecc-scheme */
-	err = omap_select_ecc_scheme(nand, OMAP_ECC_HAM1_CODE_SW,
-			0, 0);
-#endif
+	if (ecc_opt != OMAP_ECC_HAM1_CODE_SW) {
+		err = omap_select_ecc_scheme(nand, ecc_opt,
+					     CONFIG_SYS_NAND_PAGE_SIZE,
+					     CONFIG_SYS_NAND_OOBSIZE);
+	} else {
+		/*
+		 * pagesize and oobsize are not required to
+		 * configure sw ecc-scheme
+		 */
+		err = omap_select_ecc_scheme(nand, ecc_opt, 0, 0);
+	}
 	if (err)
 		return err;
 
@@ -1039,3 +1058,183 @@
 
 	return 0;
 }
+
+#ifndef CONFIG_DM_NAND
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific:
+ * - IO_ADDR_R: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W: address to write the 8 I/O lines of the flash device
+ * - cmd_ctrl: hardwarespecific function for accesing control-lines
+ * - waitfunc: hardwarespecific function for accesing device ready/busy line
+ * - ecc.hwctl: function to enable (reset) hardware ecc generator
+ * - ecc.mode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	int cs;
+#if defined(CONFIG_SYS_NAND_BUSWIDTH_16BIT)
+	uint8_t bus_width = 16;
+#else
+	uint8_t bus_width = 8;
+#endif
+#if defined(CONFIG_NAND_OMAP_ECCSCHEME)
+	enum omap_ecc ecc_opt = CONFIG_NAND_OMAP_ECCSCHEME;
+#else
+	enum omap_ecc ecc_opt = OMAP_ECC_HAM1_CODE_SW;
+#endif
+
+	cs = omap_gpmc_get_default_cs(GPMC_MAX_CS);
+	if (cs < 0)
+		return cs;
+
+	omap_nand_info[cs].control = NULL;
+	omap_nand_info[cs].cs = cs;
+	omap_nand_info[cs].ws = wscfg[cs];
+
+	return omap_gpmc_init(nand,
+			      cs,
+			      bus_width,
+			      ecc_opt,
+			      gpmc_cfg,
+			      &omap_nand_info[cs]);
+}
+
+#else /* CONFIG_DM_NAND */
+
+static int omap_gpmc_probe(struct udevice *dev)
+{
+	struct nand_chip *nand = dev_get_priv(dev);
+	struct omap_gpmc_platdata *pdata = dev_get_platdata(dev);
+	struct gpmc *gpmc_cfg = pdata->gpmc_cfg;
+	int cs;
+
+	cs = omap_gpmc_get_default_cs(pdata->max_cs);
+	if (cs < 0)
+		return cs;
+
+	return omap_gpmc_init(nand,
+			      cs,
+			      pdata->omap_nand_info[cs].bus_width,
+			      pdata->omap_nand_info[cs].ecc_scheme,
+			      gpmc_cfg,
+			      &pdata->omap_nand_info[cs]);
+}
+
+static int omap_gpmc_get_ecc_opt(int node, int elm_node)
+{
+	const void *fdt = gd->fdt_blob;
+	const char *ecc_str;
+	int ecc_opt = -ENOENT;
+
+	ecc_str = fdt_getprop(fdt, node, "ti,nand-ecc-opt", NULL);
+	if (!ecc_str) {
+		error("DT entry for ti,nand-ecc-opt not found\n");
+		return -ENOENT;
+	}
+
+	if (!strcmp(ecc_str, "sw")) {
+		ecc_opt = OMAP_ECC_HAM1_CODE_SW;
+	} else if (!strcmp(ecc_str, "ham1") ||
+		   !strcmp(ecc_str, "hw") ||
+		   !strcmp(ecc_str, "hw-romcode")) {
+		ecc_opt = OMAP_ECC_HAM1_CODE_HW;
+	} else if (!strcmp(ecc_str, "bch4")) {
+		if (elm_node > 0)
+			ecc_opt = OMAP_ECC_BCH4_CODE_HW;
+		else
+			ecc_opt = OMAP_ECC_BCH4_CODE_HW_DETECTION_SW;
+	} else if (!strcmp(ecc_str, "bch8")) {
+		if (elm_node > 0)
+			ecc_opt = OMAP_ECC_BCH8_CODE_HW;
+		else
+			ecc_opt = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW;
+	} else if (!strcmp(ecc_str, "bch16")) {
+		if (elm_node > 0)
+			ecc_opt = OMAP_ECC_BCH16_CODE_HW;
+		else
+			error("BCH16 requires ELM support\n");
+	} else {
+		error("ti,nand-ecc-opt invalid value\n");
+		return -EINVAL;
+	}
+
+	return ecc_opt;
+}
+
+static int omap_gpmc_ofdata_to_platdata(struct udevice *dev)
+{
+	struct omap_gpmc_platdata *pdata = dev_get_platdata(dev);
+	const void *fdt = gd->fdt_blob;
+	int node = dev->of_offset;
+	int subnode;
+
+	pdata->gpmc_cfg = map_physmem(dev_get_addr(dev), sizeof(struct gpmc),
+				      MAP_NOCACHE);
+	pdata->max_cs = fdtdec_get_int(fdt, node, "gpmc,num-cs", -1);
+	if (pdata->max_cs < 0) {
+		error("max chip select not found in DT\n");
+		return -ENOENT;
+	}
+
+	pdata->omap_nand_info = calloc(pdata->max_cs,
+				       sizeof(struct omap_nand_info));
+	if (!pdata->omap_nand_info)
+		return -ENOMEM;
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		int cs;
+		int len;
+		int elm_node;
+		const char *name;
+		struct omap_nand_info *nand_info;
+
+		name = fdt_get_name(fdt, subnode, &len);
+		if (strncmp(name, "nand", 4))
+			continue;
+
+		cs = fdtdec_get_int(fdt, subnode, "reg", -1);
+		if (cs < 0 || cs >= pdata->max_cs) {
+			error("Invalid cs for nand device\n");
+			return -EINVAL;
+		}
+		nand_info = &pdata->omap_nand_info[cs];
+		nand_info->cs = cs;
+		nand_info->ws = wscfg[cs];
+
+		/* get bus width 8 or 16, if not present 8 */
+		nand_info->bus_width = fdtdec_get_int(fdt, subnode,
+						      "nand-bus-width", 8);
+
+		elm_node = fdtdec_lookup_phandle(fdt, subnode, "ti,elm-id");
+
+		nand_info->ecc_scheme = omap_gpmc_get_ecc_opt(subnode,
+							      elm_node);
+		if (nand_info->ecc_scheme < 0)
+			return nand_info->ecc_scheme;
+	}
+	return 0;
+}
+
+static const struct udevice_id omap_gpmc_ids[] = {
+	{ .compatible = "ti,am3352-gpmc" },
+	{ }
+};
+
+U_BOOT_DRIVER(omap_gpmc) = {
+	.name	= "omap_gpmc",
+	.id	= UCLASS_NAND,
+	.of_match = omap_gpmc_ids,
+	.ofdata_to_platdata = omap_gpmc_ofdata_to_platdata,
+	.probe	= omap_gpmc_probe,
+	.priv_auto_alloc_size = sizeof(struct nand_chip),
+	.platdata_auto_alloc_size = sizeof(struct omap_gpmc_platdata),
+	.flags = DM_FLAG_ALLOC_PRIV_DMA,
+};
+#endif /* CONFIG_DM_NAND */
diff -u -N /dev/null U-Boot_SDcard/include/environment/ti/mmc.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/include/environment/ti/mmc.h	1969-12-31 19:31:37.000000950 -0600
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Environment variable definitions for MMC/SD on TI boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define DEFAULT_MMC_TI_ARGS \
+	"mmcdev=0\0" \
+	"mmcrootfstype=ext4 rootwait\0" \
+	"finduuid=part uuid mmc ${bootpart} uuid\0" \
+	"args_mmc=run finduuid;setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=PARTUUID=${uuid} rw " \
+		"rootfstype=${mmcrootfstype}\0" \
+	"loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+		"source ${loadaddr}\0" \
+	"bootenvfile=uEnv.txt\0" \
+	"importbootenv=echo Importing environment from mmc${mmcdev} ...; " \
+		"env import -t ${loadaddr} ${filesize}\0" \
+	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenvfile}\0" \
+	"loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
+	"loadfdt=load ${devtype} ${bootpart} ${fdtaddr} ${bootdir}/${fdtfile}\0" \
+	"envboot=mmc dev ${mmcdev}; " \
+		"if mmc rescan; then " \
+			"echo SD/MMC found on device ${mmcdev};" \
+			"if run loadbootscript; then " \
+				"run bootscript;" \
+			"else " \
+				"if run loadbootenv; then " \
+					"echo Loaded env from ${bootenvfile};" \
+					"run importbootenv;" \
+				"fi;" \
+				"if test -n $uenvcmd; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+			"fi;" \
+		"fi;\0" \
+	"mmcloados=run args_mmc; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdtaddr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"mmcboot=mmc dev ${mmcdev}; " \
+		"setenv devnum ${mmcdev}; " \
+		"setenv devtype mmc; " \
+		"if mmc rescan; then " \
+			"echo SD/MMC found on device ${mmcdev};" \
+			"if run loadimage; then " \
+				"if test ${boot_fit} -eq 1; then " \
+					"run loadfit; " \
+				"else " \
+					"run mmcloados;" \
+				"fi;" \
+			"fi;" \
+		"fi;\0"
diff -u -N U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c
--- U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c	2019-09-12 15:54:38.000000498 -0500
+++ U-Boot_SDcard/drivers/usb/musb-new/ti-musb.c	1969-12-31 19:29:28.000000125 -0600
@@ -14,6 +14,7 @@
 #include <dm/device-internal.h>
 #include <dm/lists.h>
 
+#include <watchdog.h>
 #include <asm/io.h>
 #include <asm/omap_musb.h>
 #include "musb_uboot.h"
@@ -142,6 +143,106 @@
 	return 0;
 }
 
+static struct musb *gadget;
+
+int usb_gadget_handle_interrupts(int index)
+{
+	WATCHDOG_RESET();
+	if (!gadget || !gadget->isr)
+		return -EINVAL;
+
+	return gadget->isr(0, gadget);
+}
+
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	int ret;
+
+	if (!driver || driver->speed < USB_SPEED_FULL || !driver->bind ||
+	    !driver->setup) {
+		printf("Bad parameter.\n");
+		return -EINVAL;
+	}
+
+	if (!gadget) {
+		printf("Controller uninitialized\n");
+		return -ENXIO;
+	}
+
+	ret = musb_gadget_start(&gadget->g, driver);
+	if (ret < 0)
+		return ret;
+
+	ret = driver->bind(&gadget->g);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	if (driver->disconnect)
+		driver->disconnect(&gadget->g);
+	if (driver->unbind)
+		driver->unbind(&gadget->g);
+	return 0;
+}
+
+static int ti_musb_peripheral_usb_probe(struct udevice *dev)
+{
+	struct ti_musb_platdata *platdata = dev_get_platdata(dev);
+	struct usb_bus_priv *priv = dev_get_uclass_priv(dev);
+	struct omap_musb_board_data *otg_board_data;
+
+	otg_board_data = &platdata->otg_board_data;
+
+	gadget = musb_init_controller(&platdata->plat,
+				      (struct device *)otg_board_data,
+				      platdata->base);
+	if (!gadget) {
+		error("gadget init failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int ti_musb_peripheral_remove(struct udevice *dev)
+{
+	musb_stop(gadget);
+
+	return 0;
+}
+
+static int ti_musb_peripheral_ofdata_to_platdata(struct udevice *dev)
+{
+	struct ti_musb_platdata *platdata = dev_get_platdata(dev);
+	const void *fdt = gd->fdt_blob;
+	int node = dev->of_offset;
+	int ret;
+
+	ret = ti_musb_ofdata_to_platdata(dev);
+	if (ret) {
+		error("platdata dt parse error\n");
+		return ret;
+	}
+
+	platdata->plat.mode = MUSB_PERIPHERAL;
+
+	return 0;
+}
+
+U_BOOT_DRIVER(ti_musb_peripheral) = {
+	.name	= "ti-musb-peripheral",
+	.id	= UCLASS_USB_DEV_GENERIC,
+	.ofdata_to_platdata = ti_musb_peripheral_ofdata_to_platdata,
+	.probe = ti_musb_peripheral_usb_probe,
+	.remove = ti_musb_peripheral_remove,
+	.platdata_auto_alloc_size = sizeof(struct ti_musb_platdata),
+	.priv_auto_alloc_size = sizeof(struct musb),
+};
+
 static int ti_musb_host_probe(struct udevice *dev)
 {
 	struct musb_host_data *host = dev_get_priv(dev);
@@ -222,7 +323,15 @@
 		dr_mode = usb_get_dr_mode(node);
 		switch (dr_mode) {
 		case USB_DR_MODE_PERIPHERAL:
+		case USB_DR_MODE_OTG:
 			/* Bind MUSB device */
+			ret = device_bind_driver_to_node(parent,
+							 "ti-musb-peripheral",
+							 name, node, &dev);
+			if (ret) {
+				error("musb - not able to bind usb device node\n");
+				return ret;
+			}
 			break;
 		case USB_DR_MODE_HOST:
 			/* Bind MUSB host */
diff -u -N /dev/null U-Boot_SDcard/drivers/mtd/nand/nand-uclass.c
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/mtd/nand/nand-uclass.c	1969-12-31 19:31:37.000000949 -0600
@@ -0,0 +1,38 @@
+/*
+ * NAND uclass driver for NAND bus.
+ *
+ * (C) Copyright 2017
+ *     Texas Instruments Incorporated, <www.ti.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct mtd_info *get_nand_dev_by_index(int idx)
+{
+	struct nand_chip *chip;
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device(UCLASS_NAND, idx, &dev);
+	if (ret) {
+		debug("NAND device (%d) not found\n", idx);
+		return NULL;
+	}
+
+	chip = (struct nand_chip *)dev_get_priv(dev);
+
+	return nand_to_mtd(chip);
+}
+
+UCLASS_DRIVER(nand) = {
+	.id				= UCLASS_NAND,
+	.name				= "nand",
+	.flags				= DM_UC_FLAG_SEQ_ALIAS,
+};
diff -u -N U-Boot_SDcard/common/fb_nand.c U-Boot_SDcard/common/fb_nand.c
--- U-Boot_SDcard/common/fb_nand.c	2019-09-12 15:54:17.000000964 -0500
+++ U-Boot_SDcard/common/fb_nand.c	1969-12-31 19:29:17.000000495 -0600
@@ -59,7 +59,7 @@
 		return -EINVAL;
 	}
 
-	*mtd = nand_info[dev->id->num];
+	*mtd = get_nand_dev_by_index(dev->id->num);
 
 	return 0;
 }
diff -u -N U-Boot_SDcard/cmd/bootm.c U-Boot_SDcard/cmd/bootm.c
--- U-Boot_SDcard/cmd/bootm.c	2019-09-12 15:54:44.000000994 -0500
+++ U-Boot_SDcard/cmd/bootm.c	1969-12-31 19:29:17.000000327 -0600
@@ -387,7 +387,7 @@
 		return -ENOMEM;
 	}
 
-	ret = nand_read_skip_bad(mtd, off, &len, imgdata);
+	ret = nand_read_skip_bad(mtd, off, &len, NULL, mtd->size, imgdata);
 	if (ret < 0 && ret != -EUCLEAN) {
 		free(imgdata);
 		return ret;
@@ -427,7 +427,7 @@
 		return -ENOMEM;
 	}
 
-	ret = nand_read_skip_bad(mtd, off, &len, imgdata);
+	ret = nand_read_skip_bad(mtd, off, &len, NULL, mtd->size, imgdata);
 	if (ret < 0 && ret != -EUCLEAN) {
 		free(imgdata);
 		return ret;
@@ -462,7 +462,7 @@
 	printf("\n");
 
 	for (nand_dev = 0; nand_dev < CONFIG_SYS_MAX_NAND_DEVICE; nand_dev++) {
-		mtd = nand_info[nand_dev];
+		mtd = get_nand_dev_by_index(nand_dev);
 		if (!mtd->name || !mtd->size)
 			continue;
 
diff -u -N U-Boot_SDcard/board/ti/evm/evm.c U-Boot_SDcard/board/ti/evm/evm.c
--- U-Boot_SDcard/board/ti/evm/evm.c	2019-09-12 15:54:59.000000054 -0500
+++ U-Boot_SDcard/board/ti/evm/evm.c	1969-12-31 19:29:27.000000196 -0600
@@ -259,7 +259,7 @@
 }
 #endif /* CONFIG_CMD_NET */
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N /dev/null U-Boot_SDcard/common/fw_validation.h
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/common/fw_validation.h	1969-12-31 19:31:37.000000903 -0600
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2000-2010
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * (C) Copyright 2008 Atmel Corporation
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <environment.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <search.h>
+#include <errno.h>
+#include <dm/device-internal.h>
+
+unsigned int sc_vxWorkssize;
+
+void am5728_os_checksum_validate(void);
+
+
+typedef struct binInfo{
+    unsigned short  systemOsCrc;
+    unsigned int    systemOsSize;
+    unsigned int    systemOsOffset;
+
+    unsigned short  envFileCrc;
+    unsigned int    envFileSize;
+    unsigned int    envFileOffset;
+}binInfo_t;
+
+static const unsigned short crc16tab[256]= {
+        0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
+        0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
+        0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
+        0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
+        0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
+        0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
+        0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
+        0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
+        0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
+        0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
+        0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
+        0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
+        0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
+        0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
+        0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
+        0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
+        0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
+        0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
+        0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
+        0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
+        0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
+        0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
+        0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
+        0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
+        0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
+        0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
+        0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
+        0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
+        0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
+        0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
+        0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
+        0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
+};
+
+
diff -u -N U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c
--- U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c	2019-09-12 15:54:45.000000306 -0500
+++ U-Boot_SDcard/drivers/pinctrl/pinctrl-uclass.c	1969-12-31 19:29:21.000000417 -0600
@@ -12,6 +12,7 @@
 #include <dm/lists.h>
 #include <dm/pinctrl.h>
 #include <dm/uclass.h>
+#include <dm/util.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -131,7 +132,7 @@
 	     offset > 0;
 	     offset = fdt_next_subnode(fdt, offset)) {
 		if (pre_reloc_only &&
-		    !fdt_getprop(fdt, offset, "u-boot,dm-pre-reloc", NULL))
+		    !dm_fdt_pre_reloc(fdt, offset))
 			continue;
 		/*
 		 * If this node has "compatible" property, this is not
diff -u -N U-Boot_SDcard/drivers/net/cpsw-common.c U-Boot_SDcard/drivers/net/cpsw-common.c
--- U-Boot_SDcard/drivers/net/cpsw-common.c	2019-09-12 15:54:28.000000828 -0500
+++ U-Boot_SDcard/drivers/net/cpsw-common.c	1969-12-31 19:29:21.000000268 -0600
@@ -110,7 +110,7 @@
 	if (of_device_is_compatible(dev, "ti,dm816-emac"))
 		return cpsw_am33xx_cm_get_macid(dev, 0x30, slave, mac_addr);
 
-	if (of_machine_is_compatible("ti,am4372"))
+	if (of_machine_is_compatible("ti,am43"))
 		return cpsw_am33xx_cm_get_macid(dev, 0x630, slave, mac_addr);
 
 	if (of_machine_is_compatible("ti,dra7"))
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2hk-evm.dts
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2hk-evm.dts	1969-12-31 19:31:37.000000940 -0600
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Kepler/Hawking EVM device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "keystone.dtsi"
+#include "keystone-k2hk.dtsi"
+
+/ {
+	compatible =  "ti,k2hk-evm","ti,keystone";
+	model = "Texas Instruments Keystone 2 Kepler/Hawking EVM";
+
+	soc {
+		clocks {
+			refclksys: refclksys {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <122880000>;
+				clock-output-names = "refclk-sys";
+			};
+
+			refclkpass: refclkpass {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <122880000>;
+				clock-output-names = "refclk-pass";
+			};
+
+			refclkarm: refclkarm {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <125000000>;
+				clock-output-names = "refclk-arm";
+			};
+
+			refclkddr3a: refclkddr3a {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <100000000>;
+				clock-output-names = "refclk-ddr3a";
+			};
+
+			refclkddr3b: refclkddr3b {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <100000000>;
+				clock-output-names = "refclk-ddr3b";
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		debug1_1 {
+			label = "keystone:green:debug1";
+			gpios = <&gpio0 12 GPIO_ACTIVE_HIGH>; /* 12 */
+		};
+
+		debug1_2 {
+			label = "keystone:red:debug1";
+			gpios = <&gpio0 13 GPIO_ACTIVE_HIGH>; /* 13 */
+		};
+
+		debug2 {
+			label = "keystone:blue:debug2";
+			gpios = <&gpio0 14 GPIO_ACTIVE_HIGH>; /* 14 */
+		};
+
+		debug3 {
+			label = "keystone:blue:debug3";
+			gpios = <&gpio0 15 GPIO_ACTIVE_HIGH>; /* 15 */
+		};
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&aemif {
+	cs0 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		clock-ranges;
+		ranges;
+
+		ti,cs-chipselect = <0>;
+		/* all timings in nanoseconds */
+		ti,cs-min-turnaround-ns = <12>;
+		ti,cs-read-hold-ns = <6>;
+		ti,cs-read-strobe-ns = <23>;
+		ti,cs-read-setup-ns = <9>;
+		ti,cs-write-hold-ns = <8>;
+		ti,cs-write-strobe-ns = <23>;
+		ti,cs-write-setup-ns = <8>;
+
+		nand@0,0 {
+			compatible = "ti,keystone-nand","ti,davinci-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0 0x4000000
+			       1 0 0x0000100>;
+
+			ti,davinci-chipselect = <0>;
+			ti,davinci-mask-ale = <0x2000>;
+			ti,davinci-mask-cle = <0x4000>;
+			ti,davinci-mask-chipsel = <0>;
+			nand-ecc-mode = "hw";
+			ti,davinci-ecc-bits = <4>;
+			nand-on-flash-bbt;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x0 0x100000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "params";
+				reg = <0x100000 0x80000>;
+				read-only;
+			};
+
+			partition@180000 {
+				label = "ubifs";
+				reg = <0x180000 0x1fe80000>;
+			};
+		};
+	};
+};
+
+&i2c0 {
+	dtt@50 {
+		compatible = "at,24c1024";
+		reg = <0x50>;
+	};
+};
+
+&spi0 {
+	status = "okay";
+	nor_flash: n25q128a11@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "Micron,n25q128a11", "spi-flash";
+		spi-max-frequency = <54000000>;
+		m25p,fast-read;
+		reg = <0>;
+
+		partition@0 {
+			label = "u-boot-spl";
+			reg = <0x0 0x80000>;
+			read-only;
+		};
+
+		partition@1 {
+			label = "misc";
+			reg = <0x80000 0xf80000>;
+		};
+	};
+};
+
+&mdio {
+	status = "ok";
+	ethphy0: ethernet-phy@0 {
+		compatible = "marvell,88E1111", "ethernet-phy-ieee802.3-c22";
+		reg = <0>;
+	};
+
+	ethphy1: ethernet-phy@1 {
+		compatible = "marvell,88E1111", "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds
--- U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds	2019-09-12 15:54:26.000000972 -0500
+++ U-Boot_SDcard/arch/arm/mach-omap2/u-boot-spl.lds	1969-12-31 19:29:23.000000910 -0600
@@ -1,57 +1,59 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
- *
- * (C) Copyright 2010
- * Texas Instruments, <www.ti.com>
- *	Aneesh V <aneesh@ti.com>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-MEMORY { .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\
-		LENGTH = CONFIG_SPL_MAX_SIZE }
-MEMORY { .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR, \
-		LENGTH = CONFIG_SPL_BSS_MAX_SIZE }
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	.text      :
-	{
-		__start = .;
-		*(.vectors)
-		arch/arm/cpu/armv7/start.o	(.text*)
-		*(.text*)
-	} >.sram
-
-	. = ALIGN(4);
-	.rodata : { *(SORT_BY_ALIGNMENT(.rodata*)) } >.sram
-
-	. = ALIGN(4);
-	.data : { *(SORT_BY_ALIGNMENT(.data*)) } >.sram
-
-	. = ALIGN(4);
-	.u_boot_list : {
-		KEEP(*(SORT(.u_boot_list*)));
-	} >.sram
-
-	. = ALIGN(4);
-	__image_copy_end = .;
-
-	.end :
-	{
-		*(.__end)
-	}
-
-	.bss :
-	{
-		. = ALIGN(4);
-		__bss_start = .;
-		*(.bss*)
-		. = ALIGN(4);
-		__bss_end = .;
-	} >.sdram
-}
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *	Aneesh V <aneesh@ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+MEMORY { .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\
+		LENGTH = CONFIG_SPL_MAX_SIZE }
+MEMORY { .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR, \
+		LENGTH = CONFIG_SPL_BSS_MAX_SIZE }
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	.text      :
+	{
+		__start = .;
+		*(.vectors)
+		arch/arm/cpu/armv7/start.o	(.text*)
+		*(.text*)
+	} >.sram
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(.rodata*)) } >.sram
+
+	. = ALIGN(4);
+	.data : { *(SORT_BY_ALIGNMENT(.data*)) } >.sram
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	} >.sram
+
+	. = ALIGN(4);
+	__image_copy_end = .;
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	.bss :
+	{
+		. = ALIGN(4);
+		__bss_start = .;
+		*(.bss*)
+		. = ALIGN(4);
+		__bss_end = .;
+	} >.sdram
+}
diff -u -N U-Boot_SDcard/drivers/mmc/sh_sdhi.c U-Boot_SDcard/drivers/mmc/sh_sdhi.c
--- U-Boot_SDcard/drivers/mmc/sh_sdhi.c	2019-09-12 15:54:37.000000814 -0500
+++ U-Boot_SDcard/drivers/mmc/sh_sdhi.c	1969-12-31 19:29:21.000000216 -0600
@@ -608,7 +608,7 @@
 	return ret;
 }
 
-static void sh_sdhi_set_ios(struct mmc *mmc)
+static int sh_sdhi_set_ios(struct mmc *mmc)
 {
 	int ret;
 	struct sh_sdhi_host *host = mmc_priv(mmc);
@@ -625,6 +625,7 @@
 			       sh_sdhi_readw(host, SDHI_OPTION));
 
 	debug("clock = %d, buswidth = %d\n", mmc->clock, mmc->bus_width);
+	return 0;
 }
 
 static int sh_sdhi_initialize(struct mmc *mmc)
diff -u -N U-Boot_SDcard/drivers/mmc/tegra_mmc.c U-Boot_SDcard/drivers/mmc/tegra_mmc.c
--- U-Boot_SDcard/drivers/mmc/tegra_mmc.c	2019-09-12 15:54:53.000000920 -0500
+++ U-Boot_SDcard/drivers/mmc/tegra_mmc.c	1969-12-31 19:29:21.000000219 -0600
@@ -408,7 +408,7 @@
 	priv->clock = clock;
 }
 
-static void tegra_mmc_set_ios(struct mmc *mmc)
+static int tegra_mmc_set_ios(struct mmc *mmc)
 {
 	struct tegra_mmc_priv *priv = mmc->priv;
 	unsigned char ctrl;
@@ -438,6 +438,7 @@
 
 	writeb(ctrl, &priv->reg->hostctl);
 	debug("mmc_set_ios: hostctl = %08X\n", ctrl);
+	return 0;
 }
 
 static void tegra_mmc_pad_init(struct tegra_mmc_priv *priv)
diff -u -N U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c
--- U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c	2019-09-12 15:54:56.000000857 -0500
+++ U-Boot_SDcard/drivers/mmc/gen_atmel_mci.c	1969-12-31 19:29:21.000000188 -0600
@@ -336,7 +336,7 @@
 }
 
 /* Entered into mmc structure during driver init */
-static void mci_set_ios(struct mmc *mmc)
+static int mci_set_ios(struct mmc *mmc)
 {
 	struct atmel_mci_priv *priv = mmc->priv;
 	atmel_mci_t *mci = priv->mci;
@@ -370,6 +370,8 @@
 
 		writel(busw << 7 | MMCI_BF(SCDSEL, MCI_BUS), &mci->sdcr);
 	}
+
+	return 0;
 }
 
 /* Entered into mmc structure during driver init */
diff -u -N U-Boot_SDcard/common/spl/spl_mmc.c U-Boot_SDcard/common/spl/spl_mmc.c
--- U-Boot_SDcard/common/spl/spl_mmc.c	2019-09-12 15:54:13.000000789 -0500
+++ U-Boot_SDcard/common/spl/spl_mmc.c	1969-12-31 19:29:20.000000771 -0600
@@ -7,7 +7,7 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
-#include <dm.h>
+#include <libfdt.h>
 #include <spl.h>
 #include <linux/compiler.h>
 #include <errno.h>
@@ -115,9 +115,6 @@
 
 static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 {
-#ifdef CONFIG_DM_MMC
-	struct udevice *dev;
-#endif
 	int err, mmc_dev;
 
 	mmc_dev = spl_mmc_get_device_index(boot_device);
@@ -132,14 +129,9 @@
 		return err;
 	}
 
-#ifdef CONFIG_DM_MMC
-	err = uclass_get_device(UCLASS_MMC, mmc_dev, &dev);
-	if (!err)
-		*mmcp = mmc_get_mmc_dev(dev);
-#else
 	*mmcp = find_mmc_device(mmc_dev);
 	err = *mmcp ? 0 : -ENODEV;
-#endif
+
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		printf("spl: could not find mmc device. error: %d\n", err);
diff -u -N U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c
--- U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c	2019-09-12 15:54:26.000000711 -0500
+++ U-Boot_SDcard/drivers/mmc/pxa_mmc_gen.c	1969-12-31 19:29:21.000000206 -0600
@@ -313,7 +313,7 @@
 	return 0;
 }
 
-static void pxa_mmc_set_ios(struct mmc *mmc)
+static int pxa_mmc_set_ios(struct mmc *mmc)
 {
 	struct pxa_mmc_priv *priv = mmc->priv;
 	struct pxa_mmc_regs *regs = priv->regs;
@@ -342,6 +342,8 @@
 	}
 
 	writel(pxa_mmc_clock, &regs->clkrt);
+
+	return 0;
 }
 
 static int pxa_mmc_init(struct mmc *mmc)
diff -u -N U-Boot_SDcard/board/isee/igep00x0/igep00x0.c U-Boot_SDcard/board/isee/igep00x0/igep00x0.c
--- U-Boot_SDcard/board/isee/igep00x0/igep00x0.c	2019-09-12 15:54:19.000000993 -0500
+++ U-Boot_SDcard/board/isee/igep00x0/igep00x0.c	1969-12-31 19:29:26.000000402 -0600
@@ -30,7 +30,8 @@
 static const struct ns16550_platdata igep_serial = {
 	.base = OMAP34XX_UART3,
 	.reg_shift = 2,
-	.clock = V_NS16550_CLK
+	.clock = V_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(igep_uart) = {
@@ -196,7 +197,7 @@
 static inline void setup_net_chip(void) {}
 #endif
 
-#if defined(CONFIG_GENERIC_MMC) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_GENERIC_MMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/arch/arm/mach-tegra/board.c U-Boot_SDcard/arch/arm/mach-tegra/board.c
--- U-Boot_SDcard/arch/arm/mach-tegra/board.c	2019-09-12 15:54:17.000000537 -0500
+++ U-Boot_SDcard/arch/arm/mach-tegra/board.c	1969-12-31 19:29:24.000000016 -0600
@@ -219,6 +219,7 @@
 	.base = CONFIG_SYS_NS16550_COM1,
 	.reg_shift = 2,
 	.clock = CONFIG_SYS_NS16550_CLK,
+	.fcr = UART_FCR_DEFVAL,
 };
 
 U_BOOT_DEVICE(ns16550_com1) = {
diff -u -N U-Boot_SDcard/cmd/mmc.c U-Boot_SDcard/cmd/mmc.c
--- U-Boot_SDcard/cmd/mmc.c	2019-09-12 15:54:52.000000763 -0500
+++ U-Boot_SDcard/cmd/mmc.c	1969-12-31 19:29:17.000000396 -0600
@@ -12,6 +12,55 @@
 
 static int curr_device = -1;
 
+
+static char *sprintf_speed(char *buf, ulong sz, uint ms)
+{
+	uint64_t kbytes_per_sec;
+	uint64_t mb_per_sec;
+	uint32_t remain;
+
+	if (!ms)
+		goto out;
+
+	kbytes_per_sec = ((sz >> 10) * 1000) / ms;
+	mb_per_sec = kbytes_per_sec >> 10;
+	remain = ((kbytes_per_sec - (mb_per_sec << 10)) * 100) >> 10;
+
+	if (mb_per_sec)
+		sprintf(buf, "%llu.%02u MB/s", mb_per_sec, remain);
+	else if (kbytes_per_sec)
+		sprintf(buf, "%llu KB/s", kbytes_per_sec);
+	else
+		goto out;
+
+	return buf;
+
+out:
+	strcpy(buf, "### MB/s");
+	return buf;
+}
+
+static void show_stats(struct mmc *mmc)
+{
+	char buf[50];
+	struct mmc_statistics *s;
+	s = &mmc->rd_stats;
+
+	printf("read %s. error %d/%d (%d%%)\n",
+	       sprintf_speed(buf,
+			     s->total_sz *  mmc->read_bl_len,
+			     s->total_time),
+		s->errors, s->transfers,
+		s->transfers ? (100 * s->errors / s->transfers) : 0);
+	s = &mmc->wr_stats;
+	printf("write %s. error %d/%d (%d%%)\n",
+	       sprintf_speed(buf,
+			     s->total_sz *  mmc->read_bl_len,
+			     s->total_time),
+		s->errors, s->transfers,
+		s->transfers ? (100 * s->errors / s->transfers) : 0);
+}
+
 static void print_mmcinfo(struct mmc *mmc)
 {
 	int i;
@@ -81,6 +130,7 @@
 			}
 		}
 	}
+	show_stats(mmc);
 }
 static struct mmc *init_mmc_device(int dev, bool force_init)
 {
diff -u -N U-Boot_SDcard/drivers/serial/ns16550.c U-Boot_SDcard/drivers/serial/ns16550.c
--- U-Boot_SDcard/drivers/serial/ns16550.c	2019-09-12 15:55:00.000000863 -0500
+++ U-Boot_SDcard/drivers/serial/ns16550.c	1969-12-31 19:29:21.000000538 -0600
@@ -20,9 +20,6 @@
 #define UART_LCRVAL UART_LCR_8N1		/* 8 data, 1 stop, no parity */
 #define UART_MCRVAL (UART_MCR_DTR | \
 		     UART_MCR_RTS)		/* RTS/DTR */
-#define UART_FCRVAL (UART_FCR_FIFO_EN |	\
-		     UART_FCR_RXSR |	\
-		     UART_FCR_TXSR)		/* Clear & enable FIFOs */
 
 #ifndef CONFIG_DM_SERIAL
 #ifdef CONFIG_SYS_NS16550_PORT_MAPPED
@@ -138,7 +135,7 @@
 #else
 static u32 ns16550_getfcr(NS16550_t port)
 {
-	return UART_FCRVAL;
+	return UART_FCR_DEFVAL;
 }
 #endif
 
@@ -275,7 +272,7 @@
 					    CONFIG_BAUDRATE);
 	serial_dout(&com_port->ier, CONFIG_SYS_NS16550_IER);
 	serial_dout(&com_port->mcr, UART_MCRVAL);
-	serial_dout(&com_port->fcr, UART_FCRVAL);
+	serial_dout(&com_port->fcr, UART_FCR_DEFVAL);
 
 	serial_dout(&com_port->lcr, UART_LCR_BKSE | UART_LCRVAL);
 	serial_dout(&com_port->dll, baud_divisor & 0xff);
@@ -440,7 +437,7 @@
 		return -EINVAL;
 	}
 
-	plat->fcr = UART_FCRVAL;
+	plat->fcr = UART_FCR_DEFVAL;
 	if (port_type == PORT_JZ4780)
 		plat->fcr |= UART_FCR_UME;
 
diff -u -N U-Boot_SDcard/arch/arm/dts/dra71-evm.dts U-Boot_SDcard/arch/arm/dts/dra71-evm.dts
--- U-Boot_SDcard/arch/arm/dts/dra71-evm.dts	2019-09-12 15:55:01.000000751 -0500
+++ U-Boot_SDcard/arch/arm/dts/dra71-evm.dts	1969-12-31 19:29:23.000000299 -0600
@@ -1,230 +1,457 @@
-/*
- * Copyright (C) 2016 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include "dra72-evm-common.dtsi"
-#include <dt-bindings/net/ti-dp83867.h>
-
-/ {
-	compatible = "ti,dra718-evm", "ti,dra718", "ti,dra722", "ti,dra72", "ti,dra7";
-	model = "TI DRA718 EVM";
-
-	memory {
-		device_type = "memory";
-		reg = <0x0 0x80000000 0x0 0x80000000>; /* 2GB */
-	};
-
-	vpo_sd_1v8_3v3: gpio-regulator-TPS74801 {
-		compatible = "regulator-gpio";
-
-		regulator-name = "vddshv8";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <3000000>;
-		regulator-boot-on;
-		vin-supply = <&evm_5v0>;
-
-		gpios = <&gpio7 11 GPIO_ACTIVE_HIGH>;
-		states = <1800000 0x0
-			  3000000 0x1>;
-	};
-
-	poweroff: gpio-poweroff {
-		compatible = "gpio-poweroff";
-		gpios = <&gpio7 30 GPIO_ACTIVE_HIGH>;
-		input;
-	};
-};
-
-&i2c1 {
-	status = "okay";
-	clock-frequency = <400000>;
-
-	lp8733: lp8733@60 {
-		compatible = "ti,lp8733";
-		reg = <0x60>;
-
-		buck0-in-supply =<&vsys_3v3>;
-		buck1-in-supply =<&vsys_3v3>;
-		ldo0-in-supply =<&evm_5v0>;
-		ldo1-in-supply =<&evm_5v0>;
-
-		lp8733_regulators: regulators {
-			lp8733_buck0_reg: buck0 {
-				/* FB_B0 -> LP8733-BUCK1 - VPO_S1_AVS - VDD_CORE_AVS (core, mpu, gpu) */
-				regulator-name = "lp8733-buck0";
-				regulator-min-microvolt = <850000>;
-				regulator-max-microvolt = <1250000>;
-				regulator-always-on;
-				regulator-boot-on;
-			};
-
-			lp8733_buck1_reg: buck1 {
-				/* FB_B1 -> LP8733-BUCK2 - VPO_S2_AVS - VDD_DSP_AVS (DSP/eve/iva) */
-				regulator-name = "lp8733-buck1";
-				regulator-min-microvolt = <850000>;
-				regulator-max-microvolt = <1250000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			lp8733_ldo0_reg: ldo0 {
-				/* LDO0 -> LP8733-LDO1 - VPO_L1_3V3 - VDDSHV8 (optional) */
-				regulator-name = "lp8733-ldo0";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-			};
-
-			lp8733_ldo1_reg: ldo1 {
-				/* LDO1 -> LP8733-LDO2 - VPO_L2_3V3 - VDDA_USB3V3 */
-				regulator-name = "lp8733-ldo1";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-boot-on;
-			};
-		};
-	};
-
-	lp8732: lp8732@61 {
-		compatible = "ti,lp8732";
-		reg = <0x61>;
-
-		buck0-in-supply =<&vsys_3v3>;
-		buck1-in-supply =<&vsys_3v3>;
-		ldo0-in-supply =<&vsys_3v3>;
-		ldo1-in-supply =<&vsys_3v3>;
-
-		lp8732_regulators: regulators {
-			lp8732_buck0_reg: buck0 {
-				/* FB_B0 -> LP8732-BUCK1 - VPO_S3_1V8 - VDDS_1V8 */
-				regulator-name = "lp8732-buck0";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-always-on;
-				regulator-boot-on;
-			};
-
-			lp8732_buck1_reg: buck1 {
-				/* FB_B1 -> LP8732-BUCK2 - VPO_S4_DDR - VDD_DDR_1V35 */
-				regulator-name = "lp8732-buck1";
-				regulator-min-microvolt = <1350000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			lp8732_ldo0_reg: ldo0 {
-				/* LDO0 -> LP8732-LDO1 - VPO_L3_1V8 - VDA_1V8_PLL */
-				regulator-name = "lp8732-ldo0";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			lp8732_ldo1_reg: ldo1 {
-				/* LDO1 -> LP8732-LDO2 - VPO_L4_1V8 - VDA_1V8_PHY */
-				regulator-name = "lp8732-ldo1";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-always-on;
-				regulator-boot-on;
-			};
-		};
-	};
-};
-
-&pcf_gpio_21 {
-	interrupt-parent = <&gpio7>;
-	interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
-};
-
-&pcf_hdmi {
-	p0 {
-		/*
-		 * PM_OEn to High: Disable routing I2C3 to PM_I2C
-		 * With this PM_SEL(p3) should not matter
-		 */
-		gpio-hog;
-		gpios = <0 GPIO_ACTIVE_LOW>;
-		output-high;
-		line-name = "pm_oe_n";
-	};
-};
-
-&mmc1 {
-	vmmc_aux-supply = <&vpo_sd_1v8_3v3>;
-};
-
-&mac {
-	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_LOW>,
-		     <&pcf_hdmi 9 GPIO_ACTIVE_LOW>,	/* P11 */
-		     <&pcf_hdmi 10 GPIO_ACTIVE_LOW>;	/* P12 */
-	dual_emac;
-};
-
-&cpsw_emac0 {
-	phy-handle = <&dp83867_0>;
-	phy-mode = "rgmii-id";
-	dual_emac_res_vlan = <1>;
-};
-
-&cpsw_emac1 {
-	phy-handle = <&dp83867_1>;
-	phy-mode = "rgmii-id";
-	dual_emac_res_vlan = <2>;
-};
-
-&davinci_mdio {
-	dp83867_0: ethernet-phy@2 {
-		reg = <2>;
-		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
-		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
-		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
-		ti,impedance-control = <0x1f>;
-	};
-
-	dp83867_1: ethernet-phy@3 {
-		reg = <3>;
-		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
-		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
-		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
-		ti,impedance-control = <0x1f>;
-	};
-};
-
-/* No Sata on this device */
-&sata_phy {
-	status = "disabled";
-};
-
-&sata {
-	status = "disabled";
-};
-
-/* No RTC on this device */
-&rtc {
-	status = "disabled";
-};
-
-&usb2_phy1 {
-	phy-supply = <&lp8733_ldo1_reg>;
-};
-
-&usb2_phy2 {
-	phy-supply = <&lp8733_ldo1_reg>;
-};
-
-&dss {
-	/* Supplied by VDA_1V8_PLL */
-	vdda_video-supply = <&lp8732_ldo0_reg>;
-};
-
-&hdmi {
-	/* Supplied by VDA_1V8_PHY */
-	vdda_video-supply = <&lp8732_ldo1_reg>;
-};
+/*
+ * Copyright (C) 2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "dra72-evm-common.dtsi"
+#include <dt-bindings/net/ti-dp83867.h>
+
+/ {
+	compatible = "ti,dra718-evm", "ti,dra718", "ti,dra722", "ti,dra72", "ti,dra7";
+	model = "TI DRA718 EVM";
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>; /* 2GB */
+	};
+
+	vpo_sd_1v8_3v3: gpio-regulator-TPS74801 {
+		compatible = "regulator-gpio";
+
+		regulator-name = "vddshv8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+		regulator-boot-on;
+		vin-supply = <&evm_5v0>;
+
+		gpios = <&gpio7 11 GPIO_ACTIVE_HIGH>;
+		states = <1800000 0x0
+			  3000000 0x1>;
+	};
+
+	poweroff: gpio-poweroff {
+		compatible = "gpio-poweroff";
+		gpios = <&gpio7 30 GPIO_ACTIVE_HIGH>;
+		input;
+	};
+};
+
+&dra7_pmx_core {
+	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_hs: mmc1_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr50: pinmux_mmc1_sdr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE15 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE0)	/* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_1_8v: mmc2_pins_ddr_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_hs200_1_8v: mmc2_pins_hs200_1_8v {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc1_iodelay_ddr50_conf: mmc1_iodelay_ddr50_conf {
+		pinctrl-pin-array = <
+			0x618 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CLK_IN */
+			0x624 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_IN */
+			0x630 A_DELAY_PS(495) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_IN */
+			0x63C A_DELAY_PS(116) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_IN */
+			0x648 A_DELAY_PS(117) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_IN */
+			0x654 A_DELAY_PS(32) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_IN */
+			0x620 A_DELAY_PS(1224) G_DELAY_PS(0)	/* CFG_MMC1_CLK_OUT */
+			0x62C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(44) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(64) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(79) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65C A_DELAY_PS(87) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64C A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc1_iodelay_sdr104_conf: mmc1_iodelay_sdr104_conf {
+		pinctrl-pin-array = <
+			0x620 A_DELAY_PS(520) G_DELAY_PS(320)	/* CFG_MMC1_CLK_OUT */
+			0x62c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OUT */
+			0x638 A_DELAY_PS(40) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OUT */
+			0x644 A_DELAY_PS(83) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OUT */
+			0x650 A_DELAY_PS(98) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OUT */
+			0x65c A_DELAY_PS(106) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OUT */
+			0x628 A_DELAY_PS(51) G_DELAY_PS(0)	/* CFG_MMC1_CMD_OEN */
+			0x634 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_MMC1_DAT0_OEN */
+			0x640 A_DELAY_PS(363) G_DELAY_PS(0)	/* CFG_MMC1_DAT1_OEN */
+			0x64c A_DELAY_PS(199) G_DELAY_PS(0)	/* CFG_MMC1_DAT2_OEN */
+			0x658 A_DELAY_PS(273) G_DELAY_PS(0)	/* CFG_MMC1_DAT3_OEN */
+		>;
+	};
+
+	mmc2_iodelay_ddr_1_8v_conf: mmc2_iodelay_ddr_1_8v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_IN */
+			0x1a4 A_DELAY_PS(121) G_DELAY_PS(0)	/* CFG_GPMC_A20_IN */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_IN */
+			0x1bc A_DELAY_PS(20) G_DELAY_PS(0)	/* CFG_GPMC_A22_IN */
+			0x1c8 A_DELAY_PS(108) G_DELAY_PS(0)	/* CFG_GPMC_A23_IN */
+			0x1d4 A_DELAY_PS(31) G_DELAY_PS(0)	/* CFG_GPMC_A24_IN */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1ec A_DELAY_PS(24) G_DELAY_PS(0)	/* CFG_GPMC_A26_IN */
+			0x1f8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_IN */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x194 A_DELAY_PS(152) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(206) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(78) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(2) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(266) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(43) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+
+	mmc2_iodelay_hs200_1_8v_conf: mmc2_iodelay_hs200_1_8v_conf {
+		pinctrl-pin-array = <
+			0x194 A_DELAY_PS(135) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1ac A_DELAY_PS(189) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b8 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A21_OUT */
+			0x1c4 A_DELAY_PS(0) G_DELAY_PS(70)	/* CFG_GPMC_A22_OUT */
+			0x1d0 A_DELAY_PS(730) G_DELAY_PS(360)	/* CFG_GPMC_A23_OUT */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1f4 A_DELAY_PS(70) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x368 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_CS1_OUT */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x1a8 A_DELAY_PS(231) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1b4 A_DELAY_PS(39) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1c0 A_DELAY_PS(91) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1d8 A_DELAY_PS(176) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1f0 A_DELAY_PS(101) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x364 A_DELAY_PS(360) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+		>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+	lp8733: lp8733@60 {
+		compatible = "ti,lp8733";
+		reg = <0x60>;
+
+		buck0-in-supply =<&vsys_3v3>;
+		buck1-in-supply =<&vsys_3v3>;
+		ldo0-in-supply =<&evm_5v0>;
+		ldo1-in-supply =<&evm_5v0>;
+
+		lp8733_regulators: regulators {
+			lp8733_buck0_reg: buck0 {
+				/* FB_B0 -> LP8733-BUCK1 - VPO_S1_AVS - VDD_CORE_AVS (core, mpu, gpu) */
+				regulator-name = "lp8733-buck0";
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			lp8733_buck1_reg: buck1 {
+				/* FB_B1 -> LP8733-BUCK2 - VPO_S2_AVS - VDD_DSP_AVS (DSP/eve/iva) */
+				regulator-name = "lp8733-buck1";
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			lp8733_ldo0_reg: ldo0 {
+				/* LDO0 -> LP8733-LDO1 - VPO_L1_3V3 - VDDSHV8 (optional) */
+				regulator-name = "lp8733-ldo0";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			lp8733_ldo1_reg: ldo1 {
+				/* LDO1 -> LP8733-LDO2 - VPO_L2_3V3 - VDDA_USB3V3 */
+				regulator-name = "lp8733-ldo1";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+		};
+	};
+
+	lp8732: lp8732@61 {
+		compatible = "ti,lp8732";
+		reg = <0x61>;
+
+		buck0-in-supply =<&vsys_3v3>;
+		buck1-in-supply =<&vsys_3v3>;
+		ldo0-in-supply =<&vsys_3v3>;
+		ldo1-in-supply =<&vsys_3v3>;
+
+		lp8732_regulators: regulators {
+			lp8732_buck0_reg: buck0 {
+				/* FB_B0 -> LP8732-BUCK1 - VPO_S3_1V8 - VDDS_1V8 */
+				regulator-name = "lp8732-buck0";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+
+			lp8732_buck1_reg: buck1 {
+				/* FB_B1 -> LP8732-BUCK2 - VPO_S4_DDR - VDD_DDR_1V35 */
+				regulator-name = "lp8732-buck1";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			lp8732_ldo0_reg: ldo0 {
+				/* LDO0 -> LP8732-LDO1 - VPO_L3_1V8 - VDA_1V8_PLL */
+				regulator-name = "lp8732-ldo0";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			lp8732_ldo1_reg: ldo1 {
+				/* LDO1 -> LP8732-LDO2 - VPO_L4_1V8 - VDA_1V8_PHY */
+				regulator-name = "lp8732-ldo1";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+		};
+	};
+};
+
+&pcf_gpio_21 {
+	interrupt-parent = <&gpio7>;
+	interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+};
+
+&pcf_hdmi {
+	p0 {
+		/*
+		 * PM_OEn to High: Disable routing I2C3 to PM_I2C
+		 * With this PM_SEL(p3) should not matter
+		 */
+		gpio-hog;
+		gpios = <0 GPIO_ACTIVE_LOW>;
+		output-high;
+		line-name = "pm_oe_n";
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs", "sdr12", "sdr25", "sdr50", "ddr50", "sdr104";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+	pinctrl-2 = <&mmc1_pins_sdr12>;
+	pinctrl-3 = <&mmc1_pins_sdr25>;
+	pinctrl-4 = <&mmc1_pins_sdr50>;
+	pinctrl-5 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf>;
+	pinctrl-6 = <&mmc1_pins_sdr104 &mmc1_iodelay_sdr104_conf>;
+	vmmc_aux-supply = <&vpo_sd_1v8_3v3>;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v", "hs200_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_1_8v &mmc2_iodelay_ddr_1_8v_conf>;
+	pinctrl-3 = <&mmc2_pins_hs200_1_8v &mmc2_iodelay_hs200_1_8v_conf>;
+};
+
+&mac {
+	mode-gpios = <&pcf_gpio_21 4 GPIO_ACTIVE_LOW>,
+		     <&pcf_hdmi 9 GPIO_ACTIVE_LOW>,	/* P11 */
+		     <&pcf_hdmi 10 GPIO_ACTIVE_LOW>;	/* P12 */
+	dual_emac;
+};
+
+&cpsw_emac0 {
+	phy-handle = <&dp83867_0>;
+	phy-mode = "rgmii-id";
+	dual_emac_res_vlan = <1>;
+};
+
+&cpsw_emac1 {
+	phy-handle = <&dp83867_1>;
+	phy-mode = "rgmii-id";
+	dual_emac_res_vlan = <2>;
+};
+
+&davinci_mdio {
+	dp83867_0: ethernet-phy@2 {
+		reg = <2>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		ti,impedance-control = <0x1f>;
+	};
+
+	dp83867_1: ethernet-phy@3 {
+		reg = <3>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+		ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		ti,impedance-control = <0x1f>;
+	};
+};
+
+/* No Sata on this device */
+&sata_phy {
+	status = "disabled";
+};
+
+&sata {
+	status = "disabled";
+};
+
+/* No RTC on this device */
+&rtc {
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	phy-supply = <&lp8733_ldo1_reg>;
+};
+
+&usb2_phy2 {
+	phy-supply = <&lp8733_ldo1_reg>;
+};
+
+&dss {
+	/* Supplied by VDA_1V8_PLL */
+	vdda_video-supply = <&lp8732_ldo0_reg>;
+};
+
+&hdmi {
+	/* Supplied by VDA_1V8_PHY */
+	vdda_video-supply = <&lp8732_ldo1_reg>;
+};
diff -u -N U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h
--- U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h	2019-09-12 15:54:29.000000112 -0500
+++ U-Boot_SDcard/arch/arm/include/asm/arch-omap5/dra7xx_iodelay.h	1969-12-31 19:29:30.000000539 -0600
@@ -83,6 +83,9 @@
 void __recalibrate_iodelay(struct pad_conf_entry const *pad, int npads,
 			   struct iodelay_cfg_entry const *iodelay,
 			   int niodelays);
+void late_recalibrate_iodelay(struct pad_conf_entry const *pad, int npads,
+			   struct iodelay_cfg_entry const *iodelay,
+			   int niodelays);
 int __recalibrate_iodelay_start(void);
 void __recalibrate_iodelay_end(int ret);
 
diff -u -N U-Boot_SDcard/board/technexion/twister/twister.c U-Boot_SDcard/board/technexion/twister/twister.c
--- U-Boot_SDcard/board/technexion/twister/twister.c	2019-09-12 15:54:47.000000623 -0500
+++ U-Boot_SDcard/board/technexion/twister/twister.c	1969-12-31 19:29:27.000000124 -0600
@@ -130,8 +130,7 @@
 	return 0;
 }
 
-#if defined(CONFIG_OMAP_HSMMC) && \
-	!defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_OMAP_HSMMC)
 int board_mmc_init(bd_t *bis)
 {
 	return omap_mmc_init(0, 0, 0, -1, -1);
diff -u -N U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c
--- U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c	2019-09-12 15:54:41.000000586 -0500
+++ U-Boot_SDcard/arch/arm/cpu/arm926ejs/lpc32xx/devices.c	1969-12-31 19:29:30.000000156 -0600
@@ -45,10 +45,14 @@
 
 #if !CONFIG_IS_ENABLED(OF_CONTROL)
 static const struct ns16550_platdata lpc32xx_uart[] = {
-	{ .base = UART3_BASE, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = UART4_BASE, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = UART5_BASE, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
-	{ .base = UART6_BASE, .reg_shift = 2, .clock = CONFIG_SYS_NS16550_CLK },
+	{ .base = UART3_BASE, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = UART4_BASE, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = UART5_BASE, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
+	{ .base = UART6_BASE, .reg_shift = 2,
+	  .clock = CONFIG_SYS_NS16550_CLK, .fcr = UART_FCR_DEFVAL, },
 };
 
 #if defined(CONFIG_LPC32XX_HSUART)
diff -u -N U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig
--- U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am43xx_evm_usbhost_boot_defconfig	1969-12-31 19:29:17.000000973 -0600
@@ -1,5 +1,6 @@
 CONFIG_ARM=y
 CONFIG_AM43XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_AM43XX_EVM=y
 CONFIG_ISW_ENTRY_ADDR=0x40300350
 CONFIG_SPL_STACK_R_ADDR=0x82000000
@@ -11,7 +12,9 @@
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_MTD_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
 CONFIG_SPL_USB_HOST_SUPPORT=y
@@ -38,19 +41,28 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
 CONFIG_OF_LIST="am437x-gp-evm am437x-sk-evm am43x-epos-evm am437x-idk-evm"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_OF_TRANSLATE=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
 CONFIG_DFU_SF=y
 CONFIG_DM_GPIO=y
+CONFIG_DM_I2C=y
 CONFIG_DM_MMC=y
 # CONFIG_DM_MMC_OPS is not set
+CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
 CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_ETH=y
 CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
 CONFIG_TI_QSPI=y
 CONFIG_TIMER=y
 CONFIG_OMAP_TIMER=y
@@ -67,4 +79,4 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0403
 CONFIG_G_DNL_PRODUCT_NUM=0xbd00
-CONFIG_SPL_OF_LIBFDT=y
+CONFIG_DM_NAND=y
diff -u -N U-Boot_SDcard/scripts/Makefile.spl U-Boot_SDcard/scripts/Makefile.spl
--- U-Boot_SDcard/scripts/Makefile.spl	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/scripts/Makefile.spl	1969-12-31 19:29:19.000000542 -0600
@@ -206,8 +206,13 @@
 # 'u-boot,dm-pre-reloc' property and thus are not needed by SPL. The second
 # pass removes various unused properties from the remaining nodes.
 # The output is typically a much smaller device tree file.
+ifeq ($(CONFIG_TPL_BUILD),y)
+fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-tpl
+else
+fdtgrep_props := -b u-boot,dm-pre-reloc -b u-boot,dm-spl
+endif
 quiet_cmd_fdtgrep = FDTGREP $@
-      cmd_fdtgrep = $(objtree)/tools/fdtgrep -b u-boot,dm-pre-reloc -RT $< \
+      cmd_fdtgrep = $(objtree)/tools/fdtgrep $(fdtgrep_props) -RT $< \
 		-n /chosen -O dtb | \
 	$(objtree)/tools/fdtgrep -r -O dtb - -o $@ \
 		$(addprefix -P ,$(subst $\",,$(CONFIG_OF_SPL_REMOVE_PROPS)))
diff -u -N U-Boot_SDcard/tools/patman/patman U-Boot_SDcard/tools/patman/patman
--- U-Boot_SDcard/tools/patman/patman	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/tools/patman/patman	1969-12-31 19:29:23.000000138 -0600
@@ -1,177 +1,1 @@
-#!/usr/bin/env python
-#
-# Copyright (c) 2011 The Chromium OS Authors.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-"""See README for more information"""
-
-from optparse import OptionParser
-import os
-import re
-import sys
-import unittest
-
-# Our modules
-try:
-    from patman import checkpatch, command, gitutil, patchstream, \
-        project, settings, terminal, test
-except ImportError:
-    import checkpatch
-    import command
-    import gitutil
-    import patchstream
-    import project
-    import settings
-    import terminal
-    import test
-
-
-parser = OptionParser()
-parser.add_option('-H', '--full-help', action='store_true', dest='full_help',
-       default=False, help='Display the README file')
-parser.add_option('-c', '--count', dest='count', type='int',
-       default=-1, help='Automatically create patches from top n commits')
-parser.add_option('-i', '--ignore-errors', action='store_true',
-       dest='ignore_errors', default=False,
-       help='Send patches email even if patch errors are found')
-parser.add_option('-m', '--no-maintainers', action='store_false',
-       dest='add_maintainers', default=True,
-       help="Don't cc the file maintainers automatically")
-parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
-       default=False, help="Do a dry run (create but don't email patches)")
-parser.add_option('-p', '--project', default=project.DetectProject(),
-                  help="Project name; affects default option values and "
-                  "aliases [default: %default]")
-parser.add_option('-r', '--in-reply-to', type='string', action='store',
-                  help="Message ID that this series is in reply to")
-parser.add_option('-s', '--start', dest='start', type='int',
-       default=0, help='Commit to start creating patches from (0 = HEAD)')
-parser.add_option('-t', '--ignore-bad-tags', action='store_true',
-                  default=False, help='Ignore bad tags / aliases')
-parser.add_option('--test', action='store_true', dest='test',
-                  default=False, help='run tests')
-parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
-       default=False, help='Verbose output of errors and warnings')
-parser.add_option('--cc-cmd', dest='cc_cmd', type='string', action='store',
-       default=None, help='Output cc list for patch file (used by git)')
-parser.add_option('--no-check', action='store_false', dest='check_patch',
-                  default=True,
-                  help="Don't check for patch compliance")
-parser.add_option('--no-tags', action='store_false', dest='process_tags',
-                  default=True, help="Don't process subject tags as aliaes")
-parser.add_option('-T', '--thread', action='store_true', dest='thread',
-                  default=False, help='Create patches as a single thread')
-
-parser.usage += """
-
-Create patches from commits in a branch, check them and email them as
-specified by tags you place in the commits. Use -n to do a dry run first."""
-
-
-# Parse options twice: first to get the project and second to handle
-# defaults properly (which depends on project).
-(options, args) = parser.parse_args()
-settings.Setup(parser, options.project, '')
-(options, args) = parser.parse_args()
-
-if __name__ != "__main__":
-    pass
-
-# Run our meagre tests
-elif options.test:
-    import doctest
-
-    sys.argv = [sys.argv[0]]
-    suite = unittest.TestLoader().loadTestsFromTestCase(test.TestPatch)
-    result = unittest.TestResult()
-    suite.run(result)
-
-    for module in ['gitutil', 'settings']:
-        suite = doctest.DocTestSuite(module)
-        suite.run(result)
-
-    # TODO: Surely we can just 'print' result?
-    print(result)
-    for test, err in result.errors:
-        print(err)
-    for test, err in result.failures:
-        print(err)
-
-# Called from git with a patch filename as argument
-# Printout a list of additional CC recipients for this patch
-elif options.cc_cmd:
-    fd = open(options.cc_cmd, 'r')
-    re_line = re.compile('(\S*) (.*)')
-    for line in fd.readlines():
-        match = re_line.match(line)
-        if match and match.group(1) == args[0]:
-            for cc in match.group(2).split(', '):
-                cc = cc.strip()
-                if cc:
-                    print(cc)
-    fd.close()
-
-elif options.full_help:
-    pager = os.getenv('PAGER')
-    if not pager:
-        pager = 'more'
-    fname = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),
-                         'README')
-    command.Run(pager, fname)
-
-# Process commits, produce patches files, check them, email them
-else:
-    gitutil.Setup()
-
-    if options.count == -1:
-        # Work out how many patches to send if we can
-        options.count = gitutil.CountCommitsToBranch() - options.start
-
-    col = terminal.Color()
-    if not options.count:
-        str = 'No commits found to process - please use -c flag'
-        sys.exit(col.Color(col.RED, str))
-
-    # Read the metadata from the commits
-    if options.count:
-        series = patchstream.GetMetaData(options.start, options.count)
-        cover_fname, args = gitutil.CreatePatches(options.start, options.count,
-                series)
-
-    # Fix up the patch files to our liking, and insert the cover letter
-    series = patchstream.FixPatches(series, args)
-    if series and cover_fname and series.get('cover'):
-        patchstream.InsertCoverLetter(cover_fname, series, options.count)
-
-    # Do a few checks on the series
-    series.DoChecks()
-
-    # Check the patches, and run them through 'git am' just to be sure
-    if options.check_patch:
-        ok = checkpatch.CheckPatches(options.verbose, args)
-    else:
-        ok = True
-
-    cc_file = series.MakeCcFile(options.process_tags, cover_fname,
-                                not options.ignore_bad_tags,
-                                options.add_maintainers)
-
-    # Email the patches out (giving the user time to check / cancel)
-    cmd = ''
-    its_a_go = ok or options.ignore_errors
-    if its_a_go:
-        cmd = gitutil.EmailPatches(series, cover_fname, args,
-                options.dry_run, not options.ignore_bad_tags, cc_file,
-                in_reply_to=options.in_reply_to, thread=options.thread)
-    else:
-        print(col.Color(col.RED, "Not sending emails due to errors/warnings"))
-
-    # For a dry run, just show our actions as a sanity check
-    if options.dry_run:
-        series.ShowActions(args, cmd, options.process_tags)
-        if not its_a_go:
-            print(col.Color(col.RED, "Email would not be sent"))
-
-    os.remove(cc_file)
+patman.py
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/mips/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/mips/dts/include/dt-bindings	1969-12-31 19:31:37.000000956 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N U-Boot_SDcard/configs/am57xx_evm_defconfig U-Boot_SDcard/configs/am57xx_evm_defconfig
--- U-Boot_SDcard/configs/am57xx_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am57xx_evm_defconfig	1969-12-31 19:29:17.000000975 -0600
@@ -1,19 +1,25 @@
 CONFIG_ARM=y
 CONFIG_OMAP54XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
 # CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TARGET_AM57XX_EVM=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
 CONFIG_ARMV7_LPAE=y
 CONFIG_SPL_STACK_R_ADDR=0x82000000
-CONFIG_DEFAULT_DEVICE_TREE="am57xx-beagle-x15"
+CONFIG_DEFAULT_DEVICE_TREE="am572x-idk"
 CONFIG_FIT=y
 CONFIG_OF_BOARD_SETUP=y
+CONFIG_DRA7_DSPEVE_OPP_HIGH=y
+CONFIG_DRA7_IVA_OPP_HIGH=y
+CONFIG_DRA7_GPU_OPP_HIGH=y
 CONFIG_SPL_LOAD_FIT=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_DMA_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
 CONFIG_HUSH_PARSER=y
@@ -48,8 +54,16 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
-CONFIG_OF_LIST="am57xx-beagle-x15 am57xx-beagle-x15-revb1 am572x-idk am571x-idk"
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_SPL_OF_TRANSLATE=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_OF_LIST="am57xx-beagle-x15 am57xx-beagle-x15-revb1 am57xx-evm-reva3 am572x-idk am571x-idk"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_REGMAP=y
+CONFIG_SPL_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_SYSCON=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -60,10 +74,12 @@
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_BAR=y
-CONFIG_SPI_FLASH_SPANSION=y
+#CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_DM_PMIC=y
 CONFIG_PMIC_PALMAS=y
 CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_PALMAS=y
 CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
@@ -82,4 +98,3 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
-CONFIG_SPL_OF_LIBFDT=y
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2e-clocks.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2e-clocks.dtsi	1969-12-31 19:31:37.000000930 -0600
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Edison SoC specific device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+clocks {
+	mainpllclk: mainpllclk@2310110 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,main-pll-clock";
+		clocks = <&refclksys>;
+		reg = <0x02620350 4>, <0x02310110 4>, <0x02310108 4>;
+		reg-names = "control", "multiplier", "post-divider";
+	};
+
+	papllclk: papllclk@2620358 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkpass>;
+		clock-output-names = "papllclk";
+		reg = <0x02620358 4>;
+		reg-names = "control";
+	};
+
+	ddr3apllclk: ddr3apllclk@2620360 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkddr3a>;
+		clock-output-names = "ddr-3a-pll-clk";
+		reg = <0x02620360 4>;
+		reg-names = "control";
+	};
+
+	clkusb1: clkusb1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk16>;
+		clock-output-names = "usb1";
+		reg = <0x02350004 0xb00>, <0x02350000 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <0>;
+	};
+
+	clkhyperlink0: clkhyperlink0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "hyperlink-0";
+		reg = <0x02350030 0xb00>, <0x02350014 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <5>;
+	};
+
+	clkpcie1: clkpcie1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "pcie1";
+		reg = <0x0235006c 0xb00>, <0x02350048 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <18>;
+	};
+
+	clkxge: clkxge {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "xge";
+		reg = <0x023500c8 0xb00>, <0x02350074 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <29>;
+	};
+};
diff -u -N U-Boot_SDcard/common/spl/Kconfig U-Boot_SDcard/common/spl/Kconfig
--- U-Boot_SDcard/common/spl/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/common/spl/Kconfig	1969-12-31 19:29:20.000000762 -0600
@@ -6,6 +6,9 @@
 config SUPPORT_TPL
 	bool
 
+config SPL_DFU_NO_RESET
+	bool
+
 config SPL
 	bool
 	depends on SUPPORT_SPL
@@ -449,6 +452,23 @@
 	  in drivers/power, drivers/power/pmic and drivers/power/regulator
 	  as part of an SPL build.
 
+config SPL_RAM_SUPPORT
+	bool "Support booting from RAM"
+	depends on SPL
+	default y if MICROBLAZE || ARCH_SOCFPGA || TEGRA || ARCH_ZYNQ
+	help
+	  Enable booting of an image in RAM. The image can be preloaded or
+	  it can be loaded by SPL directly into RAM (e.g. using USB).
+
+config SPL_RAM_DEVICE
+	bool "Support booting from preloaded image in RAM"
+	depends on SPL_RAM_SUPPORT
+	default y if MICROBLAZE || ARCH_SOCFPGA || TEGRA || ARCH_ZYNQ
+	help
+	  Enable booting of an image already loaded in RAM. The image has to
+	  be already in memory when SPL takes over, e.g. loaded by the boot
+	  ROM.
+
 config SPL_SATA_SUPPORT
 	bool "Support loading from SATA"
 	depends on SPL
@@ -535,6 +555,8 @@
 config SPL_DFU_SUPPORT
 	bool "Support DFU (Device Firmware Upgarde)"
 	select SPL_HASH_SUPPORT
+	select SPL_DFU_NO_RESET
+	depends on SPL_RAM_SUPPORT
 	help
 	  This feature enables the DFU (Device Firmware Upgarde) in SPL with
 	  RAM memory device support. The ROM code will load and execute
@@ -549,7 +571,7 @@
 
 config SPL_DFU_RAM
 	bool "RAM device"
-	depends on SPL_DFU_SUPPORT
+	depends on SPL_DFU_SUPPORT && SPL_RAM_SUPPORT
 	help
 	 select RAM/DDR memory device for loading binary images
 	 (u-boot/kernel) to the selected device partition using
diff -u -N U-Boot_SDcard/doc/README.ti-secure U-Boot_SDcard/doc/README.ti-secure
--- U-Boot_SDcard/doc/README.ti-secure	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/doc/README.ti-secure	1969-12-31 19:29:18.000000932 -0600
@@ -133,6 +133,26 @@
 	u-boot-spl_HS_X-LOADER - boot image for all other flash memories
 		including QSPI and NOR flash
 
+	Invoking the script for Keystone2 Secure Devices
+	=============================================
+
+	create-boot-image.sh \
+		<UNUSED> <INPUT_FILE> <OUTPUT_FILE> <UNUSED>
+
+	<UNUSED> is currently ignored and reserved for future use.
+
+	<INPUT_FILE> is the full path and filename of the public world boot
+	loader binary file (only u-boot.bin is currently supported on
+	Keystone2 devices, u-boot-spl.bin is not currently supported).
+
+	<OUTPUT_FILE> is the full path and filename of the final secure image.
+	The output binary images should be used in place of the standard
+	non-secure binary images (see the platform-specific user's guides
+	and releases notes for how the non-secure images are typically used)
+	u-boot_HS_MLO - signed and encrypted boot image that can be used to
+		boot from all media. Secure boot from SPI NOR flash is not
+		currently supported.
+
 Booting of Primary U-Boot (u-boot.img)
 ======================================
 
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/omap5-u-boot.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/omap5-u-boot.dtsi	1969-12-31 19:31:37.000000947 -0600
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * Based on "dra7.dtsi"
+ */
+
+/{
+	ocp {
+		u-boot,dm-spl;
+	};
+};
+
+&uart1 {
+	u-boot,dm-spl;
+};
+
+&uart3 {
+	u-boot,dm-spl;
+};
+
+&mmc1 {
+	u-boot,dm-spl;
+};
+
+&mmc2 {
+	u-boot,dm-spl;
+};
+
+&l4_cfg {
+	u-boot,dm-spl;
+};
+
+&scm {
+	u-boot,dm-spl;
+};
+
+&scm_conf {
+	u-boot,dm-spl;
+};
+
+&qspi {
+	u-boot,dm-spl;
+
+	m25p80@0 {
+		u-boot,dm-spl;
+	};
+};
+
+&gpio2 {
+	u-boot,dm-spl;
+};
+
+&gpio7 {
+	u-boot,dm-spl;
+};
diff -u -N U-Boot_SDcard/board/davinci/da8xxevm/README.da850 U-Boot_SDcard/board/davinci/da8xxevm/README.da850
--- U-Boot_SDcard/board/davinci/da8xxevm/README.da850	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/board/davinci/da8xxevm/README.da850	1969-12-31 19:29:25.000000175 -0600
@@ -47,6 +47,70 @@
 U-Boot > tftp u-boot.ais
 U-Boot > sf write c0700000 0 $filesize
 
+Flashing the images to NAND
+===========================
+The AIS image can be written to NAND using the u-boot "nand" commands.
+
+Example:
+
+OMAPL138_LCDK requires the AIS image to be written to the second block of
+the NAND flash.
+
+From the "nand info" command we see that the second block would start at
+offset 0x20000:
+
+  U-Boot > nand info
+      sector size      128 KiB (0x20000)
+      Page size       2048 b
+
+From the tftp command we see that we need to copy 0x74908 bytes from
+memory address 0xc0700000 (0x75000 if we align a page of 2048):
+
+  U-Boot > tftp u-boot.ais
+      Load address: 0xc0700000
+      Bytes transferred = 477448 (74908 hex)
+
+The commands to write the image from memory to NAND would be:
+
+  U-Boot > nand erase 0x20000 0x75000
+  U-Boot > nand write 0xc0700000 0x20000 0x75000
+
+Alternatively, MTD partitions may be defined. Using "mtdparts" to
+conveniently have a bootloader partition starting at the second block
+(offset 0x20000):
+
+  setenv mtdids nand0=davinci_nand.0
+  setenv mtdparts mtdparts=davinci_nand.0:128k(bootenv),2m(bootloader)
+
+In this case the commands would be simplified to:
+
+  U-Boot > tftp u-boot.ais
+  U-Boot > nand erase.part bootloader
+  U-Boot > nand write 0xc0700000 bootloader
+
+Flashing the images to MMC
+==========================
+If the boot pins are set to boot from mmc, the RBL will try to load the
+next boot stage form the first couple of sectors of an external mmc card.
+As sector 0 is usually used for storing the partition information, the
+AIS image should be written at least after the first sector, but before the
+first partition begins. (e.g: make sure to leave at least 500KB of unallocated
+space at the start of the mmc when creating the partitions)
+
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR is used by SPL, and should
+point to the sector were the u-boot image is located. (eg. After SPL)
+
+There are 2 ways to copy the AIS image to the mmc card:
+
+ 1 - Using the TI tool "uflash"
+	$ uflash -d /dev/mmcblk0  -b ./u-boot.ais -p OMAPL138  -vv
+
+ 2 - using the "dd" command
+	$ dd if=u-boot.ais of=/dev/mmcblk0 seek=117 bs=512 conv=fsync
+
+uflash writes the AIS image at offset 117. For compatibility with uflash,
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR is set to take into account this
+offset, and the dd command is adjusted accordingly.
 
 Recovery
 ========
diff -u -N U-Boot_SDcard/configs/am43xx_hs_evm_defconfig U-Boot_SDcard/configs/am43xx_hs_evm_defconfig
--- U-Boot_SDcard/configs/am43xx_hs_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am43xx_hs_evm_defconfig	1969-12-31 19:29:17.000000974 -0600
@@ -1,21 +1,37 @@
 CONFIG_ARM=y
 CONFIG_AM43XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TI_SECURE_DEVICE=y
+CONFIG_TI_SECURE_EMIF_REGION_START=0xbdb00000
+CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE=0x02000000
+CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE=0x01c00000
 CONFIG_TARGET_AM43XX_EVM=y
 CONFIG_ISW_ENTRY_ADDR=0x403018e0
 CONFIG_SPL_STACK_R_ADDR=0x82000000
 CONFIG_SPL_YMODEM_SUPPORT=y
 CONFIG_DEFAULT_DEVICE_TREE="am437x-gp-evm"
 CONFIG_FIT=y
-CONFIG_SYS_EXTRA_OPTIONS="CONS_INDEX=1, NAND"
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="CONS_INDEX=1,NAND"
 CONFIG_SPL_LOAD_FIT=y
 CONFIG_SPL_FIT_IMAGE_POST_PROCESS=y
 CONFIG_FIT_IMAGE_POST_PROCESS=y
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_ETH_SUPPORT=y
 CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_SPL_NET_SUPPORT=y
+CONFIG_SPL_NET_VCI_STRING="AM43xx U-Boot SPL"
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USBETH_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_SUPPORT=y
 CONFIG_HUSH_PARSER=y
 CONFIG_CMD_BOOTZ=y
 # CONFIG_CMD_IMLS is not set
@@ -38,7 +54,12 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_OF_LIST="am437x-gp-evm am437x-sk-evm am43x-epos-evm am437x-idk-evm"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_OF_TRANSLATE=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -47,10 +68,11 @@
 CONFIG_DM_I2C=y
 CONFIG_DM_MMC=y
 # CONFIG_DM_MMC_OPS is not set
+CONFIG_DM_NAND=y
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
 CONFIG_SPI_FLASH_MACRONIX=y
-CONFIG_DM_ETH=y
 CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
 CONFIG_DM_SPI=y
@@ -70,4 +92,3 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0403
 CONFIG_G_DNL_PRODUCT_NUM=0xbd00
-CONFIG_SPL_OF_LIBFDT=y
diff -u -N U-Boot_SDcard/tools/dtoc/dtoc U-Boot_SDcard/tools/dtoc/dtoc
--- U-Boot_SDcard/tools/dtoc/dtoc	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/tools/dtoc/dtoc	1969-12-31 19:29:23.000000071 -0600
@@ -1,382 +1,1 @@
-#!/usr/bin/python
-#
-# Copyright (C) 2016 Google, Inc
-# Written by Simon Glass <sjg@chromium.org>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-import copy
-from optparse import OptionError, OptionParser
-import os
-import struct
-import sys
-
-# Bring in the patman libraries
-our_path = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(our_path, '../patman'))
-
-import fdt
-import fdt_select
-import fdt_util
-
-# When we see these properties we ignore them - i.e. do not create a structure member
-PROP_IGNORE_LIST = [
-    '#address-cells',
-    '#gpio-cells',
-    '#size-cells',
-    'compatible',
-    'linux,phandle',
-    "status",
-    'phandle',
-    'u-boot,dm-pre-reloc',
-]
-
-# C type declarations for the tyues we support
-TYPE_NAMES = {
-    fdt.TYPE_INT: 'fdt32_t',
-    fdt.TYPE_BYTE: 'unsigned char',
-    fdt.TYPE_STRING: 'const char *',
-    fdt.TYPE_BOOL: 'bool',
-};
-
-STRUCT_PREFIX = 'dtd_'
-VAL_PREFIX = 'dtv_'
-
-def Conv_name_to_c(name):
-    """Convert a device-tree name to a C identifier
-
-    Args:
-        name:   Name to convert
-    Return:
-        String containing the C version of this name
-    """
-    str = name.replace('@', '_at_')
-    str = str.replace('-', '_')
-    str = str.replace(',', '_')
-    str = str.replace('/', '__')
-    return str
-
-def TabTo(num_tabs, str):
-    if len(str) >= num_tabs * 8:
-        return str + ' '
-    return str + '\t' * (num_tabs - len(str) // 8)
-
-class DtbPlatdata:
-    """Provide a means to convert device tree binary data to platform data
-
-    The output of this process is C structures which can be used in space-
-    constrained encvironments where the ~3KB code overhead of device tree
-    code is not affordable.
-
-    Properties:
-        fdt: Fdt object, referencing the device tree
-        _dtb_fname: Filename of the input device tree binary file
-        _valid_nodes: A list of Node object with compatible strings
-        _options: Command-line options
-        _phandle_node: A dict of nodes indexed by phandle number (1, 2...)
-        _outfile: The current output file (sys.stdout or a real file)
-        _lines: Stashed list of output lines for outputting in the future
-        _phandle_node: A dict of Nodes indexed by phandle (an integer)
-    """
-    def __init__(self, dtb_fname, options):
-        self._dtb_fname = dtb_fname
-        self._valid_nodes = None
-        self._options = options
-        self._phandle_node = {}
-        self._outfile = None
-        self._lines = []
-
-    def SetupOutput(self, fname):
-        """Set up the output destination
-
-        Once this is done, future calls to self.Out() will output to this
-        file.
-
-        Args:
-            fname: Filename to send output to, or '-' for stdout
-        """
-        if fname == '-':
-            self._outfile = sys.stdout
-        else:
-            self._outfile = open(fname, 'w')
-
-    def Out(self, str):
-        """Output a string to the output file
-
-        Args:
-            str: String to output
-        """
-        self._outfile.write(str)
-
-    def Buf(self, str):
-        """Buffer up a string to send later
-
-        Args:
-            str: String to add to our 'buffer' list
-        """
-        self._lines.append(str)
-
-    def GetBuf(self):
-        """Get the contents of the output buffer, and clear it
-
-        Returns:
-            The output buffer, which is then cleared for future use
-        """
-        lines = self._lines
-        self._lines = []
-        return lines
-
-    def GetValue(self, type, value):
-        """Get a value as a C expression
-
-        For integers this returns a byte-swapped (little-endian) hex string
-        For bytes this returns a hex string, e.g. 0x12
-        For strings this returns a literal string enclosed in quotes
-        For booleans this return 'true'
-
-        Args:
-            type: Data type (fdt_util)
-            value: Data value, as a string of bytes
-        """
-        if type == fdt.TYPE_INT:
-            return '%#x' % fdt_util.fdt32_to_cpu(value)
-        elif type == fdt.TYPE_BYTE:
-            return '%#x' % ord(value[0])
-        elif type == fdt.TYPE_STRING:
-            return '"%s"' % value
-        elif type == fdt.TYPE_BOOL:
-            return 'true'
-
-    def GetCompatName(self, node):
-        """Get a node's first compatible string as a C identifier
-
-        Args:
-            node: Node object to check
-        Return:
-            C identifier for the first compatible string
-        """
-        compat = node.props['compatible'].value
-        if type(compat) == list:
-            compat = compat[0]
-        return Conv_name_to_c(compat)
-
-    def ScanDtb(self):
-        """Scan the device tree to obtain a tree of notes and properties
-
-        Once this is done, self.fdt.GetRoot() can be called to obtain the
-        device tree root node, and progress from there.
-        """
-        self.fdt = fdt_select.FdtScan(self._dtb_fname)
-
-    def ScanTree(self):
-        """Scan the device tree for useful information
-
-        This fills in the following properties:
-            _phandle_node: A dict of Nodes indexed by phandle (an integer)
-            _valid_nodes: A list of nodes we wish to consider include in the
-                platform data
-        """
-        node_list = []
-        self._phandle_node = {}
-        for node in self.fdt.GetRoot().subnodes:
-            if 'compatible' in node.props:
-                status = node.props.get('status')
-                if (not options.include_disabled and not status or
-                    status.value != 'disabled'):
-                    node_list.append(node)
-                    phandle_prop = node.props.get('phandle')
-                    if phandle_prop:
-                        phandle = phandle_prop.GetPhandle()
-                        self._phandle_node[phandle] = node
-
-        self._valid_nodes = node_list
-
-    def IsPhandle(self, prop):
-        """Check if a node contains phandles
-
-        We have no reliable way of detecting whether a node uses a phandle
-        or not. As an interim measure, use a list of known property names.
-
-        Args:
-            prop: Prop object to check
-        Return:
-            True if the object value contains phandles, else False
-        """
-        if prop.name in ['clocks']:
-            return True
-        return False
-
-    def ScanStructs(self):
-        """Scan the device tree building up the C structures we will use.
-
-        Build a dict keyed by C struct name containing a dict of Prop
-        object for each struct field (keyed by property name). Where the
-        same struct appears multiple times, try to use the 'widest'
-        property, i.e. the one with a type which can express all others.
-
-        Once the widest property is determined, all other properties are
-        updated to match that width.
-        """
-        structs = {}
-        for node in self._valid_nodes:
-            node_name = self.GetCompatName(node)
-            fields = {}
-
-            # Get a list of all the valid properties in this node.
-            for name, prop in node.props.items():
-                if name not in PROP_IGNORE_LIST and name[0] != '#':
-                    fields[name] = copy.deepcopy(prop)
-
-            # If we've seen this node_name before, update the existing struct.
-            if node_name in structs:
-                struct = structs[node_name]
-                for name, prop in fields.items():
-                    oldprop = struct.get(name)
-                    if oldprop:
-                        oldprop.Widen(prop)
-                    else:
-                        struct[name] = prop
-
-            # Otherwise store this as a new struct.
-            else:
-                structs[node_name] = fields
-
-        upto = 0
-        for node in self._valid_nodes:
-            node_name = self.GetCompatName(node)
-            struct = structs[node_name]
-            for name, prop in node.props.items():
-                if name not in PROP_IGNORE_LIST and name[0] != '#':
-                    prop.Widen(struct[name])
-            upto += 1
-        return structs
-
-    def GenerateStructs(self, structs):
-        """Generate struct defintions for the platform data
-
-        This writes out the body of a header file consisting of structure
-        definitions for node in self._valid_nodes. See the documentation in
-        README.of-plat for more information.
-        """
-        self.Out('#include <stdbool.h>\n')
-        self.Out('#include <libfdt.h>\n')
-
-        # Output the struct definition
-        for name in sorted(structs):
-            self.Out('struct %s%s {\n' % (STRUCT_PREFIX, name));
-            for pname in sorted(structs[name]):
-                prop = structs[name][pname]
-                if self.IsPhandle(prop):
-                    # For phandles, include a reference to the target
-                    self.Out('\t%s%s[%d]' % (TabTo(2, 'struct phandle_2_cell'),
-                                             Conv_name_to_c(prop.name),
-                                             len(prop.value) / 2))
-                else:
-                    ptype = TYPE_NAMES[prop.type]
-                    self.Out('\t%s%s' % (TabTo(2, ptype),
-                                         Conv_name_to_c(prop.name)))
-                    if type(prop.value) == list:
-                        self.Out('[%d]' % len(prop.value))
-                self.Out(';\n')
-            self.Out('};\n')
-
-    def GenerateTables(self):
-        """Generate device defintions for the platform data
-
-        This writes out C platform data initialisation data and
-        U_BOOT_DEVICE() declarations for each valid node. See the
-        documentation in README.of-plat for more information.
-        """
-        self.Out('#include <common.h>\n')
-        self.Out('#include <dm.h>\n')
-        self.Out('#include <dt-structs.h>\n')
-        self.Out('\n')
-        node_txt_list = []
-        for node in self._valid_nodes:
-            struct_name = self.GetCompatName(node)
-            var_name = Conv_name_to_c(node.name)
-            self.Buf('static struct %s%s %s%s = {\n' %
-                (STRUCT_PREFIX, struct_name, VAL_PREFIX, var_name))
-            for pname, prop in node.props.items():
-                if pname in PROP_IGNORE_LIST or pname[0] == '#':
-                    continue
-                ptype = TYPE_NAMES[prop.type]
-                member_name = Conv_name_to_c(prop.name)
-                self.Buf('\t%s= ' % TabTo(3, '.' + member_name))
-
-                # Special handling for lists
-                if type(prop.value) == list:
-                    self.Buf('{')
-                    vals = []
-                    # For phandles, output a reference to the platform data
-                    # of the target node.
-                    if self.IsPhandle(prop):
-                        # Process the list as pairs of (phandle, id)
-                        it = iter(prop.value)
-                        for phandle_cell, id_cell in zip(it, it):
-                            phandle = fdt_util.fdt32_to_cpu(phandle_cell)
-                            id = fdt_util.fdt32_to_cpu(id_cell)
-                            target_node = self._phandle_node[phandle]
-                            name = Conv_name_to_c(target_node.name)
-                            vals.append('{&%s%s, %d}' % (VAL_PREFIX, name, id))
-                    else:
-                        for val in prop.value:
-                            vals.append(self.GetValue(prop.type, val))
-                    self.Buf(', '.join(vals))
-                    self.Buf('}')
-                else:
-                    self.Buf(self.GetValue(prop.type, prop.value))
-                self.Buf(',\n')
-            self.Buf('};\n')
-
-            # Add a device declaration
-            self.Buf('U_BOOT_DEVICE(%s) = {\n' % var_name)
-            self.Buf('\t.name\t\t= "%s",\n' % struct_name)
-            self.Buf('\t.platdata\t= &%s%s,\n' % (VAL_PREFIX, var_name))
-            self.Buf('\t.platdata_size\t= sizeof(%s%s),\n' %
-                     (VAL_PREFIX, var_name))
-            self.Buf('};\n')
-            self.Buf('\n')
-
-            # Output phandle target nodes first, since they may be referenced
-            # by others
-            if 'phandle' in node.props:
-                self.Out(''.join(self.GetBuf()))
-            else:
-                node_txt_list.append(self.GetBuf())
-
-        # Output all the nodes which are not phandle targets themselves, but
-        # may reference them. This avoids the need for forward declarations.
-        for node_txt in node_txt_list:
-            self.Out(''.join(node_txt))
-
-
-if __name__ != "__main__":
-    pass
-
-parser = OptionParser()
-parser.add_option('-d', '--dtb-file', action='store',
-                  help='Specify the .dtb input file')
-parser.add_option('--include-disabled', action='store_true',
-                  help='Include disabled nodes')
-parser.add_option('-o', '--output', action='store', default='-',
-                  help='Select output filename')
-(options, args) = parser.parse_args()
-
-if not args:
-    raise ValueError('Please specify a command: struct, platdata')
-
-plat = DtbPlatdata(options.dtb_file, options)
-plat.ScanDtb()
-plat.ScanTree()
-plat.SetupOutput(options.output)
-structs = plat.ScanStructs()
-
-for cmd in args[0].split(','):
-    if cmd == 'struct':
-        plat.GenerateStructs(structs)
-    elif cmd == 'platdata':
-        plat.GenerateTables()
-    else:
-        raise ValueError("Unknown command '%s': (use: struct, platdata)" % cmd)
+dtoc.py
\ No newline at end of file
diff -u -N U-Boot_SDcard/configs/am43xx_evm_defconfig U-Boot_SDcard/configs/am43xx_evm_defconfig
--- U-Boot_SDcard/configs/am43xx_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am43xx_evm_defconfig	1969-12-31 19:29:17.000000970 -0600
@@ -1,5 +1,6 @@
 CONFIG_ARM=y
 CONFIG_AM43XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_AM43XX_EVM=y
 CONFIG_SPL_STACK_R_ADDR=0x82000000
 CONFIG_SPL_YMODEM_SUPPORT=y
@@ -10,7 +11,9 @@
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_MTD_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
 CONFIG_HUSH_PARSER=y
@@ -35,8 +38,12 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
 CONFIG_OF_LIST="am437x-gp-evm am437x-sk-evm am43x-epos-evm am437x-idk-evm"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_OF_TRANSLATE=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -49,7 +56,6 @@
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_BAR=y
 CONFIG_SPI_FLASH_MACRONIX=y
-CONFIG_DM_ETH=y
 CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
 CONFIG_DM_SPI=y
@@ -69,4 +75,10 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0403
 CONFIG_G_DNL_PRODUCT_NUM=0xbd00
+CONFIG_DM_NAND=y
+CONFIG_SPL_USBETH_SUPPORT=y
 CONFIG_SPL_OF_LIBFDT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_NET_VCI_STRING="AM43xx U-Boot SPL"
+CONFIG_SPL_NET_SUPPORT=y
+CONFIG_SPL_ETH_SUPPORT=y
diff -u -N U-Boot_SDcard/tools/microcode-tool U-Boot_SDcard/tools/microcode-tool
--- U-Boot_SDcard/tools/microcode-tool	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/tools/microcode-tool	1969-12-31 19:29:19.000000635 -0600
@@ -1,317 +1,1 @@
-#!/usr/bin/env python
-#
-# Copyright (c) 2014 Google, Inc
-#
-# SPDX-License-Identifier:      GPL-2.0+
-#
-# Intel microcode update tool
-
-from optparse import OptionParser
-import os
-import re
-import struct
-import sys
-
-MICROCODE_DIR = 'arch/x86/dts/microcode'
-
-class Microcode:
-    """Holds information about the microcode for a particular model of CPU.
-
-    Attributes:
-        name:  Name of the CPU this microcode is for, including any version
-                   information (e.g. 'm12206a7_00000029')
-        model: Model code string (this is cpuid(1).eax, e.g. '206a7')
-        words: List of hex words containing the microcode. The first 16 words
-                   are the public header.
-    """
-    def __init__(self, name, data):
-        self.name = name
-        # Convert data into a list of hex words
-        self.words = []
-        for value in ''.join(data).split(','):
-            hexval = value.strip()
-            if hexval:
-                self.words.append(int(hexval, 0))
-
-        # The model is in the 4rd hex word
-        self.model = '%x' % self.words[3]
-
-def ParseFile(fname):
-    """Parse a micrcode.dat file and return the component parts
-
-    Args:
-        fname: Filename to parse
-    Returns:
-        3-Tuple:
-            date:         String containing date from the file's header
-            license_text: List of text lines for the license file
-            microcodes:   List of Microcode objects from the file
-    """
-    re_date = re.compile('/\* *(.* [0-9]{4}) *\*/$')
-    re_license = re.compile('/[^-*+] *(.*)$')
-    re_name = re.compile('/\* *(.*)\.inc *\*/', re.IGNORECASE)
-    microcodes = {}
-    license_text = []
-    date = ''
-    data = []
-    name = None
-    with open(fname) as fd:
-        for line in fd:
-            line = line.rstrip()
-            m_date = re_date.match(line)
-            m_license = re_license.match(line)
-            m_name = re_name.match(line)
-            if m_name:
-                if name:
-                    microcodes[name] = Microcode(name, data)
-                name = m_name.group(1).lower()
-                data = []
-            elif m_license:
-                license_text.append(m_license.group(1))
-            elif m_date:
-                date = m_date.group(1)
-            else:
-                data.append(line)
-    if name:
-        microcodes[name] = Microcode(name, data)
-    return date, license_text, microcodes
-
-def ParseHeaderFiles(fname_list):
-    """Parse a list of header files and return the component parts
-
-    Args:
-        fname_list: List of files to parse
-    Returns:
-            date:         String containing date from the file's header
-            license_text: List of text lines for the license file
-            microcodes:   List of Microcode objects from the file
-    """
-    microcodes = {}
-    license_text = []
-    date = ''
-    name = None
-    for fname in fname_list:
-        name = os.path.basename(fname).lower()
-        name = os.path.splitext(name)[0]
-        data = []
-        with open(fname) as fd:
-            license_start = False
-            license_end = False
-            for line in fd:
-                line = line.rstrip()
-
-                if len(line) >= 2:
-                    if line[0] == '/' and line[1] == '*':
-                        license_start = True
-                        continue
-                    if line[0] == '*' and line[1] == '/':
-                        license_end = True
-                        continue
-                if license_start and not license_end:
-                    # Ignore blank line
-                    if len(line) > 0:
-                        license_text.append(line)
-                    continue
-                # Omit anything after the last comma
-                words = line.split(',')[:-1]
-                data += [word + ',' for word in words]
-        microcodes[name] = Microcode(name, data)
-    return date, license_text, microcodes
-
-
-def List(date, microcodes, model):
-    """List the available microcode chunks
-
-    Args:
-        date:           Date of the microcode file
-        microcodes:     Dict of Microcode objects indexed by name
-        model:          Model string to search for, or None
-    """
-    print 'Date: %s' % date
-    if model:
-        mcode_list, tried = FindMicrocode(microcodes, model.lower())
-        print 'Matching models %s:' % (', '.join(tried))
-    else:
-        print 'All models:'
-        mcode_list = [microcodes[m] for m in microcodes.keys()]
-    for mcode in mcode_list:
-        print '%-20s: model %s' % (mcode.name, mcode.model)
-
-def FindMicrocode(microcodes, model):
-    """Find all the microcode chunks which match the given model.
-
-    This model is something like 306a9 (the value returned in eax from
-    cpuid(1) when running on Intel CPUs). But we allow a partial match,
-    omitting the last 1 or two characters to allow many families to have the
-    same microcode.
-
-    If the model name is ambiguous we return a list of matches.
-
-    Args:
-        microcodes: Dict of Microcode objects indexed by name
-        model:      String containing model name to find
-    Returns:
-        Tuple:
-            List of matching Microcode objects
-            List of abbreviations we tried
-    """
-    # Allow a full name to be used
-    mcode = microcodes.get(model)
-    if mcode:
-        return [mcode], []
-
-    tried = []
-    found = []
-    for i in range(3):
-        abbrev = model[:-i] if i else model
-        tried.append(abbrev)
-        for mcode in microcodes.values():
-            if mcode.model.startswith(abbrev):
-                found.append(mcode)
-        if found:
-            break
-    return found, tried
-
-def CreateFile(date, license_text, mcodes, outfile):
-    """Create a microcode file in U-Boot's .dtsi format
-
-    Args:
-        date:       String containing date of original microcode file
-        license:    List of text lines for the license file
-        mcodes:      Microcode objects to write (normally only 1)
-        outfile:    Filename to write to ('-' for stdout)
-    """
-    out = '''/*%s
- * ---
- * This is a device tree fragment. Use #include to add these properties to a
- * node.
- *
- * Date: %s
- */
-
-compatible = "intel,microcode";
-intel,header-version = <%d>;
-intel,update-revision = <%#x>;
-intel,date-code = <%#x>;
-intel,processor-signature = <%#x>;
-intel,checksum = <%#x>;
-intel,loader-revision = <%d>;
-intel,processor-flags = <%#x>;
-
-/* The first 48-bytes are the public header which repeats the above data */
-data = <%s
-\t>;'''
-    words = ''
-    add_comments = len(mcodes) > 1
-    for mcode in mcodes:
-        if add_comments:
-            words += '\n/* %s */' % mcode.name
-        for i in range(len(mcode.words)):
-            if not (i & 3):
-                words += '\n'
-            val = mcode.words[i]
-            # Change each word so it will be little-endian in the FDT
-            # This data is needed before RAM is available on some platforms so
-            # we cannot do an endianness swap on boot.
-            val = struct.unpack("<I", struct.pack(">I", val))[0]
-            words += '\t%#010x' % val
-
-    # Use the first microcode for the headers
-    mcode = mcodes[0]
-
-    # Take care to avoid adding a space before a tab
-    text = ''
-    for line in license_text:
-        if line[0] == '\t':
-            text += '\n *' + line
-        else:
-            text += '\n * ' + line
-    args = [text, date]
-    args += [mcode.words[i] for i in range(7)]
-    args.append(words)
-    if outfile == '-':
-        print out % tuple(args)
-    else:
-        if not outfile:
-            if not os.path.exists(MICROCODE_DIR):
-                print >> sys.stderr, "Creating directory '%s'" % MICROCODE_DIR
-                os.makedirs(MICROCODE_DIR)
-            outfile = os.path.join(MICROCODE_DIR, mcode.name + '.dtsi')
-        print >> sys.stderr, "Writing microcode for '%s' to '%s'" % (
-                ', '.join([mcode.name for mcode in mcodes]), outfile)
-        with open(outfile, 'w') as fd:
-            print >> fd, out % tuple(args)
-
-def MicrocodeTool():
-    """Run the microcode tool"""
-    commands = 'create,license,list'.split(',')
-    parser = OptionParser()
-    parser.add_option('-d', '--mcfile', type='string', action='store',
-                    help='Name of microcode.dat file')
-    parser.add_option('-H', '--headerfile', type='string', action='append',
-                    help='Name of .h file containing microcode')
-    parser.add_option('-m', '--model', type='string', action='store',
-                    help="Model name to extract ('all' for all)")
-    parser.add_option('-M', '--multiple', type='string', action='store',
-                    help="Allow output of multiple models")
-    parser.add_option('-o', '--outfile', type='string', action='store',
-                    help='Filename to use for output (- for stdout), default is'
-                    ' %s/<name>.dtsi' % MICROCODE_DIR)
-    parser.usage += """ command
-
-    Process an Intel microcode file (use -h for help). Commands:
-
-       create     Create microcode .dtsi file for a model
-       list       List available models in microcode file
-       license    Print the license
-
-    Typical usage:
-
-       ./tools/microcode-tool -d microcode.dat -m 306a create
-
-    This will find the appropriate file and write it to %s.""" % MICROCODE_DIR
-
-    (options, args) = parser.parse_args()
-    if not args:
-        parser.error('Please specify a command')
-    cmd = args[0]
-    if cmd not in commands:
-        parser.error("Unknown command '%s'" % cmd)
-
-    if (not not options.mcfile) != (not not options.mcfile):
-        parser.error("You must specify either header files or a microcode file, not both")
-    if options.headerfile:
-        date, license_text, microcodes = ParseHeaderFiles(options.headerfile)
-    elif options.mcfile:
-        date, license_text, microcodes = ParseFile(options.mcfile)
-    else:
-        parser.error('You must specify a microcode file (or header files)')
-
-    if cmd == 'list':
-        List(date, microcodes, options.model)
-    elif cmd == 'license':
-        print '\n'.join(license_text)
-    elif cmd == 'create':
-        if not options.model:
-            parser.error('You must specify a model to create')
-        model = options.model.lower()
-        if options.model == 'all':
-            options.multiple = True
-            mcode_list = microcodes.values()
-            tried = []
-        else:
-            mcode_list, tried = FindMicrocode(microcodes, model)
-        if not mcode_list:
-            parser.error("Unknown model '%s' (%s) - try 'list' to list" %
-                        (model, ', '.join(tried)))
-        if not options.multiple and len(mcode_list) > 1:
-            parser.error("Ambiguous model '%s' (%s) matched %s - try 'list' "
-                        "to list or specify a particular file" %
-                        (model, ', '.join(tried),
-                        ', '.join([m.name for m in mcode_list])))
-        CreateFile(date, license_text, mcode_list, options.outfile)
-    else:
-        parser.error("Unknown command '%s'" % cmd)
-
-if __name__ == "__main__":
-    MicrocodeTool()
+microcode-tool.py
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/microblaze/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/microblaze/dts/include/dt-bindings	1969-12-31 19:31:37.000000955 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2l.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2l.dtsi	1969-12-31 19:31:37.000000946 -0600
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Lamarr SoC specific device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&gic>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <1>;
+		};
+	};
+
+	soc {
+		/include/ "keystone-k2l-clocks.dtsi"
+
+		uart2: serial@02348400 {
+			compatible = "ns16550a";
+			current-speed = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			reg = <0x02348400 0x100>;
+			clocks	= <&clkuart2>;
+			interrupts = <GIC_SPI 432 IRQ_TYPE_EDGE_RISING>;
+		};
+
+		uart3:	serial@02348800 {
+			compatible = "ns16550a";
+			current-speed = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			reg = <0x02348800 0x100>;
+			clocks	= <&clkuart3>;
+			interrupts = <GIC_SPI 435 IRQ_TYPE_EDGE_RISING>;
+		};
+
+		dspgpio0: keystone_dsp_gpio@02620240 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x240>;
+		};
+
+		dspgpio1: keystone_dsp_gpio@2620244 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x244>;
+		};
+
+		dspgpio2: keystone_dsp_gpio@2620248 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x248>;
+		};
+
+		dspgpio3: keystone_dsp_gpio@262024c {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x24c>;
+		};
+
+		mdio: mdio@26200f00 {
+			compatible	= "ti,keystone_mdio", "ti,davinci_mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x26200f00 0x100>;
+			status = "disabled";
+			clocks = <&clkcpgmac>;
+			clock-names = "fck";
+			bus_freq	= <2500000>;
+		};
+		/include/ "keystone-k2l-netcp.dtsi"
+	};
+};
+
+&spi0 {
+       ti,davinci-spi-num-cs = <5>;
+};
+
+&spi1 {
+       ti,davinci-spi-num-cs = <3>;
+};
+
+&spi2 {
+       ti,davinci-spi-num-cs = <5>;
+       /* Pin muxed. Enabled and configured by Bootloader */
+       status = "disabled";
+};
diff -u -N /dev/null U-Boot_SDcard/doc/README.rapidio
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/doc/README.rapidio	1969-12-31 19:31:37.000000912 -0600
@@ -0,0 +1,152 @@
+                         RapidIO support for TI KeyStone devices
+                         =======================================
+
+
+This feature allows to boot a device through RapidIO using DirectIO (DIO).
+A new set of commands is added to U-Boot for this purpose.
+
+This feature is today designed to work with Texas Instruments KeyStone
+devices but may easily be extended to work on different architectures.
+
+How it works
+------------
+
+This boot mechanism uses the DIO functionality which allows a remote
+device to directly read from and write into the device's address space
+(basically the DDR or any mapped memory such as MSM).
+
+The boot sequence is pretty simple. The RIO driver probe initializes the
+RapidIO controller. Then the remote link partner can push the various
+images (kernel, fdt, ... etc.) into their respective locations on the
+local device through DirectIO while the local U-boot is waiting for a
+signal that the push is done. When the local U-Boot receives such a signal
+it can then start the kernel normally like with any other boot mechanism.
+
+It is the link partner's responsability to push the various images into the
+proper location of the local device's memory.
+
+The wait/signal in the image pushing process is done by the RapidIO doorbell.
+Use the 'rio doorbell_rx <info>' U-Boot command to wait
+for a 16-bit doorbell info. The link partner has only to send the expected
+16-bit doorbell info value when it has finished pushing all images.
+
+Basically the sequence should be as follows (A is the device to be booted,
+B is the link partner device which pushes the images to boot):
+
+ [B]: board is up and booted, RapidIO controller is initialized but not the link
+ [A]: board is powered on, entering U-Boot
+ [A]: U-Boot probes the RapidIO device driver, configures the local RapidIO
+      controller and hardware waits the link establishement
+ [B]: Linux kernel starts the RapidIO link configuration and eventually the
+      RapidIO enumeration/discovery process (see Linux kernel RapidIO subsytem
+      driver for more information)
+ [AB]: RapidIO link is now established between the two link partners
+ [A]: the 'rio doorbell_rx <info>' command is called and wait for doorbell
+ [B]: pushes the kernel image using DIO to pre-defined location
+ [B]: pushes the dtb image using DIO to pre-defined location
+ [B]: pushes the skern image using DIO to pre-defined location
+ [B]: (depends on bootmode) pushes the filesystem image using DIO to
+      pre-defined location
+ [B]: sends doorbell to [A] to signify end of pushing images
+ [A]: U-Boot receives the doorbell and exits the 'rio doorbell_rx' cmd
+ [A}: issue 'rio shutdown' command to power off rapidio
+ [A]: skern, fdt and kernel can be installed and started normally with the
+      'mon_install' and 'bootm' U-Boot commands
+
+RapidIO subsystem commands
+--------------------------
+
+ - rio devices:
+   This command is used to probe and show the RapidIO devices (with U-Boot
+   assigned device numbers devnum) available.  Corresponding drivers initialize
+   the respective RapidIO controlller while being probed.  It is not necessary
+   to run this command in order to have the device driver probed.  Following
+   commands also triggers probes to the devices.
+
+The <devnum> in the following commands designates the RapidIO device to
+execute the command.  If there is only one RapidIO device in the system,
+then the devnum must be 0.
+
+ - rio doorbell_rx <devnum> <info>:
+   Blocking wait for receiving 16-bit doorbell <info>.
+   (<info> is implementation specific).
+
+ - rio remove <devnum>:
+   Disables the RapidIO controller.
+
+ - rio r <devnum> port dst_id hopcount offset:
+   This command allows to read the remote RapidIO configuration space by
+   performing a maintenance read request.
+
+ - rio w <devnum> port dst_id hopcount offset value:
+   This command allows to write into the remote RapidIO configuration
+   space by performing a maintenance write request.
+
+ - rio lr <devnum> offset:
+   This performs a local RapidIO configuration space read.
+
+ - rio lw <devnum> offset value:
+   This performs a local RapidIO configuration space write.
+
+Device support
+--------------
+
+The RapidIO controller of the KeyStone devices is supported through the
+drivers/rapidio/keystone_rio.c device driver.
+
+The RapidIO driver must conform to the rio-uclass requirements, namely,
+implements probe(), remove() and the APIs specified in struct rio_ops.
+
+Booting with RapidIO
+--------------------
+
+Example of RapidIO booting with U-Boot:
+
+=> rio devices
+RapidIO uclass entries:
+devnum    device             driver
+  0       rapidio@2900000    rio_keystone
+=> rio doorbell_rx 0 0xffff
+keystone_rio_doorbell_rx: waiting for dbell any ...
+received dbell[0] status: 0x00000001
+=> rio remove 0
+=> mon_install ${addr_mon}
+## installed monitor, freq [200000000], status 0
+=> bootm ${addr_kern} ${addr_uninitrd} ${addr_fdt}
+Kernel image @ 0x82000000 [ 0x000000 - 0x400fc0 ]
+## Flattened Device Tree blob at 88000000
+   Booting using the fdt blob at 0x88000000
+   Loading Device Tree to 8fff4000, end 8ffff518 ... OK
+
+Starting kernel ...
+
+-----
+
+Here is an Linux example that uses the riot utility and the mport_cdev
+feature to boot a remote device.  The remote device uses the U-Boot
+RapidIO booting mechanism (like the example above):
+
+./riot -f k2hk_fs.cpio.gz -D 1 -A 0x88080000
+./riot -f k2hk-evm.dtb -D 1 -A 0x88000000
+./riot -f skern-k2hk.bin -D 1 -A 0x0c5f0000
+./riot -f zImage -D 1 -A 0x82000000
+./riot -L 0x00 -D 1
+
+where -f: image file, -D: destid, -A: remote mem addr, -L: doorbell info
+
+This will push the various images and notify U-Boot.
+
+-----
+
+Example of (local and remote) read/write commands:
+
+K2HK EVM # rio r 0 0 -1 1 0x0
+00000000: b9810030                               0...
+K2HK EVM # rio r 0 0 -1 1 0x4
+00000004: 00000000                               ....
+K2HK EVM # rio r 0 0 -1 1 0x8
+00000008: 00000030                               0...
+K2HK EVM # rio lr 0 0
+00000000: b9810030                               0...
+K2HK EVM # rio lr 0 8
+00000008: 00000030                               0...
diff -u -N /dev/null U-Boot_SDcard/configs/am335x_hs_evm_uart_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/am335x_hs_evm_uart_defconfig	1969-12-31 19:31:37.000000905 -0600
@@ -0,0 +1,68 @@
+CONFIG_ARM=y
+CONFIG_AM33XX=y
+# CONFIG_SPL_ENV_SUPPORT is not set
+# CONFIG_SPL_EXT_SUPPORT is not set
+# CONFIG_SPL_FAT_SUPPORT is not set
+# CONFIG_SPL_LIBDISK_SUPPORT is not set
+# CONFIG_SPL_MMC_SUPPORT is not set
+# CONFIG_SPL_NAND_SUPPORT is not set
+CONFIG_TI_SECURE_DEVICE=y
+CONFIG_TARGET_AM335X_EVM=y
+CONFIG_ISW_ENTRY_ADDR=0x40301950
+CONFIG_SPL_STACK_R_ADDR=0x82000000
+CONFIG_DEFAULT_DEVICE_TREE="am335x-evm"
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="NAND"
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SPL_FIT_IMAGE_POST_PROCESS=y
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
+CONFIG_SPL_STACK_R=y
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="am335x-evm"
+# CONFIG_BLK is not set
+CONFIG_DFU_MMC=y
+CONFIG_DFU_NAND=y
+CONFIG_DFU_RAM=y
+CONFIG_DM_I2C=y
+CONFIG_DM_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_DM_ETH=y
+CONFIG_SYS_NS16550=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_USB=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
+CONFIG_G_DNL_VENDOR_NUM=0x0451
+CONFIG_G_DNL_PRODUCT_NUM=0xd022
+CONFIG_USE_TINY_PRINTF=y
+CONFIG_RSA=y
+CONFIG_SPL_OF_LIBFDT=y
+CONFIG_OF_LIBFDT=y
diff -u -N U-Boot_SDcard/configs/k2hk_evm_defconfig U-Boot_SDcard/configs/k2hk_evm_defconfig
--- U-Boot_SDcard/configs/k2hk_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/k2hk_evm_defconfig	1969-12-31 19:29:18.000000285 -0600
@@ -9,13 +9,13 @@
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
 # CONFIG_MMC is not set
-CONFIG_DEFAULT_DEVICE_TREE="k2hk-evm"
+CONFIG_SYS_TEXT_BASE=0x0c000000
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2hk-evm"
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
 CONFIG_HUSH_PARSER=y
-CONFIG_SYS_PROMPT="K2HK EVM # "
 CONFIG_CMD_BOOTZ=y
 # CONFIG_CMD_IMLS is not set
 CONFIG_CMD_ASKENV=y
@@ -35,6 +35,7 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_CMD_UBI=y
+CONFIG_CMD_RIO=y
 CONFIG_OF_CONTROL=y
 CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_DM=y
@@ -50,3 +51,7 @@
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_DWC3=y
 CONFIG_USB_STORAGE=y
+CONFIG_KEYSTONE_RIO=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2hk-evm"
diff -u -N /dev/null U-Boot_SDcard/configs/k2e_hs_evm_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/k2e_hs_evm_defconfig	1969-12-31 19:31:37.000000908 -0600
@@ -0,0 +1,47 @@
+CONFIG_ARM=y
+CONFIG_ARCH_KEYSTONE=y
+CONFIG_TARGET_K2E_EVM=y
+CONFIG_TI_SECURE_DEVICE=y
+# CONFIG_MMC is not set
+CONFIG_SYS_TEXT_BASE=0x0c000060
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2e-evm"
+CONFIG_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_NAND=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_CONTROL=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_TI_AEMIF=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_DM_ETH=y
+CONFIG_DM_SERIAL=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
diff -u -N U-Boot_SDcard/scripts/Makefile.lib U-Boot_SDcard/scripts/Makefile.lib
--- U-Boot_SDcard/scripts/Makefile.lib	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/scripts/Makefile.lib	1969-12-31 19:29:19.000000541 -0600
@@ -363,10 +363,17 @@
 $(obj)/%_efi.S: $(obj)/%.efi
 	$(call cmd,S_efi)
 
+quiet_cmd_efi_objcopy = OBJCOPY $@
+cmd_efi_objcopy = $(OBJCOPY) -j .header -j .text -j .sdata -j .data -j \
+		.dynamic -j .dynsym  -j .rel* -j .rela* -j .reloc \
+		$(if $(EFI_TARGET),$(EFI_TARGET),-O binary) $^ $@
+
 $(obj)/%.efi: $(obj)/%.so
-	$(OBJCOPY) -j .header -j .text -j .sdata -j .data -j .dynamic \
-		-j .dynsym  -j .rel* -j .rela* -j .reloc \
-		$(if $(EFI_TARGET),$(EFI_TARGET),-O binary) $^ $@
+	$(call cmd,efi_objcopy)
+
+quiet_cmd_efi_ld = LD      $@
+cmd_efi_ld = $(LD) -nostdlib -znocombreloc -T $(EFI_LDS_PATH) -shared \
+		-Bsymbolic $^ -o $@
 
 EFI_LDS_PATH = $(srctree)/arch/$(ARCH)/lib/$(EFI_LDS)
 
@@ -374,8 +381,7 @@
 
 $(obj)/helloworld.so: $(obj)/helloworld.o arch/$(ARCH)/lib/$(EFI_CRT0) \
 		arch/$(ARCH)/lib/$(EFI_RELOC)
-	$(LD) -nostdlib -znocombreloc -T $(EFI_LDS_PATH) -shared -Bsymbolic \
-		$^ -o $@
+	$(call cmd,efi_ld)
 
 # ACPI
 # ---------------------------------------------------------------------------
diff -u -N /dev/null U-Boot_SDcard/arch/sandbox/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/sandbox/dts/include/dt-bindings	1969-12-31 19:31:37.000000958 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N U-Boot_SDcard/configs/omapl138_lcdk_defconfig U-Boot_SDcard/configs/omapl138_lcdk_defconfig
--- U-Boot_SDcard/configs/omapl138_lcdk_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/omapl138_lcdk_defconfig	1969-12-31 19:29:18.000000481 -0600
@@ -3,6 +3,7 @@
 CONFIG_TARGET_OMAPL138_LCDK=y
 CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_MMC_SUPPORT=y
 CONFIG_SPL_NAND_SUPPORT=y
 CONFIG_SPL_SERIAL_SUPPORT=y
 CONFIG_BOOTDELAY=3
@@ -12,7 +13,6 @@
 CONFIG_SPL=y
 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0xb5
 CONFIG_HUSH_PARSER=y
-CONFIG_SYS_PROMPT="U-Boot > "
 CONFIG_CMD_BOOTZ=y
 # CONFIG_CMD_IMLS is not set
 CONFIG_CMD_ASKENV=y
@@ -22,9 +22,12 @@
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_MII=y
 CONFIG_CMD_PING=y
+CONFIG_CMD_TIME=y
 CONFIG_CMD_EXT2=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_UBI=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_SYS_NAND_U_BOOT_LOCATIONS=y
 CONFIG_SYS_NAND_U_BOOT_OFFS=0x28000
 CONFIG_SPI_FLASH=y
diff -u -N U-Boot_SDcard/configs/dra7xx_evm_defconfig U-Boot_SDcard/configs/dra7xx_evm_defconfig
--- U-Boot_SDcard/configs/dra7xx_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/dra7xx_evm_defconfig	1969-12-31 19:29:18.000000174 -0600
@@ -1,5 +1,6 @@
 CONFIG_ARM=y
 CONFIG_OMAP54XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
 # CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TARGET_DRA7XX_EVM=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
@@ -9,11 +10,16 @@
 CONFIG_DEFAULT_DEVICE_TREE="dra7-evm"
 CONFIG_FIT=y
 CONFIG_OF_BOARD_SETUP=y
+CONFIG_DRA7_DSPEVE_OPP_HIGH=y
+CONFIG_DRA7_IVA_OPP_HIGH=y
+CONFIG_DRA7_GPU_OPP_HIGH=y
 CONFIG_SPL_LOAD_FIT=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_DMA_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
 CONFIG_HUSH_PARSER=y
@@ -48,8 +54,16 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_SPL_OF_TRANSLATE=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
 CONFIG_OF_LIST="dra7-evm dra72-evm dra72-evm-revc dra71-evm"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_REGMAP=y
+CONFIG_SPL_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_SYSCON=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -68,6 +82,7 @@
 CONFIG_PMIC_PALMAS=y
 CONFIG_PMIC_LP873X=y
 CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_PALMAS=y
@@ -91,4 +106,3 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
-CONFIG_SPL_OF_LIBFDT=y
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2hk-netcp.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2hk-netcp.dtsi	1969-12-31 19:31:37.000000941 -0600
@@ -0,0 +1,218 @@
+/*
+ * Device Tree Source for Keystone 2 Hawking Netcp driver
+ *
+ * Copyright 2015 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+qmss: qmss@2a40000 {
+	compatible = "ti,keystone-navigator-qmss";
+	dma-coherent;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	clocks = <&chipclk13>;
+	ranges;
+	queue-range	= <0 0x4000>;
+	linkram0	= <0x100000 0x8000>;
+	linkram1	= <0x0 0x10000>;
+
+	qmgrs {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		qmgr0 {
+			managed-queues = <0 0x2000>;
+			reg = <0x2a40000 0x20000>,
+			      <0x2a06000 0x400>,
+			      <0x2a02000 0x1000>,
+			      <0x2a03000 0x1000>,
+			      <0x23a80000 0x20000>,
+			      <0x2a80000 0x20000>;
+			reg-names = "peek", "status", "config",
+				    "region", "push", "pop";
+		};
+
+		qmgr1 {
+			managed-queues = <0x2000 0x2000>;
+			reg = <0x2a60000 0x20000>,
+			      <0x2a06400 0x400>,
+			      <0x2a04000 0x1000>,
+			      <0x2a05000 0x1000>,
+			      <0x23aa0000 0x20000>,
+			      <0x2aa0000 0x20000>;
+			reg-names = "peek", "status", "config",
+				    "region", "push", "pop";
+		};
+	};
+	queue-pools {
+		qpend {
+			qpend-0 {
+				qrange = <658 8>;
+				interrupts =<0 40 0xf04 0 41 0xf04 0 42 0xf04
+					     0 43 0xf04 0 44 0xf04 0 45 0xf04
+					     0 46 0xf04 0 47 0xf04>;
+			};
+			qpend-1 {
+				qrange = <8704 16>;
+				interrupts = <0 48 0xf04 0 49 0xf04 0 50 0xf04
+					      0 51 0xf04 0 52 0xf04 0 53 0xf04
+					      0 54 0xf04 0 55 0xf04 0 56 0xf04
+					      0 57 0xf04 0 58 0xf04 0 59 0xf04
+					      0 60 0xf04 0 61 0xf04 0 62 0xf04
+					      0 63 0xf04>;
+				qalloc-by-id;
+			};
+			qpend-2 {
+				qrange = <8720 16>;
+				interrupts = <0 64 0xf04 0 65 0xf04 0 66 0xf04
+					      0 59 0xf04 0 68 0xf04 0 69 0xf04
+					      0 70 0xf04 0 71 0xf04 0 72 0xf04
+					      0 73 0xf04 0 74 0xf04 0 75 0xf04
+					      0 76 0xf04 0 77 0xf04 0 78 0xf04
+					      0 79 0xf04>;
+			};
+		};
+		general-purpose {
+			gp-0 {
+				qrange = <4000 64>;
+			};
+			netcp-tx {
+				qrange = <640 9>;
+				qalloc-by-id;
+			};
+			netcpx-tx {
+				qrange = <8752 8>;
+				qalloc-by-id;
+			};
+		};
+	};
+	descriptor-regions {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		region-12 {
+			id = <12>;
+			region-spec = <8192 128>;	/* num_desc desc_size */
+			link-index = <0x4000>;
+		};
+	};
+}; /* qmss */
+
+knav_dmas: knav_dmas@0 {
+	compatible = "ti,keystone-navigator-dma";
+	clocks = <&papllclk>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	ranges;
+	ti,navigator-cloud-address = <0x23a80000 0x23a90000
+				   0x23aa0000 0x23ab0000>;
+
+	dma_gbe: dma_gbe@0 {
+		reg = <0x2004000 0x100>,
+			  <0x2004400 0x120>,
+			  <0x2004800 0x300>,
+			  <0x2004c00 0x120>,
+			  <0x2005000 0x400>;
+		reg-names = "global", "txchan", "rxchan",
+				"txsched", "rxflow";
+	};
+
+	dma_srio: dma_srio@0 {
+		reg = <0x2901000 0x020>,
+			<0x2901400 0x200>,
+			<0x2901800 0x200>,
+			<0x2901c00 0x200>,
+			<0x2902000 0x280>;
+		reg-names = "global", "txchan", "rxchan",
+				"txsched", "rxflow";
+	};
+};
+
+netcp: netcp@2000000 {
+	reg = <0x2620110 0x8>;
+	reg-names = "efuse";
+	compatible = "ti,netcp-1.0";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	/* NetCP address range */
+	ranges  = <0 0x2000000 0x100000>;
+
+	clocks = <&papllclk>, <&clkcpgmac>, <&chipclk12>;
+	dma-coherent;
+
+	ti,navigator-dmas = <&dma_gbe 22>,
+			<&dma_gbe 23>,
+			<&dma_gbe 8>;
+	ti,navigator-dma-names = "netrx0", "netrx1", "nettx";
+
+	netcp-devices {
+		ranges;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		gbe@90000 { /* ETHSS */
+			#address-cells = <1>;
+			#size-cells = <1>;
+			label = "netcp-gbe";
+			compatible = "ti,netcp-gbe";
+			reg = <0x90000 0x300>, <0x90400 0x400>, <0x90800 0x700>;
+			/* enable-ale; */
+			tx-queue = <648>;
+			tx-channel = "nettx";
+
+			interfaces {
+				gbe0: interface-0 {
+					slave-port = <0>;
+					link-interface = <1>;
+					phy-handle = <&ethphy0>;
+				};
+				gbe1: interface-1 {
+					slave-port = <1>;
+					link-interface = <1>;
+					phy-handle = <&ethphy1>;
+				};
+			};
+
+			secondary-slave-ports {
+				port-2 {
+					slave-port = <2>;
+					link-interface	= <2>;
+				};
+				port-3 {
+					slave-port = <3>;
+					link-interface	= <2>;
+				};
+			};
+		};
+	};
+
+	netcp-interfaces {
+		interface-0 {
+			rx-channel = "netrx0";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <8704>;
+			tx-completion-queue = <8706>;
+			efuse-mac = <1>;
+			netcp-gbe = <&gbe0>;
+
+		};
+		interface-1 {
+			rx-channel = "netrx1";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <8705>;
+			tx-completion-queue = <8707>;
+			efuse-mac = <0>;
+			local-mac-address = [02 18 31 7e 3e 6f];
+			netcp-gbe = <&gbe1>;
+		};
+	};
+};
diff -u -N U-Boot_SDcard/dts/Kconfig U-Boot_SDcard/dts/Kconfig
--- U-Boot_SDcard/dts/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/dts/Kconfig	1969-12-31 19:29:19.000000011 -0600
@@ -61,14 +61,15 @@
 
 config OF_LIST
 	string "List of device tree files to include for DT control"
-	depends on SPL_LOAD_FIT
+	depends on SPL_LOAD_FIT || FIT_EMBED
 	default DEFAULT_DEVICE_TREE
 	help
 	  This option specifies a list of device tree files to use for DT
-	  control. These will be packaged into a FIT. At run-time, SPL will
-	  select the correct DT to use by examining the hardware (e.g.
-	  reading a board ID value). This is a list of device tree files
-	  (without the directory or .dtb suffix) separated by <space>.
+	  control. These will be packaged into a FIT. At run-time, U-boot
+	  or SPL will select the correct DT to use by examining the
+	  hardware (e.g. reading a board ID value). This is a list of
+	  device tree files (without the directory or .dtb suffix)
+	  separated by <space>.
 
 config OF_SPL_REMOVE_PROPS
 	string "List of device tree properties to drop for SPL"
diff -u -N /dev/null U-Boot_SDcard/lib/efi_loader/helloworld.so
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/lib/efi_loader/helloworld.so	1969-12-31 19:31:37.000000926 -0600
@@ -0,0 +1,104 @@
+ELF          (        4       4    (                                         `   `         Qtd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MZ                                                          @   PE               X          8  8                                   8                                                                                 .reloc                              @ B.text   X  8  X  8                P@-  0$  VO    0        8FjkIBhyDG !o(F
+FFG  8p    #pFFFX...RhDmhdh3|  pd -y-+h"DX	P Hp  H e l l o ,   w o r l d ! 
+                           l                
+   k                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  :   2            u  $                   W           *     \     R           4            `            L                      A        
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              efi_main image_base _edata EFI_SUBSYSTEM _relocate _text _etext _text_size _data _bss _bss_end _data_size              	                                             
+         GCC: (Ubuntu/Linaro 4.8.4-2ubuntu1~14.04.1) 4.8.4 A,   aeabi "   7-A 
+A	
+           
+  t  $       (     I	  *  D  %   j  (  3   int I  p        k        u8 %   s16 !L   u16 "3   s32 $^   u32 %p   u64 (     5,   ;  6,               1  "     )   Y,   o
+  gA   '  hS     ie      m~   	  8,   /  9      :      ;I  
+G  F    G      H      I     J     K    
+>  (  	           W   V    a       	       
+          +     day         	     c     	     _     	          	      
+          [     s           	   m  P   
+,	  3    l   F  l  &           U  	h  	  
+    	     q      3  
+  H  hdr w   x  ,        	  ,    X  v  $  ,   (
+    ,  ,   0	    4    8#	  F  <C  ,   @F    D n  
+[   F  hdr !w   }  "	  
+  #	    %
+     '6
+  $  (q
+  (   +
+  ,  ,
+  0  .
+  4\	  3	  8   5(  <  7
+  @  8
+  D
+  9
+  H  ;R  L  >v  P  A  TK  C  X  EI  \  F  `1  I  df	  M'  hr  PA  l  So  p  W  t  Z  x  ]
+  |  ^  O  `    a	  	  b  4  eA  1  i`    q  
+  uv  S  x    |        x    J
+  .  H
+  D  x  i      7
+    	  I     
+  P  hdr w   	    y	    6       2  $  V  (f   p  ,    0    4    8    <F    @	  I  D3  I  H   I  L L    =-  b >     .  ?  Y  `             
+j  XJ    ,    0     
+  ,     ,   d   ,     !,   t  ",   
+  (,     ),    
+  *,   $  6,   (  7,   ,
+  8J  0  93   6m  :,   8m  ;,   <    @5     D
+  Z  H %   Z      8  j      ?  Y  j  
+  @	    	   
+  J  !       ^      B	   e  a	  $h  v	  (
+  	  ,  v	  09  <	  4  ^   8  I  <    (	      ^   <	  <	  u   {  (	  ^   a	  <	  I  ^    H	  ^   v	  <	   g	  	  <	   |	    ~	  	      m  v      	          K  	  ,    	  	  ,    	  K  
+  ^   ^   ,   
+   V  	  K  6
+  V  ,    "
+  K  _
+  _
+  e
+  _
+  _
+  k
+   ,        <
+  K  
+  ^   ,   
+   I  w
+  K  
+  I   
+  K  
+  	  ,   
+  I  
+   
+  
+  I  I   
+  K  	  I  ^   >   
+  K  (  ,   I  _
+     K  L  
+  L  ^   I   -  .  K  v  I  L  I  I   X  K    I  L  I   |  K    l  L  
+     K    L  I  
+     K      L  I  _
+     l    K  !  L  !     h    K  A  L  I   -  K  o    l  h  I  ,      G  K    l  _
+          u  K    l  K  ,        K    l  ,      K            K    ,   >  ,      (    K  A  l    h     #  K  `  I  I  I   G  K    l  L  
+  l  l      f  K    l  L    _
+         K    l    _
+     L    K      L  I  _
+         K  .  
+     K  D  I   4  K  c  I  ,   c   3  J    I  I  ,    o    I  ,            (
+     D    K               K         K             K  2          K  V  ,   ,   3  e
+   8  K  p  ,   
+   \  K      L  k
+  _
+  I   v  K    _
+    L     K      L     ,   I     K    c         K  ,   I     
+U  A    -     I     pv  /   qg     s    vI   A    (N  /   OI     P    S    V  ?
+  Z  	  ]  "  `    b  M  e   C
+  h%  $ |    =  Et    F    C
+  G   	  H     I     J   \  K   K           3   t  K      ,   _
+  _
+     K      ,      K         K      ,   ,      K             /  kS    l      m    K  g  v     S  K    v     +  m  *  K  t  $     8  l      G    ,   
+    M   #	  F  `     t S0R0Q0Pu   w
+  <	    	   u             t  arch/arm/lib/crt0_arm_efi.S /u/uboot_am5728_07mar/SC_Uboot_06APR/u-boot-dual_19Apr GNU AS 2.24 +         
+    \   :       int I	  "     1    *  (  j    3   I  H      )   Y,     cr     i}     8,      ;                    ?     {  	  }    	  ~    
+     M             q  	(      	  +   
+  M  .       \     !  A   s   dyn                       A   4  8  A   i  rel "  }  %  (    i 3   i   q        %  $ >   :;I  $ >   :;I  I  ! I/   I  	   
+:;   :;I8   :;I8  :;  (   :;   :;I8  :;  'I   I  '  :;     & I  .?:;'I@B   :;I  4 :;I  B   B  4 :;I?<  4 :;I?<    %   %  $ >  $ >   :;I      <   I  :;  	 :;I8  
+ :;I  :;   :;I  .?:;'I@B   :;I   :;I  4 :;I  4 :;I           P        U    $    P            
+    Q
+   $    Q               P               T            6    P6   8    P8   V    PV   \    P            4    Q4   8    Q8   :    Q:   T    QT   \    Q                R   \    R                S   \    S            
+    0&   (    U:   B    UJ   T    U            
+    0            
+    0    "    R:   T    R        H   T    p s "                           t  $                          t                       \                        lib/efi_loader ./arch/arm/include/asm include/linux include include/asm-generic  helloworld.c   types.h   types.h   efi.h   efi_api.h   part_efi.h   u-boot.h   net.h     t   !!"Ki U    2         arch/arm/lib  crt0_arm_efi.S     8   0////////0/0/              arch/arm/lib ./arch/arm/include/asm include/linux include  reloc_arm_efi.c   types.h   types.h   efi.h   elf.h       z " 3/w/0!0C  ! 0 #<u $4wX  locate_handle_buffer query_variable_info ulong reset bi_boot_params EFI_RESET_SHUTDOWN physical_start convert_pointer NETLOOP_FAIL efi_virtual_addr_t uint64_t allocate_pool headersize efi_handle_t NETLOOP_RESTART init efi_locate_search_type long long unsigned int EFI_TIMER_RELATIVE efi_status_t __u16 efi_guid_t next efi_mem_desc handle_protocol efi_boot_services bi_intfreq locate_protocol get_variable stall bi_arch_number get_next_variable stderr_handle year cursor_row efi_event_type set_cursor_position allocate_pages EFI_TIMER_STOP bi_ethspeed uint16_t bi_memsize phys_size_t efi_table_hdr efi_configuration_table NETLOOP_SUCCESS raise_tpl set_wakeup_time read_key_stroke agent_handle virtual_start cursor_column register_protocol_notify signature reserved hour lib/efi_loader/helloworld.c long long int month locate_handle bd_t __u8 __u32 get_next_monotonic_count recv bi_busfreq fw_vendor name daylight unicode_char set_variable bi_bootflags wait_for_key signal_event uninstall_protocol_interface efi_runtime_services copy_mem exit_boot_services bi_ip_addr efi_main query_capsule_caps reset_system open_protocol_information by_register_notify net_loop_state efi_reset_type efi_system_table protocols_per_handle output_string reinstall_protocol_interface open_protocol sizetype GNU C 4.8.4 -mthumb -mthumb-interwork -mabi=aapcs-linux -mword-relocations -mno-unaligned-access -mfloat-abi=soft -march=armv7-a -mfpu=vfpv3-d16 -mtls-dialect=gnu -g -Os -fno-builtin -ffreestanding -fno-stack-protector -fno-delete-null-pointer-checks -fstack-usage -fno-common -fpic -fshort-wchar efi_input_key simple_text_output_mode efi_device_path send bd_info install_configuration_table EFI_RESET_WARM fw_revision scan_code max_mode priv set_virtual_address_map net_state free_pages open_count con_out_handle efi_time num_pages _Bool iobase unsigned char get_wakeup_time controller_handle con_in nanosecond short int bi_sramsize write_hwaddr unload_image efi_simple_text_output_protocol efi_simple_input_interface create_event exit efi_time_cap start_image wait_for_event bi_dsp_freq resolution attributes disconnect_controller systable by_protocol cursor_visible __u64 length calculate_crc32 query_mode bi_flashsize test_string get_next_high_mono_count index free_pool phys_addr_t bi_sramstart close_event EFI_TIMER_PERIODIC con_in_handle std_err boottime efi_open_protocol_info_entry short unsigned int set_timer locate_device_path set_time timezone set_attribute set_watchdog_timer update_capsule minute get_time NETLOOP_CONTINUE pad1 pad2 sub_type create_event_ex all_handles bi_flashstart close_protocol EFI_RESET_COLD set_mem set_mode uninstall_multiple_protocol_interfaces uint8_t eth_current bi_arm_freq check_event bi_dram /u/uboot_am5728_07mar/SC_Uboot_06APR/u-boot-dual_19Apr bi_enetaddr halt con_out restore_tpl bi_ddr_freq eth_device bi_memstart clear_screen efi_physical_addr_t nr_tables enable_cursor accuracy bi_flashoffset sets_to_zero runtime uint32_t get_memory_map guid r_offset Elf32_Dyn arch/arm/lib/reloc_arm_efi.c relsz Elf32_Addr d_un systab Elf32_Sword Elf32_Rel d_ptr d_val __s32 r_info ldbase d_tag _relocate relent Elf32_Word     |        t  $   A     |    ,     \   B  .symtab .strtab .shstrtab .text .dynamic .data .dynsym .dynstr .hash .comment .ARM.attributes .debug_info .debug_abbrev .debug_loc .debug_aranges .debug_line .debug_str .debug_frame                                                                            !               `                *                              0                              8                k                  @         l   l  P                F      0         2                 O     p          -                  _                                 k                                 y              [                                    `                                                         0         J                                X                                0                                    0     '         	                                                                                                                       l                                                  	              
+                                                                                                    @          *   D          6             D   X          T   8         [   t          o   8            p            ,          r               t                                                                                     <                                               2            u  $                                   \                                                                                  arch/arm/lib/crt0_arm_efi.o $d pe_header coff_header section_table optional_header _start extra_header_fields $a helloworld.c $t reloc_arm_efi.c _DYNAMIC _GLOBAL_OFFSET_TABLE_ _etext efi_main EFI_SUBSYSTEM _bss_end _relocate _bss _text _data_size _data _edata _text_size image_base 
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/configs/k2hk_hs_evm_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/k2hk_hs_evm_defconfig	1969-12-31 19:31:37.000000910 -0600
@@ -0,0 +1,52 @@
+CONFIG_ARM=y
+CONFIG_ARCH_KEYSTONE=y
+CONFIG_TARGET_K2HK_EVM=y
+CONFIG_TI_SECURE_DEVICE=y
+# CONFIG_MMC is not set
+CONFIG_SYS_TEXT_BASE=0x0c000060
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2hk-evm"
+CONFIG_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_NAND=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_UBI=y
+CONFIG_CMD_RIO=y
+CONFIG_OF_CONTROL=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_TI_AEMIF=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_DM_ETH=y
+CONFIG_DM_SERIAL=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_KEYSTONE_RIO=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2hk-evm"
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2e-netcp.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2e-netcp.dtsi	1969-12-31 19:31:37.000000932 -0600
@@ -0,0 +1,206 @@
+/*
+ * Device Tree Source for Keystone 2 Edison Netcp driver
+ *
+ * Copyright 2015 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+qmss: qmss@2a40000 {
+	compatible = "ti,keystone-navigator-qmss";
+	dma-coherent;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	clocks = <&chipclk13>;
+	ranges;
+	queue-range	= <0 0x2000>;
+	linkram0	= <0x100000 0x4000>;
+	linkram1	= <0 0x10000>;
+
+	qmgrs {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		qmgr0 {
+			managed-queues = <0 0x2000>;
+			reg = <0x2a40000 0x20000>,
+			      <0x2a06000 0x400>,
+			      <0x2a02000 0x1000>,
+			      <0x2a03000 0x1000>,
+			      <0x23a80000 0x20000>,
+			      <0x2a80000 0x20000>;
+			reg-names = "peek", "status", "config",
+				    "region", "push", "pop";
+		};
+	};
+	queue-pools {
+		qpend {
+			qpend-0 {
+				qrange = <658 8>;
+				interrupts =<0 40 0xf04 0 41 0xf04 0 42 0xf04
+					     0 43 0xf04 0 44 0xf04 0 45 0xf04
+					     0 46 0xf04 0 47 0xf04>;
+			};
+			qpend-1 {
+				qrange = <528 16>;
+				interrupts = <0 48 0xf04 0 49 0xf04 0 50 0xf04
+					      0 51 0xf04 0 52 0xf04 0 53 0xf04
+					      0 54 0xf04 0 55 0xf04 0 56 0xf04
+					      0 57 0xf04 0 58 0xf04 0 59 0xf04
+					      0 60 0xf04 0 61 0xf04 0 62 0xf04
+					      0 63 0xf04>;
+				qalloc-by-id;
+			};
+			qpend-2 {
+				qrange = <544 16>;
+				interrupts = <0 64 0xf04 0 65 0xf04 0 66 0xf04
+					      0 59 0xf04 0 68 0xf04 0 69 0xf04
+					      0 70 0xf04 0 71 0xf04 0 72 0xf04
+					      0 73 0xf04 0 74 0xf04 0 75 0xf04
+					      0 76 0xf04 0 77 0xf04 0 78 0xf04
+					      0 79 0xf04>;
+			};
+		};
+		general-purpose {
+			gp-0 {
+				qrange = <4000 64>;
+			};
+			netcp-tx {
+				qrange = <896 128>;
+				qalloc-by-id;
+			};
+		};
+	};
+	descriptor-regions {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		region-12 {
+			id = <12>;
+			region-spec = <8192 128>;	/* num_desc desc_size */
+			link-index = <0x4000>;
+		};
+	};
+}; /* qmss */
+
+knav_dmas: knav_dmas@0 {
+	compatible = "ti,keystone-navigator-dma";
+	clocks = <&papllclk>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	ranges;
+	ti,navigator-cloud-address = <0x23a80000 0x23a90000
+				 0x23a80000 0x23a90000>;
+
+	dma_gbe: dma_gbe@0 {
+		reg = <0x24186000 0x100>,
+			  <0x24187000 0x2a0>,
+			  <0x24188000 0xb60>,
+			  <0x24186100 0x80>,
+			  <0x24189000 0x1000>;
+		reg-names = "global", "txchan", "rxchan",
+				"txsched", "rxflow";
+	};
+};
+
+netcp: netcp@24000000 {
+	reg = <0x2620110 0x8>;
+	reg-names = "efuse";
+	compatible = "ti,netcp-1.0";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	/* NetCP address range */
+	ranges = <0 0x24000000 0x1000000>;
+
+	clocks = <&papllclk>, <&clkcpgmac>, <&chipclk12>;
+	dma-coherent;
+
+	ti,navigator-dmas = <&dma_gbe 0>,
+			<&dma_gbe 8>,
+			<&dma_gbe 0>;
+	ti,navigator-dma-names = "netrx0", "netrx1", "nettx";
+
+	netcp-devices {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		gbe@200000 { /* ETHSS */
+			label = "netcp-gbe";
+			compatible = "ti,netcp-gbe-9";
+			reg = <0x200000 0x900>, <0x220000 0x20000>;
+			/* enable-ale; */
+			tx-queue = <896>;
+			tx-channel = "nettx";
+
+			interfaces {
+				gbe0: interface-0 {
+					slave-port = <0>;
+					link-interface	= <1>;
+					phy-handle	= <&ethphy0>;
+				};
+				gbe1: interface-1 {
+					slave-port = <1>;
+					link-interface	= <1>;
+					phy-handle	= <&ethphy1>;
+				};
+			};
+
+			secondary-slave-ports {
+				port-2 {
+					slave-port = <2>;
+					link-interface	= <2>;
+				};
+				port-3 {
+					slave-port = <3>;
+					link-interface	= <2>;
+				};
+				port-4 {
+					slave-port = <4>;
+					link-interface	= <2>;
+				};
+				port-5 {
+					slave-port = <5>;
+					link-interface	= <2>;
+				};
+				port-6 {
+					slave-port = <6>;
+					link-interface	= <2>;
+				};
+				port-7 {
+					slave-port = <7>;
+					link-interface	= <2>;
+				};
+			};
+		};
+	};
+
+	netcp-interfaces {
+		interface-0 {
+			rx-channel = "netrx0";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <528>;
+			tx-completion-queue = <530>;
+			efuse-mac = <1>;
+			netcp-gbe = <&gbe0>;
+
+		};
+		interface-1 {
+			rx-channel = "netrx1";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <529>;
+			tx-completion-queue = <531>;
+			efuse-mac = <0>;
+			local-mac-address = [02 18 31 7e 3e 00];
+			netcp-gbe = <&gbe1>;
+		};
+	};
+};
diff -u -N U-Boot_SDcard/configs/k2l_evm_defconfig U-Boot_SDcard/configs/k2l_evm_defconfig
--- U-Boot_SDcard/configs/k2l_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/k2l_evm_defconfig	1969-12-31 19:29:18.000000286 -0600
@@ -9,13 +9,13 @@
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
 # CONFIG_MMC is not set
-CONFIG_DEFAULT_DEVICE_TREE="k2l-evm"
+CONFIG_SYS_TEXT_BASE=0x0c000000
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2l-evm"
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
 CONFIG_HUSH_PARSER=y
-CONFIG_SYS_PROMPT="K2L EVM # "
 CONFIG_CMD_BOOTZ=y
 # CONFIG_CMD_IMLS is not set
 CONFIG_CMD_ASKENV=y
@@ -50,3 +50,6 @@
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_DWC3=y
 CONFIG_USB_STORAGE=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2l-evm"
diff -u -N /dev/null U-Boot_SDcard/configs/am335x_hs_evm_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/am335x_hs_evm_defconfig	1969-12-31 19:31:37.000000904 -0600
@@ -0,0 +1,65 @@
+CONFIG_ARM=y
+CONFIG_AM33XX=y
+CONFIG_TI_SECURE_DEVICE=y
+# CONFIG_SPL_EXT_SUPPORT is not set
+CONFIG_TARGET_AM335X_EVM=y
+CONFIG_ISW_ENTRY_ADDR=0x40300350
+CONFIG_SPL_STACK_R_ADDR=0x82000000
+# CONFIG_SPL_YMODEM_SUPPORT is not set
+CONFIG_DEFAULT_DEVICE_TREE="am335x-evm"
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT=y
+CONFIG_SYS_EXTRA_OPTIONS="NAND"
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SPL_FIT_IMAGE_POST_PROCESS=y
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
+CONFIG_SPL_STACK_R=y
+CONFIG_SPL_MTD_SUPPORT=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="am335x-evm"
+# CONFIG_BLK is not set
+CONFIG_DFU_MMC=y
+CONFIG_DFU_NAND=y
+CONFIG_DFU_RAM=y
+CONFIG_DM_I2C=y
+CONFIG_DM_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_DM_ETH=y
+CONFIG_SYS_NS16550=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_USB=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
+CONFIG_G_DNL_VENDOR_NUM=0x0451
+CONFIG_G_DNL_PRODUCT_NUM=0xd022
+CONFIG_USE_TINY_PRINTF=y
+CONFIG_RSA=y
+CONFIG_SPL_OF_LIBFDT=y
+CONFIG_OF_LIBFDT=y
+CONFIG_OF_BOARD_SETUP=y
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2hk.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2hk.dtsi	1969-12-31 19:31:37.000000942 -0600
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Kepler/Hawking soc specific device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&gic>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <1>;
+		};
+
+		cpu@2 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <2>;
+		};
+
+		cpu@3 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <3>;
+		};
+	};
+
+	soc {
+		/include/ "keystone-k2hk-clocks.dtsi"
+
+		dspgpio0: keystone_dsp_gpio@02620240 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x240>;
+		};
+
+		dspgpio1: keystone_dsp_gpio@2620244 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x244>;
+		};
+
+		dspgpio2: keystone_dsp_gpio@2620248 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x248>;
+		};
+
+		dspgpio3: keystone_dsp_gpio@262024c {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x24c>;
+		};
+
+		dspgpio4: keystone_dsp_gpio@2620250 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x250>;
+		};
+
+		dspgpio5: keystone_dsp_gpio@2620254 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x254>;
+		};
+
+		dspgpio6: keystone_dsp_gpio@2620258 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x258>;
+		};
+
+		dspgpio7: keystone_dsp_gpio@262025c {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x25c>;
+		};
+
+		mdio: mdio@02090300 {
+			compatible	= "ti,keystone_mdio", "ti,davinci_mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x02090300 0x100>;
+			status = "disabled";
+			clocks = <&clkcpgmac>;
+			clock-names = "fck";
+			bus_freq	= <2500000>;
+		};
+
+		rapidio: rapidio@2900000 {
+			compatible = "ti,keystone-rapidio";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2900000 0x40000>,    /* rio regs */
+			      <0x2620000 0x1000>,     /* boot config regs */
+			      <0x232c000 0x2000>;     /* serdes config regs */
+			reg-names = "rio", "boot_config", "serdes";
+			clocks = <&clksrio>;
+			clock-names = "clk_srio";
+			dma-coherent;
+
+			ti,navigator-dmas = <&dma_srio 18>,
+					    <&dma_srio 19>,
+					    <&dma_srio 0>,
+					    <&dma_srio 1>;
+			ti,navigator-dma-names = "riorx0", "riorx1",
+						 "riotx0", "riotx1";
+
+			keystone2-serdes;
+			baudrate  = <3>;              /* 5 Gbps */
+			path-mode = <4>;              /* 1 port in 4x */
+			port-register-timeout = <30>; /* 30 seconds */
+
+			lsu = <0 0>;    /* available LSU range (start end) */
+			num-dio-channels = <8>; /* number of DIO DMA channels */
+
+			ports = <0x1>;      /* bitfield of port(s) to probe */
+
+			dev-id-size = <0>;  /* RapidIO common transport system
+					     * size.
+					     * 0 - Small size. 8-bit deviceID
+					     *     fields. 256 devices.
+					     * 1 - Large size, 16-bit deviceID
+					     *     fields. 65536 devices.
+					     */
+
+			interrupts = <0 152 0xf01
+				      0 153 0xf01>; /* RIO and LSU IRQs */
+
+			num-mboxes = <2>;
+
+			mbox-0 {
+				rx-channel = "riorx0";
+				rx-pool = <128 15>; /* size region_id */
+				rx-queue-depth  = <256 0 0 0>;
+				rx-buffer-size  = <4096 0 0 0>;
+				/*rx-queue = <8714>;*/
+				/*stream-id = <0>;*/
+				tx-channel = "riotx0";
+				tx-pool = <128 15>;
+				tx-queue-depth = <256>;
+				tx-queue = <672>; /* for channel 0 */
+				/*tx-completion-queue = <8716>;*/
+				/*tx-garbage-queue = <8717>;*/
+			};
+
+			mbox-1 {
+				rx-channel = "riorx1";
+				rx-pool = <128 15>;
+				rx-queue-depth  = <256 0 0 0>;
+				rx-buffer-size  = <4096 0 0 0>;
+				/*rx-queue = <8715>;*/
+				/*stream-id = <1>;*/
+				tx-channel = "riotx1";
+				tx-pool = <128 15>;
+				tx-queue-depth = <256>;
+				tx-queue = <673>; /* for channel 1 */
+				/*tx-completion-queue = <8718>;*/
+				/*tx-garbage-queue = <8719>;*/
+			};
+		};
+
+		/include/ "keystone-k2hk-netcp.dtsi"
+	};
+};
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig
--- U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-omap2/omap5/Kconfig	1969-12-31 19:29:28.000000755 -0600
@@ -63,32 +63,6 @@
 config SYS_SOC
 	default "omap5"
 
-config TI_SECURE_EMIF_REGION_START
-	hex "Reserved EMIF region start address"
-	depends on TI_SECURE_DEVICE
-	default 0x0
-	help
-	  Reserved EMIF region start address. Set to "0" to auto-select
-	  to be at the end of the external memory region.
-
-config TI_SECURE_EMIF_TOTAL_REGION_SIZE
-	hex "Reserved EMIF region size"
-	depends on TI_SECURE_DEVICE
-	default 0x0
-	help
-	  Total reserved EMIF region size. Default is 0, which means no reserved EMIF
-	  region on secure devices.
-
-config TI_SECURE_EMIF_PROTECTED_REGION_SIZE
-	hex "Size of protected region within reserved EMIF region"
-	depends on TI_SECURE_DEVICE
-	default 0x0
-	help
-	  This config option is used to specify the size of the portion of the total
-	  reserved EMIF region set aside for secure OS needs that will  be protected
-	  using hardware memory firewalls. This value must be smaller than the
-	  TI_SECURE_EMIF_TOTAL_REGION_SIZE value.
-
 if TARGET_DRA7XX_EVM || TARGET_AM57XX_EVM
 menu "Voltage Domain OPP selections"
 
diff -u -N U-Boot_SDcard/drivers/usb/gadget/Kconfig U-Boot_SDcard/drivers/usb/gadget/Kconfig
--- U-Boot_SDcard/drivers/usb/gadget/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/drivers/usb/gadget/Kconfig	1969-12-31 19:29:27.000000982 -0600
@@ -112,6 +112,10 @@
 config G_DNL_PRODUCT_NUM
 	hex "Product ID of USB device"
 
+config USBNET_DEVADDR
+	string "USB Gadget Ethernet device mac address"
+	default "de:ad:be:ef:00:01"
+
 endif # USB_GADGET_DOWNLOAD
 
 endif # USB_GADGET
diff -u -N /dev/null U-Boot_SDcard/configs/k2g_hs_evm_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/k2g_hs_evm_defconfig	1969-12-31 19:31:37.000000909 -0600
@@ -0,0 +1,57 @@
+CONFIG_ARM=y
+CONFIG_ARCH_KEYSTONE=y
+CONFIG_TARGET_K2G_EVM=y
+CONFIG_TI_SECURE_DEVICE=y
+CONFIG_SYS_TEXT_BASE=0x0c000060
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2g-evm"
+CONFIG_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_REMOTEPROC=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_CONTROL=y
+CONFIG_DM=y
+# CONFIG_BLK is not set
+CONFIG_DM_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_DM_ETH=y
+CONFIG_REMOTEPROC_TI_POWER=y
+CONFIG_DM_SERIAL=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_TI_GPMC=y
+CONFIG_CMD_NAND=y
+CONFIG_DM_NAND=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2g-generic keystone-k2g-evm keystone-k2g-ice"
diff -u -N /dev/null U-Boot_SDcard/arch/xtensa/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/xtensa/dts/include/dt-bindings	1969-12-31 19:31:37.000000960 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/am57xx-evm-common.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/am57xx-evm-common.dtsi	1969-12-31 19:31:37.000000928 -0600
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	compatible = "ti,am5728-evm", "ti,am572x-beagle-x15", "ti,am5728", "ti,dra742", "ti,dra74", "ti,dra7";
+};
diff -u -N U-Boot_SDcard/board/ti/am43xx/MAINTAINERS U-Boot_SDcard/board/ti/am43xx/MAINTAINERS
--- U-Boot_SDcard/board/ti/am43xx/MAINTAINERS	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/board/ti/am43xx/MAINTAINERS	1969-12-31 19:29:27.000000165 -0600
@@ -7,4 +7,5 @@
 F:	configs/am43xx_evm_ethboot_defconfig
 F:	configs/am43xx_evm_qspiboot_defconfig
 F:	configs/am43xx_evm_usbhost_boot_defconfig
+F:	configs/am43xx_evm_rtconly_defconfig
 F:	configs/am43xx_hs_evm_defconfig
diff -u -N /dev/null U-Boot_SDcard/TISDK-README
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/TISDK-README	1969-12-31 19:31:37.000000895 -0600
@@ -0,0 +1,5 @@
+Create local branch
+
+The below commit is used for this local branch and is the one used by
+this sdk:
+590c7d7fe15d06a4d708403d3234bcd01cd039e1.
diff -u -N /dev/null U-Boot_SDcard/arch/nios2/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/nios2/dts/include/dt-bindings	1969-12-31 19:31:37.000000957 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N U-Boot_SDcard/drivers/memory/Kconfig U-Boot_SDcard/drivers/memory/Kconfig
--- U-Boot_SDcard/drivers/memory/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/drivers/memory/Kconfig	1969-12-31 19:29:21.000000131 -0600
@@ -15,4 +15,11 @@
 	  of 256M bytes of any of these memories can be accessed at a given
 	  time via four chip selects with 64M byte access per chip select.
 
+config TI_GPMC
+	tristate "Texas Instruments GPMC bus driver"
+	depends on ARCH_KEYSTONE
+	help
+	  This driver is for the GPMC module availableon certain TI keystone
+	  and OMAP generation SoCs.
+
 endmenu
diff -u -N /dev/null U-Boot_SDcard/lib/efi_loader/helloworld.efi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/lib/efi_loader/helloworld.efi	1969-12-31 19:31:37.000000925 -0600
@@ -0,0 +1,5 @@
+MZ                                                          @   PE               X          8  8                                   8                                                                                 .reloc                              @ B.text   X  8  X  8                P@-  0$  VO    0        8FjkIBhyDG !o(F
+FFG  8p    #pFFFX...RhDmhdh3|  pd -y-+h"DX	P Hp  H e l l o ,   w o r l d ! 
+                           l                
+   k                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  :   2            u  $                   W           *     \     R           4            `            L                      A        
+             
\ No newline at end of file
diff -u -N U-Boot_SDcard/tools/buildman/buildman U-Boot_SDcard/tools/buildman/buildman
--- U-Boot_SDcard/tools/buildman/buildman	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/tools/buildman/buildman	1969-12-31 19:29:23.000000062 -0600
@@ -1,65 +1,1 @@
-#!/usr/bin/env python
-#
-# Copyright (c) 2012 The Chromium OS Authors.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-"""See README for more information"""
-
-import multiprocessing
-import os
-import re
-import sys
-import unittest
-
-# Bring in the patman libraries
-our_path = os.path.dirname(os.path.realpath(__file__))
-sys.path.insert(1, os.path.join(our_path, '../patman'))
-
-# Our modules
-import board
-import bsettings
-import builder
-import checkpatch
-import cmdline
-import control
-import doctest
-import gitutil
-import patchstream
-import terminal
-import toolchain
-
-def RunTests():
-    import func_test
-    import test
-    import doctest
-
-    result = unittest.TestResult()
-    for module in ['toolchain', 'gitutil']:
-        suite = doctest.DocTestSuite(module)
-        suite.run(result)
-
-    sys.argv = [sys.argv[0]]
-    for module in (test.TestBuild, func_test.TestFunctional):
-        suite = unittest.TestLoader().loadTestsFromTestCase(module)
-        suite.run(result)
-
-    print result
-    for test, err in result.errors:
-        print err
-    for test, err in result.failures:
-        print err
-
-
-options, args = cmdline.ParseArgs()
-
-# Run our meagre tests
-if options.test:
-    RunTests()
-
-# Build selected commits for selected boards
-else:
-    bsettings.Setup(options.config_file)
-    ret_code = control.DoBuildman(options, args)
-    sys.exit(ret_code)
+buildman.py
\ No newline at end of file
diff -u -N U-Boot_SDcard/Kconfig U-Boot_SDcard/Kconfig
--- U-Boot_SDcard/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/Kconfig	1969-12-31 19:29:17.000000024 -0600
@@ -248,7 +248,8 @@
 
 config SYS_TEXT_BASE
 	depends on SPARC || ARC || X86 || ARCH_UNIPHIER || ARCH_ZYNQMP || \
-		(M68K && !TARGET_ASTRO_MCF5373L) || MICROBLAZE || MIPS
+		(M68K && !TARGET_ASTRO_MCF5373L) || MICROBLAZE || MIPS || \
+		ARCH_KEYSTONE
 	depends on !EFI_APP
 	hex "Text Base"
 	help
@@ -293,6 +294,22 @@
 	  injected into the FIT creation (i.e. the blobs would have been pre-
 	  processed before being added to the FIT image).
 
+config SPL_RAW_IMAGE_SUPPORT
+	bool "Support SPL loading and booting of RAW images"
+	default y
+	help
+	  SPL will support loading and booting a RAW image when this option
+	  is y. If this is not set, SPL will move on to other available
+	  boot media to find a suitable image.
+
+config SPL_LEGACY_IMAGE_SUPPORT
+	bool "Support SPL loading and booting of Legacy images"
+	default y
+	help
+	  SPL will support loading and booting Legacy images when this option
+	  is y. If this is not set, SPL will move on to other available
+	  boot media to find a suitable image.
+
 config SYS_CLK_FREQ
 	depends on ARC || ARCH_SUNXI
 	int "CPU clock frequency"
diff -u -N U-Boot_SDcard/tools/binman/binman U-Boot_SDcard/tools/binman/binman
--- U-Boot_SDcard/tools/binman/binman	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/tools/binman/binman	1969-12-31 19:29:23.000000046 -0600
@@ -1,114 +1,1 @@
-#!/usr/bin/env python
-
-# Copyright (c) 2016 Google, Inc
-# Written by Simon Glass <sjg@chromium.org>
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-# Creates binary images from input files controlled by a description
-#
-
-"""See README for more information"""
-
-import os
-import sys
-import traceback
-import unittest
-
-# Bring in the patman and dtoc libraries
-our_path = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(our_path, '../patman'))
-sys.path.append(os.path.join(our_path, '../dtoc'))
-
-# Also allow entry-type modules to be brought in from the etype directory.
-sys.path.append(os.path.join(our_path, 'etype'))
-
-import cmdline
-import command
-import control
-
-def RunTests():
-    """Run the functional tests and any embedded doctests"""
-    import entry_test
-    import fdt_test
-    import func_test
-    import test
-    import doctest
-
-    result = unittest.TestResult()
-    for module in []:
-        suite = doctest.DocTestSuite(module)
-        suite.run(result)
-
-    sys.argv = [sys.argv[0]]
-    for module in (func_test.TestFunctional, fdt_test.TestFdt,
-                   entry_test.TestEntry):
-        suite = unittest.TestLoader().loadTestsFromTestCase(module)
-        suite.run(result)
-
-    print result
-    for test, err in result.errors:
-        print test.id(), err
-    for test, err in result.failures:
-        print err
-
-def RunTestCoverage():
-    """Run the tests and check that we get 100% coverage"""
-    # This uses the build output from sandbox_spl to get _libfdt.so
-    cmd = ('PYTHONPATH=%s/sandbox_spl/tools coverage run '
-            '--include "tools/binman/*.py" --omit "*test*,*binman.py" '
-            'tools/binman/binman.py -t' % options.build_dir)
-    os.system(cmd)
-    stdout = command.Output('coverage', 'report')
-    coverage = stdout.splitlines()[-1].split(' ')[-1]
-    if coverage != '100%':
-        print stdout
-        print "Type 'coverage html' to get a report in htmlcov/index.html"
-        raise ValueError('Coverage error: %s, but should be 100%%' % coverage)
-
-
-def RunBinman(options, args):
-    """Main entry point to binman once arguments are parsed
-
-    Args:
-        options: Command-line options
-        args: Non-option arguments
-    """
-    ret_code = 0
-
-    # For testing: This enables full exception traces.
-    #options.debug = True
-
-    if not options.debug:
-        sys.tracebacklimit = 0
-
-    if options.test:
-        RunTests()
-
-    elif options.test_coverage:
-        RunTestCoverage()
-
-    elif options.full_help:
-        pager = os.getenv('PAGER')
-        if not pager:
-            pager = 'more'
-        fname = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),
-                            'README')
-        command.Run(pager, fname)
-
-    else:
-        try:
-            ret_code = control.Binman(options, args)
-        except Exception as e:
-            print 'binman: %s' % e
-            if options.debug:
-                print
-                traceback.print_exc()
-            ret_code = 1
-    return ret_code
-
-
-if __name__ == "__main__":
-    (options, args) = cmdline.ParseArgs(sys.argv)
-    ret_code = RunBinman(options, args)
-    sys.exit(ret_code)
+binman.py
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2g-netcp.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2g-netcp.dtsi	1969-12-31 19:31:37.000000937 -0600
@@ -0,0 +1,152 @@
+/*
+ * Device Tree Source for Keystone 2 Galileo Netcp driver
+ *
+ * Copyright 2015 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+qmss: qmss@4020000 {
+	compatible = "ti,keystone-navigator-qmss-l";
+	dma-coherent;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	/* power-domains = <&k2g_pds K2G_DEV_NSS0>; */
+	/* clocks = <&k2g_clks K2G_DEV_NSS0 K2G_DEV_NSS_VCLK>; */
+	clock-names = "nss_vclk";
+	ranges;
+	queue-range	= <0 0x80>;
+	linkram0	= <0x4020000 0x7ff>;
+
+	qmgrs {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		qmgr0 {
+			managed-queues = <0 0x80>;
+			reg = <0x4100000 0x800>,
+			      <0x4040000 0x100>,
+			      <0x4080000 0x800>,
+			      <0x40c0000 0x800>;
+			reg-names = "peek", "config",
+				    "region", "push";
+		};
+
+	};
+	queue-pools {
+		qpend {
+			qpend-0 {
+				qrange = <77 8>;
+				interrupts =<0 308 0xf04 0 309 0xf04 0 310 0xf04
+					     0 311 0xf04 0 312 0xf04 0 313 0xf04
+					     0 314 0xf04 0 315 0xf04>;
+				qalloc-by-id;
+			};
+		};
+		general-purpose {
+			gp-0 {
+				qrange = <112 8>;
+			};
+			netcp-tx {
+				qrange = <5 8>;
+				qalloc-by-id;
+			};
+		};
+	};
+
+	descriptor-regions {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		region-12 {
+			id = <12>;
+			region-spec = <1023 128>; /* num_desc desc_size */
+			link-index = <0x400>;
+		};
+	};
+}; /* qmss */
+
+knav_dmas: knav_dmas@0 {
+	compatible = "ti,keystone-navigator-dma";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	/* power-domains = <&k2g_pds K2G_DEV_NSS0>; */
+	/* clocks = <&k2g_clks K2G_DEV_NSS0 K2G_DEV_NSS_VCLK>; */
+	clock-names = "nss_vclk";
+	ranges;
+	ti,navigator-cloud-address = <0x40c0000 0x40c0000 0x40c0000 0x40c0000>;
+
+	dma_gbe: dma_gbe@0 {
+		reg = <0x4010000 0x100>,
+			  <0x4011000 0x2a0>, /* 21 Tx channels */
+			  <0x4012000 0x400>, /* 32 Rx channels */
+			  <0x4010100 0x80>,
+			  <0x4013000 0x400>; /* 32 Rx flows */
+		reg-names = "global", "txchan", "rxchan",
+				"txsched", "rxflow";
+	};
+
+};
+
+gbe_subsys: subsys@4200000 {
+	compatible = "syscon";
+	reg = <0x4200000 0x100>;
+};
+
+netcp: netcp@4000000 {
+	reg = <0x2620110 0x8>;
+	reg-names = "efuse";
+	compatible = "ti,netcp-1.0";
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	/* power-domains = <&k2g_pds K2G_DEV_NSS0>; */
+	/* clocks = <&k2g_clks K2G_DEV_NSS0 K2G_DEV_NSS_ESW_CLK>; */
+	clock-names = "ethss_clk";
+
+	/* NetCP address range */
+	ranges = <0 0x4000000 0x1000000>;
+
+	dma-coherent;
+
+	ti,navigator-dmas = <&dma_gbe 0>, <&dma_gbe 5>;
+	ti,navigator-dma-names = "netrx0", "nettx";
+
+	netcp-devices {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		gbe@200000 {
+			label = "netcp-gbe";
+			compatible = "ti,netcp-gbe-2";
+			syscon-subsys = <&gbe_subsys>;
+			reg = <0x200100 0xe00>, <0x220000 0x20000>;
+			/* enable-ale; */
+			tx-queue = <5>;
+			tx-channel = "nettx";
+
+			interfaces {
+				gbe0: interface-0 {
+					slave-port = <0>;
+					link-interface	= <5>;
+				};
+			};
+		};
+	};
+
+	netcp-interfaces {
+		interface-0 {
+			rx-channel = "netrx0";
+			rx-pool = <512 12>;
+			tx-pool = <511 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <77>;
+			tx-completion-queue = <78>;
+			efuse-mac = <1>;
+			netcp-gbe = <&gbe0>;
+		};
+	};
+};
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/include/dt-bindings	1969-12-31 19:31:37.000000953 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2l-netcp.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2l-netcp.dtsi	1969-12-31 19:31:37.000000945 -0600
@@ -0,0 +1,189 @@
+/*
+ * Device Tree Source for Keystone 2 Lamarr Netcp driver
+ *
+ * Copyright 2015 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+qmss: qmss@2a40000 {
+	compatible = "ti,keystone-navigator-qmss";
+	dma-coherent;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	clocks = <&chipclk13>;
+	ranges;
+	queue-range	= <0 0x2000>;
+	linkram0	= <0x100000 0x4000>;
+	linkram1	= <0x70000000 0x10000>; /* 1MB OSR mem */
+
+	qmgrs {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		qmgr0 {
+			managed-queues = <0 0x2000>;
+			reg = <0x2a40000 0x20000>,
+			      <0x2a06000 0x400>,
+			      <0x2a02000 0x1000>,
+			      <0x2a03000 0x1000>,
+			      <0x23a80000 0x20000>,
+			      <0x2a80000 0x20000>;
+			reg-names = "peek", "status", "config",
+				    "region", "push", "pop";
+		};
+	};
+	queue-pools {
+		qpend {
+			qpend-0 {
+				qrange = <658 8>;
+				interrupts =<0 40 0xf04 0 41 0xf04 0 42 0xf04
+					     0 43 0xf04 0 44 0xf04 0 45 0xf04
+					     0 46 0xf04 0 47 0xf04>;
+			};
+			qpend-1 {
+				qrange = <528 16>;
+				interrupts = <0 48 0xf04 0 49 0xf04 0 50 0xf04
+					      0 51 0xf04 0 52 0xf04 0 53 0xf04
+					      0 54 0xf04 0 55 0xf04 0 56 0xf04
+					      0 57 0xf04 0 58 0xf04 0 59 0xf04
+					      0 60 0xf04 0 61 0xf04 0 62 0xf04
+					      0 63 0xf04>;
+				qalloc-by-id;
+			};
+			qpend-2 {
+				qrange = <544 16>;
+				interrupts = <0 64 0xf04 0 65 0xf04 0 66 0xf04
+					      0 59 0xf04 0 68 0xf04 0 69 0xf04
+					      0 70 0xf04 0 71 0xf04 0 72 0xf04
+					      0 73 0xf04 0 74 0xf04 0 75 0xf04
+					      0 76 0xf04 0 77 0xf04 0 78 0xf04
+					      0 79 0xf04>;
+			};
+		};
+		general-purpose {
+			gp-0 {
+				qrange = <4000 64>;
+			};
+			netcp-tx {
+				qrange = <896 128>;
+				qalloc-by-id;
+			};
+		};
+	};
+	descriptor-regions {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		region-12 {
+			id = <12>;
+			region-spec = <8192 128>;	/* num_desc desc_size */
+			link-index = <0x4000>;
+		};
+	};
+}; /* qmss */
+
+knav_dmas: knav_dmas@0 {
+	compatible = "ti,keystone-navigator-dma";
+	clocks = <&papllclk>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	ranges;
+	ti,navigator-cloud-address = <0x23a80000 0x23a90000>;
+
+	dma_gbe: dma_gbe@0 {
+		reg = <0x26186000 0x100>,
+			  <0x26187000 0x2a0>,
+			  <0x26188000 0xb60>,
+			  <0x26186100 0x80>,
+			  <0x26189000 0x1000>;
+		reg-names = "global", "txchan", "rxchan",
+				"txsched", "rxflow";
+	};
+};
+
+netcp: netcp@26000000 {
+	reg = <0x2620110 0x8>;
+	reg-names = "efuse";
+	compatible = "ti,netcp-1.0";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	/* NetCP address range */
+	ranges = <0 0x26000000 0x1000000>;
+
+	clocks = <&papllclk>, <&clkcpgmac>, <&chipclk12>;
+	dma-coherent;
+
+	ti,navigator-dmas = <&dma_gbe 0>,
+			<&dma_gbe 8>,
+			<&dma_gbe 0>;
+	ti,navigator-dma-names = "netrx0", "netrx1", "nettx";
+
+	netcp-devices {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		gbe@200000 { /* ETHSS */
+			label = "netcp-gbe";
+			compatible = "ti,netcp-gbe-5";
+			reg = <0x200000 0x900>, <0x220000 0x20000>;
+			/* enable-ale; */
+			tx-queue = <896>;
+			tx-channel = "nettx";
+
+			interfaces {
+				gbe0: interface-0 {
+					slave-port = <0>;
+					link-interface	= <1>;
+					phy-handle	= <&ethphy0>;
+				};
+				gbe1: interface-1 {
+					slave-port = <1>;
+					link-interface	= <1>;
+					phy-handle	= <&ethphy1>;
+				};
+			};
+
+			secondary-slave-ports {
+				port-2 {
+					slave-port = <2>;
+					link-interface	= <2>;
+				};
+				port-3 {
+					slave-port = <3>;
+					link-interface	= <2>;
+				};
+			};
+		};
+	};
+
+	netcp-interfaces {
+		interface-0 {
+			rx-channel = "netrx0";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <528>;
+			tx-completion-queue = <530>;
+			efuse-mac = <1>;
+			netcp-gbe = <&gbe0>;
+
+		};
+		interface-1 {
+			rx-channel = "netrx1";
+			rx-pool = <1024 12>;
+			tx-pool = <1024 12>;
+			rx-queue-depth = <128 128 0 0>;
+			rx-buffer-size = <1518 4096 0 0>;
+			rx-queue = <529>;
+			tx-completion-queue = <531>;
+			efuse-mac = <0>;
+			local-mac-address = [02 18 31 7e 3e 7f];
+			netcp-gbe = <&gbe1>;
+		};
+	};
+};
diff -u -N U-Boot_SDcard/README U-Boot_SDcard/README
--- U-Boot_SDcard/README	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/README	1969-12-31 19:29:17.000000028 -0600
@@ -3295,10 +3295,6 @@
 		consider that a completely unreadable NAND block is bad,
 		and thus should be skipped silently.
 
-		CONFIG_SPL_ABORT_ON_RAW_IMAGE
-		When defined, SPL will proceed to another boot method
-		if the image it has loaded does not have a signature.
-
 		CONFIG_SPL_RELOC_STACK
 		Adress of the start of the stack SPL will use after
 		relocation.  If unspecified, this is equal to
diff -u -N U-Boot_SDcard/drivers/mtd/nand/Kconfig U-Boot_SDcard/drivers/mtd/nand/Kconfig
--- U-Boot_SDcard/drivers/mtd/nand/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/drivers/mtd/nand/Kconfig	1969-12-31 19:29:27.000000682 -0600
@@ -1,5 +1,15 @@
 menu "NAND Device Support"
 
+config DM_NAND
+	bool "Enable driver model for NAND"
+	depends on DM
+	help
+	  Enable driver model for NAND. The NAND interface is then
+	  implemented by the NAND uclass. Multiple NAND devices can
+	  be attached and used. The 'nand' command works as normal.
+
+	  If the NAND drivers doesn't support DM, say N.
+
 config SYS_NAND_SELF_INIT
 	bool
 	help
diff -u -N U-Boot_SDcard/configs/k2g_evm_defconfig U-Boot_SDcard/configs/k2g_evm_defconfig
--- U-Boot_SDcard/configs/k2g_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/k2g_evm_defconfig	1969-12-31 19:29:18.000000284 -0600
@@ -8,7 +8,8 @@
 CONFIG_SPL_SERIAL_SUPPORT=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
-CONFIG_DEFAULT_DEVICE_TREE="k2g-evm"
+CONFIG_SYS_TEXT_BASE=0x0c000000
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2g-evm"
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
@@ -53,3 +54,9 @@
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_DWC3=y
 CONFIG_USB_STORAGE=y
+CONFIG_TI_GPMC=y
+CONFIG_CMD_NAND=y
+CONFIG_DM_NAND=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2g-generic keystone-k2g-evm keystone-k2g-ice"
diff -u -N U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi
--- U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/am57xx-beagle-x15-common.dtsi	1969-12-31 19:29:23.000000223 -0600
@@ -449,6 +449,11 @@
 
 	bus-width = <4>;
 	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>; /* gpio 219 */
+	/delete-property/ sd-uhs-sdr104;
+	/delete-property/ sd-uhs-sdr50;
+	/delete-property/ sd-uhs-ddr50;
+	/delete-property/ sd-uhs-sdr25;
+	/delete-property/ sd-uhs-sdr12;
 };
 
 &mmc2 {
@@ -461,6 +466,7 @@
 	bus-width = <8>;
 	ti,non-removable;
 	cap-mmc-dual-data-rate;
+	no-1-8-v;
 };
 
 &sata {
diff -u -N U-Boot_SDcard/arch/arm/mach-keystone/Kconfig U-Boot_SDcard/arch/arm/mach-keystone/Kconfig
--- U-Boot_SDcard/arch/arm/mach-keystone/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-keystone/Kconfig	1969-12-31 19:29:23.000000840 -0600
@@ -15,6 +15,8 @@
 
 config TARGET_K2G_EVM
 	bool "TI Keystone 2 Galileo EVM"
+        select BOARD_LATE_INIT
+        select TI_I2C_BOARD_DETECT
 
 endchoice
 
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2g.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2g.dtsi	1969-12-31 19:31:37.000000938 -0600
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Galileo soc device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include "skeleton.dtsi"
+
+/ {
+	model = "Texas Instruments Keystone 2 SoC";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	aliases {
+		serial0	= &uart0;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &spi2;
+		spi3 = &spi3;
+		spi4 = &qspi;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&gic>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	gic: interrupt-controller {
+		compatible = "arm,cortex-a15-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x0 0x02561000 0x0 0x1000>,
+		      <0x0 0x02562000 0x0 0x2000>,
+		      <0x0 0x02564000 0x0 0x1000>,
+		      <0x0 0x02566000 0x0 0x2000>;
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) |
+				IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "ti,keystone","simple-bus";
+		interrupt-parent = <&gic>;
+		ranges;
+
+		uart0: serial@02530c00 {
+			compatible = "ns16550a";
+			current-speed = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			reg = <0x02530c00 0x100>;
+			clock-names = "uart";
+			interrupts = <GIC_SPI 164 IRQ_TYPE_EDGE_RISING>;
+		};
+
+		mdio: mdio@4200f00 {
+			compatible	= "ti,keystone_mdio", "ti,davinci_mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			/* power-domains = <&k2g_pds K2G_DEV_NSS0>; */
+			/* clocks = <&k2g_clks K2G_DEV_NSS0 K2G_DEV_NSS_ESW_CLK>; */
+			clock-names = "fck";
+			reg = <0x04200f00 0x100>;
+			status = "disabled";
+			bus_freq = <2500000>;
+		};
+
+		qspi: qspi@2940000 {
+			compatible =  "cadence,qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x02940000 0x1000>,
+			      <0x24000000 0x4000000>;
+			interrupts = <GIC_SPI 198 IRQ_TYPE_EDGE_RISING>;
+			num-cs = <4>;
+			fifo-depth = <256>;
+			sram-size = <256>;
+			status = "disabled";
+		};
+
+		#include "keystone-k2g-netcp.dtsi"
+
+		pmmc: pmmc@2900000 {
+			compatible = "ti,power-processor";
+			reg = <0x02900000 0x40000>;
+			ti,lpsc_module = <1>;
+		};
+
+		spi0: spi@21805400 {
+			compatible = "ti,keystone-spi", "ti,dm6441-spi";
+			reg = <0x21805400 0x200>;
+			num-cs = <4>;
+			ti,davinci-spi-intr-line = <0>;
+			interrupts = <GIC_SPI 64 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@21805800 {
+			compatible = "ti,keystone-spi", "ti,dm6441-spi";
+			reg = <0x21805800 0x200>;
+			num-cs = <4>;
+			ti,davinci-spi-intr-line = <0>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi2: spi@21805c00 {
+			compatible = "ti,keystone-spi", "ti,dm6441-spi";
+			reg = <0x21805C00 0x200>;
+			num-cs = <4>;
+			ti,davinci-spi-intr-line = <0>;
+			interrupts = <GIC_SPI 68 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi3: spi@21806000 {
+			compatible = "ti,keystone-spi", "ti,dm6441-spi";
+			reg = <0x21806000 0x200>;
+			num-cs = <4>;
+			ti,davinci-spi-intr-line = <0>;
+			interrupts = <GIC_SPI 70 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		mmc0: mmc@23000000 {
+			compatible = "ti,omap4-hsmmc";
+			reg = <0x23000000 0x400>;
+			interrupts = <GIC_SPI 96 IRQ_TYPE_EDGE_RISING>;
+			bus-width = <4>;
+			ti,needs-special-reset;
+			no-1-8-v;
+			max-frequency = <96000000>;
+			status = "disabled";
+		};
+
+		mmc1: mmc@23100000 {
+			compatible = "ti,omap4-hsmmc";
+			reg = <0x23100000 0x400>;
+			interrupts = <GIC_SPI 97 IRQ_TYPE_EDGE_RISING>;
+			bus-width = <8>;
+			ti,needs-special-reset;
+			ti,non-removable;
+			max-frequency = <96000000>;
+			status = "disabled";
+			clock-names = "fck";
+		};
+
+		gpmc: gpmc@21818000 {
+			compatible = "ti,am3352-gpmc";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			reg = <0x21818000 0x400>;
+			interrupts = <GIC_SPI 196 IRQ_TYPE_EDGE_RISING>;
+			gpmc,num-cs = <4>;
+			gpmc,num-waitpins = <2>;
+			status = "disabled";
+		 };
+
+		elm: elm@021c8000 {
+			compatible = "ti,am3352-elm";
+			reg = <0x021c8000 0x2000>;
+			interrupts = <GIC_SPI 197 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+		 };
+	};
+};
diff -u -N U-Boot_SDcard/board/ti/ks2_evm/Kconfig U-Boot_SDcard/board/ti/ks2_evm/Kconfig
--- U-Boot_SDcard/board/ti/ks2_evm/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/board/ti/ks2_evm/Kconfig	1969-12-31 19:29:27.000000196 -0600
@@ -49,3 +49,5 @@
 	default "k2g_evm"
 
 endif
+
+source "board/ti/common/Kconfig"
diff -u -N U-Boot_SDcard/configs/am57xx_hs_evm_defconfig U-Boot_SDcard/configs/am57xx_hs_evm_defconfig
--- U-Boot_SDcard/configs/am57xx_hs_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am57xx_hs_evm_defconfig	1969-12-31 19:29:17.000000977 -0600
@@ -1,24 +1,33 @@
 CONFIG_ARM=y
 CONFIG_OMAP54XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+# CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TI_SECURE_DEVICE=y
-# CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TARGET_AM57XX_EVM=y
-CONFIG_TI_SECURE_EMIF_REGION_START=0xbe000000
+CONFIG_TI_SECURE_EMIF_REGION_START=0xbdb00000
 CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE=0x02000000
 CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE=0x01c00000
+CONFIG_DRA7_DSPEVE_OPP_HIGH=y
+CONFIG_DRA7_IVA_OPP_HIGH=y
+CONFIG_DRA7_GPU_OPP_HIGH=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_ARMV7_LPAE=y
 CONFIG_SPL_STACK_R_ADDR=0x82000000
-CONFIG_DEFAULT_DEVICE_TREE="am57xx-beagle-x15"
+CONFIG_DEFAULT_DEVICE_TREE="am572x-idk"
 CONFIG_FIT=y
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_SPL_LOAD_FIT=y
 CONFIG_SPL_FIT_IMAGE_POST_PROCESS=y
 CONFIG_FIT_IMAGE_POST_PROCESS=y
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_DMA_SUPPORT=y
 CONFIG_HUSH_PARSER=y
 CONFIG_FASTBOOT=y
@@ -45,13 +54,23 @@
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_MII=y
 CONFIG_CMD_PING=y
+CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT2=y
 CONFIG_CMD_EXT4=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_OF_LIST="am57xx-beagle-x15 am57xx-beagle-x15-revb1 am57xx-evm-reva3 am572x-idk am571x-idk"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_REGMAP=y
+CONFIG_SPL_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_SYSCON=y
+CONFIG_SPL_OF_TRANSLATE=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -63,6 +82,11 @@
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_BAR=y
 CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_PALMAS=y
+CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_PALMAS=y
 CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
 CONFIG_DM_SPI=y
@@ -80,4 +104,3 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
-CONFIG_SPL_OF_LIBFDT=y
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2l-clocks.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2l-clocks.dtsi	1969-12-31 19:31:37.000000943 -0600
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 lamarr SoC clock nodes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+clocks {
+	armpllclk: armpllclk@2620370 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclksys>;
+		clock-output-names = "arm-pll-clk";
+		reg = <0x02620370 4>;
+		reg-names = "control";
+	};
+
+	mainpllclk: mainpllclk@2310110 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,main-pll-clock";
+		clocks = <&refclksys>;
+		reg = <0x02620350 4>, <0x02310110 4>, <0x02310108 4>;
+		reg-names = "control", "multiplier", "post-divider";
+	};
+
+	papllclk: papllclk@2620358 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclksys>;
+		clock-output-names = "papllclk";
+		reg = <0x02620358 4>;
+		reg-names = "control";
+	};
+
+	ddr3apllclk: ddr3apllclk@2620360 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclksys>;
+		clock-output-names = "ddr-3a-pll-clk";
+		reg = <0x02620360 4>;
+		reg-names = "control";
+	};
+
+	clkdfeiqnsys: clkdfeiqnsys {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "dfe";
+		reg-names = "control", "domain";
+		reg = <0x02350004 0xb00>, <0x02350000 0x400>;
+		domain-id = <0>;
+	};
+
+	clkpcie1: clkpcie1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "pcie";
+		reg = <0x0235002c 0xb00>, <0x02350000 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <4>;
+	};
+
+	clkgem1: clkgem1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem1";
+		reg = <0x02350040 0xb00>, <0x02350024 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <9>;
+	};
+
+	clkgem2: clkgem2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem2";
+		reg = <0x02350044 0xb00>, <0x02350028 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <10>;
+	};
+
+	clkgem3: clkgem3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem3";
+		reg = <0x02350048 0xb00>, <0x0235002c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <11>;
+	};
+
+	clktac: clktac {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tac";
+		reg = <0x02350064 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <17>;
+	};
+
+	clkrac: clkrac {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "rac";
+		reg = <0x02350068 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <17>;
+	};
+
+	clkdfepd0: clkdfepd0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "dfe-pd0";
+		reg = <0x0235006c 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <18>;
+	};
+
+	clkfftc0: clkfftc0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-0";
+		reg = <0x02350070 0xb00>, <0x0235004c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <19>;
+	};
+
+	clkosr: clkosr {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "osr";
+		reg = <0x02350088 0xb00>, <0x0235004c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <21>;
+	};
+
+	clktcp3d0: clktcp3d0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-0";
+		reg = <0x0235008c 0xb00>, <0x02350058 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <22>;
+	};
+
+	clktcp3d1: clktcp3d1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-1";
+		reg = <0x02350094 0xb00>, <0x02350058 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <23>;
+	};
+
+	clkvcp0: clkvcp0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-0";
+		reg = <0x0235009c 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp1: clkvcp1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-1";
+		reg = <0x023500a0 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp2: clkvcp2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-2";
+		reg = <0x023500a4 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp3: clkvcp3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-3";
+		reg = <0x023500a8 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkbcp: clkbcp {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "bcp";
+		reg = <0x023500bc 0xb00>, <0x02350068 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <26>;
+	};
+
+	clkdfepd1: clkdfepd1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "dfe-pd1";
+		reg = <0x023500c0 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <27>;
+	};
+
+	clkfftc1: clkfftc1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-1";
+		reg = <0x023500c4 0xb00>, <0x023504c0 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <28>;
+	};
+
+	clkiqnail: clkiqnail {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "iqn-ail";
+		reg = <0x023500c8 0xb00>, <0x0235004c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <29>;
+	};
+
+	clkuart2: clkuart2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&clkmodrst0>;
+		clock-output-names = "uart2";
+		reg = <0x02350000 0xb00>, <0x02350000 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <0>;
+	};
+
+	clkuart3: clkuart3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&clkmodrst0>;
+		clock-output-names = "uart3";
+		reg = <0x02350000 0xb00>, <0x02350000 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <0>;
+	};
+};
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/am437x-gp-evm-u-boot.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/am437x-gp-evm-u-boot.dtsi	1969-12-31 19:31:37.000000927 -0600
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * Based on "dra7.dtsi"
+ */
+
+/{
+	ocp {
+		u-boot,dm-spl;
+	};
+};
+
+&uart0 {
+	u-boot,dm-spl;
+};
+
+&mmc1 {
+	u-boot,dm-spl;
+};
+
+&mac {
+	u-boot,dm-spl;
+};
+
+&davinci_mdio {
+	u-boot,dm-spl;
+};
+
+&cpsw_emac0 {
+	u-boot,dm-spl;
+};
+
+&phy_sel {
+	u-boot,dm-spl;
+};
diff -u -N /dev/null U-Boot_SDcard/drivers/rapidio/Kconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/drivers/rapidio/Kconfig	1969-12-31 19:31:37.000000919 -0600
@@ -0,0 +1,20 @@
+#
+# RapidIO infrastructure and drivers
+#
+
+config DM_RIO
+	bool "Enable Driver Model for RapidIO drivers"
+	depends on DM
+	default n
+	help
+	  Enable driver model for RapidIO access. The standard RapidIO
+	  interface (rio_config_read(), etc.) is then implemented by
+	  the RapidIO uclass. Drivers provide methods to query the
+	  particular RapidIO devices that they support. The uclass
+	  interface is defined in include/rio.h.
+
+config KEYSTONE_RIO
+	bool "Support for TI KeyStone RapidIO"
+	depends on TARGET_K2HK_EVM && DM_RIO
+        help
+	  Say Y here if you want to use RapidIO to boot your board.
diff -u -N U-Boot_SDcard/board/ti/common/Kconfig U-Boot_SDcard/board/ti/common/Kconfig
--- U-Boot_SDcard/board/ti/common/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/board/ti/common/Kconfig	1969-12-31 19:29:27.000000181 -0600
@@ -1,12 +1,24 @@
-config SPL_ENV_SUPPORT
-	default y
-
 config TI_I2C_BOARD_DETECT
 	bool "Support for Board detection for TI platforms"
 	help
 	   Support for detection board information on Texas Instrument's
 	   Evaluation Boards which have I2C based EEPROM detection
 
+config EEPROM_BUS_ADDRESS
+	int "Board EEPROM's I2C bus address"
+	range 0 8
+	default 0
+
+config EEPROM_CHIP_ADDRESS
+	hex "Board EEPROM's I2C chip address"
+	range 0 0xff
+	default 0x50
+
+if ARCH_OMAP2
+
+config SPL_ENV_SUPPORT
+	default y
+
 config SPL_EXT_SUPPORT
 	default y
 
@@ -39,3 +51,5 @@
 
 config SPL_SERIAL_SUPPORT
 	default y
+
+endif
diff -u -N /dev/null U-Boot_SDcard/configs/am43xx_hs_evm_qspi_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/am43xx_hs_evm_qspi_defconfig	1969-12-31 19:31:37.000000907 -0600
@@ -0,0 +1,59 @@
+CONFIG_ARM=y
+CONFIG_AM43XX=y
+CONFIG_TI_SECURE_DEVICE=y
+CONFIG_TI_SECURE_EMIF_REGION_START=0xbdb00000
+CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE=0x02000000
+CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE=0x01c00000
+CONFIG_TARGET_AM43XX_EVM=y
+CONFIG_ISW_ENTRY_ADDR=0x300018e0
+CONFIG_DEFAULT_DEVICE_TREE="am43x-epos-evm"
+CONFIG_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="SERIAL1,CONS_INDEX=1,QSPI,QSPI_BOOT"
+CONFIG_FIT_IMAGE_POST_PROCESS=y
+CONFIG_QSPI_BOOT=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_DFU_SF=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SYS_NS16550=y
+CONFIG_TI_QSPI=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GADGET=y
+CONFIG_USB_DWC3_OMAP=y
+CONFIG_USB_DWC3_PHY_OMAP=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
+CONFIG_G_DNL_VENDOR_NUM=0x0403
+CONFIG_G_DNL_PRODUCT_NUM=0xbd00
+CONFIG_OF_LIBFDT=y
diff -u -N U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig
--- U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am57xx_evm_nodt_defconfig	1969-12-31 19:29:17.000000976 -0600
@@ -40,7 +40,8 @@
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_BAR=y
-CONFIG_SPI_FLASH_SPANSION=y
+#CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SYS_NS16550=y
 CONFIG_TI_QSPI=y
 CONFIG_USB=y
@@ -57,3 +58,5 @@
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
 CONFIG_OF_LIBFDT=y
+CONFIG_DRA7_GPU_OPP_HIGH=y
+CONFIG_QSPI_BOOT_ENABLE=y
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2e.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2e.dtsi	1969-12-31 19:31:37.000000933 -0600
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Edison soc device tree
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&gic>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <1>;
+		};
+
+		cpu@2 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <2>;
+		};
+
+		cpu@3 {
+			compatible = "arm,cortex-a15";
+			device_type = "cpu";
+			reg = <3>;
+		};
+	};
+
+	soc {
+		/include/ "keystone-k2e-clocks.dtsi"
+
+		usb: usb@2680000 {
+			interrupts = <GIC_SPI 152 IRQ_TYPE_EDGE_RISING>;
+			dwc3@2690000 {
+				interrupts = <GIC_SPI 152 IRQ_TYPE_EDGE_RISING>;
+			};
+		};
+
+		usb1_phy: usb_phy@2620750 {
+			compatible = "ti,keystone-usbphy";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x2620750 24>;
+			status = "disabled";
+		};
+
+		usb1: usb@25000000 {
+			compatible = "ti,keystone-dwc3";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x25000000 0x10000>;
+			clocks = <&clkusb1>;
+			clock-names = "usb";
+			interrupts = <GIC_SPI 414 IRQ_TYPE_EDGE_RISING>;
+			ranges;
+			dma-coherent;
+			dma-ranges;
+			status = "disabled";
+
+			dwc3@25010000 {
+				compatible = "synopsys,dwc3";
+				reg = <0x25010000 0x70000>;
+				interrupts = <GIC_SPI 414 IRQ_TYPE_EDGE_RISING>;
+				usb-phy = <&usb1_phy>, <&usb1_phy>;
+			};
+		};
+
+		dspgpio0: keystone_dsp_gpio@02620240 {
+			compatible = "ti,keystone-dsp-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio,syscon-dev = <&devctrl 0x240>;
+		};
+
+		pcie1: pcie@21020000 {
+			compatible = "ti,keystone-pcie","snps,dw-pcie";
+			clocks = <&clkpcie1>;
+			clock-names = "pcie";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			reg =  <0x21021000 0x2000>, <0x21020000 0x1000>, <0x02620128 4>;
+			ranges = <0x81000000 0 0 0x23260000 0x4000 0x4000
+				0x82000000 0 0x60000000 0x60000000 0 0x10000000>;
+
+			status = "disabled";
+			device_type = "pci";
+			num-lanes = <2>;
+
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &pcie_intc1 0>, /* INT A */
+					<0 0 0 2 &pcie_intc1 1>, /* INT B */
+					<0 0 0 3 &pcie_intc1 2>, /* INT C */
+					<0 0 0 4 &pcie_intc1 3>; /* INT D */
+
+			pcie_msi_intc1: msi-interrupt-controller {
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				interrupt-parent = <&gic>;
+				interrupts = <GIC_SPI 377 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 378 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 379 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 380 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 381 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 382 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 383 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 384 IRQ_TYPE_EDGE_RISING>;
+			};
+
+			pcie_intc1: legacy-interrupt-controller {
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				interrupt-parent = <&gic>;
+				interrupts = <GIC_SPI 373 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 374 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 375 IRQ_TYPE_EDGE_RISING>,
+					<GIC_SPI 376 IRQ_TYPE_EDGE_RISING>;
+			};
+		};
+
+		mdio: mdio@24200f00 {
+			compatible	= "ti,keystone_mdio", "ti,davinci_mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x24200f00 0x100>;
+			status = "disabled";
+			clocks = <&clkcpgmac>;
+			clock-names = "fck";
+			bus_freq	= <2500000>;
+		};
+		/include/ "keystone-k2e-netcp.dtsi"
+	};
+};
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig
--- U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-omap2/am33xx/Kconfig	1969-12-31 19:29:28.000000721 -0600
@@ -10,6 +10,8 @@
 	select DM_SERIAL
 	select DM_GPIO
 	select TI_I2C_BOARD_DETECT
+	select SPL_SYS_MALLOC_SIMPLE if SPL
+	select SPL_SEPARATE_BSS if SPL
 	help
 	  This option specifies support for the AM335x
 	  GP and HS EVM development platforms. The AM335x
@@ -94,6 +96,13 @@
 config SPL_I2C_SUPPORT
 	default y
 
+config SPL_RTC_ONLY_SUPPORT
+	bool
+	depends on SPL
+	prompt "Enable RTC ONLY Support"
+	help
+	  If you want RTC ONLY Support, say Y.
+
 config TARGET_AM43XX_EVM
 	bool "Support am43xx_evm"
 	select TI_I2C_BOARD_DETECT
@@ -119,7 +128,7 @@
 	  point address depending on the device type
 	  (secure/non-secure), boot media (xip/non-xip) and
 	  image headers.
-	default 0x402F4000 if AM43XX
+	default 0x40300000 if AM43XX
 	default 0x402F0400 if AM33XX
 
 config PUB_ROM_DATA_SIZE
diff -u -N /dev/null U-Boot_SDcard/arch/arm/dts/keystone-k2hk-clocks.dtsi
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/keystone-k2hk-clocks.dtsi	1969-12-31 19:31:37.000000939 -0600
@@ -0,0 +1,425 @@
+/*
+ * Copyright 2013-2014 Texas Instruments, Inc.
+ *
+ * Keystone 2 Kepler/Hawking SoC clock nodes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+clocks {
+	armpllclk: armpllclk@2620370 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkarm>;
+		clock-output-names = "arm-pll-clk";
+		reg = <0x02620370 4>;
+		reg-names = "control";
+	};
+
+	mainpllclk: mainpllclk@2310110 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,main-pll-clock";
+		clocks = <&refclksys>;
+		reg = <0x02620350 4>, <0x02310110 4>, <0x02310108 4>;
+		reg-names = "control", "multiplier", "post-divider";
+	};
+
+	papllclk: papllclk@2620358 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkpass>;
+		clock-output-names = "papllclk";
+		reg = <0x02620358 4>;
+		reg-names = "control";
+	};
+
+	ddr3apllclk: ddr3apllclk@2620360 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkddr3a>;
+		clock-output-names = "ddr-3a-pll-clk";
+		reg = <0x02620360 4>;
+		reg-names = "control";
+	};
+
+	ddr3bpllclk: ddr3bpllclk@2620368 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,pll-clock";
+		clocks = <&refclkddr3b>;
+		clock-output-names = "ddr-3b-pll-clk";
+		reg = <0x02620368 4>;
+		reg-names = "control";
+	};
+
+	clktsip: clktsip {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk16>;
+		clock-output-names = "tsip";
+		reg = <0x02350000 0xb00>, <0x02350000 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <0>;
+	};
+
+	clksrio: clksrio {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1rstiso13>;
+		clock-output-names = "srio";
+		reg = <0x0235002c 0xb00>, <0x02350010 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <4>;
+	};
+
+	clkhyperlink0: clkhyperlink0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "hyperlink-0";
+		reg = <0x02350030 0xb00>, <0x02350014 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <5>;
+	};
+
+	clkgem1: clkgem1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem1";
+		reg = <0x02350040 0xb00>, <0x02350024 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <9>;
+	};
+
+	clkgem2: clkgem2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem2";
+		reg = <0x02350044 0xb00>, <0x02350028 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <10>;
+	};
+
+	clkgem3: clkgem3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem3";
+		reg = <0x02350048 0xb00>, <0x0235002c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <11>;
+	};
+
+	clkgem4: clkgem4 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem4";
+		reg = <0x0235004c 0xb00>, <0x02350030 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <12>;
+	};
+
+	clkgem5: clkgem5 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem5";
+		reg = <0x02350050 0xb00>, <0x02350034 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <13>;
+	};
+
+	clkgem6: clkgem6 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem6";
+		reg = <0x02350054 0xb00>, <0x02350038 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <14>;
+	};
+
+	clkgem7: clkgem7 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk1>;
+		clock-output-names = "gem7";
+		reg = <0x02350058 0xb00>, <0x0235003c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <15>;
+	};
+
+	clkddr31: clkddr31 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "ddr3-1";
+		reg = <0x02350060 0xb00>, <0x02350040 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <16>;
+	};
+
+	clktac: clktac {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tac";
+		reg = <0x02350064 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <17>;
+	};
+
+	clkrac01: clkrac01 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "rac-01";
+		reg = <0x02350068 0xb00>, <0x02350044 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <17>;
+	};
+
+	clkrac23: clkrac23 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "rac-23";
+		reg = <0x0235006c 0xb00>, <0x02350048 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <18>;
+	};
+
+	clkfftc0: clkfftc0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-0";
+		reg = <0x02350070 0xb00>, <0x0235004c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <19>;
+	};
+
+	clkfftc1: clkfftc1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-1";
+		reg = <0x02350074 0xb00>, <0x0235004c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <19>;
+	};
+
+	clkfftc2: clkfftc2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-2";
+		reg = <0x02350078 0xb00>, <0x02350050 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <20>;
+	};
+
+	clkfftc3: clkfftc3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-3";
+		reg = <0x0235007c 0xb00>, <0x02350050 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <20>;
+	};
+
+	clkfftc4: clkfftc4 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-4";
+		reg = <0x02350080 0xb00>, <0x02350050 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <20>;
+	};
+
+	clkfftc5: clkfftc5 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "fftc-5";
+		reg = <0x02350084 0xb00>, <0x02350050 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <20>;
+	};
+
+	clkaif: clkaif {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "aif";
+		reg = <0x02350088 0xb00>, <0x02350054 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <21>;
+	};
+
+	clktcp3d0: clktcp3d0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-0";
+		reg = <0x0235008c 0xb00>, <0x02350058 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <22>;
+	};
+
+	clktcp3d1: clktcp3d1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-1";
+		reg = <0x02350090 0xb00>, <0x02350058 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <22>;
+	};
+
+	clktcp3d2: clktcp3d2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-2";
+		reg = <0x02350094 0xb00>, <0x0235005c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <23>;
+	};
+
+	clktcp3d3: clktcp3d3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "tcp3d-3";
+		reg = <0x02350098 0xb00>, <0x0235005c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <23>;
+	};
+
+	clkvcp0: clkvcp0 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-0";
+		reg = <0x0235009c 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp1: clkvcp1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-1";
+		reg = <0x023500a0 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp2: clkvcp2 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-2";
+		reg = <0x023500a4 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp3: clkvcp3 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-3";
+		reg = <0x023500a8 0xb00>, <0x02350060 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <24>;
+	};
+
+	clkvcp4: clkvcp4 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-4";
+		reg = <0x023500ac 0xb00>, <0x02350064 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <25>;
+	};
+
+	clkvcp5: clkvcp5 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-5";
+		reg = <0x023500b0 0xb00>, <0x02350064 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <25>;
+	};
+
+	clkvcp6: clkvcp6 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-6";
+		reg = <0x023500b4 0xb00>, <0x02350064 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <25>;
+	};
+
+	clkvcp7: clkvcp7 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "vcp-7";
+		reg = <0x023500b8 0xb00>, <0x02350064 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <25>;
+	};
+
+	clkbcp: clkbcp {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "bcp";
+		reg = <0x023500bc 0xb00>, <0x02350068 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <26>;
+	};
+
+	clkdxb: clkdxb {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "dxb";
+		reg = <0x023500c0 0xb00>, <0x0235006c 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <27>;
+	};
+
+	clkhyperlink1: clkhyperlink1 {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk12>;
+		clock-output-names = "hyperlink-1";
+		reg = <0x023500c4 0xb00>, <0x02350070 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <28>;
+	};
+
+	clkxge: clkxge {
+		#clock-cells = <0>;
+		compatible = "ti,keystone,psc-clock";
+		clocks = <&chipclk13>;
+		clock-output-names = "xge";
+		reg = <0x023500c8 0xb00>, <0x02350074 0x400>;
+		reg-names = "control", "domain";
+		domain-id = <29>;
+	};
+};
diff -u -N /dev/null U-Boot_SDcard/arch/x86/dts/include/dt-bindings
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/arch/x86/dts/include/dt-bindings	1969-12-31 19:31:37.000000959 -0600
@@ -0,0 +1,1 @@
+../../../../include/dt-bindings
\ No newline at end of file
diff -u -N U-Boot_SDcard/configs/k2e_evm_defconfig U-Boot_SDcard/configs/k2e_evm_defconfig
--- U-Boot_SDcard/configs/k2e_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/k2e_evm_defconfig	1969-12-31 19:29:18.000000283 -0600
@@ -9,13 +9,13 @@
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
 # CONFIG_MMC is not set
-CONFIG_DEFAULT_DEVICE_TREE="k2e-evm"
+CONFIG_SYS_TEXT_BASE=0x0c000000
+CONFIG_DEFAULT_DEVICE_TREE="keystone-k2e-evm"
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
 CONFIG_HUSH_PARSER=y
-CONFIG_SYS_PROMPT="K2E EVM # "
 CONFIG_CMD_BOOTZ=y
 # CONFIG_CMD_IMLS is not set
 CONFIG_CMD_ASKENV=y
@@ -50,3 +50,6 @@
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_DWC3=y
 CONFIG_USB_STORAGE=y
+CONFIG_DTB_RESELECT=y
+CONFIG_FIT_EMBED=y
+CONFIG_OF_LIST="keystone-k2e-evm"
diff -u -N U-Boot_SDcard/arch/arm/dts/dra7.dtsi U-Boot_SDcard/arch/arm/dts/dra7.dtsi
--- U-Boot_SDcard/arch/arm/dts/dra7.dtsi	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/dra7.dtsi	1969-12-31 19:29:23.000000295 -0600
@@ -400,6 +400,14 @@
 			reg = <0x40d00000 0x100>;
 		};
 
+		dra7_iodelay_core: padconf@4844a000 {
+			compatible = "ti,dra7-iodelay";
+			reg = <0x4844a000 0x0d1c>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#pinctrl-cells = <2>;
+		};
+
 		sdma: dma-controller@4a056000 {
 			compatible = "ti,omap4430-sdma";
 			reg = <0x4a056000 0x1000>;
@@ -1019,7 +1027,7 @@
 		};
 
 		mmc1: mmc@4809c000 {
-			compatible = "ti,omap4-hsmmc";
+			compatible = "ti,dra7-hsmmc", "ti,omap4-hsmmc";
 			reg = <0x4809c000 0x400>;
 			interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "mmc1";
@@ -1029,10 +1037,16 @@
 			dma-names = "tx", "rx";
 			status = "disabled";
 			pbias-supply = <&pbias_mmc_reg>;
+			max-frequency = <192000000>;
+			sd-uhs-sdr104;
+			sd-uhs-sdr50;
+			sd-uhs-ddr50;
+			sd-uhs-sdr25;
+			sd-uhs-sdr12;
 		};
 
 		mmc2: mmc@480b4000 {
-			compatible = "ti,omap4-hsmmc";
+			compatible = "ti,dra7-hsmmc", "ti,omap4-hsmmc";
 			reg = <0x480b4000 0x400>;
 			interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "mmc2";
@@ -1040,10 +1054,15 @@
 			dmas = <&sdma_xbar 47>, <&sdma_xbar 48>;
 			dma-names = "tx", "rx";
 			status = "disabled";
+			max-frequency = <192000000>;
+			sd-uhs-sdr25;
+			sd-uhs-sdr12;
+			mmc-hs200-1_8v;
+			mmc-ddr-1_8v;
 		};
 
 		mmc3: mmc@480ad000 {
-			compatible = "ti,omap4-hsmmc";
+			compatible = "ti,dra7-hsmmc", "ti,omap4-hsmmc";
 			reg = <0x480ad000 0x400>;
 			interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "mmc3";
@@ -1051,10 +1070,15 @@
 			dmas = <&sdma_xbar 77>, <&sdma_xbar 78>;
 			dma-names = "tx", "rx";
 			status = "disabled";
+			/* Errata i887 limits max-frequency of MMC3 to 64 MHz */
+			max-frequency = <64000000>;
+			sd-uhs-sdr12;
+			sd-uhs-sdr25;
+			sd-uhs-sdr50;
 		};
 
 		mmc4: mmc@480d1000 {
-			compatible = "ti,omap4-hsmmc";
+			compatible = "ti,dra7-hsmmc", "ti,omap4-hsmmc";
 			reg = <0x480d1000 0x400>;
 			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "mmc4";
@@ -1062,6 +1086,9 @@
 			dmas = <&sdma_xbar 57>, <&sdma_xbar 58>;
 			dma-names = "tx", "rx";
 			status = "disabled";
+			max-frequency = <192000000>;
+			sd-uhs-sdr12;
+			sd-uhs-sdr25;
 		};
 
 		mmu0_dsp1: mmu@40d01000 {
diff -u -N U-Boot_SDcard/common/Kconfig U-Boot_SDcard/common/Kconfig
--- U-Boot_SDcard/common/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/common/Kconfig	1969-12-31 19:29:17.000000447 -0600
@@ -352,6 +352,24 @@
 
 endmenu
 
+config DTB_RESELECT
+	bool "Support swapping dtbs at a later point in boot"
+	depends on FIT_EMBED
+	default n
+	help
+	  It is possible during initial boot you may need to use a generic
+	  dtb until you can fully determine the board your running on. This
+	  config allows boards to implement a function at a later point
+	  during boot to switch to the "correct" dtb.
+
+config FIT_EMBED
+	bool "Support a FIT image embedded in the U-boot image"
+	default n
+	help
+	  This option provides hooks to allow U-boot to parse an
+	  appended FIT image and enable board specific code to then select
+	  the correct DTB to be used.
+
 config DEFAULT_FDT_FILE
 	string "Default fdt file"
 	help
diff -u -N /dev/null U-Boot_SDcard/configs/am43xx_evm_rtconly_defconfig
--- /dev/null	1969-12-31 18:00:00.000000000 -0600
+++ U-Boot_SDcard/configs/am43xx_evm_rtconly_defconfig	1969-12-31 19:31:37.000000906 -0600
@@ -0,0 +1,79 @@
+CONFIG_ARM=y
+CONFIG_AM43XX=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_AM43XX_EVM=y
+CONFIG_SPL_STACK_R_ADDR=0x82000000
+CONFIG_SPL_YMODEM_SUPPORT=y
+CONFIG_DEFAULT_DEVICE_TREE="am437x-gp-evm"
+CONFIG_FIT=y
+CONFIG_SYS_EXTRA_OPTIONS="CONS_INDEX=1,NAND"
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
+CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_RTC_ONLY_SUPPORT=y
+CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_SPL_OS_BOOT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_ASKENV=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_OF_LIST="am437x-gp-evm am437x-sk-evm am43x-epos-evm am437x-idk-evm"
+CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_OF_TRANSLATE=y
+# CONFIG_BLK is not set
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_DFU_SF=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_DM_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_ETH=y
+CONFIG_DM_SERIAL=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_TI_QSPI=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GADGET=y
+CONFIG_USB_DWC3_OMAP=y
+CONFIG_USB_DWC3_PHY_OMAP=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
+CONFIG_G_DNL_VENDOR_NUM=0x0403
+CONFIG_G_DNL_PRODUCT_NUM=0xbd00
diff -u -N U-Boot_SDcard/cmd/Kconfig U-Boot_SDcard/cmd/Kconfig
--- U-Boot_SDcard/cmd/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/cmd/Kconfig	1969-12-31 19:29:17.000000311 -0600
@@ -459,6 +459,12 @@
 	help
 	  GPIO support.
 
+config CMD_RIO
+	bool "rapidio"
+	select DM_RIO
+	help
+	  RapidIO support.
+
 endmenu
 
 
diff -u -N U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi
--- U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/dts/am57xx-idk-common.dtsi	1969-12-31 19:29:23.000000227 -0600
@@ -301,12 +301,27 @@
 	dr_mode = "otg";
 };
 
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&v3_3d>;
+	vmmc_aux-supply = <&ldo1_reg>;
+	bus-width = <4>;
+	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>; /* gpio 219 */
+	/delete-property/ sd-uhs-sdr104;
+	/delete-property/ sd-uhs-sdr50;
+	/delete-property/ sd-uhs-ddr50;
+	/delete-property/ sd-uhs-sdr25;
+	/delete-property/ sd-uhs-sdr12;
+};
+
 &mmc2 {
 	status = "okay";
 	vmmc-supply = <&v3_3d>;
 	bus-width = <8>;
 	ti,non-removable;
 	max-frequency = <96000000>;
+	no-1-8-v;
+	/delete-property/ mmc-hs200-1_8v;
 };
 
 &qspi {
@@ -314,7 +329,10 @@
 
 	spi-max-frequency = <76800000>;
 	m25p80@0 {
-		compatible = "s25fl256s1", "spi-flash", "jedec,spi-nor";
+/*		compatible = "s25fl256s1", "spi-flash", "jedec,spi-nor"; */
+
+                compatible = "mx25l51235f", "spi-flash", "jedec,spi-nor";  
+/*               compatible = "mx66l2g45g", "spi-flash", "jedec,spi-nor";    */
 		spi-max-frequency = <76800000>;
 		reg = <0>;
 		spi-tx-bus-width = <1>;
diff -u -N U-Boot_SDcard/arch/arm/mach-omap2/Kconfig U-Boot_SDcard/arch/arm/mach-omap2/Kconfig
--- U-Boot_SDcard/arch/arm/mach-omap2/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/arch/arm/mach-omap2/Kconfig	1969-12-31 19:29:23.000000885 -0600
@@ -1,6 +1,6 @@
 config TI_SECURE_DEVICE
 	bool "HS Device Type Support"
-	depends on OMAP54XX || AM43XX || AM33XX
+	depends on OMAP54XX || AM43XX || AM33XX || ARCH_KEYSTONE
 	help
 	  If a high secure (HS) device type is being used, this config
 	  must be set. This option impacts various aspects of the
@@ -8,6 +8,32 @@
 	  authenticated) and the code. See the doc/README.ti-secure
 	  file for further details.
 
+config TI_SECURE_EMIF_REGION_START
+	hex "Reserved EMIF region start address"
+	depends on TI_SECURE_DEVICE
+	default 0x0
+	help
+	  Reserved EMIF region start address. Set to "0" to auto-select
+	  to be at the end of the external memory region.
+
+config TI_SECURE_EMIF_TOTAL_REGION_SIZE
+	hex "Reserved EMIF region size"
+	depends on TI_SECURE_DEVICE
+	default 0x0
+	help
+	  Total reserved EMIF region size. Default is 0, which means no reserved EMIF
+	  region on secure devices.
+
+config TI_SECURE_EMIF_PROTECTED_REGION_SIZE
+	hex "Size of protected region within reserved EMIF region"
+	depends on TI_SECURE_DEVICE
+	default 0x0
+	help
+	  This config option is used to specify the size of the portion of the total
+	  reserved EMIF region set aside for secure OS needs that will  be protected
+	  using hardware memory firewalls. This value must be smaller than the
+	  TI_SECURE_EMIF_TOTAL_REGION_SIZE value.
+
 source "arch/arm/mach-omap2/omap3/Kconfig"
 
 source "arch/arm/mach-omap2/omap4/Kconfig"
diff -u -N U-Boot_SDcard/MAINTAINERS U-Boot_SDcard/MAINTAINERS
--- U-Boot_SDcard/MAINTAINERS	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/MAINTAINERS	1969-12-31 19:29:17.000000026 -0600
@@ -434,6 +434,18 @@
 F:	drivers/spmi/
 F:	include/spmi/
 
+TI SYSTEM SECURITY
+M:	Andrew F. Davis <afd@ti.com>
+S:	Supported
+F:	arch/arm/mach-omap2/omap5/sec_entry_cpu1.S
+F:	arch/arm/mach-omap2/omap5/sec-fxns.c
+F:	arch/arm/mach-omap2/sec-common.c
+F:	arch/arm/mach-omap2/config_secure.mk
+F:	configs/am335x_hs_evm_defconfig
+F:	configs/am43xx_hs_evm_defconfig
+F:	configs/am57xx_hs_evm_defconfig
+F:	configs/dra7xx_hs_evm_defconfig
+
 TQ GROUP
 #M:	Martin Krause <martin.krause@tq-systems.de>
 S:	Orphaned (Since 2016-02)
diff -u -N U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig
--- U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/dra7xx_hs_evm_defconfig	1969-12-31 19:29:18.000000175 -0600
@@ -1,14 +1,18 @@
 CONFIG_ARM=y
 CONFIG_OMAP54XX=y
 CONFIG_SYS_MALLOC_F_LEN=0x2000
+# CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TI_SECURE_DEVICE=y
-# CONFIG_SPL_NAND_SUPPORT is not set
 CONFIG_TARGET_DRA7XX_EVM=y
-CONFIG_TI_SECURE_EMIF_REGION_START=0xbe000000
+CONFIG_TI_SECURE_EMIF_REGION_START=0xbdb00000
 CONFIG_TI_SECURE_EMIF_TOTAL_REGION_SIZE=0x02000000
 CONFIG_TI_SECURE_EMIF_PROTECTED_REGION_SIZE=0x01c00000
+CONFIG_DRA7_DSPEVE_OPP_HIGH=y
+CONFIG_DRA7_IVA_OPP_HIGH=y
+CONFIG_DRA7_GPU_OPP_HIGH=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_ARMV7_LPAE=y
 CONFIG_SPL_STACK_R_ADDR=0x82000000
 CONFIG_DEFAULT_DEVICE_TREE="dra7-evm"
 CONFIG_FIT=y
@@ -16,10 +20,14 @@
 CONFIG_SPL_LOAD_FIT=y
 CONFIG_SPL_FIT_IMAGE_POST_PROCESS=y
 CONFIG_FIT_IMAGE_POST_PROCESS=y
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_VERSION_VARIABLE=y
 CONFIG_SPL=y
+CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_STACK_R=y
+CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_DMA_SUPPORT=y
 CONFIG_HUSH_PARSER=y
 CONFIG_FASTBOOT=y
@@ -53,8 +61,16 @@
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
 CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
 CONFIG_OF_LIST="dra7-evm dra72-evm dra72-evm-revc dra71-evm"
 CONFIG_DM=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_REGMAP=y
+CONFIG_SPL_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_SYSCON=y
+CONFIG_SPL_OF_TRANSLATE=y
 # CONFIG_BLK is not set
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
@@ -73,6 +89,7 @@
 CONFIG_PMIC_PALMAS=y
 CONFIG_PMIC_LP873X=y
 CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_PALMAS=y
@@ -96,4 +113,3 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
-CONFIG_SPL_OF_LIBFDT=y
diff -u -N U-Boot_SDcard/configs/am335x_evm_defconfig U-Boot_SDcard/configs/am335x_evm_defconfig
--- U-Boot_SDcard/configs/am335x_evm_defconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/configs/am335x_evm_defconfig	1969-12-31 19:29:17.000000955 -0600
@@ -13,6 +13,9 @@
 CONFIG_SPL_STACK_R=y
 CONFIG_SPL_MTD_SUPPORT=y
 CONFIG_SPL_MUSB_NEW_SUPPORT=y
+CONFIG_SPL_NET_SUPPORT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USBETH_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
 # CONFIG_CMD_IMLS is not set
 CONFIG_CMD_ASKENV=y
@@ -37,7 +40,6 @@
 # CONFIG_DM_MMC_OPS is not set
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_WINBOND=y
-CONFIG_DM_ETH=y
 CONFIG_SYS_NS16550=y
 CONFIG_TIMER=y
 CONFIG_OMAP_TIMER=y
@@ -50,5 +52,14 @@
 CONFIG_G_DNL_MANUFACTURER="Texas Instruments"
 CONFIG_G_DNL_VENDOR_NUM=0x0451
 CONFIG_G_DNL_PRODUCT_NUM=0xd022
+CONFIG_USE_TINY_PRINTF=y
 CONFIG_RSA=y
 CONFIG_SPL_OF_LIBFDT=y
+CONFIG_MISC=y
+CONFIG_DM_USB=y
+CONFIG_USB_MUSB_TI=y
+CONFIG_OF_LIBFDT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_DM_NAND=y
+CONFIG_SPL_NET_VCI_STRING="AM335x U-Boot SPL"
+CONFIG_SPL_ETH_SUPPORT=y
diff -u -N U-Boot_SDcard/drivers/dfu/Kconfig U-Boot_SDcard/drivers/dfu/Kconfig
--- U-Boot_SDcard/drivers/dfu/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/drivers/dfu/Kconfig	1969-12-31 19:29:20.000000957 -0600
@@ -17,6 +17,11 @@
 	help
 	  This option enables using DFU to read and write to MMC based storage.
 
+config SPL_DFU_MMC
+	bool "MMC back end for SPL-DFU"
+	help
+	  This option enables DFU for SPL to read and write to MMC based storage.
+
 config DFU_NAND
 	bool "NAND back end for DFU"
 	help
diff -u -N U-Boot_SDcard/drivers/Kconfig U-Boot_SDcard/drivers/Kconfig
--- U-Boot_SDcard/drivers/Kconfig	2017-01-09 10:57:05.000000000 -0600
+++ U-Boot_SDcard/drivers/Kconfig	1969-12-31 19:29:18.000000959 -0600
@@ -60,6 +60,8 @@
 
 source "drivers/ram/Kconfig"
 
+source "drivers/rapidio/Kconfig"
+
 source "drivers/remoteproc/Kconfig"
 
 source "drivers/reset/Kconfig"
