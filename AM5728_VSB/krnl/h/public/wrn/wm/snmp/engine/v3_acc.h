/* $Header: /usr/cvsroot/target/h/wrn/wm/snmp/engine/v3_acc.h,v 1.2 2001/11/06 21:35:05 josh Exp $ */

/*
 * Copyright (C) 1999-2005 Wind River Systems, Inc.
 * All rights reserved.  Provided under license only.
 * Distribution or other use of this software is only
 * permitted pursuant to the terms of a license agreement
 * from Wind River Systems (and is otherwise prohibited).
 * Refer to that license agreement for terms of use.
 */


/****************************************************************************
 *  Copyright 1998 Integrated Systems, Inc.
 *  All rights reserved.
 ****************************************************************************/

/*
 * $Log: v3_acc.h,v $
 * Revision 1.2  2001/11/06 21:35:05  josh
 * new revised path structure, first pass.  Also removing useless
 * shell include files.
 *
 * Revision 1.1.1.1  2001/11/05 17:47:23  tneale
 * Tornado shuffle
 *
 * Revision 9.6  2001/04/25 16:52:23  josh
 * the SNMP_ACCESS_T object is now initialized with a default
 * status of ETC_RS_NIS instead of ETC_RS_NREADY
 *
 * Revision 9.5  2001/01/19 22:22:11  paul
 * Update copyright.
 *
 * Revision 9.4  2000/03/17 19:48:43  meister
 * Update copyright notice
 *
 * Revision 9.3  2000/03/09 20:58:35  tneale
 * All structure definitions are now bracketted with a test that
 * potentially sets an alignment pragma.  This is to maintain compatibility
 * with the code base that had been distributed by Wind River.
 *
 * Revision 9.2  2000/03/09 16:59:22  tneale
 *  Added #ifdef for C++ to declare extern C if needed
 *
 * Revision 9.1  2000/02/04 21:54:19  josh
 * prototyping functions that may need to be called by other modules
 * this is done primarily to make the vxWorks compiler happy.
 * Warning:  the prototypes added may be duplicated by a mib_hand.h
 * file generated by Emissary.
 *
 * Revision 9.0  1998/10/16 22:10:23  sar
 * Update version stamp to match release
 *
 * Revision 1.7  1998/08/12 04:52:16  sar
 * revamp the initialization routines to limit the amount of
 * code that might get pulled in.
 *
 * Revision 1.6  1998/07/06 01:01:21  sar
 * Update type of security level field to make compilers happy
 *
 * Revision 1.5  1998/07/01 01:48:18  sar
 * As part of the set_defaults macro do a memset to zero the memory
 *
 * Revision 1.4  1998/06/18 04:42:03  sar
 * Modified bflags in ebuffer to be unsigned ints and updated
 * calling routines accordingly
 *
 * Revision 1.3  1998/06/16 05:29:56  sar
 * clean up some type info
 * modify the api for the next routine
 *
 * Revision 1.2  1998/05/30 02:52:08  sar
 * Modifed the names used for max string length
 * Updated user lookup
 *
 * Revision 1.1  1998/05/23 19:49:39  sar
 * Include files for use with v3 code.  They define the structures
 * and entry points for the various pieces.
 * acc: access and group information
 * auth & priv: authentication and privacy
 * con: context
 * eng: engine ids, both this agents and any others it knows
 * mth: method routines, for use with mib control files
 * user: user info
 *
 */

/* [clearcase]
modification history
-------------------
01a,19apr05,job  update copyright notices
*/


#if (!defined(v3_acc_inc))
#define v3_acc_inc

#ifdef __cplusplus
extern"C" {
#endif

#if (!defined(asn1_inc))
#include <wrn/wm/snmp/engine/asn1.h>
#endif

#if (!defined(buffer_inc))
#include <wrn/wm/snmp/engine/buffer.h>
#endif

#if (!defined(smi_inc))
#include <wrn/wm/snmp/engine/smi.h>
#endif

#define ETC_ACCESS_VIEW_MAX   32
#define ETC_ACCESS_GROUP_MAX  32
#define ETC_ACCESS_ACCESS_MAX 32

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 1
#endif

typedef struct SNMP_GROUP_S
	{
	struct SNMP_GROUP_S *next;
	sbits32_t  model;	/* security model, an index */
	bits8_t   *uname;	/* security name, other index */
	ALENGTH_T  uname_len;   /* length of security name */
	EBUFFER_T  grp_name;	/* group name */
	bits16_t   status;
	bits16_t   storage;
	} SNMP_GROUP_T;

/* global root pointer for group list */
extern SNMP_GROUP_T *root_group;

#define SNMP_Group_Set_Defaults(G) (MEMSET((G), 0, sizeof(SNMP_GROUP_T)), \
				    EBufferInitialize(&((G)->grp_name)),  \
				    (G)->storage = ETC_STO_NONVOL,        \
				    (G)->status  = ETC_RS_NREADY)

extern SNMP_GROUP_T * SNMP_Group_Create     __((void));
extern void           SNMP_Group_Destroy    __((SNMP_GROUP_T *));
extern int            SNMP_Group_Install    __((SNMP_GROUP_T *, sbits32_t,
					        bits8_t *, ALENGTH_T));
extern void           SNMP_Group_Deinstall  __((SNMP_GROUP_T *));
extern SNMP_GROUP_T * SNMP_Group_Lookup     __((sbits32_t, bits8_t *,
					        ALENGTH_T));
extern SNMP_GROUP_T * SNMP_Group_Next       __((int, OIDC_T *));
extern SNMP_GROUP_T * SNMP_Group_Next_Group __((SNMP_GROUP_T *));
extern void           SNMP_Group_Name       __((SNMP_GROUP_T *, sbits32_t *, 
						bits8_t *, ALENGTH_T *));

#define SNMP_Group_Set_Group(G, S, L, F) \
	(EBufferAllocateLoad((F), &((G)->grp_name), (S), (L)))

#define SNMP_Group_Compare_Names(G1, G2) ((G1 == G2) ? 0 : 1)

#define SNMP_Group_Get_Group(G)           (EBufferStart(&((G)->grp_name)))
#define SNMP_Group_Get_Group_Len(G)       (EBufferUsed(&((G)->grp_name)))

#define SNMP_Group_Get_Status(G)	  ((G)->status)
#define SNMP_Group_Set_Status(G, V)	  ((G)->status = (bits16_t)(V))
#define SNMP_Group_Get_Storage(G)	  ((G)->storage)
#define SNMP_Group_Set_Storage(G, V)	  ((G)->storage = (bits16_t)(V))

typedef struct SNMP_ACC_GRP_S
	{
	struct SNMP_ACC_GRP_S *next;
	bits8_t   *grp_name;	/* group name, an index */ 
	ALENGTH_T  grp_len;
	struct SNMP_ACCESS_S *access;
	} SNMP_ACC_GRP_T;

typedef struct SNMP_ACCESS_S
	{
	struct SNMP_ACC_GRP_S *group;
	struct SNMP_ACCESS_S  *next;
	bits8_t   *prefix;	/* context prefix, an index */
	ALENGTH_T  prefix_len;
	int       prefix_match; /* prefix match, exact - 1, prefix - 2 */ 
	sbits32_t model;	/* security model, an index */
	sbits16_t level;	/* security level, an index */ 
	EBUFFER_T readview;	/* name of view for reading */
	EBUFFER_T writeview;	/* name of view for writing */
	EBUFFER_T notifyview;	/* name of view for notifies */
	int       status;
	int       storage;
	} SNMP_ACCESS_T;

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 0
#endif

#define ETC_ACCESS_EXACT  1
#define ETC_ACCESS_PREFIX 2

/* global root pointer for access list */
extern SNMP_ACC_GRP_T *root_access;

#define SNMP_V3_Access_Set_Defaults(A) (MEMSET((A), 0, sizeof(SNMP_ACCESS_T)),\
					(A)->prefix_match = ETC_ACCESS_EXACT, \
					EBufferInitialize(&((A)->readview)),  \
					EBufferInitialize(&((A)->writeview)), \
					EBufferInitialize(&((A)->notifyview)),\
					(A)->storage = ETC_STO_NONVOL,        \
					(A)->status  = ETC_RS_NIS)

extern SNMP_ACCESS_T * SNMP_V3_Access_Create    __((void));
extern void            SNMP_V3_Access_Destroy   __((SNMP_ACCESS_T *));
extern int             SNMP_V3_Access_Install   __((SNMP_ACCESS_T *,
						    bits8_t *, ALENGTH_T,
						    bits8_t *, ALENGTH_T,
						    sbits32_t, sbits32_t));
extern void            SNMP_V3_Access_Deinstall __((SNMP_ACCESS_T *));
extern SNMP_ACCESS_T * SNMP_V3_Access_Lookup	__((bits8_t *, ALENGTH_T,
						    bits8_t *, ALENGTH_T,
						    sbits32_t, sbits32_t));
extern SNMP_ACCESS_T * SNMP_V3_Access_Next      __((int, OIDC_T *)); 
extern SNMP_ACCESS_T * SNMP_V3_Access_Next_Access __((SNMP_ACCESS_T *));

extern void             SNMP_V3_Access_Name     __((SNMP_ACCESS_T *,
						    bits8_t   *, ALENGTH_T *,
						    bits8_t   *, ALENGTH_T *,
						    sbits32_t *, sbits32_t *));

extern SNMP_ACCESS_T * SNMP_V3_Access_Find      __((bits8_t *, ALENGTH_T,
						    bits8_t *, ALENGTH_T,
						    sbits32_t, sbits32_t));
extern int	       SNMP_V3_Access_Set_View  __((SNMP_ACCESS_T *,
						    EBUFFER_T *, bits8_t *,
						    ALENGTH_T, unsigned int));

#define SNMP_V3_Access_Compare_Names(A1, A2)  ((A1 == A2) ? 0 : 1)

#define SNMP_V3_Access_Get_Read(A)	  EBufferStart(&((A)->readview))
#define SNMP_V3_Access_Get_Read_Len(A)	  EBufferUsed(&((A)->readview))
#define SNMP_V3_Access_Set_Read(A,S,L,F) \
		SNMP_V3_Access_Set_View(A, &((A)->readview), S, L, F)
#define SNMP_V3_Access_Get_Write(A)	  EBufferStart(&((A)->writeview))
#define SNMP_V3_Access_Get_Write_Len(A)	  EBufferUsed(&((A)->writeview))
#define SNMP_V3_Access_Set_Write(A,S,L,F) \
		SNMP_V3_Access_Set_View(A, &((A)->writeview), S, L, F)
#define SNMP_V3_Access_Get_Notify(A)	  EBufferStart(&((A)->notifyview))
#define SNMP_V3_Access_Get_Notify_Len(A)  EBufferUsed(&((A)->notifyview))
#define SNMP_V3_Access_Set_Notify(A,S,L,F) \
		SNMP_V3_Access_Set_View(A, &((A)->notifyview), S, L, F)


#define SNMP_V3_Access_Get_Prefix_Match(A)    ((A)->prefix_match)
#define SNMP_V3_Access_Set_Prefix_Match(A, B) (((A)->prefix_match) = (B))

#define SNMP_V3_Access_Get_Status(A)	  ((A)->status)
#define SNMP_V3_Access_Set_Status(A, V)	  ((A)->status = (bits16_t)(V))
#define SNMP_V3_Access_Get_Storage(A)	  ((A)->storage)
#define SNMP_V3_Access_Set_Storage(A, V)  ((A)->storage = (bits16_t)(V))

extern void grouptable_get   __((OIDC_T, int, OIDC_T *,
				 SNMP_PKT_T *, VB_T *));

extern void grouptable_next   __((OIDC_T, int, OIDC_T *,
				  SNMP_PKT_T *, VB_T *));

extern void grouptable_test   __((OIDC_T, int, OIDC_T *,
				  SNMP_PKT_T *, VB_T *));

extern void grouptable_set   __((OIDC_T, int, OIDC_T *,
				 SNMP_PKT_T *, VB_T *));

extern void accesstable_get   __((OIDC_T, int, OIDC_T *,
				  SNMP_PKT_T *, VB_T *));

extern void accesstable_next   __((OIDC_T, int, OIDC_T *,
				   SNMP_PKT_T *, VB_T *));

extern void accesstable_test   __((OIDC_T, int, OIDC_T *,
				   SNMP_PKT_T *, VB_T *));

extern void accesstable_set   __((OIDC_T, int, OIDC_T *,
				  SNMP_PKT_T *, VB_T *));

#ifdef __cplusplus
}
#endif

#endif /* #if (!defined(v3_acc_inc))*/
