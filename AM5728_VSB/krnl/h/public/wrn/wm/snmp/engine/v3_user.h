/* $Header: /usr/cvsroot/target/h/wrn/wm/snmp/engine/v3_user.h,v 1.2 2001/11/06 21:35:07 josh Exp $ */

/*
 * Copyright (C) 1999-2012 Wind River Systems, Inc.
 * All rights reserved.  Provided under license only.
 * Distribution or other use of this software is only
 * permitted pursuant to the terms of a license agreement
 * from Wind River Systems (and is otherwise prohibited).
 * Refer to that license agreement for terms of use.
 */


/****************************************************************************
 *  Copyright 1998 Integrated Systems, Inc.
 *  All rights reserved.
 ****************************************************************************/

/*
 * $Log: v3_user.h,v $
 * Revision 1.2  2001/11/06 21:35:07  josh
 * new revised path structure, first pass.  Also removing useless
 * shell include files.
 *
 * Revision 1.1.1.1  2001/11/05 17:47:24  tneale
 * Tornado shuffle
 *
 * Revision 9.7  2001/01/19 22:22:13  paul
 * Update copyright.
 *
 * Revision 9.6  2000/03/17 19:48:47  meister
 * Update copyright notice
 *
 * Revision 9.5  2000/03/09 20:58:36  tneale
 * All structure definitions are now bracketted with a test that
 * potentially sets an alignment pragma.  This is to maintain compatibility
 * with the code base that had been distributed by Wind River.
 *
 * Revision 9.4  2000/03/09 17:14:06  tneale
 * Added #ifdef for C++ to extern C if needed
 *
 * Revision 9.3  2000/02/04 21:54:26  josh
 * prototyping functions that may need to be called by other modules
 * this is done primarily to make the vxWorks compiler happy.
 * Warning:  the prototypes added may be duplicated by a mib_hand.h
 * file generated by Emissary.
 *
 * Revision 9.2  1999/11/02 20:55:18  josh
 * bringing usmUserTable into line with new spec: RFC 2574
 * allows changing of auth and priv protocols after clone,
 * allows row creation without initial clone, and allows enabling of rows
 * without keychange for unused protocols (no authkeychange required if
 * not using auth, etc.)
 *
 * Revision 9.1  1999/09/30 21:56:14  josh
 * change public field to public_data so as not to conflict with
 * C++ compilers
 *
 * Revision 9.0  1998/10/16 22:10:27  sar
 * Update version stamp to match release
 *
 * Revision 1.7  1998/08/12 04:52:17  sar
 * revamp the initialization routines to limit the amount of
 * code that might get pulled in.
 *
 * Revision 1.6  1998/08/01 17:28:37  sar
 * Removed the id check flag
 *
 * Revision 1.5  1998/07/01 01:48:20  sar
 * As part of the set_defaults macro do a memset to zero the memory
 *
 * Revision 1.4  1998/06/30 00:30:58  sar
 * Added macros to get and set user flags (cloned, authed and prived)
 *
 * Revision 1.3  1998/06/16 05:30:38  sar
 * modify the api for the next routine
 * split the engine id into its own struct
 *
 * Revision 1.2  1998/05/30 02:52:07  sar
 * Modifed the names used for max string length
 * Updated user lookup
 *
 * Revision 1.1  1998/05/23 19:49:41  sar
 * Include files for use with v3 code.  They define the structures
 * and entry points for the various pieces.
 * acc: access and group information
 * auth & priv: authentication and privacy
 * con: context
 * eng: engine ids, both this agents and any others it knows
 * mth: method routines, for use with mib control files
 * user: user info
 *
 */

/* [clearcase]
modification history
-------------------
01c,07dec12,h_l  change uname from bits8_t to sbits8_t type.
01b,22oct12,rjq  implemented SNMP manager over DTLS SSH
01a,13apr05,AJS  Diffie-Hellman work
*/


#if (!defined(v3_user_inc))
#define v3_user_inc

#ifdef __cplusplus
extern"C" {
#endif

#if (!defined(asn1_inc))
#include <wrn/wm/snmp/engine/asn1.h>
#endif

#if (!defined(buffer_inc))
#include <wrn/wm/snmp/engine/buffer.h>
#endif

#if (!defined(v3_auth_inc))
#include <wrn/wm/snmp/engine/v3_auth.h>
#endif

#if (!defined(v3_priv_inc))
#include <wrn/wm/snmp/engine/v3_priv.h>
#endif

#if (!defined(v3_eng_inc))
#include <wrn/wm/snmp/engine/v3_eng.h>
#endif

#if (!defined(smi_inc))
#include <wrn/wm/snmp/engine/smi.h>
#endif

#if INSTALL_SNMP_V3_DIFFIE_HELLMAN
#include <openssl/bn.h>
#include <openssl/dh.h>
#endif /* INSTALL_SNMP_V3_DIFFIE_HELLMAN */

#define ETC_USER_USER_MAX 32
#define ETC_USER_ENGINE_MAX 32
#define ENGINE_MAXNAMELEN 32

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 1
#endif

#if INSTALL_SNMP_V3_DIFFIE_HELLMAN

#define LEAF_usmDHParameters                1
#define LEAF_usmDHUserAuthKeyChange         1
#define LEAF_usmDHUserOwnAuthKeyChange      2
#define LEAF_usmDHUserPrivKeyChange         3
#define LEAF_usmDHUserOwnPrivKeyChange      4

typedef struct SNMP_DH_S
        {
        EBUFFER_T  DHpubAuthKey;    /* DH public authentication key */
        EBUFFER_T  DHpubPrivKey;    /* DH public privacy key */
        DH        *DHauthValues;    /* DH values for the auth key */
        DH        *DHprivValues;    /* DH values for the priv key */
        } SNMP_DH_T;
        
typedef struct SNMP_DH_PARAMS_S
        {
        BIGNUM      *prime;         /* Large prime */
        BIGNUM      *base;          /* Generator; typically 2 or 5 */
        int          pvl;           /* Private value length, in bits */
        EBUFFER_T    encodedString; /* Encoded string with values above */
        } SNMP_DH_PARAMS_T;
        
extern int SNMP_init_DH (void);
        
#endif /* INSTALL_SNMP_V3_DIFFIE_HELLMAN */

typedef struct SNMP_USER_ENG_S
        {
        struct SNMP_USER_ENG_S *next;
        bits8_t                *id;
        ALENGTH_T               id_len;
        struct SNMP_USER_S     *user;
        } SNMP_USER_ENG_T;

typedef struct SNMP_USER_S 
        {
        SNMP_USER_ENG_T    *parent; 
        struct SNMP_USER_S *next;
        sbits8_t           *uname;
        ALENGTH_T           uname_len;
        SNMP_AUTH_T        *auth;
        bits8_t            *authkey;
        SNMP_PRIV_T        *priv;
        bits8_t            *privkey;
        EBUFFER_T           public_data; 
        bits8_t             maxsec;
        sbits16_t           storage;
        sbits16_t           status;
        sbits16_t           flags;
#if INSTALL_SNMP_V3_DIFFIE_HELLMAN
        SNMP_DH_T           DH_keys;
#endif /* INSTALL_SNMP_V3_DIFFIE_HELLMAN */
        } SNMP_USER_T;

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 0
#endif

#define ETC_USER_CLONED        0x01
#define ETC_USER_AUTHED        0x02
#define ETC_USER_PRIVED        0x04
#define ETC_USER_VALID_AUTHKEY 0x08
#define ETC_USER_VALID_PRIVKEY 0x10
#define ETC_USER_ALL_FLAGS     0x1F

/* global root pointer for the user list */
extern SNMP_USER_ENG_T *root_user;
extern SNMP_USER_T     *snmptalk_peer_user;

#if INSTALL_SNMP_V3_DIFFIE_HELLMAN
#define SNMP_User_Set_Defaults(U) (MEMSET((U), 0, sizeof(SNMP_USER_T)),             \
                                   EBufferInitialize(&((U)->public_data)),          \
                                   EBufferInitialize(&((U)->DH_keys.DHpubAuthKey)), \
                                   EBufferInitialize(&((U)->DH_keys.DHpubPrivKey)), \
                                   (U)->storage = ETC_STO_NONVOL,                   \
                                   (U)->status  = ETC_RS_NREADY)
#else
#define SNMP_User_Set_Defaults(U) (MEMSET((U), 0, sizeof(SNMP_USER_T)),             \
                                   EBufferInitialize(&((U)->public_data)),          \
                                   (U)->storage = ETC_STO_NONVOL,                   \
                                   (U)->status  = ETC_RS_NREADY)
#endif /* INSTALL_SNMP_V3_DIFFIE_HELLMAN */


extern SNMP_USER_T * SNMP_User_Lookup    __((bits8_t *, ALENGTH_T,
                                             bits8_t *, ALENGTH_T));
extern SNMP_USER_T * SNMP_User_Next      __((int, OIDC_T *));
extern SNMP_USER_T * SNMP_User_Next_User __((SNMP_USER_T *));
extern void          SNMP_User_Destroy   __((SNMP_USER_T *));
extern SNMP_USER_T * SNMP_User_Create    __((SNMP_AUTH_T *, SNMP_PRIV_T *));
extern int           SNMP_User_Install   __((SNMP_USER_T *,
                                             bits8_t *, ALENGTH_T,
                                             bits8_t *, ALENGTH_T));
extern void          SNMP_User_Deinstall __((SNMP_USER_T *));
extern void          SNMP_User_Name      __((SNMP_USER_T *,
                                             bits8_t *, ALENGTH_T *,
                                             bits8_t *, ALENGTH_T *));

extern void          SNMP_User_Get_Sec_Name __((SNMP_USER_T *, bits8_t *,
                                                ALENGTH_T *));
extern int           SNMP_User_Set_Auth __((SNMP_USER_T *, SNMP_AUTH_T *));

extern int           SNMP_User_Set_AuthKey  __((SNMP_USER_T *, bits8_t *,
                                                ALENGTH_T));
extern int           SNMP_User_Set_PrivKey  __((SNMP_USER_T *, bits8_t *,
                                                ALENGTH_T));
extern int           SNMP_User_Swap_Users  __((SNMP_USER_T *, SNMP_USER_T *));

#define SNMP_User_Compare_Names(U1, U2) (((U1) == (U2)) ? 0 : 1)

#define SNMP_User_Get_Auth(U)           ((U)->auth)
#define SNMP_User_Get_AuthKey(U)        ((U)->authkey)
#define SNMP_User_Get_Priv(U)           ((U)->priv)
#define SNMP_User_Get_PrivKey(U)        ((U)->privkey)
#define SNMP_User_Get_Public(U)         (EBufferStart(&((U)->public_data)))
#define SNMP_User_Get_Public_Len(U)     (EBufferUsed(&((U)->public_data)))
#define SNMP_User_Get_MaxSec(U)         ((U)->maxsec)
#define SNMP_User_Get_Storage(U)        ((U)->storage)
#define SNMP_User_Set_Storage(U, V)     ((U)->storage = (sbits16_t)(V))
#define SNMP_User_Get_Status(U)         ((U)->status)
#define SNMP_User_Set_Status(U, V)      ((U)->status = (sbits16_t)(V))
#define SNMP_User_Get_Flags(U)          ((U)->flags)
#define SNMP_User_Set_Flags(U, F)       ((U)->flags = (sbits16_t)(F))

/* These macros are for internal use only and should not be used
   by customers.  It makes use of internal knowledge of the user
   structure which may change in the future, causing the macros
   to become unsupportable.  In this case any code calling these
   macros will need to be updated.
   currently the only mapping between name and security name
   is the identity mapping */
#define SNMP_User_Get_SName(U)          ((U)->uname)
#define SNMP_User_Get_SName_Len(U)      ((U)->uname_len)

extern sbits32_t   v3_usmUserSpinLock;

extern void usertable_get   __((OIDC_T, int, OIDC_T *,
                                SNMP_PKT_T *, VB_T *));

extern void usertable_next   __((OIDC_T, int, OIDC_T *,
                                 SNMP_PKT_T *, VB_T *));

extern void usertable_test   __((OIDC_T, int, OIDC_T *,
                                 SNMP_PKT_T *, VB_T *));

extern void usertable_set   __((OIDC_T, int, OIDC_T *,
                                SNMP_PKT_T *, VB_T *));

#ifdef __cplusplus
}
#endif

#endif /* (!defined(user_inc)) */


