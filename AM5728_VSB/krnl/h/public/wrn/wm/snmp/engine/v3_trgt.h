/* $Header: /usr/cvsroot/target/h/wrn/wm/snmp/engine/v3_trgt.h,v 1.2 2001/11/06 21:35:07 josh Exp $ */

/*
 * Copyright (C) 1999-2005, 2013 Wind River Systems, Inc.
 * All rights reserved.  Provided under license only.
 * Distribution or other use of this software is only
 * permitted pursuant to the terms of a license agreement
 * from Wind River Systems (and is otherwise prohibited).
 * Refer to that license agreement for terms of use.
 */

/****************************************************************************
 *  Copyright 1998 Integrated Systems, Inc.
 *  All rights reserved.
 ****************************************************************************/

/*
 * $Log: v3_trgt.h,v $
 * Revision 1.2  2001/11/06 21:35:07  josh
 * new revised path structure, first pass.  Also removing useless
 * shell include files.
 *
 * Revision 1.1.1.1  2001/11/05 17:47:24  tneale
 * Tornado shuffle
 *
 * Revision 9.8.4.2  2001/09/21 19:16:08  josh
 * updating and expanding structures for use with coexistence
 *
 * Revision 9.8.4.1  2001/07/16 18:02:13  josh
 * a first-round commit adding infrastructure support
 * for the SNMPv3 Coexistence RFC (2576)
 *
 * Revision 9.8  2001/04/11 20:42:56  josh
 * merge from the kingfisher branch
 *
 * Revision 9.7  2001/01/19 22:22:12  paul
 * Update copyright.
 *
 * Revision 9.6  2000/06/09 14:54:13  josh
 * modifications due to new installation options, new proxy code
 * moved some definitions from sendntfy.h into v3_trgt.h so they'd
 * be built with the target code
 *
 * Revision 9.5.2.2  2001/03/12 22:08:02  tneale
 * Updated copyright
 *
 * Revision 9.5.2.1  2000/09/21 21:14:55  josh
 * bringing branch include files in line with root
 *
 * Revision 9.5  2000/03/17 19:48:47  meister
 * Update copyright notice
 *
 * Revision 9.4  2000/03/09 20:58:36  tneale
 * All structure definitions are now bracketted with a test that
 * potentially sets an alignment pragma.  This is to maintain compatibility
 * with the code base that had been distributed by Wind River.
 *
 * Revision 9.3  2000/03/09 17:07:15  tneale
 *  Added #ifdef for C++ to declare extern C if needed
 *
 * Revision 9.2  2000/02/04 21:54:25  josh
 * prototyping functions that may need to be called by other modules
 * this is done primarily to make the vxWorks compiler happy.
 * Warning:  the prototypes added may be duplicated by a mib_hand.h
 * file generated by Emissary.
 *
 * Revision 9.1  2000/01/02 22:55:56  josh
 * patching up a memory leak here, a broken compare there...per
 * sar's comments
 *
 * Revision 9.0  1999/10/21 20:43:35  josh
 * updating version stamps
 *
 * Revision 1.5  1999/10/21 19:13:09  josh
 * adding flags for flags fields in various objects to help with row
 * creation
 *
 * Revision 1.4  1999/10/15 17:47:26  josh
 * included MIB leaf definitions and cleaned up useless macros
 *
 * Revision 1.3  1999/09/21 21:31:45  josh
 * fixed a few structure access macros
 *
 * Revision 1.2  1999/09/14 19:35:26  josh
 * updating default initialization per RFC 2573
 *
 * Revision 1.1  1999/06/16 17:04:23  josh
 * First step of adding RFC2573 Notify support.
 *
 *
 */


/* [clearcase]
modification history
-------------------
01b,06aug13,bbz  clear the med impact warning from prevent.pl(WIND00429583)
01a,19apr05,job  update copyright notices
*/


#if (!defined(v3_trgt_inc))
#define v3_trgt_inc

#ifdef __cplusplus
extern"C" {
#endif

#if (!defined(asn1_inc))
#include <wrn/wm/snmp/engine/asn1.h>
#endif

#if (!defined(buffer_inc))
#include <wrn/wm/snmp/engine/buffer.h>
#endif

#if (!defined(smi_inc))
#include <wrn/wm/snmp/engine/smi.h>
#endif

#define ETC_TARGET_ADDR_MAX   32
#define ETC_TARGET_PARAMS_MAX  32

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 1
#endif

typedef struct SNMP_TARGET_ADDR_S
        {
	struct SNMP_TARGET_ADDR_S *next; 
        EBUFFER_T  target_name;     /* the name of the target */
        OBJ_ID_T   tdomain;         /* the transport domain */
        EBUFFER_T  taddress;        /* target address */
        EBUFFER_T  tmask;           /* target mask */
        sbits32_t  timeout;         /* interval between retr. */
        bits16_t   retry_count;     /* number of retrans. */
        bits32_t   target_mms;      /* max message size */
        EBUFFER_T  tag_list;        /* list of magic labels */
        EBUFFER_T  params;          /* name of SNMP_TARGET_PARAM_T */
        bits16_t   storage;
        bits16_t   status;
        bits16_t   flags;
        } SNMP_TARGET_ADDR_T;

#define ETC_TADDR_TDOMAIN   0x01
#define ETC_TADDR_TADDRESS  0x02
#define ETC_TADDR_PARAMS    0x04
#define ETC_TADDR_ALL_FLAGS 0x07

#define ETC_TADDR_TIMEOUT      1500
#define ETC_TADDR_RETRY_COUNT  3
#define ETC_TADDR_MMS          484

/* global root pointer for target params list */
extern SNMP_TARGET_ADDR_T *root_target_addr;

#define SNMP_Target_Addr_Set_Defaults(T)           \
      (MEMSET((T), 0, sizeof(SNMP_TARGET_ADDR_T)), \
       EBufferInitialize(&((T)->target_name)),     \
       EBufferInitialize(&((T)->taddress)),        \
       EBufferInitialize(&((T)->tmask)),           \
       EBufferInitialize(&((T)->tag_list)),        \
       EBufferInitialize(&((T)->params)),          \
       (T)->timeout = ETC_TADDR_TIMEOUT,           \
       (T)->retry_count = ETC_TADDR_RETRY_COUNT,   \
       (T)->target_mms = ETC_TADDR_MMS,            \
       (T)->storage = ETC_STO_NONVOL,              \
       (T)->status = ETC_RS_NREADY,                \
       (T)->flags = 0)
          
extern SNMP_TARGET_ADDR_T * SNMP_Target_Addr_Create  __((void));
extern void SNMP_Target_Addr_Destroy __((SNMP_TARGET_ADDR_T *));
extern int  SNMP_Target_Addr_Install __((SNMP_TARGET_ADDR_T *, bits8_t *, 
					 ALENGTH_T));
extern void SNMP_Target_Addr_Deinstall __((SNMP_TARGET_ADDR_T *));
extern SNMP_TARGET_ADDR_T * SNMP_Target_Addr_Lookup __((bits8_t *, ALENGTH_T));
extern SNMP_TARGET_ADDR_T * SNMP_Target_Addr_Next __((int, OIDC_T *));
extern SNMP_TARGET_ADDR_T * SNMP_Target_Addr_Next_Addr __((SNMP_TARGET_ADDR_T *));
extern void SNMP_Target_Addr_Name __((SNMP_TARGET_ADDR_T *, bits8_t *, 
				      ALENGTH_T *));

#define SNMP_Target_Addr_Get_Name(T)       (EBufferStart(&((T)->target_name)))
#define SNMP_Target_Addr_Get_Name_Len(T)   (EBufferUsed(&((T)->target_name)))

#define SNMP_Target_Addr_Get_TDomain(T)    (&((T)->tdomain))
#define SNMP_Target_Addr_Set_TDomain(T, D, L)  \
        (build_object_id((L), (D), (&((T)->tdomain))))

#define SNMP_Target_Addr_Get_TAddress(T)     (EBufferStart(&((T)->taddress)))
#define SNMP_Target_Addr_Get_TAddress_Len(T) (EBufferUsed(&((T)->taddress)))
#define SNMP_Target_Addr_Set_TAddress(T, S, L, F) \
        (EBufferAllocateLoad((F), &((T)->taddress), (S), (L)))

#define SNMP_Target_Addr_Get_TMask(T)     (EBufferStart(&((T)->tmask)))
#define SNMP_Target_Addr_Get_TMask_Len(T) (EBufferUsed(&((T)->tmask)))
#define SNMP_Target_Addr_Set_TMask(T, S, L, F) \
        (EBufferAllocateLoad((F), &((T)->tmask), (S), (L)))

#define SNMP_Target_Addr_Get_Timeout(T)    ((T)->timeout)
#define SNMP_Target_Addr_Set_Timeout(T, V) ((T)->timeout = (sbits32_t)(V))

#define SNMP_Target_Addr_Get_Retry_Count(T)    ((T)->retry_count)
#define SNMP_Target_Addr_Set_Retry_Count(T, V) ((T)->retry_count = (bits16_t)(V))

#define SNMP_Target_Addr_Get_MMS(T)     ((T)->target_mms)
#define SNMP_Target_Addr_Set_MMS(T, V)  ((T)->target_mms = (bits16_t)(V))

#define SNMP_Target_Addr_Get_Tag_List(T)     (EBufferStart(&((T)->tag_list)))
#define SNMP_Target_Addr_Get_Tag_List_Len(T) (EBufferUsed(&((T)->tag_list)))
#define SNMP_Target_Addr_Set_Tag_List(T, S, L, F) \
        (EBufferAllocateLoad((F), &((T)->tag_list), (S), (L)))

#define SNMP_Target_Addr_Get_Params(T)   (EBufferStart(&((T)->params)))
#define SNMP_Target_Addr_Get_Params_Len(T)   (EBufferUsed(&((T)->params)))
#define SNMP_Target_Addr_Set_Params(T, S, L, F) \
        (EBufferAllocateLoad((F), &((T)->params), (S), (L)))

#define SNMP_Target_Addr_Get_Storage(T)     ((T)->storage)
#define SNMP_Target_Addr_Set_Storage(T, V)  ((T)->storage = (bits16_t)(V))

#define SNMP_Target_Addr_Get_Status(T)     ((T)->status)
#define SNMP_Target_Addr_Set_Status(T, V)  ((T)->status = (bits16_t)(V))

#define SNMP_Target_Addr_Get_Flags(T)     ((T)->flags)
#define SNMP_Target_Addr_Set_Flags(T, V)  ((T)->flags = (bits16_t)(V))

typedef struct SNMP_TARGET_PARAMS_S
        {
	struct SNMP_TARGET_PARAMS_S *next;
        EBUFFER_T  params_name;     /* name of the params object */
        sbits32_t  mp_model;        /* SNMP version, roughly */
        sbits32_t  sec_model;       /* security model */
        EBUFFER_T  sec_name;        /* security name, aka user */
        bits16_t   sec_level;       /* security level (auth/priv) */
        bits16_t   storage;        
        bits16_t   status;
        bits16_t   flags;
        } SNMP_TARGET_PARAMS_T;

#ifdef WINDNET_STRUCT_ALIGN
#pragma align 0
#endif

#define ETC_TPARAM_MPMODEL   0x01
#define ETC_TPARAM_SECMODEL  0x02
#define ETC_TPARAM_SECNAME   0x04
#define ETC_TPARAM_SECLEVEL  0x08
#define ETC_TPARAM_ALL_FLAGS 0x0F

/* global root pointer for target params list */
extern SNMP_TARGET_PARAMS_T *root_target_params;

#define SNMP_Target_Params_Set_Defaults(G)           \
      (MEMSET((G), 0, sizeof(SNMP_TARGET_PARAMS_T)), \
       EBufferInitialize(&((G)->params_name)),       \
       EBufferInitialize(&((G)->sec_name)),          \
       (G)->storage = ETC_STO_NONVOL,                \
       (G)->status = ETC_RS_NREADY,                  \
       (G)->flags = 0)
          
extern SNMP_TARGET_PARAMS_T * SNMP_Target_Params_Create  __((void));
extern void SNMP_Target_Params_Destroy __((SNMP_TARGET_PARAMS_T *));
extern int  SNMP_Target_Params_Install __((SNMP_TARGET_PARAMS_T *, bits8_t *,
                                           ALENGTH_T));
extern void SNMP_Target_Params_Deinstall __((SNMP_TARGET_PARAMS_T *));
extern SNMP_TARGET_PARAMS_T * SNMP_Target_Params_Lookup __((bits8_t *,
                                                            ALENGTH_T));
extern SNMP_TARGET_PARAMS_T * SNMP_Target_Params_Next __((int, OIDC_T *));
extern SNMP_TARGET_PARAMS_T * SNMP_Target_Params_Next_Params 
                                             __((SNMP_TARGET_PARAMS_T *));
extern void SNMP_Target_Params_Name __((SNMP_TARGET_PARAMS_T *, 
                                        bits8_t *, ALENGTH_T *));

#define SNMP_Target_Params_Get_Name(T)     (EBufferStart(&((T)->params_name)))
#define SNMP_Target_Params_Get_Name_Len(T) (EBufferUsed(&((T)->params_name)))

#define SNMP_Target_Params_Get_MP_Model(T)     ((T)->mp_model)
#define SNMP_Target_Params_Set_MP_Model(T, V)  ((T)->mp_model = (sbits32_t)(V))

#define SNMP_Target_Params_Get_Sec_Model(T)    ((T)->sec_model)
#define SNMP_Target_Params_Set_Sec_Model(T, V) ((T)->sec_model = (sbits32_t)(V))

#define SNMP_Target_Params_Get_Sec_Name(T)     (EBufferStart(&((T)->sec_name)))
#define SNMP_Target_Params_Get_Sec_Name_Len(T) (EBufferUsed(&((T)->sec_name)))
#define SNMP_Target_Params_Set_Sec_Name(T, S, L, F) \
        (EBufferAllocateLoad((F), &((T)->sec_name), (S), (L)))

#define SNMP_Target_Params_Get_Sec_Level(T)    ((T)->sec_level)
#define SNMP_Target_Params_Set_Sec_Level(T, V) ((T)->sec_level = (bits16_t)(V))

#define SNMP_Target_Params_Get_Storage(T)    ((T)->storage)
#define SNMP_Target_Params_Set_Storage(T, V) ((T)->storage = (bits16_t)(V))

#define SNMP_Target_Params_Get_Status(T)    ((T)->status)
#define SNMP_Target_Params_Set_Status(T, V) ((T)->status = (bits16_t)(V))

#define SNMP_Target_Params_Get_Flags(T)    ((T)->flags)
#define SNMP_Target_Params_Set_Flags(T, V) ((T)->flags = (bits16_t)(V))

extern sbits32_t  v3_snmpTargetSpinLock;

extern void snmpTargetAddrEntry_get  __((OIDC_T, int, OIDC_T *,
					 SNMP_PKT_T *, VB_T *));

extern void snmpTargetAddrEntry_next  __((OIDC_T, int, OIDC_T *,
					  SNMP_PKT_T *, VB_T *));

extern void snmpTargetAddrEntry_test  __((OIDC_T, int, OIDC_T *,
					  SNMP_PKT_T *, VB_T *));

extern void snmpTargetAddrEntry_set  __((OIDC_T, int, OIDC_T *,
					 SNMP_PKT_T *, VB_T *));

extern void snmpTargetParamsEntry_get  __((OIDC_T, int, OIDC_T *,
					   SNMP_PKT_T *, VB_T *));

extern void snmpTargetParamsEntry_next  __((OIDC_T, int, OIDC_T *,
					    SNMP_PKT_T *, VB_T *));

extern void snmpTargetParamsEntry_test  __((OIDC_T, int, OIDC_T *,
					    SNMP_PKT_T *, VB_T *));

extern void snmpTargetParamsEntry_set  __((OIDC_T, int, OIDC_T *,
					   SNMP_PKT_T *, VB_T *));

#ifndef ENVOY_SNMPADDR_TO_TADDRESS
#define ENVOY_USE_DEFAULT_SNMPADDR 1
#define ENVOY_SNMPADDR_TO_TADDRESS(A, D, T) \
	envoy_snmpaddr_to_taddress(A, D, T)

extern int envoy_snmpaddr_to_taddress __((SNMPADDR_T *, OBJ_ID_T *, 
					  EBUFFER_T *));
#endif

#ifndef ENVOY_TADDRESS_TO_SNMPADDR
#define ENVOY_USE_DEFAULT_TADDRESS 1
#define ENVOY_TADDRESS_TO_SNMPADDR(A, D, T) \
	envoy_taddress_to_snmpaddr(A, D, T)

extern int envoy_taddress_to_snmpaddr __((SNMPADDR_T *, OBJ_ID_T *, 
					  EBUFFER_T *));
#endif

extern envoy_err_t copyVarBind __((VB_T *, int, SNMP_PKT_T *));
extern int copyVarBindList __((VBL_T *, VBL_T *, sbits32_t));
extern int SNMP_Convert_VB __((VBL_T *, OBJ_ID_T *, int *,
                               sbits32_t *, bits32_t *));
extern envoy_err_t copyNotifyVarBindList __((SNMP_PKT_T *, SNMP_PKT_T *));

/* The leaf definitions for the method routines */
#define LEAF_snmpTargetAddrName	1
#define MINSIZE_snmpTargetAddrName	1L
#define MAXSIZE_snmpTargetAddrName	32L
#define LEAF_snmpTargetAddrTDomain	2
#define LEAF_snmpTargetAddrTAddress	3
#define MINSIZE_snmpTargetAddrTAddress	1L
#define MAXSIZE_snmpTargetAddrTAddress	255L
#define LEAF_snmpTargetAddrTimeout	4
#define MIN_snmpTargetAddrTimeout	0L
#define MAX_snmpTargetAddrTimeout	2147483647L
#define LEAF_snmpTargetAddrRetryCount	5
#define MIN_snmpTargetAddrRetryCount	0L
#define MAX_snmpTargetAddrRetryCount	255L
#define LEAF_snmpTargetAddrTagList	6
#define MINSIZE_snmpTargetAddrTagList	0L
#define MAXSIZE_snmpTargetAddrTagList	255L
#define LEAF_snmpTargetAddrParams	7
#define MINSIZE_snmpTargetAddrParams	1L
#define MAXSIZE_snmpTargetAddrParams	32L
#define LEAF_snmpTargetAddrStorageType	8
#define VAL_snmpTargetAddrStorageType_other	1L
#define VAL_snmpTargetAddrStorageType_volatile	2L
#define VAL_snmpTargetAddrStorageType_nonVolatile	3L
#define VAL_snmpTargetAddrStorageType_permanent	4L
#define VAL_snmpTargetAddrStorageType_readOnly	5L
#define LEAF_snmpTargetAddrRowStatus	9
#define VAL_snmpTargetAddrRowStatus_active	1L
#define VAL_snmpTargetAddrRowStatus_notInService	2L
#define VAL_snmpTargetAddrRowStatus_notReady	3L
#define VAL_snmpTargetAddrRowStatus_createAndGo	4L
#define VAL_snmpTargetAddrRowStatus_createAndWait	5L
#define VAL_snmpTargetAddrRowStatus_destroy	6L
#define LEAF_snmpTargetParamsName	1
#define MINSIZE_snmpTargetParamsName	1L
#define MAXSIZE_snmpTargetParamsName	32L
#define LEAF_snmpTargetParamsMPModel	2
#define MIN_snmpTargetParamsMPModel	0L
#define MAX_snmpTargetParamsMPModel	2147483647L
#define LEAF_snmpTargetParamsSecurityModel	3
#define MIN_snmpTargetParamsSecurityModel	1L
#define MAX_snmpTargetParamsSecurityModel	2147483646L
#define LEAF_snmpTargetParamsSecurityName	4
#define MINSIZE_snmpTargetParamsSecurityName	0L
#define MAXSIZE_snmpTargetParamsSecurityName	255L
#define LEAF_snmpTargetParamsSecurityLevel	5
#define VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv	1L
#define VAL_snmpTargetParamsSecurityLevel_authNoPriv	2L
#define VAL_snmpTargetParamsSecurityLevel_authPriv	3L
#define LEAF_snmpTargetParamsStorageType	6
#define VAL_snmpTargetParamsStorageType_other	1L
#define VAL_snmpTargetParamsStorageType_volatile	2L
#define VAL_snmpTargetParamsStorageType_nonVolatile	3L
#define VAL_snmpTargetParamsStorageType_permanent	4L
#define VAL_snmpTargetParamsStorageType_readOnly	5L
#define LEAF_snmpTargetParamsRowStatus	7
#define VAL_snmpTargetParamsRowStatus_active	1L
#define VAL_snmpTargetParamsRowStatus_notInService	2L
#define VAL_snmpTargetParamsRowStatus_notReady	3L
#define VAL_snmpTargetParamsRowStatus_createAndGo	4L
#define VAL_snmpTargetParamsRowStatus_createAndWait	5L
#define VAL_snmpTargetParamsRowStatus_destroy	6L


#ifdef __cplusplus
}
#endif

#endif /* #if (!defined(v3_trgt_inc))*/
